### 1. Algorithms & Data Structures (C++): Baised Standings

The biased standings problem is a classic algorithmic problem in which you're given a list of teams along with their actual standings and their desired standings. The task is to find the minimum number of swaps required to make the standings unbiased.

Here's a basic approach to solve this problem:

1. First, create a map or dictionary to store the desired standings of each team.
2. Iterate through the list of teams, calculate the difference between their actual standings and their desired standings.
3. Sort the teams based on this difference. Teams with the largest differences (i.e., the most biased) should come first.
4. Iterate through the sorted list of teams, and for each team:
   - Check if its actual position matches its desired position. If it does, continue to the next team.
   - Otherwise, swap this team with the team occupying its desired position.
   - Update the standings and the number of swaps.
5. Return the total number of swaps made.

Here's a basic implementation in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <unordered_map>

using namespace std;

int minimumSwaps(vector<pair<string, int>>& teams) {
    unordered_map<string, int> desired;
    for (auto& team : teams) {
        desired[team.first] = team.second;
    }

    sort(teams.begin(), teams.end(), [&](const auto& a, const auto& b) {
        return abs(a.second - desired[a.first]) > abs(b.second - desired[b.first]);
    });

    int swaps = 0;
    for (auto& team : teams) {
        if (team.second != desired[team.first]) {
            swap(team, teams[desired[team.first] - 1]);
            swaps++;
        }
    }

    return swaps;
}

int main() {
    vector<pair<string, int>> teams = {{"TeamA", 1}, {"TeamB", 2}, {"TeamC", 3}, {"TeamD", 4}};
    cout << "Minimum swaps required: " << minimumSwaps(teams) << endl;
    return 0;
}
```

This is a basic implementation, and you might need to modify it based on specific constraints or requirements of the problem you're solving.

### 1. Algorithms & Data Structures (C++): Minimum Steps in Infinite Grid

To find the minimum steps required to reach a point on an infinite grid, you can use the concept of Manhattan distance. The Manhattan distance between two points \((x_1, y_1)\) and \((x_2, y_2)\) on a grid is given by \(|x_1 - x_2| + |y_1 - y_2|\).

Here's a C++ implementation to find the minimum steps:

```cpp
#include <iostream>
#include <cmath>

using namespace std;

int minStepsInInfiniteGrid(int x1, int y1, int x2, int y2) {
    return max(abs(x2 - x1), abs(y2 - y1));
}

int main() {
    int x1, y1, x2, y2;
    cout << "Enter coordinates of point 1 (x1 y1): ";
    cin >> x1 >> y1;
    cout << "Enter coordinates of point 2 (x2 y2): ";
    cin >> x2 >> y2;

    int minSteps = minStepsInInfiniteGrid(x1, y1, x2, y2);
    cout << "Minimum steps required: " << minSteps << endl;

    return 0;
}
```

This code takes input for the coordinates of two points on the infinite grid and calculates the minimum steps required to reach from the first point to the second point using the Manhattan distance formula.

For example, if you input (0, 0) and (3, 4), the output would be 4, as you would need to move 3 steps right and 4 steps up.

### 1. Algorithms & Data Structures (C++): Minimum Steps to 1

To solve the Minimum Steps to 1 problem in C++, you can use dynamic programming. Here's a basic implementation using memoization:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int minStepsToOne(int n, vector<int>& memo) {
    if (n == 1) return 0;
    if (memo[n] != -1) return memo[n];
    
    int steps = 1 + minStepsToOne(n - 1, memo);
    if (n % 2 == 0) steps = min(steps, 1 + minStepsToOne(n / 2, memo));
    if (n % 3 == 0) steps = min(steps, 1 + minStepsToOne(n / 3, memo));
    
    memo[n] = steps;
    return steps;
}

int main() {
    int n;
    cout << "Enter a number: ";
    cin >> n;

    vector<int> memo(n + 1, -1);
    int steps = minStepsToOne(n, memo);
    
    cout << "Minimum steps to reach 1: " << steps << endl;

    return 0;
}
```

This code recursively calculates the minimum steps to reach 1 from a given number `n` using memoization to store intermediate results. The `minStepsToOne` function calculates the minimum steps for each number `n`, and the `main` function takes user input and prints the result.

### 1. Algorithms & Data Structures (C++): Minimum Steps to 1 Bottom Up Method

Certainly! The "Minimum Steps to 1" problem, often referred to as the "Collatz Conjecture," is a classic problem in computer science. The goal is to find the minimum number of steps it takes to reduce a given number to 1 using a set of rules. The rules are as follows:

1. If the number is even, divide it by 2.
2. If the number is odd, multiply it by 3 and add 1.

Here's a C++ implementation of the Bottom-Up Dynamic Programming approach for solving this problem:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int minStepsTo1(int n) {
    vector<int> dp(n + 1, 0);

    // Base case: 1 doesn't require any steps to reduce to 1
    dp[1] = 0;

    // Bottom-up approach
    for (int i = 2; i <= n; ++i) {
        dp[i] = dp[i - 1] + 1;  // Start with the assumption of one more step than the previous number

        // If current number is even, divide by 2
        if (i % 2 == 0)
            dp[i] = min(dp[i], dp[i / 2] + 1);

        // If current number is odd, multiply by 3 and add 1
        // Then, find the minimum steps to reduce that number to 1
        if (i % 2 != 0)
            dp[i] = min(dp[i], dp[(i * 3 + 1) / 2] + 2);
    }

    return dp[n];
}

int main() {
    int n;
    cout << "Enter a number: ";
    cin >> n;

    cout << "Minimum steps to reach 1: " << minStepsTo1(n) << endl;

    return 0;
}
```

This implementation maintains an array `dp` where `dp[i]` represents the minimum steps required to reduce the number `i` to 1. It iterates from 2 to `n`, filling in `dp[i]` based on the previously calculated values. Finally, it returns `dp[n]`, which holds the minimum steps required to reduce `n` to 1.

### 1. Algorithms & Data Structures (C++): Minimum Steps to 1 Brute Force Method

Sure! The problem of finding the minimum steps to reach 1 from a given number through a set of allowed operations is a classic dynamic programming problem. Here's a brute-force approach in C++:

```cpp
#include <iostream>
#include <climits>
using namespace std;

// Function to recursively find the minimum steps to reach 1
int minStepsTo1(int n) {
    // Base case
    if (n == 1) {
        return 0;
    }

    // Initialize the minimum steps required
    int minSteps = INT_MAX;

    // Try all possible operations
    // Operation 1: Subtract 1
    int steps1 = 1 + minStepsTo1(n - 1);

    // Operation 2: Divide by 2 (if divisible)
    int steps2 = (n % 2 == 0) ? 1 + minStepsTo1(n / 2) : INT_MAX;

    // Operation 3: Divide by 3 (if divisible)
    int steps3 = (n % 3 == 0) ? 1 + minStepsTo1(n / 3) : INT_MAX;

    // Update the minimum steps required
    minSteps = min(minSteps, min(steps1, min(steps2, steps3)));

    return minSteps;
}

int main() {
    int n;
    cout << "Enter a number: ";
    cin >> n;

    int steps = minStepsTo1(n);
    cout << "Minimum steps to reach 1: " << steps << endl;

    return 0;
}
```

In this code:

- The `minStepsTo1` function recursively finds the minimum steps required to reach 1 from the given number `n`.
- It tries three operations:
  1. Subtract 1 from `n`.
  2. If `n` is divisible by 2, divide it by 2.
  3. If `n` is divisible by 3, divide it by 3.
- The function returns the minimum steps required.
- The `main` function takes input from the user and prints the minimum steps to reach 1.

### 1. Algorithms & Data Structures (C++): Minimum Steps to 1 Memorization Method

Sure, the problem you're referring to is a classic dynamic programming problem. The goal is to find the minimum number of steps needed to reduce a given number to 1, following a set of rules. One common approach is using memoization to optimize the recursive solution. Here's how you can implement it in C++:

```cpp
#include <iostream>
#include <vector>
#include <climits>

using namespace std;

// Memoization table to store already computed results
vector<int> memo;

// Recursive function to calculate minimum steps
int minSteps(int n) {
    // Base case: if n is 1, no more steps needed
    if (n == 1)
        return 0;

    // If result is already calculated, return it
    if (memo[n] != -1)
        return memo[n];

    // Calculate steps for n
    int steps = 1 + minSteps(n - 1);

    // Check if n is divisible by 2
    if (n % 2 == 0)
        steps = min(steps, 1 + minSteps(n / 2));

    // Check if n is divisible by 3
    if (n % 3 == 0)
        steps = min(steps, 1 + minSteps(n / 3));

    // Save the result in memoization table
    memo[n] = steps;

    return steps;
}

int main() {
    int n = 10; // Example number
    memo.assign(n + 1, -1); // Initialize memoization table with -1
    cout << "Minimum steps to reduce " << n << " to 1: " << minSteps(n) << endl;
    return 0;
}
```

Explanation:

- The `minSteps` function calculates the minimum number of steps needed to reduce the given number `n` to 1.
- It checks if the result for `n` is already computed in the memoization table. If yes, it returns the result directly.
- Otherwise, it calculates the result recursively by considering three operations: subtracting 1, dividing by 2 (if divisible), and dividing by 3 (if divisible).
- It saves the result in the memoization table to avoid redundant calculations.
- In the `main` function, you can change the value of `n` to any number you want to test.

### 1. Algorithms & Data Structures (C++): Beautiful Numbers

Beautiful numbers in computer science often refer to numbers with special properties or characteristics. One common definition of a beautiful number is one that has factors (excluding 1 and itself) whose sum equals the number itself.

Here's a simple C++ function to check if a number is beautiful according to this definition:

```cpp
#include <iostream>

bool isBeautiful(int num) {
    int sum = 0;
    for (int i = 2; i <= num / 2; ++i) {
        if (num % i == 0) {
            sum += i;
        }
    }
    return sum == num;
}

int main() {
    int num;
    std::cout << "Enter a number: ";
    std::cin >> num;

    if (isBeautiful(num)) {
        std::cout << num << " is a beautiful number." << std::endl;
    } else {
        std::cout << num << " is not a beautiful number." << std::endl;
    }

    return 0;
}
```

This code defines a function `isBeautiful` that takes an integer `num` as input and checks whether it's beautiful or not. It iterates from 2 to `num / 2` (since factors beyond this range wouldn't sum up to `num`), calculates the sum of factors, and returns true if the sum equals `num`, indicating it's beautiful.

You can modify the definition of beauty according to other criteria if needed. For instance, you might define beauty differently for prime numbers or for numbers with other specific properties.

### 1. Algorithms & Data Structures (C++): Bernoulli's Trial

Bernoulli's trial is a fundamental concept in probability theory, named after the Swiss mathematician Jacob Bernoulli. It refers to a random experiment with exactly two possible outcomes: success and failure. Success has a probability of \( p \) and failure has a probability of \( 1 - p \), where \( 0 \leq p \leq 1 \).

In C++, you can simulate Bernoulli's trial using a random number generator to generate a number between 0 and 1, and then compare it with the probability \( p \). Here's a simple example:

```cpp
#include <iostream>
#include <random>

// Function to simulate Bernoulli trial
bool bernoulliTrial(double p) {
    // Initialize random number generator
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<> dis(0.0, 1.0);

    // Generate a random number between 0 and 1
    double randomNum = dis(gen);

    // Check if the random number is less than p (success) or not (failure)
    if (randomNum < p)
        return true; // Success
    else
        return false; // Failure
}

int main() {
    // Probability of success
    double p = 0.5;

    // Number of trials
    int numTrials = 10;

    // Perform Bernoulli trials
    for (int i = 0; i < numTrials; ++i) {
        bool result = bernoulliTrial(p);
        if (result)
            std::cout << "Trial " << i+1 << ": Success" << std::endl;
        else
            std::cout << "Trial " << i+1 << ": Failure" << std::endl;
    }

    return 0;
}
```

In this example, the `bernoulliTrial` function simulates a single Bernoulli trial with a given probability \( p \). The `main` function performs a specified number of trials (`numTrials`) and prints the result of each trial (success or failure).

### 1. Algorithms & Data Structures (C++): Best Time to Buy And Sell A Stock

The "Best Time to Buy and Sell a Stock" problem is a classic algorithmic problem often encountered in technical interviews and competitive programming. In this problem, you're given an array of stock prices where the \( i^{th} \) element is the price of a given stock on day \( i \). You need to find the maximum profit you can achieve by buying and selling the stock at most once.

Here's a simple C++ implementation of the solution:

```cpp
#include <vector>
#include <algorithm>

int maxProfit(std::vector<int>& prices) {
    int n = prices.size();
    if (n <= 1) return 0;
    
    int min_price = prices[0];
    int max_profit = 0;
    
    for (int i = 1; i < n; ++i) {
        max_profit = std::max(max_profit, prices[i] - min_price);
        min_price = std::min(min_price, prices[i]);
    }
    
    return max_profit;
}
```

Explanation:

- We initialize `min_price` as the first price in the array and `max_profit` as 0.
- We iterate through the array, updating `max_profit` by finding the maximum difference between the current price and `min_price`.
- We also update `min_price` if we find a lower price.
- At the end of the iteration, `max_profit` will hold the maximum profit achievable by buying and selling the stock at most once.

You can use this function by passing the vector of stock prices as an argument:

```cpp
int main() {
    std::vector<int> prices = {7, 1, 5, 3, 6, 4};
    int max_profit = maxProfit(prices);
    std::cout << "Maximum profit: " << max_profit << std::endl;
    return 0;
}
```

This will output:

```bash
Maximum profit: 5
```

which means the maximum profit that can be obtained by buying and selling the stock is 5.

### 1. Algorithms & Data Structures (C++): Best Time to Buy And Sell A Stock - Arrays

The "Best Time to Buy and Sell Stock" problem is a classic algorithmic problem in computer science. In this problem, you're given an array where the \(i^{th}\) element represents the price of a given stock on day \(i\). You need to find the maximum profit that can be achieved by buying and selling the stock at most once.

Here's a simple implementation of this problem in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int maxProfit(vector<int>& prices) {
    int n = prices.size();
    if (n == 0) return 0;

    int maxProfit = 0;
    int minPrice = prices[0];

    for (int i = 1; i < n; ++i) {
        maxProfit = max(maxProfit, prices[i] - minPrice);
        minPrice = min(minPrice, prices[i]);
    }

    return maxProfit;
}

int main() {
    // Example usage:
    vector<int> prices = {7, 1, 5, 3, 6, 4};
    cout << "Maximum profit: " << maxProfit(prices) << endl;
    return 0;
}
```

In this implementation, we iterate through the prices array once. For each day, we update the minimum price seen so far (`minPrice`) and calculate the potential profit if we were to sell the stock on that day (`prices[i] - minPrice`). We update the maximum profit (`maxProfit`) whenever we find a greater profit. Finally, we return the maximum profit.

### 1. Algorithms & Data Structures (C++): Big Addition Concepts

In C++, adding large numbers involves handling numbers that exceed the capacity of standard data types like `int` or `long long`. You typically tackle this by using strings or arrays to represent numbers and perform addition digit by digit, just like you would manually. Here's a concept of how you can implement big addition in C++:

```cpp
#include <iostream>
#include <string>
using namespace std;

string bigAddition(const string& num1, const string& num2) {
    int len1 = num1.length();
    int len2 = num2.length();
    int carry = 0;
    string result = "";

    // Start adding digits from the rightmost position
    int i = len1 - 1;
    int j = len2 - 1;

    while (i >= 0 || j >= 0 || carry) {
        int digitSum = carry;
        if (i >= 0)
            digitSum += num1[i--] - '0';
        if (j >= 0)
            digitSum += num2[j--] - '0';

        // Add the current digit to the result string
        result = char(digitSum % 10 + '0') + result;

        // Update carry for next calculation
        carry = digitSum / 10;
    }

    return result;
}

int main() {
    string num1 = "12345678901234567890";
    string num2 = "98765432109876543210";

    cout << "Sum: " << bigAddition(num1, num2) << endl;

    return 0;
}
```

In this implementation:

- We define a function `bigAddition` that takes two strings representing large numbers as input and returns their sum as a string.
- We initialize `carry` to 0 and `result` to an empty string.
- We iterate through both numbers from their rightmost digits to the leftmost.
- At each step, we extract the digits from both numbers, add them along with the carry, compute the sum and the carry for the next iteration, and append the resulting digit to the `result` string.
- Finally, we return the result string.

This implementation allows you to add large numbers without worrying about overflow issues that may arise with standard numeric data types.

### 1. Algorithms & Data Structures (C++): Minimum XOR Sum of Two Arrays

To find the minimum XOR sum of two arrays in C++, you can use dynamic programming with bitmasking. Here's a sample implementation:

```cpp
#include <iostream>
#include <vector>
#include <climits>

using namespace std;

int minimumXORSum(vector<int>& nums1, vector<int>& nums2) {
    int n = nums1.size();
    vector<int> dp(1 << n, INT_MAX);
    dp[0] = 0;
    
    for (int mask = 0; mask < (1 << n); mask++) {
        int cnt = __builtin_popcount(mask); // Count the number of elements included in the mask
        for (int j = 0; j < n; j++) {
            if (!(mask & (1 << j))) { // If nums2[j] is not already paired
                int newMask = mask | (1 << j);
                dp[newMask] = min(dp[newMask], dp[mask] + (nums1[cnt] ^ nums2[j]));
            }
        }
    }
    
    return dp[(1 << n) - 1];
}

int main() {
    vector<int> nums1 = {1, 3, 6};
    vector<int> nums2 = {4, 8, 7};
    cout << "Minimum XOR sum: " << minimumXORSum(nums1, nums2) << endl;
    return 0;
}
```

This code calculates the minimum XOR sum of two arrays (`nums1` and `nums2`). The function `minimumXORSum` utilizes dynamic programming with bitmasking. It iterates through all possible combinations of elements from both arrays and calculates the XOR sum. The result is stored in the `dp` array, and the minimum value is returned at the end.

Make sure to include `<iostream>`, `<vector>`, and `<climits>` headers at the beginning of your file for the code to work correctly.

### 1. Algorithms & Data Structures (C++): Mixtures-SPOJ

The Mixtures problem on SPOJ is a classic dynamic programming problem that can be solved using dynamic programming with memoization or tabulation. Here's a brief explanation of the problem and how you can approach it:

#### Problem Statement

Given a sequence of mixtures, each with a specific color and smoke intensity, you need to mix them optimally to minimize the total smoke produced. When mixing two mixtures with colors A and B, the resulting mixture has a color of (A + B) % 100 and its smoke intensity is the product of the two mixture's colors. You need to find the minimum total smoke produced when mixing all the mixtures optimally.

#### Approach

Let's define a function `solve(i, j)` as the minimum total smoke produced by mixing mixtures from index `i` to `j` (inclusive). The base case is when `i == j`, where the minimum total smoke produced is 0 because there's only one mixture.

For any other case, we can try all possible split points `k` between `i` and `j` (inclusive) and find the minimum total smoke produced by mixing mixtures from `i` to `k` and from `k+1` to `j`, plus the smoke produced by mixing these two submixtures.

We can implement this recursively, but since there will be overlapping subproblems, it's better to use memoization or tabulation to avoid redundant calculations.

#### Pseudocode (Memoization)

```plaintext
function solveMemo(i, j):
    if i == j:
        return 0
    
    if memo[i][j] is not calculated:
        min_smoke = infinity
        for k from i to j-1:
            smoke_left = solveMemo(i, k)
            smoke_right = solveMemo(k+1, j)
            total_smoke = smoke_left + smoke_right + (color[i] * color[k+1])
            min_smoke = min(min_smoke, total_smoke)
        memo[i][j] = min_smoke
    return memo[i][j]

Initialize memoization table memo with -1

min_total_smoke = solveMemo(0, N-1) // N is the number of mixtures
```

#### Implementation in C++

```cpp
#include <iostream>
#include <vector>
#include <climits>
using namespace std;

vector<vector<int>> memo;
vector<int> color;

int solveMemo(int i, int j) {
    if (i == j) return 0;
    if (memo[i][j] != -1) return memo[i][j];
    
    int min_smoke = INT_MAX;
    for (int k = i; k < j; k++) {
        int smoke_left = solveMemo(i, k);
        int smoke_right = solveMemo(k + 1, j);
        int total_smoke = smoke_left + smoke_right + (color[i] * color[k + 1]);
        min_smoke = min(min_smoke, total_smoke);
    }
    memo[i][j] = min_smoke;
    return min_smoke;
}

int main() {
    int N;
    while (cin >> N) {
        color.resize(N);
        memo.assign(N, vector<int>(N, -1));
        for (int i = 0; i < N; i++) {
            cin >> color[i];
        }
        int min_total_smoke = solveMemo(0, N - 1);
        cout << min_total_smoke << endl;
    }
    return 0;
}
```

This C++ code should solve the Mixtures problem on SPOJ efficiently using memoization.

### 1. Algorithms & Data Structures (C++): A Mazing Problem

The "Mazing Problem" typically refers to solving a maze using algorithms and data structures. In C++, you can employ various algorithms such as Depth-First Search (DFS) or Breadth-First Search (BFS) to find a path through the maze. Here's a simplified example of how you might approach it using DFS:

```cpp
#include <iostream>
#include <vector>
#include <stack>

using namespace std;

// Define the dimensions of the maze
const int ROWS = 5;
const int COLS = 5;

// Define directions: Up, Right, Down, Left
const int dirRow[] = {-1, 0, 1, 0};
const int dirCol[] = {0, 1, 0, -1};

// Structure to represent a cell in the maze
struct Cell {
    int row, col;
};

// Function to check if a cell is valid (within bounds and not blocked)
bool isValid(int row, int col, vector<vector<int>>& maze) {
    return (row >= 0 && row < ROWS && col >= 0 && col < COLS && maze[row][col] == 1);
}

// Function to solve the maze using DFS
bool solveMazeDFS(vector<vector<int>>& maze, int startRow, int startCol, int endRow, int endCol) {
    stack<Cell> stk;
    vector<vector<bool>> visited(ROWS, vector<bool>(COLS, false));

    // Push the starting cell onto the stack
    stk.push({startRow, startCol});
    visited[startRow][startCol] = true;

    while (!stk.empty()) {
        Cell curr = stk.top();
        stk.pop();

        // If the current cell is the destination, we've found the solution
        if (curr.row == endRow && curr.col == endCol)
            return true;

        // Explore all possible directions from the current cell
        for (int i = 0; i < 4; ++i) {
            int newRow = curr.row + dirRow[i];
            int newCol = curr.col + dirCol[i];

            // If the new cell is valid and not visited yet, push it onto the stack
            if (isValid(newRow, newCol, maze) && !visited[newRow][newCol]) {
                stk.push({newRow, newCol});
                visited[newRow][newCol] = true;
            }
        }
    }

    // If stack becomes empty and we haven't reached the destination, maze has no solution
    return false;
}

int main() {
    // Example maze represented as a 2D vector
    vector<vector<int>> maze = {
        {1, 0, 1, 1, 1},
        {1, 1, 1, 0, 1},
        {0, 0, 0, 1, 1},
        {1, 0, 1, 1, 0},
        {1, 1, 1, 1, 1}
    };

    // Starting and ending points
    int startRow = 0, startCol = 0;
    int endRow = 4, endCol = 4;

    if (solveMazeDFS(maze, startRow, startCol, endRow, endCol)) {
        cout << "Path found!\n";
    } else {
        cout << "No path found.\n";
    }

    return 0;
}
```

This code implements a simple depth-first search to find a path from the starting point to the ending point in a maze represented as a 2D grid. You can adjust the maze layout and starting/ending points to test different scenarios.

### 1. Algorithms & Data Structures (C++): Activity Scheduling Problem

The Activity Scheduling Problem is a classic problem in computer science and involves selecting the maximum number of non-overlapping activities that can be performed, given a set of activities each marked with a start time and an end time. Here's a C++ implementation of the Activity Scheduling Problem using a greedy algorithm:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

// Structure to represent an activity
struct Activity {
    int start, finish;
};

// Function to compare activities based on their finish time
bool activityCompare(const Activity& a, const Activity& b) {
    return (a.finish < b.finish);
}

// Function to find the maximum number of activities that can be scheduled
void maxActivities(std::vector<Activity>& activities) {
    // Sort activities based on their finish time
    std::sort(activities.begin(), activities.end(), activityCompare);
    
    // The first activity always gets selected
    std::cout << "Selected activities: ";
    int i = 0;
    std::cout << "(" << activities[i].start << ", " << activities[i].finish << "), ";
    
    // Consider the rest of the activities
    for (int j = 1; j < activities.size(); j++) {
        // If this activity has a start time greater than or equal to the finish time of the previously selected activity, then select it
        if (activities[j].start >= activities[i].finish) {
            std::cout << "(" << activities[j].start << ", " << activities[j].finish << "), ";
            i = j;
        }
    }
    std::cout << std::endl;
}

int main() {
    std::vector<Activity> activities = {{1, 2}, {3, 4}, {0, 6}, {5, 7}, {8, 9}, {5, 9}};
    
    std::cout << "Original activities: ";
    for (const auto& activity : activities) {
        std::cout << "(" << activity.start << ", " << activity.finish << "), ";
    }
    std::cout << std::endl;
    
    maxActivities(activities);
    
    return 0;
}
```

This code first defines a structure `Activity` to represent each activity with start and finish times. Then, it defines a function `activityCompare` to compare activities based on their finish times, which is used to sort the activities. The `maxActivities` function implements the greedy algorithm to select the maximum number of non-overlapping activities. Finally, in the `main` function, an example set of activities is defined, and the `maxActivities` function is called to find the maximum number of activities that can be scheduled.

### 1. Algorithms & Data Structures (C++): Activity Selection Problem

The Activity Selection Problem is a classic problem in computer science where you're given a set of activities, each with a start and finish time, and you want to select the maximum number of non-overlapping activities. This problem can be solved using a greedy algorithm. Here's how you can solve it in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// Structure to represent an activity
struct Activity {
    int start, finish;
};

// Function to compare activities based on their finish time
bool activityCompare(const Activity& a, const Activity& b) {
    return (a.finish < b.finish);
}

// Function to solve the activity selection problem
void selectActivities(vector<Activity>& activities) {
    // Sort activities based on finish time
    sort(activities.begin(), activities.end(), activityCompare);

    // The first activity is always selected
    cout << "Selected activities: ";
    int i = 0;
    cout << "[" << activities[i].start << ", " << activities[i].finish << "] ";
    
    // Consider the rest of the activities
    for (int j = 1; j < activities.size(); j++) {
        // If this activity has a start time greater than or equal to the finish
        // time of the previously selected activity, then select it
        if (activities[j].start >= activities[i].finish) {
            cout << "[" << activities[j].start << ", " << activities[j].finish << "] ";
            i = j; // Update index of the last selected activity
        }
    }
    cout << endl;
}

int main() {
    vector<Activity> activities = {{1, 2}, {3, 4}, {0, 6}, {5, 7}, {8, 9}, {5, 9}};
    
    selectActivities(activities);
    
    return 0;
}
```

This C++ code defines a structure `Activity` to represent each activity with start and finish times. It then defines a comparison function `activityCompare` to sort the activities based on their finish times. The `selectActivities` function implements the greedy algorithm to select the maximum number of non-overlapping activities. Finally, in the `main` function, a sample set of activities is defined and passed to the `selectActivities` function to demonstrate its usage.

### 1. Algorithms & Data Structures (C++): Aggressive Cows

The Aggressive Cows problem is a classic problem in algorithms and data structures. It goes like this:

You have a set of stalls, each with a certain position along a straight line. You also have a certain number of cows. The goal is to place the cows in the stalls in such a way that the minimum distance between any two cows is as large as possible.

This problem can be solved using binary search combined with a greedy algorithm. Here's a high-level approach to solve it:

1. Sort the positions of the stalls.
2. Initialize two variables, `low` and `high`, to represent the minimum and maximum possible minimum distances between any two cows. `low` will initially be set to 0, and `high` will be set to the maximum possible distance, which is the distance between the first and last stall.
3. Perform binary search on the range `[low, high]` to find the maximum minimum distance that satisfies the condition.
4. In each iteration of binary search, calculate the mid-point (`mid`) of the current range.
5. Use a greedy algorithm to try to place the cows in the stalls such that the minimum distance between any two cows is at least `mid`.
6. If it's possible to place all the cows with this minimum distance, update `low = mid + 1`. Otherwise, update `high = mid - 1`.
7. Repeat steps 3-6 until `low > high`. The answer will be stored in `high`, which represents the maximum minimum distance.

Here's a sample implementation in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

bool canPlaceCows(const vector<int>& stalls, int cows, int distance) {
    int count = 1;
    int last_position = stalls[0];
    for (int i = 1; i < stalls.size(); ++i) {
        if (stalls[i] - last_position >= distance) {
            last_position = stalls[i];
            count++;
        }
        if (count == cows) {
            return true;
        }
    }
    return false;
}

int aggressiveCows(const vector<int>& stalls, int cows) {
    int low = 0;
    int high = stalls.back() - stalls.front();
    int max_min_distance = 0;

    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (canPlaceCows(stalls, cows, mid)) {
            max_min_distance = mid;
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    return max_min_distance;
}

int main() {
    vector<int> stalls = {1, 2, 4, 8, 9};
    int cows = 3;
    int result = aggressiveCows(stalls, cows);
    cout << "Maximum minimum distance between cows: " << result << endl;
    return 0;
}
```

This implementation assumes that the positions of the stalls are given in sorted order. The `aggressiveCows` function calculates the maximum minimum distance using binary search, and the `canPlaceCows` function checks whether it's possible to place the cows with a given minimum distance.

### 1. Algorithms & Data Structures (C++): Airbnb Math Question: Single Number

The Single Number problem is a classic algorithmic problem often encountered in coding interviews and competitive programming challenges. The problem statement typically goes like this:

Given an array of integers where every element appears twice except for one, which appears exactly once, find and return that single element.

Here's an example of the problem:

```plaintext
Input: [4, 1, 2, 1, 2]
Output: 4
```

The naive approach to solve this problem is to use a hash table (unordered_map in C++) to store the frequency of each number and then iterate through the hash table to find the number with a frequency of 1.

However, a more efficient solution is to use bitwise XOR (^) operation. XORing a number with itself yields 0, so if we XOR all the numbers in the array, the duplicates will cancel each other out, leaving only the single number.

Here's how you can implement this in C++:

```cpp
#include <vector>

int singleNumber(std::vector<int>& nums) {
    int result = 0;
    for (int num : nums) {
        result ^= num;
    }
    return result;
}
```

This solution has a time complexity of O(n), where n is the number of elements in the array, and it requires only constant extra space.

### 1. Algorithms & Data Structures (C++): Alice and Candies

Sure! "Alice and Candies" is a classic problem that can be solved using dynamic programming. Here's the problem statement:

Alice loves candies, and she wants to collect as many candies as possible. She starts at position 0 on a straight line and there are 'n' positions numbered from 0 to n-1 where the candies are placed. Each position 'i' has a certain number of candies, given by an array 'candies[]'.

Alice can only move to the right, and the number of candies she can collect at each position is given by the array 'candies[]'. However, she can only move to a position if the number of candies at that position is strictly greater than the number of candies she has collected so far.

Your task is to determine the maximum number of candies Alice can collect.

Here's a sample solution in C++ using dynamic programming:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int maxCandies(vector<int>& candies) {
    int n = candies.size();
    vector<int> dp(n, 0); // dp[i] stores the maximum candies Alice can collect starting from position i

    // Base case: at the last position, Alice can only collect candies at that position
    dp[n - 1] = candies[n - 1];

    // Fill the dp array from right to left
    for (int i = n - 2; i >= 0; i--) {
        // If the number of candies at position i is greater than the maximum candies collected so far (dp[i + 1]),
        // Alice can move to position i and collect candies
        if (candies[i] > dp[i + 1]) {
            dp[i] = candies[i] + dp[i + 1];
        } else {
            // If she can't move to position i, she can't collect any more candies beyond this position
            dp[i] = dp[i + 1];
        }
    }

    // Maximum candies Alice can collect is the value at dp[0]
    return dp[0];
}

int main() {
    vector<int> candies = {2, 3, 5, 1, 3};
    cout << "Maximum candies Alice can collect: " << maxCandies(candies) << endl;
    return 0;
}
```

This code initializes a dynamic programming array `dp`, where `dp[i]` represents the maximum number of candies Alice can collect starting from position `i`. Then, it iterates through the positions from right to left, updating `dp[i]` based on whether Alice can move to position `i` or not. Finally, it returns `dp[0]`, which represents the maximum number of candies Alice can collect starting from the beginning.

### 1. Algorithms & Data Structures (C++): Alice Problem

The Alice Problem is a classic problem in algorithms and data structures. It's a scenario where Alice wants to send a secret message to Bob, but they need to ensure that the message remains confidential even if intercepted by a malicious third party.

Here's a typical approach to solving the Alice Problem:

1. **Encryption**: Alice encrypts her message using a cryptographic algorithm. This algorithm transforms the message into an unreadable format that can only be understood by someone who possesses the decryption key.

2. **Key Exchange**: Alice and Bob need to agree on a secret key for encryption and decryption. This key should be exchanged securely, preferably using a secure channel or through a secure key exchange protocol like Diffie-Hellman key exchange.

3. **Transmission**: After encrypting the message and agreeing on a secret key, Alice sends the encrypted message to Bob through a potentially insecure communication channel.

4. **Decryption**: Upon receiving the encrypted message, Bob decrypts it using the agreed-upon secret key. Only Bob, who possesses the correct key, can decrypt and read the original message.

In terms of data structures and algorithms, cryptographic algorithms like AES (Advanced Encryption Standard), RSA (Rivest-Shamir-Adleman), or ECC (Elliptic Curve Cryptography) are often employed for encryption and decryption. These algorithms rely on various data structures and mathematical techniques to ensure the security of the communication.

Additionally, efficient key exchange algorithms and protocols are crucial for securely establishing shared keys between Alice and Bob. Data structures like hash tables, trees, or graphs might be utilized in implementing these algorithms.

Overall, the Alice Problem highlights the importance of secure communication protocols, encryption algorithms, and key exchange mechanisms in ensuring confidentiality and integrity in data transmission over potentially insecure channels.

### 1. Algorithms & Data Structures (C++): Alice Studies Informatics

That sounds like a fascinating subject! Algorithms and data structures are fundamental in computer science and informatics. If Alice is studying this area, she's delving into the core of how computers manage and manipulate data efficiently. From understanding how to store and retrieve information to optimizing processes through algorithms, it's a field rich with both theory and practical application.

Here's a brief overview of what Alice might encounter:

1. **Data Structures**: These are the building blocks for organizing and storing data in a computer's memory. Examples include arrays, linked lists, stacks, queues, trees, graphs, and hash tables. Each has its own advantages and use cases, and understanding when to use each one is crucial.

2. **Algorithms**: Algorithms are step-by-step procedures for solving problems. They can range from simple sorting algorithms like bubble sort to complex graph traversal algorithms like Dijkstra's algorithm. Alice would likely study different algorithm design techniques, such as divide and conquer, dynamic programming, and greedy algorithms.

3. **Analysis of Algorithms**: It's not just about knowing how to implement algorithms; Alice will also learn how to analyze their efficiency. This involves understanding concepts like time complexity and space complexity, which help determine how an algorithm will perform as the size of the input data increases.

4. **Advanced Topics**: Depending on her interests and the depth of her studies, Alice might also explore advanced topics like algorithmic complexity theory, computational geometry, parallel and distributed algorithms, and more.

C++ is a powerful language for implementing algorithms and data structures due to its efficiency and flexibility. It allows for low-level manipulation of memory, which is crucial for implementing many data structures, while also providing high-level abstractions that make algorithm implementation more readable and maintainable.

Is there a specific aspect of algorithms and data structures you'd like to delve into further? Or perhaps some specific problem you or Alice are facing?

### 1. Algorithms & Data Structures (C++): Algorithm : Moore Voting : Majority Element

The Moore Voting algorithm is a clever approach to find the majority element in an array, if it exists. The majority element is the element that appears more than n/2 times in an array of size n. This algorithm has a time complexity of O(n) and a space complexity of O(1). Here's how it works in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int findMajorityElement(vector<int>& nums) {
    int candidate = 0;
    int count = 0;

    // Find the candidate for majority element
    for (int num : nums) {
        if (count == 0) {
            candidate = num;
            count = 1;
        } else if (num == candidate) {
            count++;
        } else {
            count--;
        }
    }

    // Verify if the candidate is the majority element
    count = 0;
    for (int num : nums) {
        if (num == candidate) {
            count++;
        }
    }

    if (count > nums.size() / 2) {
        return candidate;
    } else {
        return -1; // Majority element doesn't exist
    }
}

int main() {
    vector<int> nums = {3, 3, 4, 2, 4, 4, 2, 4, 4};
    int majorityElement = findMajorityElement(nums);
    if (majorityElement != -1) {
        cout << "The majority element is: " << majorityElement << endl;
    } else {
        cout << "Majority element does not exist" << endl;
    }
    return 0;
}
```

This code defines a function `findMajorityElement` that takes a reference to a vector of integers `nums`. It iterates through the vector once to find a candidate for the majority element. Then, it verifies if the candidate is indeed the majority element by counting its occurrences. If it appears more than n/2 times, it returns the candidate; otherwise, it returns -1 to indicate that there is no majority element. Finally, in the `main` function, an example vector is used to demonstrate the algorithm.

### 1. Algorithms & Data Structures (C++): algorithm for bracket checking

Certainly! Bracket checking is a common problem encountered in computer science, particularly in parsing and interpreting languages. Here's a simple algorithm in C++ to check whether a given string has balanced brackets:

```cpp
#include <iostream>
#include <stack>
#include <string>

bool areBracketsBalanced(const std::string& expr) {
    std::stack<char> stack;

    for (char bracket : expr) {
        if (bracket == '(' || bracket == '[' || bracket == '{') {
            // Push opening brackets onto the stack
            stack.push(bracket);
        } else if (bracket == ')' || bracket == ']' || bracket == '}') {
            // If the stack is empty, there's no matching opening bracket
            if (stack.empty()) {
                return false;
            }
            // Pop the top bracket from the stack and check if it matches
            char top = stack.top();
            stack.pop();
            if ((bracket == ')' && top != '(') ||
                (bracket == ']' && top != '[') ||
                (bracket == '}' && top != '{')) {
                return false; // Mismatched brackets
            }
        }
    }

    // If the stack is not empty, there are unmatched opening brackets
    return stack.empty();
}

int main() {
    std::string expr = "{(a+b)*(c-d)}";
    if (areBracketsBalanced(expr)) {
        std::cout << "Balanced" << std::endl;
    } else {
        std::cout << "Not balanced" << std::endl;
    }
    return 0;
}
```

This code uses a stack to keep track of opening brackets. When it encounters a closing bracket, it checks if there's a corresponding opening bracket at the top of the stack. If the brackets match, it continues; otherwise, it returns false. At the end of the iteration, if the stack is empty, it indicates that all brackets were matched.

### 1. Algorithms & Data Structures (C++): Big Integers

Big integers, also known as arbitrarily large integers or arbitrary-precision integers, are data structures used to store and manipulate integers of unlimited size. In C++, you typically implement big integers by storing digits of the integer in an array or a linked list.

Here's a basic implementation of big integers in C++ using an array:

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

using namespace std;

class BigInt {
private:
    vector<int> digits;

public:
    BigInt() {}

    BigInt(string str) {
        for (int i = str.length() - 1; i >= 0; --i) {
            digits.push_back(str[i] - '0');
        }
    }

    void print() {
        for (int i = digits.size() - 1; i >= 0; --i) {
            cout << digits[i];
        }
        cout << endl;
    }

    BigInt operator+(const BigInt& other) const {
        BigInt result;
        int carry = 0;
        int maxDigits = max(digits.size(), other.digits.size());
        for (int i = 0; i < maxDigits || carry; ++i) {
            if (i == result.digits.size())
                result.digits.push_back(0);
            int sum = carry;
            if (i < digits.size())
                sum += digits[i];
            if (i < other.digits.size())
                sum += other.digits[i];
            carry = sum / 10;
            result.digits[i] = sum % 10;
        }
        return result;
    }
};

int main() {
    BigInt a("123456789012345678901234567890");
    BigInt b("987654321098765432109876543210");
    BigInt c = a + b;
    c.print();
    return 0;
}
```

This code defines a `BigInt` class that can handle addition of big integers. You can extend this implementation to support other arithmetic operations like subtraction, multiplication, and division as per your requirements. Additionally, you may want to implement comparison operators (`<`, `<=`, `==`, `!=`, `>=`, `>`), unary operators (`+`, `-`), and other functionalities commonly associated with integers.

### 1. Algorithms & Data Structures (C++): Amazon Array Question: Longest substring without repeating characters

To solve the problem of finding the longest substring without repeating characters, you can use the sliding window technique along with a hash set to keep track of characters. Here's how you can implement it in C++:

```cpp
#include <iostream>
#include <unordered_set>
#include <string>

using namespace std;

int longestSubstringWithoutRepeating(string s) {
    unordered_set<char> charSet;
    int maxLength = 0;
    int left = 0;
    
    for (int right = 0; right < s.length(); ++right) {
        char currentChar = s[right];
        while (charSet.find(currentChar) != charSet.end()) {
            charSet.erase(s[left]);
            ++left;
        }
        charSet.insert(currentChar);
        maxLength = max(maxLength, right - left + 1);
    }
    
    return maxLength;
}

int main() {
    string s = "abcabcbb";
    cout << "Length of the longest substring without repeating characters: " << longestSubstringWithoutRepeating(s) << endl;
    return 0;
}
```

This code defines a function `longestSubstringWithoutRepeating` which takes a string `s` as input and returns the length of the longest substring without repeating characters. It iterates through the string using a sliding window approach. The `left` and `right` pointers define the current window, and `charSet` keeps track of characters within the window. If a repeating character is encountered, the left pointer is moved to the right until the repeating character is removed from the window. The maximum length of the substring is updated as the window moves. Finally, the function returns the maximum length found.

### 1. Algorithms & Data Structures (C++): Amazon Dynamic Programming Question: Climbing Stairs

Certainly! The "Climbing Stairs" problem is a classic dynamic programming question that can be solved efficiently using either recursion with memoization or iterative dynamic programming. Here's a solution in C++ using iterative dynamic programming:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int climbStairs(int n) {
    if (n <= 2) return n;

    vector<int> dp(n + 1);
    dp[1] = 1;
    dp[2] = 2;

    for (int i = 3; i <= n; ++i) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }

    return dp[n];
}

int main() {
    int n = 5; // Example input, change this value to test with different inputs
    cout << "Number of distinct ways to climb " << n << " stairs: " << climbStairs(n) << endl;
    return 0;
}
```

In this solution, we initialize a vector `dp` of size `n + 1` to store the number of distinct ways to climb each stair. We then fill this vector iteratively starting from the base cases `dp[1] = 1` and `dp[2] = 2`. For each subsequent stair `i`, the number of ways to reach it is the sum of the number of ways to reach the previous two stairs (`dp[i - 1]` and `dp[i - 2]`). Finally, we return `dp[n]`, which represents the number of distinct ways to climb `n` stairs.

### 1. Algorithms & Data Structures (C++): Amazon Dynamic Programming Question: Climbing Stairs: Bottom up approach explanation

Sure, let's delve into the bottom-up approach for solving the climbing stairs problem using dynamic programming in C++.

The problem statement is as follows: You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

Here's how we can solve this using dynamic programming:

1. **Identify the base cases:**
    - If there are 0 steps, there's only one way to climb, i.e., not climbing at all (1 way).
    - If there's 1 step, there's only one way to climb, i.e., climbing one step (1 way).

2. **Initialize an array to store the solutions:**
    - Let's call this array `dp`, where `dp[i]` represents the number of distinct ways to climb to the ith step.

3. **Build up the solution bottom-up:**
    - Since the number of ways to reach step `i` depends only on the number of ways to reach steps `i-1` and `i-2`, we can iteratively build up the solution.
    - Start from the base cases and compute the number of ways to reach each step up to `n` using the formula: `dp[i] = dp[i-1] + dp[i-2]`.

4. **Return the result:**
    - Once we have computed the number of ways to reach the nth step, return `dp[n]`.

Here's a C++ implementation:

```cpp
#include <iostream>
#include <vector>

int climbStairs(int n) {
    // Base cases
    if (n <= 1) return 1;
    
    // Initialize dp array
    std::vector<int> dp(n + 1, 0);
    dp[0] = 1;
    dp[1] = 1;
    
    // Build up the solution bottom-up
    for (int i = 2; i <= n; ++i) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    
    // Return the result
    return dp[n];
}

int main() {
    int n = 5; // Example input
    std::cout << "Number of distinct ways to climb " << n << " steps: " << climbStairs(n) << std::endl;
    return 0;
}
```

This code will output the number of distinct ways to climb `n` steps using the bottom-up dynamic programming approach.

### 1. Algorithms & Data Structures (C++): Amazon Dynamic Programming Question: Trapping Rain Water

The "Trapping Rain Water" problem is a classic dynamic programming question frequently asked in technical interviews, including those at companies like Amazon. Here's an explanation of the problem and a solution using dynamic programming in C++:

#### Problem Statement

Given an array representing the heights of walls at different indices, where the width of each wall is 1 unit, calculate how much rainwater can be trapped between the walls.

#### Example

Input: [0,1,0,2,1,0,1,3,2,1,2,1]  
Output: 6

#### Explanation

In this example, the heights of the walls form a structure that traps 6 units of rainwater.

#### Solution (Dynamic Programming Approach)

```cpp
#include <iostream>
#include <vector>

using namespace std;

int trap(vector<int>& height) {
    int n = height.size();
    if (n == 0) return 0;

    vector<int> leftMax(n, 0); // Array to store the maximum height to the left of each index
    vector<int> rightMax(n, 0); // Array to store the maximum height to the right of each index

    leftMax[0] = height[0];
    for (int i = 1; i < n; ++i) {
        leftMax[i] = max(leftMax[i - 1], height[i]);
    }

    rightMax[n - 1] = height[n - 1];
    for (int i = n - 2; i >= 0; --i) {
        rightMax[i] = max(rightMax[i + 1], height[i]);
    }

    int water = 0;
    for (int i = 0; i < n; ++i) {
        water += min(leftMax[i], rightMax[i]) - height[i];
    }

    return water;
}

int main() {
    vector<int> height = {0,1,0,2,1,0,1,3,2,1,2,1};
    cout << "Amount of trapped rainwater: " << trap(height) << " units" << endl;
    return 0;
}
```

This solution calculates the maximum height to the left and right of each index using two arrays. Then, it traverses the height array again to compute the amount of water trapped at each index by taking the minimum of the maximum heights on both sides and subtracting the height of the current index. Finally, it sums up the trapped water at each index to get the total amount of trapped rainwater.

### 1. Algorithms & Data Structures (C++): Amazon Interview Questions

Certainly! Amazon is known for asking a variety of algorithm and data structure questions in their interviews, aiming to assess a candidate's problem-solving skills and understanding of fundamental concepts. Here are some examples of questions you might encounter:

1. **Reverse a Linked List**: Write a function to reverse a linked list.

2. **Two Sum**: Given an array of integers, return indices of the two numbers such that they add up to a specific target.

3. **Merge Two Sorted Lists**: Merge two sorted linked lists and return it as a new sorted list.

4. **Validate BST (Binary Search Tree)**: Write a function to determine if a binary tree is a valid binary search tree.

5. **Implement a Stack using Queues**: Implement a stack data structure using queues. You need to write push(), pop(), top(), and empty() methods.

6. **Longest Substring Without Repeating Characters**: Given a string, find the length of the longest substring without repeating characters.

7. **Serialize and Deserialize a Binary Tree**: Design an algorithm to serialize and deserialize a binary tree.

8. **Find Median from Data Stream**: Design a data structure that supports the following two operations: addNum(int num) - Add a integer number from the data stream to the data structure, and findMedian() - Return the median of all elements so far.

9. **Find the Intersection of Two Linked Lists**: Write a program to find the node at which the intersection of two singly linked lists begins.

10. **Word Break**: Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.

These are just a few examples, but they cover a range of difficulty levels and concepts commonly tested in technical interviews. It's important to practice solving problems like these and understand the underlying data structures and algorithms involved.

### 1. Algorithms & Data Structures (C++): Amazon Linked list question: Linked list cycle

Certainly! The "Linked List Cycle" problem is a classic algorithmic problem often asked in technical interviews, and it's also relevant to Amazon's hiring process, given their focus on algorithmic problem-solving skills. Here's how it typically goes:

#### Problem Statement

Given a linked list, determine if it has a cycle in it. A cycle is when a node in the linked list points to a previously visited node, creating a loop in the linked list.

#### Example

```plaintext
Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).
```

#### Approach

The most common approach to solve this problem is by using two pointers, often referred to as the slow pointer and the fast pointer. The slow pointer moves one step at a time, while the fast pointer moves two steps at a time. If there's a cycle, eventually, the fast pointer will meet the slow pointer.

#### C++ Solution

```cpp
#include <iostream>

using namespace std;

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    bool hasCycle(ListNode *head) {
        if (head == nullptr || head->next == nullptr) return false;

        ListNode *slow = head;
        ListNode *fast = head->next;

        while (slow != fast) {
            if (fast == nullptr || fast->next == nullptr) return false;
            slow = slow->next;
            fast = fast->next->next;
        }

        return true;
    }
};

// Example usage:
int main() {
    Solution solution;
    ListNode* head = new ListNode(3);
    head->next = new ListNode(2);
    head->next->next = new ListNode(0);
    head->next->next->next = new ListNode(-4);
    head->next->next->next->next = head->next; // Creating a cycle

    cout << (solution.hasCycle(head) ? "Cycle detected!" : "No cycle detected.") << endl;

    // Clean up memory
    ListNode* current = head;
    while (current != nullptr) {
        ListNode* temp = current;
        current = current->next;
        delete temp;
    }

    return 0;
}
```

In this C++ solution, the `hasCycle` function uses the two-pointer technique to determine whether there's a cycle in the linked list. The `main` function demonstrates its usage with an example.

### 1. Algorithms & Data Structures (C++): Amazon Math Question: Count Primes

Certainly! The problem of counting primes is a classic algorithmic task. Here's a straightforward C++ implementation to count the number of prime numbers less than a given number `n` using the Sieve of Eratosthenes algorithm:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int countPrimes(int n) {
    // Create a boolean vector "isPrime" and initialize all entries as true.
    // A value in isPrime[i] will be false if i is not a prime, else true.
    vector<bool> isPrime(n, true);

    // 0 and 1 are not primes, so mark them as false.
    isPrime[0] = false;
    isPrime[1] = false;

    // Iterate over the numbers starting from 2.
    for (int i = 2; i * i < n; ++i) {
        // If isPrime[i] is true, then i is a prime.
        if (isPrime[i]) {
            // Mark all multiples of i as false since they cannot be primes.
            for (int j = i * i; j < n; j += i) {
                isPrime[j] = false;
            }
        }
    }

    // Count the number of primes (the number of true entries in isPrime).
    int count = 0;
    for (int i = 2; i < n; ++i) {
        if (isPrime[i]) {
            ++count;
        }
    }

    return count;
}

int main() {
    int n;
    cout << "Enter a number: ";
    cin >> n;
    cout << "Number of primes less than " << n << ": " << countPrimes(n) << endl;
    return 0;
}
```

This program first initializes a boolean vector `isPrime`, where each element represents whether its index is a prime number or not. Then it iterates through the numbers up to the square root of `n`, marking multiples of each prime number as not prime. Finally, it counts the number of primes and returns the count.

### 1. Algorithms & Data Structures (C++): Amazon Math Question: Robot return to origin

The "Robot return to origin" problem is a classic algorithmic problem where you're given a sequence of moves representing the path of a robot. The task is to determine if the robot returns to its original starting position (the origin) after executing all the moves. Each move can be represented by a character: 'U' for up, 'D' for down, 'L' for left, and 'R' for right.

Here's a simple C++ implementation to solve this problem:

```cpp
#include <iostream>
#include <string>

bool judgeCircle(std::string moves) {
    int x = 0, y = 0; // Initial position of the robot
    
    // Iterate through each move
    for(char move : moves) {
        if(move == 'U') y++; // Move up
        else if(move == 'D') y--; // Move down
        else if(move == 'L') x--; // Move left
        else if(move == 'R') x++; // Move right
    }
    
    // Check if the robot returns to the origin
    return x == 0 && y == 0;
}

int main() {
    std::string moves = "UDLR"; // Example sequence of moves
    if(judgeCircle(moves))
        std::cout << "The robot returns to the origin." << std::endl;
    else
        std::cout << "The robot does not return to the origin." << std::endl;
    
    return 0;
}
```

In this code:

- The `judgeCircle` function takes a string `moves` as input and returns true if the robot returns to the origin, and false otherwise.
- Inside `judgeCircle`, two variables `x` and `y` represent the current position of the robot. Initially, they are both set to 0.
- We iterate through each character in the `moves` string. For each character, we update the position of the robot accordingly.
- Finally, we check if the final position of the robot is `(0, 0)` (i.e., the origin). If so, we return true; otherwise, we return false.

This implementation has a time complexity of O(n), where n is the number of moves in the input string.

### 1. Algorithms & Data Structures (C++): Amazon Stack Question: Valid Parenthesis

Sure, here's a simple implementation of a function in C++ to check if a string containing just parentheses ('(', ')', '{', '}', '[', ']') is valid or not using a stack:

```cpp
#include <iostream>
#include <stack>
#include <string>

bool isValidParentheses(const std::string& s) {
    std::stack<char> stack;
    for (char c : s) {
        if (c == '(' || c == '{' || c == '[') {
            stack.push(c);
        } else {
            if (stack.empty()) return false;
            char top = stack.top();
            stack.pop();
            if ((c == ')' && top != '(') ||
                (c == '}' && top != '{') ||
                (c == ']' && top != '[')) {
                return false;
            }
        }
    }
    return stack.empty();
}

int main() {
    std::string test_string = "{[()]}";
    if (isValidParentheses(test_string)) {
        std::cout << "Valid parentheses" << std::endl;
    } else {
        std::cout << "Invalid parentheses" << std::endl;
    }
    return 0;
}
```

This code uses a stack to store opening parentheses encountered so far. When a closing parenthesis is encountered, it checks if the stack is empty (meaning there is no corresponding opening parenthesis). If not, it pops the top element from the stack and checks if it corresponds to the closing parenthesis. If not, the parentheses are not valid. At the end of the loop, if the stack is not empty, it means there were more opening parentheses than closing ones, so the string is also invalid.

### 1. Algorithms & Data Structures (C++): Amazon Trees question: Path Sum

Sure, I can help you with that! In the context of binary trees, a "path sum" problem typically involves finding whether there exists a path from the root to a leaf node such that the sum of values along this path equals a given target sum.

Here's a basic outline of how you might approach this problem:

1. **Define the Binary Tree Node Structure**: Start by defining the structure of a binary tree node in C++. Each node should have a value and pointers to its left and right children.

2. **Implement the Path Sum Function**: Write a function to check whether there exists a path from the root to a leaf node such that the sum of values along the path equals the given target sum. You can implement this function recursively, traversing the tree and keeping track of the current sum.

3. **Recursive Approach**: Recursively traverse the tree. At each node, subtract the node's value from the target sum and continue traversing down the left and right subtrees. If you reach a leaf node and the remaining sum equals the leaf node's value, then a path with the target sum exists.

4. **Base Cases**: Handle the base cases where the current node is null (indicating an empty subtree) and when you reach a leaf node.

5. **Example Code**:

```cpp
#include <iostream>

using namespace std;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

bool hasPathSum(TreeNode* root, int sum) {
    if (root == nullptr) return false;
    
    // If the current node is a leaf node and its value equals the remaining sum, return true
    if (root->left == nullptr && root->right == nullptr && sum - root->val == 0)
        return true;

    // Recursively check the left and right subtrees
    return hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val);
}

int main() {
    // Example Usage
    TreeNode* root = new TreeNode(5);
    root->left = new TreeNode(4);
    root->right = new TreeNode(8);
    root->left->left = new TreeNode(11);
    root->left->left->left = new TreeNode(7);
    root->left->left->right = new TreeNode(2);
    root->right->left = new TreeNode(13);
    root->right->right = new TreeNode(4);
    root->right->right->right = new TreeNode(1);

    int targetSum = 22;
    cout << "Path with sum " << targetSum << " exists: " << (hasPathSum(root, targetSum) ? "Yes" : "No") << endl;

    // Free allocated memory
    delete root->right->right->right;
    delete root->right->right;
    delete root->right->left;
    delete root->right;
    delete root->left->left->right;
    delete root->left->left->left;
    delete root->left->left;
    delete root->left;
    delete root;

    return 0;
}
```

This is a basic implementation. Depending on the specific requirements or constraints of your problem, you may need to modify or optimize it further. Let me know if you need more clarification or assistance with anything!

### 1. Algorithms & Data Structures (C++): Angry Birds

Designing a game like Angry Birds involves a combination of algorithms and data structures to handle physics simulation, collision detection, rendering, game logic, and more. Here's a high-level overview of some key aspects and how they might be implemented in C++:

1. **Physics Simulation**:
   - **Verlet Integration**: Use Verlet integration for simulating physics. Verlet integration is suitable for games because it's stable and efficient for simulating motion.
   - **Data Structures**: Use a data structure like a quadtree to efficiently handle collision detection among various game objects like birds, obstacles, and pigs.

2. **Collision Detection**:
   - **Bounding Boxes**: Represent game objects with bounding boxes for fast initial collision detection.
   - **Narrow Phase Collision Detection**: Use more precise algorithms like Separating Axis Theorem (SAT) or Gilbert-Johnson-Keerthi (GJK) algorithm for precise collision detection once initial collisions are detected.
   - **Data Structures**: Spatial partitioning techniques like quadtree or octree can help optimize collision detection, especially in scenes with many objects.

3. **Rendering**:
   - **OpenGL or DirectX**: Use a graphics API like OpenGL or DirectX for rendering.
   - **Sprite Rendering**: Implement a sprite rendering system to draw game objects like birds, obstacles, and pigs on the screen.
   - **Particle Systems**: Implement particle systems for effects like explosions and debris when objects collide.

4. **Game Logic**:
   - **Finite State Machines (FSM)**: Implement FSMs to manage the states of various game objects like birds (ready to launch, in flight, collided, etc.).
   - **Event Handling**: Implement event-driven architecture to handle player input, collisions, and game events like level completion or failure.

5. **User Interface**:
   - **Graphical User Interface (GUI)**: Implement a GUI system for menus, level selection, and in-game HUD (Heads-Up Display).
   - **Input Handling**: Manage user input for controlling the trajectory and actions of the birds using mouse or touch inputs.

6. **Level Design and Management**:
   - **Level Data Representation**: Design a data structure to represent levels, including the positions and types of obstacles and pigs.
   - **Level Progression**: Implement logic for unlocking new levels and tracking player progress.

7. **Audio**:
   - **Sound Effects**: Integrate sound effects for actions like bird launching, collisions, and destruction of objects.
   - **Music**: Include background music that fits the theme of the game.

8. **Optimization**:
   - **Profiling**: Use profiling tools to identify performance bottlenecks and optimize critical sections of the code.
   - **Data Structure Optimization**: Optimize data structures and algorithms for memory usage and runtime performance.

In C++, you'd implement these aspects using classes, structures, functions, and libraries like OpenGL or DirectX for graphics and audio. Careful design and optimization are essential for creating a smooth and enjoyable gaming experience.

### 1. Algorithms & Data Structures (C++): Astronaut Pairs

To solve the "Astronaut Pairs" problem, you can use the concept of connected components in a graph. Here's a step-by-step approach:

1. **Represent Astronauts as Nodes**: Each astronaut will be represented as a node in the graph.

2. **Build the Graph**: Iterate through the astronaut pairs and create edges between the astronauts in each pair. This step constructs the graph.

3. **Find Connected Components**: Use depth-first search (DFS) or breadth-first search (BFS) to find connected components in the graph. Each connected component represents a group of astronauts who can form a pair.

4. **Calculate Pair Combinations**: After identifying the connected components, calculate the number of possible pair combinations within each component. For a connected component with 'n' astronauts, the number of pairs can be calculated using the formula: \( \frac{n \times (n-1)}{2} \).

5. **Sum Up Pairs**: Sum up the pairs from all connected components to get the total number of pairs.

Here's a C++ implementation using adjacency list representation and DFS:

```cpp
#include <iostream>
#include <vector>
#include <unordered_set>

using namespace std;

class Graph {
    int V;
    vector<int> *adj;

public:
    Graph(int V) {
        this->V = V;
        adj = new vector<int>[V];
    }

    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    void DFSUtil(int v, bool visited[], unordered_set<int> &component) {
        visited[v] = true;
        component.insert(v);

        for (int i : adj[v]) {
            if (!visited[i])
                DFSUtil(i, visited, component);
        }
    }

    unordered_set<unordered_set<int>> connectedComponents() {
        bool *visited = new bool[V];
        for (int v = 0; v < V; v++)
            visited[v] = false;

        unordered_set<unordered_set<int>> components;

        for (int v = 0; v < V; v++) {
            if (!visited[v]) {
                unordered_set<int> component;
                DFSUtil(v, visited, component);
                components.insert(component);
            }
        }

        delete[] visited;
        return components;
    }
};

long long countPairs(int n) {
    return n * (n - 1) / 2;
}

int main() {
    int N, P;
    cin >> N >> P;

    Graph g(N);

    for (int i = 0; i < P; ++i) {
        int u, v;
        cin >> u >> v;
        g.addEdge(u, v);
    }

    auto components = g.connectedComponents();
    long long totalPairs = 0;

    for (const auto &component : components) {
        int componentSize = component.size();
        totalPairs += countPairs(componentSize);
    }

    cout << totalPairs << endl;

    return 0;
}
```

In this code:

- `Graph` class represents the graph using adjacency list representation.
- `addEdge` function adds edges between vertices.
- `DFSUtil` performs Depth First Search to find connected components.
- `connectedComponents` returns a set of sets, where each inner set represents a connected component.
- `countPairs` calculates the number of pairs in a connected component.
- In `main`, it reads the input, builds the graph, finds connected components, calculates pairs, and prints the result.

This code should give you a good starting point to solve the "Astronaut Pairs" problem efficiently in C++.

### 1. Algorithms & Data Structures (C++): Apple Linked list question: Merge Two Sorted Lists

Sure, I can help you with that. In C++, you can merge two sorted linked lists into one sorted linked list efficiently. Here's a basic implementation:

```cpp
#include <iostream>

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        // Create a dummy node to start the merged list
        ListNode* dummy = new ListNode(0);
        ListNode* current = dummy;

        // Traverse both lists simultaneously
        while (l1 != nullptr && l2 != nullptr) {
            if (l1->val < l2->val) {
                current->next = l1;
                l1 = l1->next;
            } else {
                current->next = l2;
                l2 = l2->next;
            }
            current = current->next;
        }

        // If any list has remaining nodes, append them
        if (l1 != nullptr)
            current->next = l1;
        else
            current->next = l2;

        // Return the merged list starting from the next of dummy node
        return dummy->next;
    }
};

// Helper function to print the linked list
void printList(ListNode* head) {
    while (head != nullptr) {
        std::cout << head->val << " ";
        head = head->next;
    }
    std::cout << std::endl;
}

int main() {
    // Example usage
    ListNode* l1 = new ListNode(1);
    l1->next = new ListNode(3);
    l1->next->next = new ListNode(5);

    ListNode* l2 = new ListNode(2);
    l2->next = new ListNode(4);
    l2->next->next = new ListNode(6);

    Solution solution;
    ListNode* mergedList = solution.mergeTwoLists(l1, l2);

    std::cout << "Merged List: ";
    printList(mergedList);

    // Free the memory
    while (mergedList != nullptr) {
        ListNode* temp = mergedList;
        mergedList = mergedList->next;
        delete temp;
    }
    return 0;
}
```

This code defines a `ListNode` structure to represent each node in the linked list. Then, it defines a `Solution` class with a method `mergeTwoLists` that takes two sorted linked lists `l1` and `l2` as input and returns a new sorted linked list containing all the elements of `l1` and `l2`. Finally, there's a `main` function where you can create two sorted linked lists, merge them using the `mergeTwoLists` method, and print the result.

### 1. Algorithms & Data Structures (C++): Apple Stack Question: Binary Tree Level Order Traversal

To perform level order traversal of a binary tree in C++, you can use a queue data structure. The algorithm works by traversing the tree level by level, starting from the root node. At each level, it dequeues nodes from the queue, processes them, and enqueues their children if they exist.

Here's a basic implementation of the algorithm:

```cpp
#include <iostream>
#include <queue>

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

vector<vector<int>> levelOrder(TreeNode* root) {
    vector<vector<int>> result;
    if (root == nullptr) return result;

    queue<TreeNode*> q;
    q.push(root);

    while (!q.empty()) {
        int levelSize = q.size();
        vector<int> levelNodes;

        for (int i = 0; i < levelSize; ++i) {
            TreeNode* node = q.front();
            q.pop();
            levelNodes.push_back(node->val);

            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }

        result.push_back(levelNodes);
    }

    return result;
}

// Helper function to create a binary tree from an array representation
TreeNode* createTree(const vector<int>& nodes, int index) {
    TreeNode* root = nullptr;

    if (index < nodes.size() && nodes[index] != -1) {
        root = new TreeNode(nodes[index]);
        root->left = createTree(nodes, 2 * index + 1);
        root->right = createTree(nodes, 2 * index + 2);
    }

    return root;
}

int main() {
    // Example usage
    vector<int> nodes = {3, 9, 20, -1, -1, 15, 7}; // Input array representing the binary tree
    TreeNode* root = createTree(nodes, 0);
    vector<vector<int>> result = levelOrder(root);

    // Output the result
    cout << "Level Order Traversal:" << endl;
    for (const auto& level : result) {
        for (int val : level) {
            cout << val << " ";
        }
        cout << endl;
    }

    return 0;
}
```

This code defines a TreeNode structure representing a node in a binary tree. The `levelOrder` function takes the root of the binary tree as input and returns a vector of vectors containing the level order traversal.

In the main function, an example binary tree is created from an array representation, and the level order traversal is printed. You can replace the input array `nodes` with your own binary tree structure for testing.

### 1. Algorithms & Data Structures (C++): Mock Interview

Sure! Let's start with a typical interview question:

**Question**: Implement a function to check if a string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward. Ignore spaces, punctuation, and capitalization.

**Solution (C++)**:

```cpp
#include <iostream>
#include <string>
#include <algorithm>

bool isPalindrome(const std::string& str) {
    // Remove spaces and punctuation and convert to lowercase
    std::string cleanStr;
    for(char c : str) {
        if(std::isalnum(c))
            cleanStr += std::tolower(c);
    }

    // Check if the cleaned string is a palindrome
    int left = 0, right = cleanStr.size() - 1;
    while (left < right) {
        if (cleanStr[left] != cleanStr[right])
            return false;
        left++;
        right--;
    }
    return true;
}

int main() {
    std::string input;
    std::cout << "Enter a string: ";
    std::getline(std::cin, input);
    
    if (isPalindrome(input))
        std::cout << "Yes, it's a palindrome!" << std::endl;
    else
        std::cout << "No, it's not a palindrome!" << std::endl;
    
    return 0;
}
```

Feel free to ask if you have any questions about the code or if you want to move to another question!

### 1. Algorithms & Data Structures (C++): Big O - O(1)

In algorithms and data structures, Big O notation is used to describe the worst-case time complexity of an algorithm in terms of the size of its input. When we say an algorithm has a time complexity of O(1), it means that the time it takes to execute does not depend on the size of the input data.

In simpler terms, O(1) means that the algorithm will always execute in the same amount of time, regardless of the size of the input. This is often referred to as "constant time" complexity.

A common example of an algorithm with O(1) complexity is accessing an element in an array by its index. No matter how large the array is, accessing any element takes the same amount of time because the index calculation is straightforward and doesn't depend on the size of the array. Another example is accessing a value in a hash table, assuming a good hash function that evenly distributes values across the table.

Here's a simple C++ example illustrating constant time complexity:

```cpp
#include <iostream>
#include <vector>

int constantTimeAccess(const std::vector<int>& arr, int index) {
    // Accessing the element at the given index in the vector
    return arr[index];
}

int main() {
    std::vector<int> myArray = {1, 2, 3, 4, 5};

    // Accessing an element at index 2 (O(1) operation)
    int element = constantTimeAccess(myArray, 2);
    std::cout << "Element at index 2: " << element << std::endl;

    return 0;
}
```

No matter how large `myArray` is, accessing an element at index 2 will always take the same amount of time, making it O(1) complexity.

### 1. Algorithms & Data Structures (C++): Big O - O(logN)

In the realm of algorithms and data structures, Big O notation is used to describe the performance or complexity of an algorithm in terms of its input size. When you see O(logN), it indicates that the algorithm's time complexity grows logarithmically with the size of the input.

In simpler terms, as the input size (N) increases, the time taken by the algorithm to complete its task increases, but not proportionally. Instead, it increases in a logarithmic manner. This is often considered very efficient, especially compared to algorithms with linear (O(N)), quadratic (O(N^2)), or exponential (O(2^N)) time complexities.

Common algorithms that exhibit O(logN) time complexity include binary search on sorted arrays or trees, certain divide-and-conquer algorithms like binary exponentiation, and operations on balanced binary trees like AVL trees or Red-Black trees.

For example, in a binary search algorithm, with each comparison, the search space is halved. So, even with large input sizes, the number of steps required to find an element grows at a logarithmic rate.

### 1. Algorithms & Data Structures (C++): Big O - O(N)

In the realm of algorithms and data structures, Big O notation is a way of expressing the upper bound on the time complexity or space complexity of an algorithm in terms of the input size.

When you see O(N) notation, it means that the algorithm's time complexity grows linearly with the size of the input. Here, 'N' typically represents the size of the input data. So, if you have an algorithm with O(N) time complexity, doubling the size of the input would roughly double the time taken for the algorithm to execute.

In C++, many algorithms exhibit O(N) time complexity. For example, iterating through an array or a linked list to find a specific element would often have O(N) time complexity, where 'N' is the number of elements in the data structure.

Here's a simple example of a function in C++ that demonstrates linear time complexity:

```cpp
#include <iostream>
#include <vector>

void linearSearch(const std::vector<int>& arr, int target) {
    for (int i = 0; i < arr.size(); ++i) {
        if (arr[i] == target) {
            std::cout << "Found target at index " << i << std::endl;
            return;
        }
    }
    std::cout << "Target not found" << std::endl;
}

int main() {
    std::vector<int> myArray = {1, 2, 3, 4, 5};
    int target = 3;
    linearSearch(myArray, target);
    return 0;
}
```

In the `linearSearch` function, the loop iterates through each element of the array until it finds the target element or reaches the end of the array. The time taken by this function increases linearly with the size of the input array, hence it has O(N) time complexity.

### 1. Algorithms & Data Structures (C++): Big O - O(n^2)

In computer science, Big O notation is used to describe the performance or complexity of an algorithm in terms of the input size. O(n^2) is a notation used to denote an algorithm whose worst-case time complexity grows quadratically with the size of the input.

When an algorithm has a time complexity of O(n^2), it means that the number of operations the algorithm performs is proportional to the square of the size of the input (n). This typically arises in algorithms that involve nested loops, where each loop iterates over the input data.

In the context of data structures and algorithms implemented in C++, examples of algorithms with O(n^2) time complexity include:

1. **Bubble Sort**: A simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The worst-case time complexity of bubble sort is O(n^2).

2. **Selection Sort**: Another simple sorting algorithm that divides the input list into two parts: a sorted sublist and an unsorted sublist. It repeatedly selects the smallest (or largest, depending on sorting order) element from the unsorted sublist and moves it to the sorted sublist. The worst-case time complexity of selection sort is O(n^2).

3. **Insertion Sort**: This algorithm builds the final sorted list one element at a time by repeatedly taking the next element from the input data and inserting it into its correct position in the sorted list. The worst-case time complexity of insertion sort is O(n^2).

4. **Naive String Matching**: A basic string searching algorithm that checks for a substring's occurrence within a given string by comparing each character of the substring to each character of the string. The worst-case time complexity of naive string matching is O(n^2), where n is the length of the string.

These are just a few examples, and there are other algorithms with O(n^2) time complexity as well. It's essential to understand the time complexity of algorithms to choose the most efficient one for a given problem and input size.

### 1. Algorithms & Data Structures (C++): Big O and Scalability

Understanding Big O notation and scalability is crucial in designing efficient algorithms and data structures, especially in languages like C++. Big O notation describes the upper bound of an algorithm's time or space complexity in terms of the input size. It helps in analyzing the efficiency and scalability of algorithms and data structures.

Let's delve into some common time complexities and their scalability implications:

1. **O(1) - Constant Time**: The algorithm's runtime is independent of the input size. It's the most efficient complexity.

   ```cpp
   void constantTime(int arr[], int n) {
       cout << arr[0]; // Accessing the first element, regardless of array size
   }
   ```

   - Scalability: Remains constant regardless of input size. Ideal for situations where performance is critical.

2. **O(log n) - Logarithmic Time**: The runtime grows logarithmically with the input size.

   ```cpp
   void binarySearch(int arr[], int n, int target) {
       int low = 0;
       int high = n - 1;
       while (low <= high) {
           int mid = low + (high - low) / 2;
           if (arr[mid] == target) {
               cout << "Found at index: " << mid;
               return;
           } else if (arr[mid] < target) {
               low = mid + 1;
           } else {
               high = mid - 1;
           }
       }
       cout << "Not found";
   }
   ```

   - Scalability: Efficient for large datasets. However, it's not as fast as O(1), but still much better than linear time complexities for large inputs.

3. **O(n) - Linear Time**: The runtime increases linearly with the input size.

   ```cpp
   void linearTime(int arr[], int n) {
       for (int i = 0; i < n; i++) {
           cout << arr[i];
       }
   }
   ```

   - Scalability: The performance directly scales with the input size. While linear algorithms are generally efficient, they might not be suitable for very large datasets.

4. **O(n log n) - Linearithmic Time**: Common in efficient sorting algorithms like merge sort and quicksort.

   ```cpp
   void mergeSort(int arr[], int left, int right) {
       if (left < right) {
           int mid = left + (right - left) / 2;
           mergeSort(arr, left, mid);
           mergeSort(arr, mid + 1, right);
           merge(arr, left, mid, right);
       }
   }
   ```

   - Scalability: Offers better performance than quadratic time complexities (e.g., O(n^2)) for large datasets.

5. **O(n^2) - Quadratic Time**: Common in algorithms with nested iterations.

   ```cpp
   void bubbleSort(int arr[], int n) {
       for (int i = 0; i < n - 1; i++) {
           for (int j = 0; j < n - i - 1; j++) {
               if (arr[j] > arr[j + 1]) {
                   swap(arr[j], arr[j + 1]);
               }
           }
       }
   }
   ```

   - Scalability: Can become inefficient for moderately large datasets due to its quadratic growth rate.

Understanding the scalability of algorithms and data structures is essential for writing efficient and maintainable code, especially when dealing with large-scale applications or processing huge volumes of data. Always strive for algorithms with better time complexities while considering trade-offs between time and space.

### 1. Algorithms & Data Structures (C++): Big O Calculation

Sure, I'd be happy to help with that! Big O notation is a way of expressing the upper bound of an algorithm's time or space complexity in terms of the input size. It's a common measure used to analyze the efficiency of algorithms.

In C++, let's take a few examples:

1. **Linear Search**: This algorithm iterates through each element in a collection until it finds the desired value. In the worst-case scenario, it may have to go through all elements.

```cpp
int linearSearch(int arr[], int n, int x) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == x) {
            return i; // Element found
        }
    }
    return -1; // Element not found
}
```

The time complexity of linear search is O(n), where 'n' is the number of elements in the array. This is because the time taken is directly proportional to the size of the input.

1. **Binary Search**: This algorithm halves the search space in each iteration, making it much more efficient than linear search.

```cpp
int binarySearch(int arr[], int low, int high, int x) {
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] == x) {
            return mid; // Element found
        } else if (arr[mid] < x) {
            low = mid + 1; // Search in the right half
        } else {
            high = mid - 1; // Search in the left half
        }
    }
    return -1; // Element not found
}
```

The time complexity of binary search is O(log n), where 'n' is the number of elements in the array. This is because it divides the search space in half in each iteration.

These are just a couple of examples, but understanding Big O notation allows you to evaluate the efficiency of algorithms as the size of the input grows.

### 1. Algorithms & Data Structures (C++): Big O Cheat Sheet

Certainly! Here's a basic cheat sheet for common algorithms and their corresponding Big O notation in C++:

1. **Constant Time (O(1))**:
   - Operations that take the same amount of time regardless of the size of the input.

   ```cpp
   int constantTimeFunction(int arr[], int size) {
       return arr[0]; // Accessing the first element of the array
   }
   ```

2. **Linear Time (O(n))**:
   - Operations where time taken is directly proportional to the size of the input.

   ```cpp
   void linearTimeFunction(int arr[], int size) {
       for (int i = 0; i < size; ++i) {
           // Do something with arr[i]
       }
   }
   ```

3. **Logarithmic Time (O(log n))**:
   - Operations where the time taken grows logarithmically with the size of the input.

   ```cpp
   int binarySearch(int arr[], int size, int key) {
       int low = 0, high = size - 1;
       while (low <= high) {
           int mid = low + (high - low) / 2;
           if (arr[mid] == key) return mid;
           else if (arr[mid] < key) low = mid + 1;
           else high = mid - 1;
       }
       return -1; // Key not found
   }
   ```

4. **Linearithmic Time (O(n log n))**:
   - Commonly seen in efficient sorting algorithms like Merge Sort and Quick Sort.

   ```cpp
   void mergeSort(int arr[], int l, int r) {
       if (l < r) {
           int m = l + (r - l) / 2;
           mergeSort(arr, l, m);
           mergeSort(arr, m + 1, r);
           merge(arr, l, m, r);
       }
   }
   ```

5. **Quadratic Time (O(n^2))**:
   - Operations where the time taken grows quadratically with the size of the input.

   ```cpp
   void bubbleSort(int arr[], int size) {
       for (int i = 0; i < size - 1; ++i) {
           for (int j = 0; j < size - i - 1; ++j) {
               if (arr[j] > arr[j + 1]) {
                   swap(arr[j], arr[j + 1]);
               }
           }
       }
   }
   ```

6. **Exponential Time (O(2^n))**:
   - Operations where the time doubles with each addition to the input data set.

   ```cpp
   int fibonacci(int n) {
       if (n <= 1) return n;
       return fibonacci(n - 1) + fibonacci(n - 2);
   }
   ```

Remember, this is just a basic overview. Actual performance can depend on various factors including the hardware, compiler optimizations, and specific implementation details.

### 1. Algorithms & Data Structures (C++): Big O: Different Terms for Inputs

When discussing algorithms and data structures, "Big O" notation is used to describe the time or space complexity of an algorithm in terms of the size of its input. Here are some common terms used to denote different types of inputs:

1. **n**: This is the most common variable used to represent the size of the input data. It typically refers to the number of elements in an array, the number of nodes in a tree, the length of a string, etc.

2. **m**: Sometimes, in algorithms involving nested loops or multiple inputs, you might see another variable like 'm' representing a different input size. For example, if you have a 2D array, 'n' might represent the number of rows and 'm' might represent the number of columns.

3. **k**: In some cases, especially in algorithms where the input needs to be divided or partitioned, 'k' is used to represent the size of the partitions or subsets.

4. **h**: In tree-related algorithms, 'h' often represents the height of the tree. This could be the height of a binary tree, the height of an AVL tree, or any other tree-based data structure.

5. **l**: This is sometimes used to represent the length of something, like the length of a string or the number of characters in an input.

6. **V**, **E**: In graph algorithms, 'V' is often used to represent the number of vertices (nodes) in the graph, and 'E' represents the number of edges.

7. **w**: In graph algorithms with weighted edges, 'w' is often used to represent the weight of an edge.

These are just conventions, and you may encounter variations depending on the context or the preferences of the author. However, these are some of the more common ones you'll see when analyzing algorithms and their complexities.

### 1. Algorithms & Data Structures (C++): Big O: Drop Constants

In Big O notation, dropping constants is a simplification used to focus on the dominant factors that affect the performance of an algorithm. When analyzing the time complexity of algorithms, we're primarily interested in how the runtime grows relative to the size of the input, rather than exact execution times.

For example, if you have an algorithm with a time complexity of O(3n^2 + 4n + 7), when we drop the constants, it becomes O(n^2 + n + 1). The constants (3, 4, and 7) become insignificant as n grows larger, so we ignore them when determining the overall behavior of the algorithm.

This simplification makes it easier to compare the efficiency of algorithms without getting bogged down in specific implementation details or hardware differences. It focuses on the fundamental relationship between the input size and the algorithm's performance.

Here's a quick summary of dropping constants in Big O notation:

1. **Focus on Dominant Terms**: Identify the term with the highest growth rate as the dominant factor. This is typically the term with the highest exponent.

2. **Ignore Constants**: Drop any constant coefficients associated with the dominant term(s). These constants become irrelevant as the input size increases.

3. **Simplify**: Express the time complexity using the simplified terms, typically in the form O(n^k), where k is the highest exponent in the expression.

This simplification allows us to describe the performance of algorithms in a concise and consistent manner, enabling better understanding and comparison.

### 1. Algorithms & Data Structures (C++): Big O: Drop Non-Dominants

When analyzing the time or space complexity of algorithms, particularly in the context of Big O notation, it's often useful to focus on the dominant terms that have the greatest impact as the input size grows. This is known as dropping non-dominant terms.

In Big O notation, we express the upper bound of an algorithm's complexity as a function of the input size \( n \). Let's say we have an algorithm with a complexity of \( O(n^2 + n) \). As \( n \) grows, the \( n^2 \) term will quickly dominate the \( n \) term. So, we can simplify this to \( O(n^2) \) by dropping the non-dominant term \( n \).

Similarly, if we have an algorithm with complexity \( O(3n^2 + 5n + 2) \), as \( n \) becomes large, the leading term \( 3n^2 \) will dominate the others. Thus, we can simplify it to \( O(n^2) \) by dropping the non-dominant terms \( 5n \) and \( 2 \).

By focusing on the dominant terms, we can get a clearer picture of how the algorithm's performance scales with input size without being bogged down by less significant factors. This simplification makes it easier to compare and reason about different algorithms.

### 1. Algorithms & Data Structures (C++): Applications of Nim Sum

Nim Sum, also known as bitwise XOR (exclusive OR) sum, has various applications in algorithms and data structures, particularly in games theory, cryptography, and optimization problems. In the context of games, it's often used to determine winning strategies in impartial games, where players take turns removing items from heaps or piles. Here are some applications of Nim Sum:

1. **Game Theory**: In combinatorial game theory, Nim Sum is extensively used to analyze and solve impartial games like Nim, Wythoff's game, and Grundy's game. The Grundy number of a game position is precisely the Nim Sum of its component positions. This relationship helps in determining the winning strategy for various game positions.

2. **Grundy Numbers**: Grundy numbers are used to evaluate game positions. They represent the nim-value of a position in a game. By calculating the Nim Sum of the Grundy numbers of various positions, one can determine the optimal moves and winning strategies.

3. **Optimization Problems**: Nim Sum can be applied to various optimization problems, especially those involving bitwise operations. For example, it can be used in problems related to finding the maximum independent set in a graph or optimizing the allocation of resources in certain scenarios.

4. **Cryptography**: In some cryptographic algorithms, bitwise XOR operations are used extensively for encryption and decryption purposes. Nim Sum can be utilized in certain cryptographic schemes or protocols where XOR operations are prevalent.

5. **Error Detection and Correction**: In data communication and storage systems, Nim Sum can be employed for error detection and correction. XOR checksums are used to verify data integrity and detect transmission errors.

6. **Puzzle Solving**: Nim Sum can be used in solving various types of puzzles and brain teasers that involve bitwise operations. For instance, it can be applied to solving certain Sudoku variants or logic puzzles.

7. **Graph Theory**: Nim Sum can also find applications in graph theory, particularly in problems related to graph coloring, graph isomorphism, and other combinatorial optimization problems.

These are just a few examples of how Nim Sum can be applied in various domains. Its versatility in handling bitwise XOR operations makes it a powerful tool in algorithmic problem-solving and optimization.

### 1. Algorithms & Data Structures (C++): Arrays: Container With Most Water

The "Container With Most Water" problem is a classic algorithmic problem where you're given an array of non-negative integers representing the heights of walls. You're supposed to find the two walls that form a container, such that the container has the maximum area when filled with water. The width of the container is determined by the indices of the walls, and the height is determined by the shorter wall.

Here's a C++ solution using the two-pointer technique:

```cpp
#include <vector>
#include <algorithm>

using namespace std;

int maxArea(vector<int>& height) {
    int max_area = 0;
    int left = 0;
    int right = height.size() - 1;
    
    while (left < right) {
        int current_area = min(height[left], height[right]) * (right - left);
        max_area = max(max_area, current_area);
        
        if (height[left] < height[right]) {
            left++;
        } else {
            right--;
        }
    }
    
    return max_area;
}

// Example usage:
int main() {
    vector<int> heights = {1, 8, 6, 2, 5, 4, 8, 3, 7};
    int max_area = maxArea(heights);
    cout << "Max area: " << max_area << endl;
    return 0;
}
```

This solution works by using two pointers, one at the beginning of the array (`left`) and one at the end (`right`). At each step, it calculates the area formed by the current pair of walls and updates `max_area` if necessary. Then, it moves the pointer that corresponds to the shorter wall inward, since moving the pointer corresponding to the taller wall will only reduce the area (the width of the container is shrinking).

The time complexity of this solution is O(n), where n is the number of elements in the array, because each pointer moves at most n-1 steps.

### 1. Algorithms & Data Structures (C++): Arrays: Container With Most Water: Analyzing Space and Time Complexity

The problem of finding the container with the most water can be efficiently solved using a two-pointer approach. In this problem, we essentially want to maximize the area formed between the vertical lines by choosing two lines and the distance between them. Here's the algorithm:

1. Initialize two pointers, one pointing to the beginning of the array (`left`) and the other pointing to the end (`right`).
2. Calculate the area formed between the two pointers: `min(height[left], height[right]) * (right - left)`.
3. Move the pointer that corresponds to the shorter line towards the other pointer. This is because moving the pointer corresponding to the longer line will not increase the area, and since the area is bounded by the shorter line, moving the shorter line might result in a larger area.
4. Update the maximum area found so far.
5. Repeat steps 2-4 until the two pointers meet.

Here's the C++ code implementing the above algorithm:

```cpp
#include <vector>
#include <algorithm>

using namespace std;

int maxArea(vector<int>& height) {
    int maxArea = 0;
    int left = 0, right = height.size() - 1;
    
    while (left < right) {
        int area = min(height[left], height[right]) * (right - left);
        maxArea = max(maxArea, area);
        
        if (height[left] < height[right]) {
            left++;
        } else {
            right--;
        }
    }
    
    return maxArea;
}
```

Now let's analyze the space and time complexity:

- Time Complexity: The time complexity of this algorithm is O(N), where N is the number of elements in the input array. This is because we are iterating through the array once with two pointers, and each iteration takes constant time.
- Space Complexity: The space complexity of this algorithm is O(1). We are using only a constant amount of extra space regardless of the size of the input array. We are not using any data structures that grow with the size of the input. Therefore, the space complexity is constant.

### 1. Algorithms & Data Structures (C++): Arrays: Google Interview Question Two Sum

The "Two Sum" problem is a classic algorithmic problem often asked in coding interviews. The problem statement typically goes like this:

**Problem Statement:**
Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.

**Example:**

```plaintext
Input: nums = [2, 7, 11, 15], target = 9
Output: [0, 1]
Explanation: nums[0] + nums[1] = 2 + 7 = 9, so the answer is [0, 1].
```

One simple approach to solve this problem is by using a hash table (unordered_map in C++), which allows for constant-time lookups. The algorithm has a time complexity of O(n), where n is the number of elements in the array.

Here's a C++ implementation:

```cpp
#include <vector>
#include <unordered_map>

std::vector<int> twoSum(std::vector<int>& nums, int target) {
    std::unordered_map<int, int> numMap;
    std::vector<int> result;

    for (int i = 0; i < nums.size(); ++i) {
        int complement = target - nums[i];
        if (numMap.find(complement) != numMap.end()) {
            result.push_back(numMap[complement]);
            result.push_back(i);
            return result;
        }
        numMap[nums[i]] = i;
    }
    return result; // No solution found
}

// Example usage:
#include <iostream>
int main() {
    std::vector<int> nums = {2, 7, 11, 15};
    int target = 9;
    std::vector<int> indices = twoSum(nums, target);
    if (indices.size() == 2) {
        std::cout << "Indices: [" << indices[0] << ", " << indices[1] << "]" << std::endl;
    } else {
        std::cout << "No solution found." << std::endl;
    }
    return 0;
}
```

This code initializes a hash table to store the indices of the numbers as they are traversed. Then, for each number in the array, it checks if the complement (target - current number) exists in the hash table. If it does, it returns the indices of the current number and its complement. If no solution is found, an empty vector is returned.

### 1. Algorithms & Data Structures (C++): Arrays: Google Interview Question Two Sum: Analyzing Space and Time Complexity

When analyzing the space and time complexity of the Two Sum problem, let's first define the problem:

**Problem Statement:** Given an array of integers `nums` and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.

Now, let's discuss the solution and analyze its space and time complexities.

**Solution Approach:**

A straightforward approach to solve this problem is to use a hash table (unordered_map in C++). We iterate through the array once. For each element `nums[i]`, we check if the complement (`target - nums[i]`) exists in the hash table. If it does, we found the solution, and we return the indices of both numbers. If it doesn't, we add `nums[i]` to the hash table.

**Algorithm:**

1. Initialize an empty hash table to store elements and their indices.
2. Iterate through the array `nums`.
   - For each element `nums[i]`, calculate its complement `target - nums[i]`.
   - Check if the complement exists in the hash table.
     - If it exists, return the indices of the current element `i` and the complement's index from the hash table.
     - If it doesn't exist, add `nums[i]` to the hash table along with its index.
3. If no solution is found, return an empty vector or throw an exception (depending on requirements).

**Time Complexity:**

- The time complexity of this approach is O(n), where n is the number of elements in the array. This is because we traverse the array once and the average time complexity of hash table operations (insertion, deletion, and search) is O(1).

**Space Complexity:**

- The space complexity of this approach is also O(n), where n is the number of elements in the array. This is because, in the worst case, we may need to store all the elements of the array in the hash table.

**Implementation (C++):**

```cpp
#include <unordered_map>
#include <vector>

std::vector<int> twoSum(std::vector<int>& nums, int target) {
    std::unordered_map<int, int> numMap; // Stores element-value pairs

    for (int i = 0; i < nums.size(); ++i) {
        int complement = target - nums[i];
        if (numMap.find(complement) != numMap.end()) {
            return {numMap[complement], i}; // Found the solution
        }
        numMap[nums[i]] = i; // Store the current element and its index
    }

    // No solution found
    return {}; // or throw exception
}
```

This solution efficiently solves the Two Sum problem with a time complexity of O(n) and a space complexity of O(n).

### 1. Algorithms & Data Structures (C++): Arrays: Trapping Rainwater

Trapping Rainwater is a classic problem in algorithms and data structures. It's a problem where you're given an elevation map represented by an array where the width of each bar is 1. You need to compute how much rainwater can be trapped after raining.

Here's a general approach to solving the problem:

1. **Identify the water trapping areas**: Start from the first index and iterate through the array to find local maxima. These local maxima indicate potential areas where water can be trapped.

2. **Compute the water trapped**: Once you have identified the local maxima, compute the amount of water that can be trapped between them. This can be done by calculating the water level at each index. The water level at any index will be the minimum of the maximum heights of bars to its left and right, minus its own height.

3. **Sum up the trapped water**: Sum up the water trapped between each pair of local maxima.

Here's a simple implementation of the algorithm in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int trapRainwater(vector<int>& height) {
    int n = height.size();
    if (n <= 2) return 0;

    vector<int> leftMax(n), rightMax(n);

    // Calculate left max height for each position
    leftMax[0] = height[0];
    for (int i = 1; i < n; ++i)
        leftMax[i] = max(leftMax[i - 1], height[i]);

    // Calculate right max height for each position
    rightMax[n - 1] = height[n - 1];
    for (int i = n - 2; i >= 0; --i)
        rightMax[i] = max(rightMax[i + 1], height[i]);

    // Calculate trapped water
    int water = 0;
    for (int i = 0; i < n; ++i)
        water += min(leftMax[i], rightMax[i]) - height[i];

    return water;
}

int main() {
    vector<int> height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};
    cout << "Trapped rainwater: " << trapRainwater(height) << endl;
    return 0;
}
```

This implementation calculates the left and right maximum heights for each position separately and then calculates the trapped water by subtracting the height of each bar from the minimum of its left and right maximum heights. Finally, it sums up the trapped water for all positions.

### 1. Algorithms & Data Structures (C++): Arrays: Trapping Rainwater: Analyzing Space and Time Complexity

The problem of trapping rainwater is a classic one in algorithmic interviews and involves finding out how much rainwater can be trapped between bars in an array representing elevation levels. Let's analyze the space and time complexity of a typical solution in C++.

Here's a basic algorithm:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int trap(vector<int>& height) {
    int n = height.size();
    if (n <= 2) return 0;
    
    vector<int> leftMax(n), rightMax(n);
    leftMax[0] = height[0];
    rightMax[n - 1] = height[n - 1];
    
    for (int i = 1; i < n; ++i) {
        leftMax[i] = max(leftMax[i - 1], height[i]);
    }
    
    for (int i = n - 2; i >= 0; --i) {
        rightMax[i] = max(rightMax[i + 1], height[i]);
    }
    
    int waterTrapped = 0;
    for (int i = 0; i < n; ++i) {
        waterTrapped += min(leftMax[i], rightMax[i]) - height[i];
    }
    
    return waterTrapped;
}

int main() {
    vector<int> height = {0,1,0,2,1,0,1,3,2,1,2,1};
    cout << "Amount of trapped rainwater: " << trap(height) << endl;
    return 0;
}
```

Let's analyze the space complexity first:

1. **Input Space**: The space used by the input array `height` is O(n), where n is the number of elements in the array.
2. **Auxiliary Space**: The space used by the additional arrays `leftMax` and `rightMax` is also O(n) since they store the maximum height encountered from the left and right sides respectively for each element.

So, the total space complexity is O(n).

Now, let's analyze the time complexity:

1. **Initialization**: Initializing the `leftMax` and `rightMax` arrays takes O(n) time.
2. **Finding Maximums**: The loops to populate `leftMax` and `rightMax` each take O(n) time.
3. **Calculating Trapped Water**: The final loop to calculate the amount of trapped water also takes O(n) time.

Thus, the overall time complexity is O(n).

This solution efficiently solves the problem in linear time and space complexity.

### 1. Algorithms & Data Structures (C++): Binary Trees - Interview Question - Level Order Of Binary Tree

Sure, the level order traversal of a binary tree is a fundamental operation in computer science. It visits all the nodes of a binary tree by level, starting from the root node and moving down level by level.

Here's the C++ implementation of the level order traversal of a binary tree using a queue:

```cpp
#include <iostream>
#include <queue>

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

void levelOrder(TreeNode* root) {
    if (root == NULL) return;

    queue<TreeNode*> q;
    q.push(root);

    while (!q.empty()) {
        TreeNode* current = q.front();
        q.pop();

        cout << current->val << " ";

        if (current->left != NULL) {
            q.push(current->left);
        }
        if (current->right != NULL) {
            q.push(current->right);
        }
    }
}

int main() {
    // Example usage:
    // Constructing a sample binary tree
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);
    root->right->left = new TreeNode(6);
    root->right->right = new TreeNode(7);

    // Output level order traversal
    cout << "Level Order Traversal: ";
    levelOrder(root);

    return 0;
}
```

This code defines a binary tree node structure `TreeNode` and a function `levelOrder` to perform level order traversal. We use a queue to keep track of nodes at each level. We start by pushing the root node into the queue and then iterate over the queue until it's empty, popping each node, printing its value, and pushing its children into the queue if they exist.

You can customize the binary tree according to your requirements and use the `levelOrder` function to obtain the level order traversal.

### 1. Algorithms & Data Structures (C++): Binary Trees - Interview Question - Maximum Depth Of Binary Tree

Certainly! Finding the maximum depth of a binary tree is a common interview question that tests your understanding of tree traversal algorithms. One of the most common approaches to solve this problem is by using depth-first search (DFS), which can be implemented recursively. Here's how you can do it in C++:

```cpp
#include <iostream>
#include <algorithm> // for std::max

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

int maxDepth(TreeNode* root) {
    if (root == nullptr) // Base case: if the tree is empty, depth is 0
        return 0;
    else {
        // Recursively find the maximum depth of the left and right subtrees
        int leftDepth = maxDepth(root->left);
        int rightDepth = maxDepth(root->right);
        
        // Return the maximum of the depths of the left and right subtrees, plus 1 for the current node
        return 1 + std::max(leftDepth, rightDepth);
    }
}

int main() {
    // Example usage
    TreeNode* root = new TreeNode(3);
    root->left = new TreeNode(9);
    root->right = new TreeNode(20);
    root->right->left = new TreeNode(15);
    root->right->right = new TreeNode(7);

    std::cout << "Maximum Depth: " << maxDepth(root) << std::endl;

    // Clean up memory
    delete root->left;
    delete root->right->left;
    delete root->right->right;
    delete root->right;
    delete root;

    return 0;
}
```

This code defines a `TreeNode` struct representing a node in a binary tree, and a function `maxDepth` that calculates the maximum depth of the binary tree using DFS recursively. Finally, in the `main` function, an example binary tree is created and its maximum depth is calculated and printed.

### 1. Algorithms & Data Structures (C++): Binary Trees - Interview Question - Right Side View of Tree

The "Right Side View of a Binary Tree" is a classic interview question that requires traversing the tree and recording the rightmost node at each level. Here's a general approach to solve it using C++:

```cpp
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

vector<int> rightSideView(TreeNode* root) {
    vector<int> result;
    if (!root) return result;

    queue<TreeNode*> q;
    q.push(root);

    while (!q.empty()) {
        int size = q.size();
        for (int i = 0; i < size; ++i) {
            TreeNode* node = q.front();
            q.pop();
            if (i == size - 1) // Rightmost node in this level
                result.push_back(node->val);
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
    }

    return result;
}

// Utility function to create a new tree node
TreeNode* newNode(int val) {
    TreeNode* node = new TreeNode(val);
    return node;
}

int main() {
    TreeNode* root = newNode(1);
    root->left = newNode(2);
    root->right = newNode(3);
    root->left->right = newNode(5);
    root->right->right = newNode(4);

    vector<int> result = rightSideView(root);

    cout << "Right side view of the binary tree: ";
    for (int val : result) {
        cout << val << " ";
    }
    cout << endl;

    return 0;
}
```

This code defines a `TreeNode` struct representing a node in the binary tree. The `rightSideView` function takes the root of the binary tree as input and returns a vector containing the values of the right side view of the tree.

We use a queue for level order traversal of the tree. At each level, we iterate through the nodes and push their children into the queue. We also keep track of the rightmost node at each level. Finally, we return the vector containing the values of the rightmost nodes at each level.

You can test this code with different binary trees to see how it performs.

### 1. Algorithms & Data Structures (C++): Bloomberg Backtracking question: Palindrome Partitioning

The Palindrome Partitioning problem is a classic example of a backtracking problem. The task is to partition a given string into as many palindromic substrings as possible. Here's a basic outline of how you can solve this problem in C++ using backtracking:

```cpp
#include <iostream>
#include <vector>
#include <string>

using namespace std;

bool isPalindrome(const string& str, int start, int end) {
    while (start < end) {
        if (str[start++] != str[end--])
            return false;
    }
    return true;
}

void partitionHelper(const string& str, int start, vector<string>& currentPartition, vector<vector<string>>& result) {
    if (start == str.size()) {
        result.push_back(currentPartition);
        return;
    }

    for (int i = start; i < str.size(); ++i) {
        if (isPalindrome(str, start, i)) {
            currentPartition.push_back(str.substr(start, i - start + 1));
            partitionHelper(str, i + 1, currentPartition, result);
            currentPartition.pop_back();
        }
    }
}

vector<vector<string>> partition(string s) {
    vector<vector<string>> result;
    vector<string> currentPartition;
    partitionHelper(s, 0, currentPartition, result);
    return result;
}

int main() {
    string s = "aab";
    vector<vector<string>> partitions = partition(s);

    cout << "All possible palindrome partitions of " << s << " are:\n";
    for (const auto& partition : partitions) {
        for (const auto& pal : partition) {
            cout << pal << " ";
        }
        cout << endl;
    }

    return 0;
}
```

This code defines a function `partition` which takes a string `s` and returns a vector of vectors containing all possible palindrome partitions of `s`. The `partitionHelper` function recursively partitions the string and checks if each substring is a palindrome using the `isPalindrome` function. If it is, it adds it to the current partition and recurses further. Once the entire string is traversed, it adds the current partition to the result.

### 1. Algorithms & Data Structures (C++): Bloomberg Dynamic Programming Question: Unique Paths

The Unique Paths problem is a classic dynamic programming question often asked in technical interviews. Here's the problem statement:

**Problem Statement:**
A robot is located at the top-left corner of a grid m x n. The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid. How many possible unique paths are there?

**Example:**
For example, consider a 3 x 3 grid. The robot starts at the top-left corner and wants to reach the bottom-right corner. There are a total of 6 possible unique paths.

```bash
Input: m = 3, n = 3
Output: 6
```

**Solution Approach (Dynamic Programming):**
We can solve this problem efficiently using dynamic programming. The idea is to build a 2D array `dp` where `dp[i][j]` represents the number of unique paths to reach the cell `(i, j)` from the top-left corner `(0, 0)`.

The base cases are:

- For the cells in the first row (`dp[0][j]`), there's only one way to reach each cell, which is moving right from the leftmost cell.
- For the cells in the first column (`dp[i][0]`), there's only one way to reach each cell, which is moving down from the topmost cell.

For other cells, the number of unique paths to reach `(i, j)` is the sum of the paths to reach the cell above `(i-1, j)` and the cell to the left `(i, j-1)`.

Here's the C++ code implementing the solution:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int uniquePaths(int m, int n) {
    // Create a 2D array dp[m][n]
    vector<vector<int>> dp(m, vector<int>(n, 0));

    // Base cases:
    // There's only one way to reach cells in the first row or first column
    for (int i = 0; i < m; ++i)
        dp[i][0] = 1;
    for (int j = 0; j < n; ++j)
        dp[0][j] = 1;

    // Fill the dp array using dynamic programming
    for (int i = 1; i < m; ++i) {
        for (int j = 1; j < n; ++j) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; // Unique paths to reach (i, j)
        }
    }

    // The result is in the bottom-right corner of the dp array
    return dp[m - 1][n - 1];
}

int main() {
    int m = 3, n = 3;
    cout << "Number of unique paths in a " << m << "x" << n << " grid: " << uniquePaths(m, n) << endl;
    return 0;
}
```

This solution has a time complexity of O(m *n) and space complexity of O(m* n), where m is the number of rows and n is the number of columns in the grid.

### 1. Algorithms & Data Structures (C++): Blocked Roads

Blocked Roads problem can be solved using graph traversal algorithms, typically Breadth-First Search (BFS) or Depth-First Search (DFS). Here's how you can approach it using BFS in C++:

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

// Structure to represent a graph edge
struct Edge {
    int from, to;
    Edge(int _from, int _to) : from(_from), to(_to) {}
};

// Function to perform BFS traversal
bool isPathExist(vector<vector<int>>& graph, int start, int end) {
    vector<bool> visited(graph.size(), false);
    queue<int> q;

    q.push(start);
    visited[start] = true;

    while (!q.empty()) {
        int curr = q.front();
        q.pop();

        if (curr == end)
            return true;

        for (int neighbor : graph[curr]) {
            if (!visited[neighbor]) {
                q.push(neighbor);
                visited[neighbor] = true;
            }
        }
    }

    return false;
}

int main() {
    // Example graph representation
    int n = 6; // Number of nodes
    vector<vector<int>> graph(n);

    // Adding edges to the graph
    vector<Edge> edges = {{0, 1}, {1, 2}, {2, 3}, {3, 4}, {4, 5}, {0, 2}, {1, 3}, {2, 4}, {3, 5}};

    // Add edges to adjacency list
    for (const auto& edge : edges) {
        graph[edge.from].push_back(edge.to);
        graph[edge.to].push_back(edge.from); // Add this line for undirected graph
    }

    // Check if there is a path between node 0 and node 5
    int start = 0, end = 5;
    if (isPathExist(graph, start, end))
        cout << "There is a path between " << start << " and " << end << endl;
    else
        cout << "There is no path between " << start << " and " << end << endl;

    return 0;
}
```

This code checks if there's a path between two nodes in a graph. You can adjust it to incorporate the blocked roads information by simply not adding those edges to the adjacency list.

### 1. Algorithms & Data Structures (C++): Board Game (Trie+Backtracking+Graph)

Creating a board game using a combination of Trie, backtracking, and graph algorithms sounds like an interesting challenge! Here's a high-level overview of how you could approach this:

1. **Design the Board**: Decide on the size and layout of the board for your game. This could be a grid of cells where players can move around.

2. **Implement Trie**: Trie data structure can be used to efficiently store and search for words. This will be useful if your game involves forming words from letters on the board.

3. **Implement Graph**: Depending on the mechanics of your game, you might need to represent connections between cells on the board as a graph. For example, if players can move from one cell to adjacent cells, you'll need to represent these connections.

4. **Backtracking Algorithm**: Backtracking can be used to explore all possible paths or combinations on the board. For example, if your game involves finding paths to form words, you can use backtracking to explore different combinations of letters on the board.

5. **Game Logic**: Implement the core logic of your game using the above components. This includes things like player movements, word formation, scoring, and determining game outcomes.

6. **User Interface (optional)**: If you're creating a digital version of your game, you may want to implement a user interface to display the board, accept player inputs, and provide feedback.

Here's a simple example in C++ to illustrate how you might combine these elements:

```cpp
#include <iostream>
#include <vector>
#include <unordered_set>
using namespace std;

// Define TrieNode structure
struct TrieNode {
    bool isEndOfWord;
    TrieNode* children[26];
    TrieNode() {
        isEndOfWord = false;
        for (int i = 0; i < 26; ++i)
            children[i] = nullptr;
    }
};

// Trie class
class Trie {
    TrieNode* root;
public:
    Trie() {
        root = new TrieNode();
    }

    // Insert a word into the trie
    void insert(string word) {
        TrieNode* node = root;
        for (char ch : word) {
            int index = ch - 'a';
            if (!node->children[index])
                node->children[index] = new TrieNode();
            node = node->children[index];
        }
        node->isEndOfWord = true;
    }

    // Search if a word exists in the trie
    bool search(string word) {
        TrieNode* node = root;
        for (char ch : word) {
            int index = ch - 'a';
            if (!node->children[index])
                return false;
            node = node->children[index];
        }
        return node != nullptr && node->isEndOfWord;
    }
};

// Backtracking function to find words on the board
void findWords(vector<vector<char>>& board, int i, int j, TrieNode* node, string& word, unordered_set<string>& result) {
    if (i < 0 || i >= board.size() || j < 0 || j >= board[0].size() || board[i][j] == '#')
        return;

    char ch = board[i][j];
    board[i][j] = '#';
    TrieNode* nextNode = node->children[ch - 'a'];

    if (nextNode) {
        word.push_back(ch);
        if (nextNode->isEndOfWord)
            result.insert(word);
        
        findWords(board, i + 1, j, nextNode, word, result);
        findWords(board, i - 1, j, nextNode, word, result);
        findWords(board, i, j + 1, nextNode, word, result);
        findWords(board, i, j - 1, nextNode, word, result);

        word.pop_back();
    }
    board[i][j] = ch;
}

int main() {
    Trie trie;
    // Populate trie with dictionary words
    vector<string> dictionary = {"cat", "bat", "rat", "cart"};
    for (const string& word : dictionary)
        trie.insert(word);

    // Example board
    vector<vector<char>> board = {
        {'c', 'a', 'r'},
        {'t', 't', 'b'},
        {'a', 'a', 't'}
    };

    unordered_set<string> result;

    // Find words on the board
    for (int i = 0; i < board.size(); ++i) {
        for (int j = 0; j < board[0].size(); ++j) {
            string word = "";
            findWords(board, i, j, trie.root, word, result);
        }
    }

    // Print found words
    cout << "Words found on the board:" << endl;
    for (const string& word : result)
        cout << word << endl;

    return 0;
}
```

This example demonstrates how you might use a Trie data structure and backtracking to find words on a board of characters. You can extend and modify this code to fit the mechanics of your specific board game.

### 1. Algorithms & Data Structures (C++): Bob and his Brother

Sure, let's discuss the problem "Bob and his Brother" in the context of algorithms and data structures.

**Problem Statement:**
Bob and his brother are playing a game with an array of integers. Bob's task is to find the longest subarray in which the sum of the elements is less than or equal to a given value K. Bob's brother challenges him to solve this problem efficiently.

**Input:**

- An array of integers `arr` of size N.
- An integer value K.

**Output:**

- The length of the longest subarray where the sum of elements is less than or equal to K.

**Approach:**
This problem can be efficiently solved using the two-pointer technique. We'll maintain two pointers, `left` and `right`, that define the current subarray we are considering. We'll start with both pointers at the beginning of the array and gradually move the `right` pointer to expand the subarray. While doing so, we'll keep track of the sum of elements in the subarray. If the sum exceeds K, we'll move the `left` pointer to shrink the subarray until the sum becomes less than or equal to K again. Meanwhile, we'll update the length of the longest subarray found so far.

**Algorithm:**

1. Initialize two pointers `left` and `right` to the beginning of the array.
2. Initialize a variable `maxLen` to store the length of the longest subarray found so far.
3. Initialize a variable `sum` to store the sum of elements in the current subarray.
4. Iterate through the array using the `right` pointer:
   - Add the element at the `right` pointer to the `sum`.
   - While the sum exceeds K, move the `left` pointer to shrink the subarray and subtract the element at the `left` pointer from the `sum`.
   - Update `maxLen` if the length of the current subarray is greater than `maxLen`.
5. Return `maxLen`.

**Implementation (C++):**

```cpp
#include <iostream>
#include <vector>

using namespace std;

int longestSubarrayLessThanK(const vector<int>& arr, int K) {
    int left = 0, right = 0, sum = 0, maxLen = 0;

    while (right < arr.size()) {
        sum += arr[right];

        while (sum > K) {
            sum -= arr[left];
            left++;
        }

        maxLen = max(maxLen, right - left + 1);
        right++;
    }

    return maxLen;
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int K = 9;

    cout << "Length of longest subarray: " << longestSubarrayLessThanK(arr, K) << endl;

    return 0;
}
```

This implementation efficiently solves the problem by finding the length of the longest subarray where the sum of elements is less than or equal to K.

### 1. Algorithms & Data Structures (C++): Box Stacking

Box stacking is a classic problem in computer science that involves arranging a set of boxes in a stack to maximize the total height while satisfying certain constraints. Each box has dimensions (length, width, and height), and you can rotate the boxes to place them on top of each other. However, a box can only be placed on top of another box if it has a strictly smaller base area and is strictly shorter in height.

Here's a high-level overview of an algorithm to solve the box stacking problem in C++:

1. Define a structure to represent a box, including its dimensions and its base area.
2. Generate all possible rotations of each box so that its dimensions are sorted in non-increasing order.
3. Sort the boxes based on their base areas in non-increasing order.
4. Use dynamic programming to find the maximum height achievable by stacking the boxes.
5. Iterate through each box and calculate the maximum height achievable by stacking boxes up to that box.

Here's a basic implementation of the algorithm:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct Box {
    int length, width, height;
};

// Function to generate all rotations of a box
vector<Box> generateRotations(const Box& box) {
    vector<Box> rotations;
    rotations.push_back(box);
    
    // Generate rotations for each dimension
    for (int i = 1; i <= 3; ++i) {
        Box rotated = box;
        if (i == 1) {
            rotated.length = box.height;
            rotated.height = box.width;
        } else if (i == 2) {
            rotated.width = box.height;
            rotated.height = box.length;
        } else {
            rotated.length = box.width;
            rotated.width = box.length;
        }
        rotations.push_back(rotated);
    }
    
    return rotations;
}

// Comparator function to sort boxes based on base area
bool compare(const Box& box1, const Box& box2) {
    return (box1.length * box1.width > box2.length * box2.width);
}

// Function to find the maximum height achievable by stacking boxes
int maxHeight(vector<Box>& boxes) {
    // Generate all rotations of each box
    vector<Box> allRotations;
    for (const auto& box : boxes) {
        vector<Box> rotations = generateRotations(box);
        allRotations.insert(allRotations.end(), rotations.begin(), rotations.end());
    }
    
    // Sort the boxes based on their base areas
    sort(allRotations.begin(), allRotations.end(), compare);
    
    int n = allRotations.size();
    vector<int> dp(n);
    
    // Dynamic programming to find the maximum height achievable
    for (int i = 0; i < n; ++i) {
        dp[i] = allRotations[i].height;
        for (int j = 0; j < i; ++j) {
            if (allRotations[j].length > allRotations[i].length &&
                allRotations[j].width > allRotations[i].width) {
                dp[i] = max(dp[i], dp[j] + allRotations[i].height);
            }
        }
    }
    
    // Find the maximum height achievable
    int maxHeight = 0;
    for (int i = 0; i < n; ++i) {
        maxHeight = max(maxHeight, dp[i]);
    }
    
    return maxHeight;
}

int main() {
    vector<Box> boxes = {{4, 6, 7}, {1, 2, 3}, {4, 5, 6}, {10, 12, 32}};
    cout << "Maximum height achievable: " << maxHeight(boxes) << endl;
    return 0;
}
```

This implementation generates all possible rotations of each box and then sorts them based on their base areas. Finally, it uses dynamic programming to find the maximum height achievable by stacking the boxes.

### 1. Algorithms & Data Structures (C++): Box Stacking Problem

The Box Stacking Problem is a classic problem in computer science that involves finding the maximum height of a stack of boxes when each box can only be placed on top of another box if it has a smaller base area and is smaller in all dimensions. Here's a basic outline of how you might approach solving this problem in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct Box {
    int length, width, height;
};

// Function to generate all possible rotations of a box
vector<Box> generateRotations(const Box& box) {
    vector<Box> rotations;
    rotations.push_back(box);

    // Generate all rotations of the box
    for (int i = 1; i <= 3; ++i) {
        Box rotatedBox = box;
        if (i == 1) {
            swap(rotatedBox.length, rotatedBox.width);
        } else if (i == 2) {
            swap(rotatedBox.length, rotatedBox.height);
        } else if (i == 3) {
            swap(rotatedBox.width, rotatedBox.height);
        }
        rotations.push_back(rotatedBox);
    }

    return rotations;
}

// Function to compare two boxes based on their base area
bool compareBoxes(const Box& box1, const Box& box2) {
    return (box1.length * box1.width) > (box2.length * box2.width);
}

// Function to find the maximum height of the stack
int maxStackHeight(vector<Box>& boxes) {
    // Generate all possible rotations of each box
    vector<Box> allRotations;
    for (const auto& box : boxes) {
        auto rotations = generateRotations(box);
        allRotations.insert(allRotations.end(), rotations.begin(), rotations.end());
    }

    // Sort the boxes based on their base area in non-increasing order
    sort(allRotations.begin(), allRotations.end(), compareBoxes);

    // Initialize an array to store the maximum height of stack ending with each box
    int n = allRotations.size();
    vector<int> maxHeight(n);

    // Initialize the maxHeight array
    for (int i = 0; i < n; ++i) {
        maxHeight[i] = allRotations[i].height;
    }

    // Compute the maximum height of stack ending with each box
    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (allRotations[i].length < allRotations[j].length &&
                allRotations[i].width < allRotations[j].width) {
                maxHeight[i] = max(maxHeight[i], maxHeight[j] + allRotations[i].height);
            }
        }
    }

    // Find the maximum height of the stack
    int maxStackHeight = 0;
    for (int i = 0; i < n; ++i) {
        maxStackHeight = max(maxStackHeight, maxHeight[i]);
    }

    return maxStackHeight;
}

int main() {
    // Example usage
    vector<Box> boxes = {
        {4, 6, 7},
        {1, 2, 3},
        {4, 5, 6},
        {10, 12, 32}
    };

    cout << "Maximum height of the stack: " << maxStackHeight(boxes) << endl;

    return 0;
}
```

This code defines a `Box` structure representing a box with length, width, and height. The `generateRotations` function generates all possible rotations of a given box. The `compareBoxes` function compares two boxes based on their base area. The `maxStackHeight` function calculates the maximum height of the stack using dynamic programming. Finally, the `main` function demonstrates the usage of the `maxStackHeight` function with an example set of boxes.

### 1. Algorithms & Data Structures (C++): Brackets

The "Brackets" problem is a classic problem in computer science and is commonly encountered in coding interviews. The problem involves checking if a given string of brackets (such as parentheses, square brackets, and curly braces) is balanced.

Here's a simple algorithm to solve the problem:

1. Create a stack to store the opening brackets.
2. Iterate through the string.
3. If the current character is an opening bracket (i.e., '{', '[', or '('), push it onto the stack.
4. If the current character is a closing bracket (i.e., '}', ']', or ')'), check if the stack is empty. If it is, return false because there is no corresponding opening bracket for the current closing bracket.
5. If the stack is not empty, pop the top element from the stack and check if it matches the current closing bracket. If they don't match, return false.
6. If the stack becomes empty after iterating through the string, return true because all brackets have been matched.

Here's a sample implementation in C++:

```cpp
#include <iostream>
#include <stack>
#include <string>

bool isBalanced(const std::string& str) {
    std::stack<char> brackets;
    for (char c : str) {
        if (c == '{' || c == '[' || c == '(') {
            brackets.push(c);
        } else if (c == '}' || c == ']' || c == ')') {
            if (brackets.empty()) {
                return false;
            }
            char top = brackets.top();
            brackets.pop();
            if ((c == '}' && top != '{') ||
                (c == ']' && top != '[') ||
                (c == ')' && top != '(')) {
                return false;
            }
        }
    }
    return brackets.empty();
}

int main() {
    std::string str = "{[()]}";
    if (isBalanced(str)) {
        std::cout << "The string is balanced." << std::endl;
    } else {
        std::cout << "The string is not balanced." << std::endl;
    }
    return 0;
}
```

This implementation has a time complexity of O(n), where n is the length of the input string, and a space complexity of O(n) due to the stack used to store the opening brackets.

### 1. Algorithms & Data Structures (C++): Break the chain

Breaking the chain in the context of algorithms and data structures typically refers to breaking a cycle in a linked list, graph, or any other data structure where such cycles can occur. In the case of a linked list, breaking the chain involves finding and removing a loop or cycle if one exists.

Here's an example of how you might break the cycle in a linked list in C++:

```cpp
#include <iostream>

struct Node {
    int data;
    Node* next;
    
    Node(int data) : data(data), next(nullptr) {}
};

void detectAndRemoveLoop(Node* head) {
    if (head == nullptr || head->next == nullptr)
        return;

    Node *slow = head, *fast = head;

    // Move slow and fast pointers at different speeds until they meet
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;

        if (slow == fast)
            break;
    }

    // If loop exists, move slow to head and advance both pointers at the same speed
    if (slow == fast) {
        slow = head;
        while (slow->next != fast->next) {
            slow = slow->next;
            fast = fast->next;
        }
        // Break the loop by making the next pointer of the last node point to nullptr
        fast->next = nullptr;
    }
}

void printList(Node* node) {
    while (node != nullptr) {
        std::cout << node->data << " ";
        node = node->next;
    }
    std::cout << std::endl;
}

int main() {
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);
    head->next->next->next->next = head->next; // creating a cycle
    
    detectAndRemoveLoop(head);
    
    std::cout << "Linked list after removing loop: ";
    printList(head);

    return 0;
}
```

This code first detects if there's a loop in the linked list using Floyd's Cycle Detection algorithm, and if a loop is detected, it removes the loop by breaking the chain at the point where the cycle begins. Finally, it prints the modified linked list.

### 1. Algorithms & Data Structures (C++): Bulbs

The "Bulbs" problem is a classic algorithmic problem where you're given an array of integers representing bulbs, initially all turned off. You need to find out the minimum number of switches you have to press to turn on all the bulbs. Each switch toggles the state of the bulbs - if it's off, it turns it on, and if it's on, it turns it off.

Here's the problem statement more formally:

You are given an array of \( n \) bulbs, where each bulb is at position \( i \), with \( i \) ranging from 1 to \( n \). Initially, all the bulbs are turned off. We can toggle the state of the bulbs with a series of \( m \) operations. In the \( k \)th operation, we take all the bulbs whose position is a multiple of \( k \) where \( k \) is an integer ranging from 1 to \( m \) and toggle their state. Find the minimum number of operations you need to perform to turn on all the bulbs.

One way to approach this problem is to observe that a bulb will only be on if it is toggled an odd number of times. For a bulb at position \( i \), it will be toggled in every operation whose divisor is a factor of \( i \). So, if \( i \) has an odd number of divisors, it will be on, and if it has an even number of divisors, it will be off. The bulbs that have an odd number of divisors are perfect squares (since they have an odd number of factors).

Therefore, the solution is simply the count of perfect squares less than or equal to \( n \) because those are the bulbs that will be turned on. So, the algorithm to solve this problem efficiently is:

1. Count the number of perfect squares less than or equal to \( n \).
2. Return this count as the minimum number of operations required.

Here's a sample C++ implementation of this algorithm:

```cpp
#include <cmath>

int bulbs(int n) {
    return sqrt(n);
}
```

This algorithm runs in constant time \( O(1) \) because the calculation of the square root is a constant-time operation.

### 1. Algorithms & Data Structures (C++): Bulls and Cows

Bulls and Cows is a classic guessing game where one player thinks of a secret number and the other player tries to guess it. The game provides feedback after each guess in the form of "bulls" and "cows." A "bull" indicates a correct digit in the correct position, while a "cow" indicates a correct digit in the wrong position.

Here's a simple algorithm to implement the Bulls and Cows game in C++:

```cpp
#include <iostream>
#include <string>
#include <unordered_set>

using namespace std;

class BullsAndCows {
private:
    string secretNumber;

public:
    BullsAndCows() {
        // Generate a 4-digit random number as the secret number
        secretNumber = generateSecretNumber();
    }

    string generateSecretNumber() {
        string secret;
        unordered_set<char> digits;

        // Generate unique digits for the secret number
        while (digits.size() < 4) {
            char digit = '0' + rand() % 10;
            if (digits.find(digit) == digits.end()) {
                digits.insert(digit);
                secret.push_back(digit);
            }
        }

        return secret;
    }

    string guessNumber(string guess) {
        int bulls = 0, cows = 0;

        for (int i = 0; i < 4; ++i) {
            if (guess[i] == secretNumber[i]) {
                ++bulls;
            } else if (secretNumber.find(guess[i]) != string::npos) {
                ++cows;
            }
        }

        return to_string(bulls) + " Bulls and " + to_string(cows) + " Cows";
    }
};

int main() {
    BullsAndCows game;

    cout << "Welcome to Bulls and Cows game! Try to guess the secret 4-digit number.\n";

    while (true) {
        string guess;
        cout << "Enter your guess: ";
        cin >> guess;

        if (guess.size() != 4 || !isdigit(guess[0]) || !isdigit(guess[1]) ||
            !isdigit(guess[2]) || !isdigit(guess[3])) {
            cout << "Invalid guess! Please enter a 4-digit number.\n";
            continue;
        }

        string result = game.guessNumber(guess);
        cout << "Result: " << result << endl;

        if (result == "4 Bulls and 0 Cows") {
            cout << "Congratulations! You've guessed the secret number.\n";
            break;
        }
    }

    return 0;
}
```

This code provides a basic implementation of the Bulls and Cows game in C++. It generates a random 4-digit secret number and allows the player to guess until they correctly guess the number. After each guess, it provides feedback in terms of bulls and cows.

### 1. Algorithms & Data Structures (C++): Busyman

The "Busyman" problem is a classic algorithmic problem that can be solved using greedy techniques. Here's the problem statement:

You are given a list of activities, each represented by a pair of integers (start_time, end_time), where start_time represents the start time of the activity and end_time represents the end time of the activity. Your task is to find the maximum number of activities that can be performed, assuming that a person can only perform one activity at a time, and he can't perform two activities simultaneously.

The algorithm to solve this problem is straightforward:

1. Sort the activities based on their end times in ascending order.
2. Initialize a variable to keep track of the count of activities performed, let's call it "count", and set it to 1 (assuming the first activity is always performed).
3. Iterate through the sorted activities starting from the second one.
4. For each activity, if its start time is greater than or equal to the end time of the previously selected activity, increment the count and update the end time of the last selected activity.
5. After iterating through all activities, the value of "count" will represent the maximum number of activities that can be performed.

Here's a sample C++ implementation of the algorithm:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// Custom comparator function to sort activities based on end times
bool compareActivities(const pair<int, int>& a, const pair<int, int>& b) {
    return a.second < b.second;
}

int maxActivities(vector<pair<int, int>>& activities) {
    // Sort activities based on end times
    sort(activities.begin(), activities.end(), compareActivities);
    
    int count = 1; // At least one activity can be performed
    int lastEndTime = activities[0].second;

    // Iterate through the sorted activities
    for (int i = 1; i < activities.size(); ++i) {
        if (activities[i].first >= lastEndTime) {
            // If the start time of the current activity is greater than or equal
            // to the end time of the last selected activity, perform this activity
            ++count;
            lastEndTime = activities[i].second; // Update lastEndTime
        }
    }

    return count;
}

int main() {
    // Sample input
    vector<pair<int, int>> activities = {{1, 4}, {3, 5}, {0, 6}, {5, 7}, {3, 8}, {5, 9}, {6, 10}, {8, 11}, {8, 12}, {2, 13}, {12, 14}};
    
    cout << "Maximum number of activities that can be performed: " << maxActivities(activities) << endl;
    
    return 0;
}
```

This implementation sorts the activities based on their end times and then iterates through them to find the maximum number of non-overlapping activities that can be performed.

### 1. Algorithms & Data Structures (C++): Check Palindrome

Sure! Here's a simple C++ function to check if a given string is a palindrome or not:

```cpp
#include <iostream>
#include <string>
#include <algorithm>

bool isPalindrome(const std::string& str) {
    std::string temp = str;
    std::transform(temp.begin(), temp.end(), temp.begin(), ::tolower);
    std::string::iterator left = temp.begin();
    std::string::iterator right = temp.end() - 1;

    while (left < right) {
        if (*left != *right) {
            return false;
        }
        ++left;
        --right;
    }
    return true;
}

int main() {
    std::string str;
    std::cout << "Enter a string: ";
    std::getline(std::cin, str);

    if (isPalindrome(str)) {
        std::cout << str << " is a palindrome." << std::endl;
    } else {
        std::cout << str << " is not a palindrome." << std::endl;
    }

    return 0;
}
```

This program defines a function `isPalindrome` that takes a string as input and returns `true` if the string is a palindrome (ignoring case), and `false` otherwise. The `main` function simply reads a string from the user and prints whether it is a palindrome or not.

### 1. Algorithms & Data Structures (C++): Candies

"Candies" is a popular algorithmic problem where you are given an array representing the ratings of children in a class. You need to distribute a certain number of candies to each child according to the following rules:

1. Each child must have at least one candy.
2. Children with a higher rating than their neighbors should have more candies than them.

The task is to minimize the total number of candies used. This problem can be solved using various approaches, including greedy algorithms and dynamic programming.

Here's a basic approach to solve this problem:

```cpp
#include <vector>
#include <algorithm>

int minCandies(std::vector<int>& ratings) {
    int n = ratings.size();
    std::vector<int> candies(n, 1); // Initially, every child gets one candy

    // Traverse from left to right, ensure right neighbor gets more candies if necessary
    for (int i = 1; i < n; ++i) {
        if (ratings[i] > ratings[i - 1])
            candies[i] = candies[i - 1] + 1;
    }

    // Traverse from right to left, ensure left neighbor gets more candies if necessary
    for (int i = n - 2; i >= 0; --i) {
        if (ratings[i] > ratings[i + 1])
            candies[i] = std::max(candies[i], candies[i + 1] + 1);
    }

    // Sum up the total candies used
    int total = 0;
    for (int candy : candies) {
        total += candy;
    }
    return total;
}

int main() {
    std::vector<int> ratings = {1, 2, 3, 3, 2, 1};
    int minTotalCandies = minCandies(ratings);
    return 0;
}
```

This implementation ensures that every child gets at least one candy and adjusts the number of candies based on the ratings of their neighbors. It traverses the array twice, once from left to right and once from right to left, to ensure that the conditions are met. Finally, it calculates the total number of candies used.

### 1. Algorithms & Data Structures (C++): Catalan Numbers

Catalan numbers are a sequence of natural numbers that have numerous applications in combinatorics. They are named after the Belgian mathematician Eugène Charles Catalan, who introduced them in the 19th century. In combinatorial mathematics, Catalan numbers arise in various counting problems, such as counting the number of different ways to parenthesize expressions, the number of paths in certain lattice structures, and many others.

The nth Catalan number, denoted \( C_n \), is given by the following formula:

\[ C_n = \frac{{2n!}}{{(n + 1)!n!}} \]

Alternatively, Catalan numbers can also be defined recursively:

\[ C_0 = 1 \]
\[ C_{n+1} = \sum_{i=0}^{n} C_i \times C_{n-i} \]

Here's a simple C++ implementation to calculate Catalan numbers using both methods:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Function to calculate Catalan number using formula
unsigned long long catalan_formula(int n) {
    unsigned long long res = 1;
    for (int i = 0; i < n; ++i) {
        res = res * (2 * n - i);
        res = res / (i + 1);
    }
    return res / (n + 1);
}

// Function to calculate Catalan number using dynamic programming
unsigned long long catalan_dp(int n) {
    vector<unsigned long long> catalan(n + 1, 0);
    catalan[0] = 1;
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j < i; ++j) {
            catalan[i] += catalan[j] * catalan[i - j - 1];
        }
    }
    return catalan[n];
}

int main() {
    int n;
    cout << "Enter the value of n: ";
    cin >> n;
    cout << "Using formula, C_" << n << " = " << catalan_formula(n) << endl;
    cout << "Using dynamic programming, C_" << n << " = " << catalan_dp(n) << endl;
    return 0;
}
```

This code prompts the user to enter the value of \( n \) and then calculates the nth Catalan number using both the formula and dynamic programming approach.

### 1. Algorithms & Data Structures (C++): Catalan Numbers Code - Iterative / Dynamic Programming

Certainly! Here's an implementation of generating Catalan numbers using both iterative and dynamic programming approaches in C++:

1. **Iterative Approach**:

```cpp
#include <iostream>
using namespace std;

unsigned long long catalanIterative(int n) {
    if (n <= 1) return 1;
    unsigned long long* catalan = new unsigned long long[n + 1];
    catalan[0] = catalan[1] = 1;
    for (int i = 2; i <= n; i++) {
        catalan[i] = 0;
        for (int j = 0; j < i; j++) {
            catalan[i] += catalan[j] * catalan[i - j - 1];
        }
    }
    unsigned long long res = catalan[n];
    delete[] catalan;
    return res;
}

int main() {
    int n = 10; // Example: calculating the 10th Catalan number
    cout << "The " << n << "th Catalan number is: " << catalanIterative(n) << endl;
    return 0;
}
```

1. **Dynamic Programming Approach**:

```cpp
#include <iostream>
using namespace std;

unsigned long long catalanDP(int n) {
    unsigned long long* catalan = new unsigned long long[n + 1];
    catalan[0] = catalan[1] = 1;
    for (int i = 2; i <= n; i++) {
        catalan[i] = 0;
        for (int j = 0; j < i; j++) {
            catalan[i] += catalan[j] * catalan[i - j - 1];
        }
    }
    unsigned long long res = catalan[n];
    delete[] catalan;
    return res;
}

int main() {
    int n = 10; // Example: calculating the 10th Catalan number
    cout << "The " << n << "th Catalan number is: " << catalanDP(n) << endl;
    return 0;
}
```

Both of these implementations will calculate the nth Catalan number and print the result. You can change the value of `n` in the `main` function to calculate any specific Catalan number you want.

### 1. Algorithms & Data Structures (C++): Catalan Numbers Code - Recursive

Certainly! Below is a simple C++ code to calculate Catalan numbers recursively:

```cpp
#include <iostream>
using namespace std;

// Function to calculate the nth Catalan number recursively
unsigned long long catalan(unsigned int n) {
    // Base case
    if (n <= 1)
        return 1;

    // Initialize result
    unsigned long long res = 0;

    // Calculate value of catalan(n) using recursive formula
    for (unsigned int i = 0; i < n; i++)
        res += catalan(i) * catalan(n - i - 1);

    return res;
}

int main() {
    unsigned int n;
    cout << "Enter the value of n: ";
    cin >> n;
    cout << "Catalan number " << n << " is " << catalan(n) << endl;
    return 0;
}
```

This code defines a function `catalan()` which computes the nth Catalan number recursively using the formula \(C_n = \sum_{i=0}^{n-1} C_i \cdot C_{n-i-1}\). The `main()` function prompts the user to enter the value of \(n\) and then prints out the corresponding Catalan number.

Remember that the Catalan numbers can grow very rapidly, so for larger values of \(n\), this recursive approach might not be the most efficient. In such cases, it's better to use an iterative approach or memoization to avoid redundant calculations.

### 1. Algorithms & Data Structures (C++): Cheapest Flight Within K Stops

The problem you're referring to is often known as the "Cheapest Flight Within K Stops" problem, which is a variation of the classic shortest path problem. The task is to find the cheapest flight from a given source to a destination within a maximum number of stops.

Here's a high-level approach to solve this problem:

1. **Graph Representation**: Represent the flights as a graph where nodes are airports and edges are flights between them. Each edge has a weight representing the cost of the flight.

2. **Dijkstra's Algorithm**: Use Dijkstra's algorithm to find the shortest path from the source to the destination. However, Dijkstra's algorithm finds the shortest path without considering the number of stops. We need to extend this algorithm to keep track of the number of stops as well.

3. **Modified Dijkstra's Algorithm**: Instead of just storing the shortest distance from the source to each node, maintain a tuple `(distance, stops)` for each node, where `distance` represents the shortest distance from the source to that node and `stops` represents the number of stops made to reach that node.

4. **Priority Queue**: Use a priority queue to select the next node to visit. The priority queue should prioritize nodes based on the total cost `(distance + stops)`.

5. **Terminate Condition**: Terminate the algorithm when either the destination node is reached or the number of stops exceeds `K`.

6. **Optimization**: Keep track of visited nodes to avoid revisiting them unnecessarily.

Here's a simplified code outline in C++:

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <climits>

using namespace std;

#define INF INT_MAX

// Structure to represent a node
struct Node {
    int id;
    int distance;
    int stops;
    Node(int i, int d, int s) : id(i), distance(d), stops(s) {}
};

// Structure to represent an edge
struct Edge {
    int to;
    int cost;
    Edge(int t, int c) : to(t), cost(c) {}
};

// Comparison function for priority queue
struct Compare {
    bool operator()(const Node& a, const Node& b) {
        return a.distance > b.distance;
    }
};

int findCheapestPrice(int n, vector<vector<Edge>>& flights, int src, int dst, int K) {
    vector<vector<int>> dp(n, vector<int>(K + 2, INF));
    priority_queue<Node, vector<Node>, Compare> pq;
    pq.push(Node(src, 0, 0));

    while (!pq.empty()) {
        Node curr = pq.top();
        pq.pop();

        if (curr.id == dst) return curr.distance;

        if (curr.stops > K) continue;

        for (const Edge& e : flights[curr.id]) {
            int new_distance = curr.distance + e.cost;
            if (new_distance < dp[e.to][curr.stops + 1]) {
                dp[e.to][curr.stops + 1] = new_distance;
                pq.push(Node(e.to, new_distance, curr.stops + 1));
            }
        }
    }

    return -1; // If destination is not reachable
}

int main() {
    // Example usage
    int n = 3; // Number of nodes
    vector<vector<Edge>> flights(n); // Adjacency list representation
    flights[0].push_back(Edge(1, 100)); // Flight from node 0 to node 1 with cost 100
    flights[1].push_back(Edge(2, 200)); // Flight from node 1 to node 2 with cost 200
    int src = 0;
    int dst = 2;
    int K = 1; // Maximum number of stops allowed

    int cheapestPrice = findCheapestPrice(n, flights, src, dst, K);
    if (cheapestPrice != -1)
        cout << "Cheapest price from " << src << " to " << dst << " within " << K << " stops is: " << cheapestPrice << endl;
    else
        cout << "No such flight found within " << K << " stops" << endl;

    return 0;
}
```

This code outlines the basic structure of how you can solve this problem in C++. You would need to implement the `findCheapestPrice` function which uses a modified Dijkstra's algorithm to find the cheapest flight within `K` stops.

### 1. Algorithms & Data Structures (C++): Chopsticks

"Chopsticks" is a game often taught in the context of algorithms and data structures as it provides a good exercise in understanding certain concepts like recursion, dynamic programming, or even graph theory depending on how you choose to implement it.

Here's a basic outline of the game and how you might approach it:

**The Game:**

- Chopsticks is a two-player hand game typically played with four fingers, usually excluding the thumb, on each hand.
- Players start with one finger extended on each hand.
- Players take turns to "attack" the opponent's hand by distributing the total number of fingers they have between their hands to the opponent's hands.
- If a hand's finger count reaches five, it is considered "dead" and the fingers on that hand become zero.
- The objective is to eliminate both of the opponent's hands.

**Approach:**

- **Game Representation**: You need to represent the game state in a data structure. You could use a tuple or a custom class to represent the number of fingers on each hand.
- **Game Logic**: Implement the rules of the game. This includes distributing fingers, checking for dead hands, and determining the winner.
- **AI**: If you want to create an AI opponent, you can use algorithms such as minimax with alpha-beta pruning to search the game tree efficiently. The state space for Chopsticks isn't too large, so you might not need advanced techniques like neural networks.
- **User Interface**: Develop a way for players to interact with the game, whether through a command-line interface or a graphical interface.

**Sample Implementation:**

```cpp
#include <iostream>
#include <tuple>

using namespace std;

// Function to check if a hand is dead
bool isDead(int fingers) {
    return fingers >= 5;
}

// Function to apply an attack
tuple<int, int> attack(int a, int b) {
    return make_tuple((a + b) % 5, b);
}

// Function to play the game
void playChopsticks() {
    int fingersA = 1, fingersB = 1; // Start with one finger on each hand
    char currentPlayer = 'A';

    while (true) {
        cout << "Player " << currentPlayer << "'s turn. Choose your attack (e.g., 11 for attack with one finger on each hand): ";
        int attack;
        cin >> attack;

        // Apply attack
        tie(fingersA, fingersB) = attack == 12 ? attack(fingersA, fingersB) : attack(fingersB, fingersA);

        // Check for dead hands
        if (isDead(fingersA) && isDead(fingersB)) {
            cout << "It's a tie!" << endl;
            break;
        } else if (isDead(fingersA)) {
            cout << "Player B wins!" << endl;
            break;
        } else if (isDead(fingersB)) {
            cout << "Player A wins!" << endl;
            break;
        }

        // Switch player
        currentPlayer = (currentPlayer == 'A') ? 'B' : 'A';
    }
}

int main() {
    playChopsticks();
    return 0;
}
```

This is a very basic implementation just to give you an idea. Depending on your requirements, you may want to add more features like error checking, input validation, or even a graphical interface. You could also expand it by adding AI opponents or additional game modes.

### 1. Algorithms & Data Structures (C++): Climbing Stairs

The "Climbing Stairs" problem is a classic dynamic programming problem. The task is to determine the number of distinct ways to reach the top of a staircase with 'n' steps. You can climb either 1 or 2 steps at a time.

Here's a C++ solution using dynamic programming:

```cpp
#include <iostream>
#include <vector>

int climbStairs(int n) {
    if (n == 0 || n == 1) // Base cases
        return 1;
    
    std::vector<int> dp(n + 1, 0); // Create a DP array of size n+1
    
    // Base cases
    dp[0] = 1;
    dp[1] = 1;

    // Fill the DP array bottom-up
    for (int i = 2; i <= n; ++i) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }

    return dp[n];
}

int main() {
    int n;
    std::cout << "Enter the number of steps: ";
    std::cin >> n;
    std::cout << "Number of distinct ways: " << climbStairs(n) << std::endl;
    return 0;
}
```

This solution uses a bottom-up dynamic programming approach. We initialize a DP array `dp` of size `n + 1` to store the number of distinct ways to climb each step. We fill this array iteratively from the base cases `dp[0] = 1` and `dp[1] = 1` up to `dp[n]` using the recurrence relation `dp[i] = dp[i - 1] + dp[i - 2]`. Finally, we return `dp[n]`, which represents the number of distinct ways to climb `n` steps.

### 1. Algorithms & Data Structures (C++): Climbing Stairs - Dynamic Programming

Climbing Stairs is a classic problem often used to introduce dynamic programming concepts. The problem statement is as follows:

You are climbing a staircase. It takes n steps to reach the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

Dynamic programming is an efficient approach to solving this problem by breaking it down into simpler subproblems and storing the solutions to those subproblems to avoid redundant calculations. Here's a C++ implementation using dynamic programming:

```cpp
#include <iostream>
#include <vector>

int climbStairs(int n) {
    if (n <= 2) return n;
    
    std::vector<int> dp(n + 1);
    dp[1] = 1;
    dp[2] = 2;
    
    for (int i = 3; i <= n; ++i) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    
    return dp[n];
}

int main() {
    int n;
    std::cout << "Enter the number of steps in the staircase: ";
    std::cin >> n;
    
    std::cout << "Number of distinct ways to climb the staircase: " << climbStairs(n) << std::endl;
    
    return 0;
}
```

In this implementation:

- We initialize a vector `dp` of size `n + 1` to store the number of distinct ways to climb `i` steps.
- We handle the base cases where `n` is less than or equal to 2.
- We iterate from 3 to `n`, filling in the `dp` array by summing up the number of ways to reach `i - 1` and `i - 2` steps.
- Finally, we return `dp[n]`, which represents the number of distinct ways to climb `n` steps.

This implementation has a time complexity of O(n) and a space complexity of O(n), where n is the number of steps in the staircase.

### 1. Algorithms & Data Structures (C++): Climbing Stairs Dynamic Programming

Climbing Stairs is a classic problem in dynamic programming. The problem statement goes like this: You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

Here's how you can solve it using dynamic programming in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int climbStairs(int n) {
    if (n <= 2)
        return n;
    
    vector<int> dp(n + 1, 0);
    dp[1] = 1; // One way to climb one step
    dp[2] = 2; // Two ways to climb two steps
    
    for (int i = 3; i <= n; ++i) {
        // At each step, the number of ways to reach it is the sum of the
        // number of ways to reach the previous two steps.
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    
    return dp[n];
}

int main() {
    int n;
    cout << "Enter the number of steps: ";
    cin >> n;
    
    int ways = climbStairs(n);
    cout << "Number of distinct ways to climb " << n << " steps: " << ways << endl;
    
    return 0;
}
```

Explanation:

- We use an array `dp` to store the number of ways to reach each step.
- `dp[i]` represents the number of distinct ways to reach the `i`-th step.
- We initialize `dp[1]` and `dp[2]` because there's only one way to reach the first step and two ways to reach the second step.
- Then, we iterate from step 3 to `n`, calculating the number of ways to reach each step based on the number of ways to reach the previous two steps.
- Finally, we return `dp[n]`, which gives us the number of distinct ways to climb `n` steps.

### 1. Algorithms & Data Structures (C++): Climbing Stairs Recursive

Sure, here's a simple recursive implementation of the climbing stairs problem in C++:

```cpp
#include <iostream>
using namespace std;

int climbStairs(int n) {
    if (n <= 1) {
        return 1; // Base case: There's only one way to climb 0 or 1 step
    }
    // Recursive case: The number of ways to climb n steps is the sum of ways to climb n-1 and n-2 steps
    return climbStairs(n - 1) + climbStairs(n - 2);
}

int main() {
    int n;
    cout << "Enter the number of stairs: ";
    cin >> n;
    cout << "Number of ways to climb " << n << " stairs: " << climbStairs(n) << endl;
    return 0;
}
```

This code calculates the number of distinct ways to climb to the top of `n` stairs. The recursive function `climbStairs` is defined to return the number of ways to climb `n` stairs. If `n` is 0 or 1, there's only one way to climb it. Otherwise, it recursively calculates the number of ways by adding the number of ways to climb `n-1` stairs and `n-2` stairs, because at each step you can either climb 1 or 2 stairs.

Keep in mind that while this recursive solution is simple, it's not the most efficient for large inputs due to redundant calculations. Dynamic programming or memoization can be used to optimize it.

### 1. Algorithms & Data Structures (C++): Closest Divisors

The problem "Closest Divisors" typically involves finding two numbers that are the closest divisors of a given integer \( num \), and returning them as an array in ascending order. One common approach is to iterate from the square root of \( num \) downwards, checking if the number is a divisor. Here's how you can implement it in C++:

```cpp
#include <vector>
#include <cmath>

using namespace std;

vector<int> closestDivisors(int num) {
    int limit = sqrt(num + 2);
    for (int i = limit; i >= 1; --i) {
        if ((num + 1) % i == 0) {
            return {i, (num + 1) / i};
        }
        if ((num + 2) % i == 0) {
            return {i, (num + 2) / i};
        }
    }
    return {};
}

int main() {
    int num = 8;
    vector<int> result = closestDivisors(num);
    cout << "Closest divisors of " << num << " are: " << result[0] << " and " << result[1] << endl;
    return 0;
}
```

In this implementation, we iterate from the square root of \( num + 2 \) down to 1, checking if \( num + 1 \) or \( num + 2 \) is divisible by \( i \). We start from the square root of \( num + 2 \) because the divisors will not exceed this value.

### 1. Algorithms & Data Structures (C++): Closest Room

The "Closest Room" problem involves finding the closest room to a given query point based on certain criteria. Here's a basic outline of how you might approach this problem in C++:

1. **Data Structure for Rooms**: Define a struct or class to represent a room. Each room should have an ID and possibly other attributes such as its dimensions or location.

2. **Input**: Obtain input regarding the query point and information about each room. This could be from user input, file input, or any other source.

3. **Distance Metric**: Decide on a distance metric to determine the closeness of a room to the query point. Common choices include Euclidean distance, Manhattan distance, or others depending on the problem requirements.

4. **Calculate Distances**: Calculate the distance between the query point and each room using the chosen distance metric.

5. **Sorting**: Sort the rooms based on their distances from the query point. This can be done using a sorting algorithm like quicksort, mergesort, or a priority queue.

6. **Output**: Output the closest room or rooms based on the sorted list.

Here's a simple example in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct Room {
    int id;
    int x, y; // Coordinates of the room
};

double calculateDistance(int x1, int y1, int x2, int y2) {
    return sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2));
}

bool compareRooms(const Room& r1, const Room& r2, int qx, int qy) {
    double dist1 = calculateDistance(r1.x, r1.y, qx, qy);
    double dist2 = calculateDistance(r2.x, r2.y, qx, qy);
    return dist1 < dist2;
}

int main() {
    int query_x, query_y;
    cout << "Enter the coordinates of the query point: ";
    cin >> query_x >> query_y;

    int numRooms;
    cout << "Enter the number of rooms: ";
    cin >> numRooms;

    vector<Room> rooms(numRooms);
    cout << "Enter the ID and coordinates (x y) of each room:\n";
    for (int i = 0; i < numRooms; ++i) {
        cin >> rooms[i].id >> rooms[i].x >> rooms[i].y;
    }

    // Sort rooms based on distance from query point
    sort(rooms.begin(), rooms.end(), [&](const Room& r1, const Room& r2) {
        return compareRooms(r1, r2, query_x, query_y);
    });

    // Output the closest room
    cout << "Closest room to query point (" << query_x << ", " << query_y << "):\n";
    cout << "Room ID: " << rooms[0].id << ", Distance: " << calculateDistance(rooms[0].x, rooms[0].y, query_x, query_y) << endl;

    return 0;
}
```

In this example, we use the Euclidean distance metric to calculate the distance between the query point and each room. We then sort the rooms based on their distances from the query point and output the closest room.

### 1. Algorithms & Data Structures (C++): Code and Complexity of MO's Algorithm

MO's Algorithm is a powerful offline algorithm for solving range query problems efficiently. It's particularly useful when you have to answer multiple queries on different ranges of an array. The basic idea is to divide the array into blocks and process the queries in a specific order to minimize the number of operations.

Here's a basic implementation of MO's Algorithm in C++ along with the time complexity analysis:

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <cmath>

using namespace std;

const int BLOCK_SIZE = 320; // Adjust this block size according to the problem constraints

struct Query {
    int left, right, index;
};

bool compare(Query a, Query b) {
    if (a.left / BLOCK_SIZE != b.left / BLOCK_SIZE)
        return a.left / BLOCK_SIZE < b.left / BLOCK_SIZE;
    return a.right < b.right;
}

void add(int value) {
    // Add the value to the current state of the algorithm
}

void remove(int value) {
    // Remove the value from the current state of the algorithm
}

int answerQueries(const vector<int>& array, const vector

```cpp
vector<int>& queries) {
    int n = array.size();
    int q = queries.size();

    vector<int> answers(q);

    // Sort queries according to MO's order
    vector

```cpp
    <Query> sortedQueries(q);
    for (int i = 0; i < q; ++i) {
        sortedQueries[i].left = queries[i][0];
        sortedQueries[i].right = queries[i][1];
        sortedQueries[i].index = i;
    }
    sort(sortedQueries.begin(), sortedQueries.end(), compare);

    // Initialize MO's Algorithm
    int currentLeft = 0, currentRight = -1;

    // Process each query
    for (int i = 0; i < q; ++i) {
        int left = sortedQueries[i].left;
        int right = sortedQueries[i].right;

        // Extend the current range to the left
        while (currentLeft > left) {
            currentLeft--;
            add(array[currentLeft]);
        }

        // Extend the current range to the right
        while (currentRight < right) {
            currentRight++;
            add(array[currentRight]);
        }

        // Shrink the current range from the left
        while (currentLeft < left) {
            remove(array[currentLeft]);
            currentLeft++;
        }

        // Shrink the current range from the right
        while (currentRight > right) {
            remove(array[currentRight]);
            currentRight--;
        }

        // Store the answer
        answers[sortedQueries[i].index] = getAnswer();

        // Reset the algorithm's state if necessary
        // (depends on the problem)
    }

    return answers;
}
```

In the above code:

- We define a struct `Query` to represent each query with its left and right boundaries.
- The `compare` function is used to sort the queries according to MO's order.
- `add` and `remove` functions are used to update the algorithm's state when extending or shrinking the current range.
- `getAnswer` function is used to get the answer for the current query range.
- Finally, we process each query one by one, extending or shrinking the current range as needed and storing the answers.

#### Time Complexity Analysis

- Sorting the queries initially takes \(O(q \log q)\).
- Processing each query takes \(O(\frac{n}{\text{BLOCK\_SIZE}} \cdot q)\).
- Total time complexity is \(O((q + \frac{n}{\text{BLOCK\_SIZE}}) \cdot \log q)\).
- If BLOCK_SIZE is appropriately chosen, typically close to \(\sqrt{n}\) or \(n^{2/3}\), the total complexity simplifies to \(O(n \log q)\) or \(O((n + q) \cdot \sqrt{n} \cdot \log q)\), respectively.

This algorithm is quite efficient for a wide range of problems where we have to process multiple queries on different ranges of an array. Adjusting the BLOCK_SIZE is crucial for optimal performance, and it often requires some experimentation.

### 1. Algorithms & Data Structures (C++): Coin change

The Coin Change problem is a classic algorithmic problem where the task is to determine the number of ways to make change for a given amount of money using a specific set of coin denominations. Here's a C++ implementation of the Coin Change problem using dynamic programming:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int countWays(vector<int>& coins, int amount) {
    int n = coins.size();
    vector<vector<int>> dp(n + 1, vector<int>(amount + 1, 0));

    // Base case: If the amount is 0, there is only one way to make change (by not selecting any coin)
    for (int i = 0; i <= n; ++i)
        dp[i][0] = 1;

    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= amount; ++j) {
            // If the current coin value is greater than the amount, we can't include it
            if (coins[i - 1] > j)
                dp[i][j] = dp[i - 1][j];
            else
                // The number of ways to make change is the sum of ways to make change
                // without considering this coin (dp[i-1][j]) and using this coin (dp[i][j - coins[i-1]])
                dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i - 1]];
        }
    }

    return dp[n][amount];
}

int main() {
    vector<int> coins = {1, 2, 5};
    int amount = 5;
    cout << "Number of ways to make change: " << countWays(coins, amount) << endl;
    return 0;
}
```

In this implementation, `countWays` function takes a vector `coins` containing the denominations of coins available and an integer `amount` representing the target amount for which we need to make change. The function returns the number of ways to make change for the given amount using the provided coin denominations.

The algorithm uses a dynamic programming approach where `dp[i][j]` represents the number of ways to make change for amount `j` using the first `i` coins from the `coins` vector. We build the solution bottom-up by considering each coin denomination one by one and updating the `dp` table accordingly. Finally, the value at `dp[n][amount]` gives us the answer.

### 1. Algorithms & Data Structures (C++): Coin Change - Dynamic Programming

Sure, I can help you with that! The Coin Change problem is a classic dynamic programming problem where you're given a target amount and a set of coin denominations, and you need to find the minimum number of coins required to make up that amount. Here's a C++ implementation using dynamic programming:

```cpp
#include <iostream>
#include <vector>
#include <climits>

using namespace std;

int coinChange(vector<int>& coins, int amount) {
    // Create a vector to store minimum number of coins required for each amount from 0 to 'amount'
    vector<int> dp(amount + 1, INT_MAX);

    // Base case: 0 coins needed to make 0 amount
    dp[0] = 0;

    // Iterate through each coin denomination
    for (int coin : coins) {
        // Update dp[i] if using the current coin denomination can reduce the number of coins needed
        for (int i = coin; i <= amount; ++i) {
            if (dp[i - coin] != INT_MAX) { // If previous subproblem has a valid solution
                dp[i] = min(dp[i], dp[i - coin] + 1); // Update minimum number of coins required
            }
        }
    }

    return dp[amount] == INT_MAX ? -1 : dp[amount]; // If dp[amount] is still INT_MAX, no solution exists
}

int main() {
    vector<int> coins = {1, 2, 5}; // Example coin denominations
    int amount = 11; // Example target amount
    cout << "Minimum number of coins required: " << coinChange(coins, amount) << endl;
    return 0;
}
```

This code defines a function `coinChange` that takes a vector of coin denominations and an amount as input and returns the minimum number of coins required to make up that amount. The main function demonstrates its usage by calling it with example coin denominations and amount.

### 1. Algorithms & Data Structures (C++): Coin change (problem)

The coin change problem is a classic algorithmic problem commonly encountered in computer science and dynamic programming. The problem statement is as follows:

Given a set of coin denominations and a target amount, determine the minimum number of coins required to make up that amount. You can use any coin denomination any number of times.

Here's a C++ implementation of the coin change problem using dynamic programming:

```cpp
#include <iostream>
#include <vector>
#include <climits>

using namespace std;

int coinChange(vector<int>& coins, int amount) {
    // Initialize a vector to store minimum number of coins required for each amount from 0 to amount
    vector<int> dp(amount + 1, INT_MAX);
    // Base case: 0 coins required to make up amount 0
    dp[0] = 0;

    // Iterate over each coin denomination
    for (int coin : coins) {
        // For each coin denomination, iterate over all possible amounts starting from the coin denomination value
        for (int i = coin; i <= amount; ++i) {
            // If it's possible to make amount 'i' with this coin,
            // update the minimum number of coins required
            if (dp[i - coin] != INT_MAX) {
                dp[i] = min(dp[i], dp[i - coin] + 1);
            }
        }
    }

    // Return the result for the target amount
    return dp[amount] == INT_MAX ? -1 : dp[amount];
}

int main() {
    vector<int> coins = {1, 2, 5}; // Example set of coin denominations
    int amount = 11; // Example target amount
    cout << "Minimum number of coins required: " << coinChange(coins, amount) << endl;
    return 0;
}
```

In this implementation:

- We use dynamic programming to build up solutions for larger amounts based on solutions for smaller amounts.
- We initialize a vector `dp` to store the minimum number of coins required for each amount from 0 to the target amount.
- We iterate over each coin denomination and for each denomination, we iterate over all possible amounts starting from the coin denomination value. We update `dp[i]` if it's possible to make amount `i` with the current coin denomination.
- Finally, we return `-1` if it's not possible to make up the target amount, otherwise, we return the minimum number of coins required.

You can change the `coins` vector and the `amount` variable to test different scenarios.

### 1. Algorithms & Data Structures (C++): Coin change (solution)

Sure! The Coin Change problem is a classic dynamic programming problem where you're given a set of coin denominations and a target amount, and you need to find the minimum number of coins required to make up that amount. Here's a C++ solution using dynamic programming:

```cpp
#include <iostream>
#include <vector>
#include <climits>

using namespace std;

int minCoins(vector<int>& coins, int amount) {
    vector<int> dp(amount + 1, INT_MAX);
    dp[0] = 0;

    for (int i = 1; i <= amount; ++i) {
        for (int j = 0; j < coins.size(); ++j) {
            if (coins[j] <= i && dp[i - coins[j]] != INT_MAX) {
                dp[i] = min(dp[i], dp[i - coins[j]] + 1);
            }
        }
    }

    return dp[amount] == INT_MAX ? -1 : dp[amount];
}

int main() {
    vector<int> coins = {1, 2, 5}; // Example denominations
    int amount = 11; // Example target amount

    int minCoinsNeeded = minCoins(coins, amount);
    if (minCoinsNeeded == -1) {
        cout << "It is not possible to make up the amount " << amount << " with the given denominations." << endl;
    } else {
        cout << "Minimum number of coins needed to make up " << amount << ": " << minCoinsNeeded << endl;
    }

    return 0;
}
```

This solution uses a bottom-up approach to build up the solution from smaller subproblems. The `dp` array keeps track of the minimum number of coins required to make up each amount from 0 to the target amount. We iterate through each coin denomination for each amount, updating the `dp` array accordingly.

At the end, `dp[amount]` will contain the minimum number of coins needed to make up the target amount, or `INT_MAX` if it's not possible to make up that amount with the given denominations.

### 1. Algorithms & Data Structures (C++): Coin Change 2

The Coin Change 2 problem is a classic dynamic programming problem where you're tasked with finding the number of combinations that make up a given amount of money using a set of coin denominations. Here's a C++ implementation of the Coin Change 2 problem:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int change(int amount, vector<int>& coins) {
    vector<int> dp(amount + 1);
    dp[0] = 1;

    for (int coin : coins) {
        for (int i = coin; i <= amount; ++i) {
            dp[i] += dp[i - coin];
        }
    }

    return dp[amount];
}

int main() {
    int amount = 5;
    vector<int> coins = {1, 2, 5};

    cout << "Number of combinations: " << change(amount, coins) << endl;

    return 0;
}
```

In this code:

- The `change` function takes the amount of money (`amount`) and a vector of coin denominations (`coins`) as input and returns the number of combinations to make up the given amount using the given coins.
- We initialize a vector `dp` of size `amount + 1` to store the number of combinations for each amount from 0 to `amount`.
- We set `dp[0]` to 1 because there is exactly one way to make up an amount of 0 (using no coins).
- We iterate through each coin denomination and update the `dp` array for each amount greater than or equal to the current coin denomination.
- At the end, `dp[amount]` contains the total number of combinations to make up the given amount.

You can customize the `amount` and `coins` vector in the `main` function to test different scenarios.

### 1. Algorithms & Data Structures (C++): Coin Change Problem

The Coin Change Problem is a classic dynamic programming problem where you're given a set of coin denominations and a target amount to make change for. The task is to find the minimum number of coins required to make up that amount. Here's a C++ implementation of the Coin Change Problem using dynamic programming:

```cpp
#include <iostream>
#include <vector>
#include <climits>

using namespace std;

int minCoins(vector<int>& coins, int amount) {
    // Initialize a vector to store the minimum number of coins required for each amount
    vector<int> dp(amount + 1, INT_MAX);

    // Base case: 0 coins are needed to make change for 0
    dp[0] = 0;

    // Iterate through all amounts from 1 to the target amount
    for (int i = 1; i <= amount; ++i) {
        // For each coin denomination
        for (int coin : coins) {
            // Check if the coin denomination is less than or equal to the current amount
            if (coin <= i) {
                // Update the minimum number of coins required for the current amount
                // by taking the minimum of the current value and 1 plus the minimum number of coins
                // required for the remaining amount after subtracting the current coin denomination
                if (dp[i - coin] != INT_MAX) {
                    dp[i] = min(dp[i], dp[i - coin] + 1);
                }
            }
        }
    }

    // If dp[amount] is still INT_MAX, it means it's not possible to make change for the amount
    // Otherwise, return the minimum number of coins required
    return dp[amount] == INT_MAX ? -1 : dp[amount];
}

int main() {
    vector<int> coins = {1, 2, 5}; // Example coin denominations
    int amount = 11; // Example target amount

    int minCoinsRequired = minCoins(coins, amount);
    if (minCoinsRequired != -1) {
        cout << "Minimum number of coins required to make change for " << amount << " is: " << minCoinsRequired << endl;
    } else {
        cout << "It is not possible to make change for " << amount << " with the given denominations." << endl;
    }

    return 0;
}
```

In this implementation:

- We use a dynamic programming approach to build a table (`dp`) where each cell `dp[i]` represents the minimum number of coins needed to make change for the amount `i`.
- We initialize `dp[0]` to be 0 because no coins are needed to make change for 0.
- We iterate through all amounts from 1 to the target amount (`amount`) and for each amount, we iterate through all coin denominations. We update `dp[i]` using the minimum of its current value and 1 plus the minimum number of coins required for the remaining amount after subtracting the current coin denomination.
- Finally, we return `dp[amount]` which represents the minimum number of coins required to make change for the target amount. If it's still `INT_MAX`, it means it's not possible to make change for the amount.

### 1. Algorithms & Data Structures (C++): Coin change: Complexity analysis

The coin change problem involves finding the number of ways to make change for a given amount using a set of denominations. Let's analyze the complexity of solving this problem using dynamic programming in C++.

#### Algorithm Overview

1. **Initialization:** Create a table `dp[]` of size `(amount + 1)` to store the number of ways to make change for each amount from 0 to `amount`.
2. **Base Case:** Set `dp[0] = 1` since there's one way to make change for an amount of 0 (using no coins).
3. **Iterative DP:** For each coin denomination `coin`, iterate over all amounts from `coin` to `amount`, updating `dp[amount]` by adding `dp[amount - coin]`.

#### Complexity Analysis

- **Time Complexity:**
  - The time complexity is O(amount * numCoins), where `amount` is the target amount for which we want to make change, and `numCoins` is the number of different coin denominations.
  - This complexity arises because we iterate through each denomination for each amount from 1 to `amount`, calculating the number of ways to make change.
  - Each cell of the `dp[]` table is computed only once.
- **Space Complexity:**
  - The space complexity is O(amount), as we only need to store the `dp[]` table, which has a size of `amount + 1`.
  - We do not require additional space proportional to the number of coin denominations because we iterate through them iteratively, not storing them in memory.

#### Code Example (C++)

```cpp
#include <iostream>
#include <vector>

int coinChange(int amount, std::vector<int>& coins) {
    std::vector<int> dp(amount + 1, 0);
    dp[0] = 1;

    for (int coin : coins) {
        for (int i = coin; i <= amount; ++i) {
            dp[i] += dp[i - coin];
        }
    }

    return dp[amount];
}

int main() {
    std::vector<int> coins = {1, 2, 5};
    int amount = 5;
    std::cout << "Number of ways to make change: " << coinChange(amount, coins) << std::endl;
    return 0;
}
```

This code demonstrates how to find the number of ways to make change for an amount using dynamic programming in C++. The `coinChange()` function calculates the result, and the `main()` function shows an example usage.

### 1. Algorithms & Data Structures (C++): Collecting Coins

"Collecting Coins" is a classic problem in algorithms and data structures. The problem involves finding the minimum number of coin flips needed to make all coins in a row face the same direction. The direction of each coin is represented by 'H' (heads) or 'T' (tails). A flip operation involves flipping a single coin and its adjacent coins.

Here's a simple approach in C++ to solve this problem:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int minFlipsToMakeSame(vector<char>& coins) {
    int n = coins.size();
    int flips = 0;
    
    for (int i = 1; i < n; ++i) {
        if (coins[i] != coins[i - 1]) {
            ++flips;
            coins[i] = coins[i] == 'H' ? 'T' : 'H';
        }
    }
    
    return flips;
}

int main() {
    vector<char> coins = {'T', 'T', 'H', 'H', 'T'};
    
    int minFlips = minFlipsToMakeSame(coins);
    
    cout << "Minimum number of flips required: " << minFlips << endl;
    
    return 0;
}
```

In this code:

- The `minFlipsToMakeSame` function takes a vector of characters representing the initial state of coins.
- It iterates through the coins, checking if the current coin is different from the previous one. If so, it increments the flips counter and flips the current coin.
- Finally, it returns the total number of flips required to make all coins face the same direction.

You can adjust the `coins` vector in the `main` function to test with different initial configurations.

### 1. Algorithms & Data Structures (C++): Colourful Knapsack

The "Colourful Knapsack" problem is an extension of the classic Knapsack problem where each item has a color associated with it, and you need to maximize the value of items selected while ensuring that no two selected items have the same color. This problem is also known as the "Multiple Knapsack" problem with a color constraint.

Here's how you can approach solving the Colourful Knapsack problem using dynamic programming in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct Item {
    int weight;
    int value;
    int color;
};

int max(int a, int b) {
    return (a > b) ? a : b;
}

int knapsack(int W, vector<Item>& items) {
    int n = items.size();
    vector<vector<int>> dp(n + 1, vector<int>(W + 1, 0));

    for (int i = 1; i <= n; ++i) {
        for (int w = 1; w <= W; ++w) {
            if (items[i - 1].weight > w) {
                dp[i][w] = dp[i - 1][w];
            } else {
                if (dp[i - 1][w] < (items[i - 1].value + dp[i - 1][w - items[i - 1].weight])) {
                    if(dp[i - 1][w - items[i - 1].weight] == items[i - 1].color || dp[i - 1][w - items[i - 1].weight] == 0)
                        dp[i][w] = max(dp[i - 1][w], items[i - 1].value + dp[i - 1][w - items[i - 1].weight]);
                    else
                        dp[i][w] = dp[i - 1][w];
                }
                else
                    dp[i][w] = dp[i - 1][w];
            }
        }
    }
    return dp[n][W];
}

int main() {
    vector<Item> items = {
        {2, 10, 1},  // weight, value, color
        {3, 7, 2},
        {5, 5, 1},
        {8, 8, 3}
    };
    int W = 10; // Knapsack capacity
    cout << "Maximum value that can be obtained: " << knapsack(W, items) << endl;
    return 0;
}
```

This C++ code defines a structure `Item` to represent items with weight, value, and color attributes. The `knapsack` function takes the capacity of the knapsack and a vector of items as input and returns the maximum value that can be obtained without selecting items of the same color. It utilizes dynamic programming to solve the problem efficiently.

You can adjust the input items and knapsack capacity in the `main` function to solve different instances of the Colourful Knapsack problem.

### 1. Algorithms & Data Structures (C++): Commutable Islands

The "Commutable Islands" problem is a classic problem in graph theory and can be solved using algorithms like Kruskal's algorithm for finding the minimum spanning tree (MST).

#### Problem Statement

Given a list of connections between islands and the cost to build each connection, find the minimum cost to connect all the islands.

#### Approach

1. **Create a Graph:** First, represent the islands and their connections as a weighted undirected graph.

2. **Sort Connections:** Sort the connections based on their costs in ascending order.

3. **Use Kruskal's Algorithm:** Iterate through the sorted connections and add them to the MST one by one. Ensure that adding a connection does not create a cycle in the MST.

4. **Calculate Total Cost:** Keep track of the total cost while adding connections.

#### Implementation (in C++)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// Data structure to represent a weighted edge
struct Edge {
    int src, dest, weight;
};

class UnionFind {
private:
    vector<int> parent, rank;

public:
    UnionFind(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        for (int i = 0; i < n; ++i)
            parent[i] = i;
    }

    int find(int x) {
        if (x != parent[x])
            parent[x] = find(parent[x]);
        return parent[x];
    }

    void merge(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);

        if (rootX != rootY) {
            if (rank[rootX] < rank[rootY])
                parent[rootX] = rootY;
            else if (rank[rootX] > rank[rootY])
                parent[rootY] = rootX;
            else {
                parent[rootY] = rootX;
                rank[rootX]++;
            }
        }
    }
};

int minimumCostToConnect(int n, vector<Edge>& connections) {
    // Step 1: Sort connections based on weights
    sort(connections.begin(), connections.end(), [](const Edge& a, const Edge& b) {
        return a.weight < b.weight;
    });

    // Step 2: Initialize union-find data structure
    UnionFind uf(n);

    int minCost = 0;

    // Step 3: Use Kruskal's algorithm to find minimum spanning tree
    for (const Edge& edge : connections) {
        int x = uf.find(edge.src);
        int y = uf.find(edge.dest);

        // Add edge to MST if it doesn't form a cycle
        if (x != y) {
            minCost += edge.weight;
            uf.merge(x, y);
        }
    }

    return minCost;
}

int main() {
    int n = 4; // Number of islands
    vector<Edge> connections = {{0, 1, 1}, {1, 2, 2}, {2, 3, 4}, {0, 3, 5}};

    int minCost = minimumCostToConnect(n, connections);
    cout << "Minimum cost to connect all islands: " << minCost << endl;

    return 0;
}
```

#### Explanation

- The `Edge` struct represents a weighted edge in the graph.
- `UnionFind` class implements the union-find data structure for cycle detection.
- `minimumCostToConnect` function finds the minimum cost to connect all islands using Kruskal's algorithm.
- In the `main` function, you can define the number of islands `n` and the connections between them in the `connections` vector.

This implementation should give you the minimum cost required to connect all the islands.

### 1. Algorithms & Data Structures (C++): Computing Multiplicative Modulo Inverse

To compute the multiplicative modulo inverse of a number `a` modulo `m`, you can use the Extended Euclidean Algorithm. This algorithm finds the greatest common divisor (GCD) of two numbers `a` and `m`, and simultaneously expresses this GCD as a linear combination of `a` and `m`. If `a` and `m` are coprime (i.e., their GCD is 1), then the coefficient of `a` in this linear combination is the multiplicative modulo inverse of `a` modulo `m`.

Here's a C++ implementation of the Extended Euclidean Algorithm to compute the multiplicative modulo inverse:

```cpp
#include <iostream>

// Function to calculate GCD using Euclidean algorithm
int gcdExtended(int a, int b, int &x, int &y) {
    // Base Case
    if (a == 0) {
        x = 0;
        y = 1;
        return b;
    }

    int x1, y1;
    int gcd = gcdExtended(b % a, a, x1, y1);

    // Update x and y using results of recursive call
    x = y1 - (b / a) * x1;
    y = x1;

    return gcd;
}

// Function to find multiplicative modulo inverse of 'a' under modulo 'm'
int modInverse(int a, int m) {
    int x, y;
    int gcd = gcdExtended(a, m, x, y);
    if (gcd != 1) {
        std::cout << "Inverse doesn't exist";
        return -1; // Inverse doesn't exist
    } else {
        // To handle negative x, add m
        int result = (x % m + m) % m;
        return result;
    }
}

int main() {
    int a = 3;
    int m = 11;
    int inverse = modInverse(a, m);
    if (inverse != -1) {
        std::cout << "Multiplicative modulo inverse of " << a << " mod " << m << " is: " << inverse << std::endl;
    }
    return 0;
}
```

This code calculates the multiplicative modulo inverse of `a` modulo `m`. You can change the values of `a` and `m` in the `main()` function to compute the inverse for different values.

### 1. Algorithms & Data Structures (C++): Computing the Max of Sum Sequences

To compute the maximum sum of sub-sequences in a given sequence, you can use the Kadane's algorithm. This algorithm efficiently finds the maximum sum subarray within a one-dimensional array of numbers. Here's a simple implementation in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int maxSumSubsequence(const std::vector<int>& nums) {
    int maxEndingHere = nums[0];
    int maxSoFar = nums[0];

    for (size_t i = 1; i < nums.size(); ++i) {
        maxEndingHere = std::max(nums[i], maxEndingHere + nums[i]);
        maxSoFar = std::max(maxSoFar, maxEndingHere);
    }

    return maxSoFar;
}

int main() {
    std::vector<int> nums = {1, -3, 2, 1, -1};
    std::cout << "Maximum sum subsequence: " << maxSumSubsequence(nums) << std::endl;
    return 0;
}
```

This code will output the maximum sum subsequence for the given input sequence. You can replace the `nums` vector with any sequence you want to find the maximum sum subsequence for.

### 1. Algorithms & Data Structures (C++): Container With Most Water

The "Container With Most Water" problem is a classic algorithmic problem. Given an array of non-negative integers representing the heights of bars, where the width of each bar is 1, find the container with the most water.

Here's a simple approach in C++:

```cpp
#include <vector>
#include <algorithm>

int maxArea(std::vector<int>& height) {
    int maxArea = 0;
    int left = 0;
    int right = height.size() - 1;

    while (left < right) {
        int minHeight = std::min(height[left], height[right]);
        int currentArea = (right - left) * minHeight;
        maxArea = std::max(maxArea, currentArea);
        if (height[left] < height[right]) {
            left++;
        } else {
            right--;
        }
    }

    return maxArea;
}
```

This algorithm starts with two pointers, one at the beginning of the array and one at the end. It calculates the area between the two pointers and updates the maximum area found so far. Then, it moves the pointer with the smaller height towards the other pointer, because moving the pointer with the larger height will never increase the area and moving the pointer with the smaller height might potentially increase it.

This solution has a time complexity of O(n), where n is the number of elements in the array, because each pointer can move at most n-1 times.

### 1. Algorithms & Data Structures (C++): Contains Duplicate

Sure, you can solve the "Contains Duplicate" problem using C++ and various algorithms and data structures. One common approach is to use a hash table (unordered_set in C++) to keep track of the elements encountered so far. Here's a simple implementation:

```cpp
#include <iostream>
#include <vector>
#include <unordered_set>

bool containsDuplicate(std::vector<int>& nums) {
    std::unordered_set<int> seen;
    for (int num : nums) {
        if (seen.find(num) != seen.end()) {
            // Found a duplicate
            return true;
        }
        seen.insert(num);
    }
    // No duplicates found
    return false;
}

int main() {
    std::vector<int> nums = {1, 2, 3, 4, 5}; // Example vector without duplicates
    std::vector<int> numsWithDuplicates = {1, 2, 3, 1, 4, 5}; // Example vector with duplicates

    std::cout << "Vector without duplicates: ";
    if (containsDuplicate(nums)) {
        std::cout << "Contains duplicates.\n";
    } else {
        std::cout << "Does not contain duplicates.\n";
    }

    std::cout << "Vector with duplicates: ";
    if (containsDuplicate(numsWithDuplicates)) {
        std::cout << "Contains duplicates.\n";
    } else {
        std::cout << "Does not contain duplicates.\n";
    }

    return 0;
}
```

This code defines a function `containsDuplicate` that takes a vector of integers as input and returns true if there are any duplicates in the vector, otherwise returns false. The function uses an unordered_set to keep track of the elements encountered so far. If a duplicate is found, the function returns true immediately. Otherwise, it continues iterating through the vector and returns false if no duplicates are found. Finally, in the main function, it demonstrates how to use this function with example vectors.

### 1. Algorithms & Data Structures (C++): Converting Infix to Postfix

Converting an infix expression to a postfix expression is a common task in computer science and involves using a stack to manage operators precedence. Here's a step-by-step algorithm to convert an infix expression to a postfix expression in C++:

```cpp
#include <iostream>
#include <stack>
#include <string>
#include <unordered_map>

using namespace std;

// Function to check if a character is an operator
bool isOperator(char c) {
    return c == '+' || c == '-' || c == '*' || c == '/';
}

// Function to get the precedence of an operator
int getPrecedence(char op) {
    if (op == '*' || op == '/')
        return 2;
    else if (op == '+' || op == '-')
        return 1;
    else
        return 0; // Assuming '(' has the lowest precedence
}

// Function to convert infix expression to postfix expression
string infixToPostfix(const string& infix) {
    stack<char> s;
    string postfix = "";

    for (char c : infix) {
        if (isalnum(c)) { // If the character is an operand
            postfix += c;
        } else if (c == '(') {
            s.push(c);
        } else if (c == ')') {
            while (!s.empty() && s.top() != '(') {
                postfix += s.top();
                s.pop();
            }
            s.pop(); // Pop '('
        } else { // If the character is an operator
            while (!s.empty() && getPrecedence(s.top()) >= getPrecedence(c)) {
                postfix += s.top();
                s.pop();
            }
            s.push(c);
        }
    }

    // Pop any remaining operators from the stack
    while (!s.empty()) {
        postfix += s.top();
        s.pop();
    }

    return postfix;
}

int main() {
    string infix = "a+b*(c-d)/e";
    cout << "Infix expression: " << infix << endl;
    string postfix = infixToPostfix(infix);
    cout << "Postfix expression: " << postfix << endl;
    return 0;
}
```

This code defines a function `infixToPostfix` which takes an infix expression as input and returns the corresponding postfix expression. It uses a stack to keep track of operators and their precedence. The algorithm iterates through each character of the infix expression and applies the necessary rules to convert it into postfix form. Finally, the resulting postfix expression is returned.

You can test this code by providing your own infix expression in the `main` function.

### 1. Algorithms & Data Structures (C++): Count All Possible Routes

Counting all possible routes between two nodes in a graph is a classic problem in computer science. This problem can be solved using dynamic programming, particularly in a scenario where the graph is weighted and the number of routes is required.

Here's a basic outline of how you could approach this problem in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

const int MOD = 1e9 + 7;

int countRoutes(vector<int>& locations, int start, int finish, int fuel, vector<vector<int>>& memo) {
    if (fuel < 0) return 0; // If fuel goes negative, return 0.
    if (memo[start][fuel] != -1) return memo[start][fuel]; // If already computed, return memoized value.

    int routes = (start == finish); // If start is same as finish, 1 route exists.

    for (int i = 0; i < locations.size(); ++i) {
        if (i != start) { // Exclude the current location.
            routes = (routes + countRoutes(locations, i, finish, fuel - abs(locations[start] - locations[i]), memo)) % MOD;
        }
    }

    memo[start][fuel] = routes; // Memoize the result.
    return routes;
}

int countRoutes(vector<int>& locations, int start, int finish, int fuel) {
    vector<vector<int>> memo(locations.size(), vector<int>(fuel + 1, -1)); // Memoization table.
    return countRoutes(locations, start, finish, fuel, memo);
}

int main() {
    vector<int> locations = {2, 3, 6, 8, 4};
    int start = 1, finish = 3, fuel = 5;

    cout << "Number of routes: " << countRoutes(locations, start, finish, fuel) << endl;

    return 0;
}
```

This C++ code defines a function `countRoutes` which calculates the number of possible routes from a start location to a finish location with a given amount of fuel. It uses memoization to optimize the computation by storing intermediate results.

This problem is essentially a recursive problem where you explore all possible paths from the start to the finish. The base case is when you reach the finish node. You keep track of the remaining fuel at each step, ensuring that it doesn't go negative.

Remember, this is just one way to solve this problem, and there are several other approaches you could take, such as using BFS or DFS, depending on the characteristics of your graph.

### 1. Algorithms & Data Structures (C++): Count Primes

Counting primes efficiently is a classic problem in computer science. One popular algorithm for this task is the Sieve of Eratosthenes. Here's a C++ implementation of this algorithm:

```cpp
#include <vector>

int countPrimes(int n) {
    if (n <= 2) return 0;

    std::vector<bool> isPrime(n, true);
    isPrime[0] = false;
    isPrime[1] = false;

    for (int i = 2; i * i < n; ++i) {
        if (isPrime[i]) {
            for (int j = i * i; j < n; j += i) {
                isPrime[j] = false;
            }
        }
    }

    int count = 0;
    for (int i = 2; i < n; ++i) {
        if (isPrime[i]) {
            ++count;
        }
    }

    return count;
}

// Example usage:
int main() {
    int n = 20; // Count primes up to 20
    int primesCount = countPrimes(n);
    std::cout << "Number of primes less than " << n << ": " << primesCount << std::endl;
    return 0;
}
```

This code starts by initializing a boolean vector `isPrime` of size `n`, where each element represents whether the corresponding number is prime or not. It then marks multiples of each prime as non-prime, starting from 2 up to the square root of `n`. Finally, it counts the number of primes remaining in the vector.

The time complexity of this algorithm is approximately O(n log log n), where n is the input number. This makes it very efficient for counting primes up to large numbers.

### 1. Algorithms & Data Structures (C++): Count Subarrays with Target Sum

Sure, counting subarrays with a target sum is a classic problem that can be solved efficiently using two-pointer technique or prefix sum. Here's how you can implement it using the prefix sum approach in C++:

```cpp
#include <iostream>
#include <unordered_map>
#include <vector>

using namespace std;

int countSubarraysWithTargetSum(const vector<int>& nums, int target) {
    unordered_map<int, int> prefixSumFreq;
    int count = 0;
    int prefixSum = 0;
    
    // Initialize prefix sum frequency map
    prefixSumFreq[0] = 1;
    
    for (int i = 0; i < nums.size(); ++i) {
        prefixSum += nums[i];
        
        // Check if there exists a prefix subarray with sum (prefixSum - target)
        if (prefixSumFreq.find(prefixSum - target) != prefixSumFreq.end()) {
            count += prefixSumFreq[prefixSum - target];
        }
        
        // Increment the frequency of current prefix sum
        prefixSumFreq[prefixSum]++;
    }
    
    return count;
}

int main() {
    // Example usage
    vector<int> nums = {1, 2, 3, 4, 5};
    int target = 7;
    cout << "Number of subarrays with target sum: " << countSubarraysWithTargetSum(nums, target) << endl;
    return 0;
}
```

This code initializes a `prefixSumFreq` map to keep track of the frequency of prefix sums encountered so far. It then iterates through the array, updating the `prefixSum` and checking if there exists a prefix subarray with sum `(prefixSum - target)`. If such a subarray exists, it increments the `count` by the frequency of that prefix sum. Finally, it updates the frequency of the current prefix sum in the `prefixSumFreq` map.

### 1. Algorithms & Data Structures (C++): Counting Rectangles

Counting rectangles within a grid is an interesting problem in computer science and mathematics. Let's break down how you might approach this using C++.

Firstly, let's define the problem. Given a grid of points (x, y), we want to count all possible rectangles that can be formed using these points as corners.

Here's a high-level approach:

1. **Grid Representation**: You need to represent your grid, which can be done using a 2D array or any other suitable data structure.

2. **Nested Loop**: You'll need two nested loops to iterate over all pairs of points (x1, y1) and (x2, y2) in the grid.

3. **Counting Rectangles**: For each pair of points, you can consider them as opposite corners of a potential rectangle. Now, you need to check if the other two corners also exist in the grid. If they do, then it forms a rectangle. So, you need to check if the points (x1, y2) and (x2, y1) are present in the grid.

4. **Counting**: Increment a counter whenever you find a valid rectangle.

Here's a basic implementation in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Function to count rectangles in a grid
int countRectangles(vector<vector<int>>& grid) {
    int rows = grid.size();
    int cols = grid[0].size();
    int count = 0;

    // Iterate over all pairs of points
    for (int x1 = 0; x1 < rows; ++x1) {
        for (int y1 = 0; y1 < cols; ++y1) {
            for (int x2 = x1 + 1; x2 < rows; ++x2) {
                for (int y2 = y1 + 1; y2 < cols; ++y2) {
                    // Check if other two corners exist
                    if (grid[x1][y1] && grid[x1][y2] &&
                        grid[x2][y1] && grid[x2][y2]) {
                        count++;
                    }
                }
            }
        }
    }

    return count;
}

int main() {
    vector<vector<int>> grid = {
        {1, 0, 1, 0},
        {0, 1, 0, 1},
        {1, 0, 1, 0}
    };

    cout << "Number of rectangles: " << countRectangles(grid) << endl;

    return 0;
}
```

This code assumes that 1 represents a point in the grid and 0 represents an empty space. You can adjust this representation according to your needs. This implementation has a time complexity of O(n^4), where n is the size of the grid.

### 1. Algorithms & Data Structures (C++): Counting Rectangles | Sets

Counting rectangles in a given grid is a classic problem in computer science, often used to test algorithmic skills. The problem involves counting all the rectangles that can be formed using the grid lines as the sides of the rectangle. Here's a C++ solution using sets:

```cpp
#include <iostream>
#include <set>

using namespace std;

struct Point {
    int x, y;
};

int countRectangles(Point points[], int n) {
    set<pair<int, int>> pointSet;
    for (int i = 0; i < n; i++) {
        pointSet.insert({points[i].x, points[i].y});
    }

    int count = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (points[i].x != points[j].x && points[i].y != points[j].y) {
                if (pointSet.find({points[i].x, points[j].y}) != pointSet.end() &&
                    pointSet.find({points[j].x, points[i].y}) != pointSet.end()) {
                    count++;
                }
            }
        }
    }

    return count / 2; // Divided by 2 to eliminate double counting
}

int main() {
    Point points[] = {{0, 0}, {0, 1}, {1, 0}, {1, 1}, {2, 0}, {2, 1}};
    int n = sizeof(points) / sizeof(points[0]);
    cout << "Number of rectangles: " << countRectangles(points, n) << endl;
    return 0;
}
```

This code defines a `Point` struct to represent a point in 2D space. The `countRectangles` function takes an array of `Point`s and its size `n`. It uses a set to store the points for efficient lookup.

The function then iterates through all pairs of points and checks if they form opposite corners of a rectangle. If they do, it checks if the other two corners also exist in the set. If they do, it increments the count. The count is divided by 2 at the end to avoid double counting.

Finally, the `main` function demonstrates the usage of `countRectangles` with a sample array of points.

### 1. Algorithms & Data Structures (C++): Counting Set Bits

Counting set bits in an integer is a classic problem in computer science. There are several ways to approach it, but one of the most efficient methods is known as the Brian Kernighan's Algorithm. Here's how you can implement it in C++:

```cpp
#include <iostream>

// Function to count set bits in an integer
int countSetBits(int n) {
    int count = 0;
    while (n) {
        n &= (n - 1);
        count++;
    }
    return count;
}

// Main function to test the implementation
int main() {
    int num = 25; // Example integer
    std::cout << "Number of set bits in " << num << " is: " << countSetBits(num) << std::endl;
    return 0;
}
```

This algorithm works by repeatedly turning off the rightmost set bit in the number until the number becomes zero, and counting the number of iterations. Each iteration reduces the number of set bits by one until there are no more set bits left.

### 1. Algorithms & Data Structures (C++): Counting Triangles

Counting triangles in a given undirected graph is a classic problem in computer science. A triangle in a graph consists of three vertices connected by edges forming a closed loop. One approach to count triangles in a graph is by using the concept of adjacency matrices or adjacency lists. Here's how you can approach this problem in C++ using adjacency lists:

```cpp
#include <iostream>
#include <vector>
#include <unordered_set>

using namespace std;

// Function to count the number of triangles in an undirected graph
int countTriangles(vector<vector<int>>& graph) {
    int n = graph.size();
    int triangleCount = 0;

    // Iterate through each vertex
    for (int u = 0; u < n; ++u) {
        // Store the neighbors of the current vertex
        unordered_set<int> neighbors(graph[u].begin(), graph[u].end());

        // Iterate through each pair of neighbors
        for (int v : neighbors) {
            for (int w : neighbors) {
                // Check if (v, w) forms an edge and forms a triangle with u
                if (v != w && neighbors.count(v) && neighbors.count(w)) {
                    triangleCount++;
                }
            }
        }
    }

    // Since each triangle is counted thrice (once for each vertex),
    // divide the count by 3 to get the actual count of triangles
    return triangleCount / 3;
}

int main() {
    // Example graph represented using adjacency lists
    vector<vector<int>> graph = {
        {1, 2},     // Neighbors of vertex 0
        {0, 2, 3},  // Neighbors of vertex 1
        {0, 1, 3},  // Neighbors of vertex 2
        {1, 2}      // Neighbors of vertex 3
    };

    cout << "Number of triangles in the graph: " << countTriangles(graph) << endl;

    return 0;
}
```

In this code:

- We represent the graph using an adjacency list, where `graph[i]` contains the neighbors of vertex `i`.
- We iterate through each vertex and for each vertex, we iterate through its neighbors.
- For each pair of neighbors (`v` and `w`), we check if they form an edge and if they are also connected to the current vertex `u`.
- If both conditions are met, we increment the `triangleCount`.
- Finally, we divide the `triangleCount` by 3 because each triangle is counted three times (once for each vertex).

This approach has a time complexity of O(V^2), where V is the number of vertices in the graph.

### 1. Algorithms & Data Structures (C++): Counting Triangles | Unordered Maps

Counting triangles in a graph is a classic problem in computer science and mathematics. One efficient approach to solve this problem involves using unordered maps (hash maps) in C++. Here's a basic outline of how you can implement this:

```cpp
#include <iostream>
#include <unordered_map>
#include <vector>
using namespace std;

// Function to count the number of triangles
int countTriangles(const vector<vector<int>>& graph) {
    int triangleCount = 0;
    int n = graph.size();

    // Create a map to store the degree of each vertex
    unordered_map<int, int> degree;

    // Calculate degree of each vertex
    for (int i = 0; i < n; ++i) {
        degree[i] = graph[i].size(); // Degree of vertex i
    }

    // Iterate through each edge and count triangles
    for (int i = 0; i < n; ++i) {
        for (int j : graph[i]) {
            for (int k : graph[j]) {
                // Check if there's an edge between k and i to form a triangle
                if (degree[k] > 0 && graph[k][i]) {
                    // Increment triangle count
                    triangleCount++;
                }
            }
        }
    }

    // Each triangle is counted 3 times, so divide by 3
    return triangleCount / 3;
}

int main() {
    // Example graph represented as an adjacency list
    vector<vector<int>> graph = {
        {1, 2},     // Vertex 0 is connected to vertices 1 and 2
        {0, 2},     // Vertex 1 is connected to vertices 0 and 2
        {0, 1, 3},  // Vertex 2 is connected to vertices 0, 1, and 3
        {2}         // Vertex 3 is connected to vertex 2
    };

    // Count triangles in the graph
    int triangles = countTriangles(graph);

    // Output the result
    cout << "Number of triangles in the graph: " << triangles << endl;

    return 0;
}
```

This code first calculates the degree of each vertex and stores it in an unordered map. Then, it iterates through each edge to check if there's an edge between the third vertex to form a triangle. If such an edge exists, it increments the triangle count. Finally, it returns the total count of triangles divided by 3 since each triangle is counted three times during the iteration.

### 1. Algorithms & Data Structures (C++): Coupon Collector

The Coupon Collector's Problem is a classic problem in probability theory and combinatorics. The problem goes like this: Imagine you have a collection of different coupons, and each time you collect a coupon, it's equally likely to be any one of the coupons, independent of which coupons you've collected before. The question is, on average, how many coupons do you need to collect in order to have at least one of each kind?

In C++, you can implement a simulation to estimate the average number of coupons needed to collect all types. Here's a simple implementation using a set to represent the collected coupons:

```cpp
#include <iostream>
#include <cstdlib>
#include <ctime>
#include <unordered_set>

int couponCollector(int numCoupons) {
    std::unordered_set<int> collected;
    int count = 0;

    while (collected.size() < numCoupons) {
        int coupon = rand() % numCoupons;  // Assume coupons are numbered from 0 to numCoupons-1
        if (collected.find(coupon) == collected.end()) {
            collected.insert(coupon);
        }
        count++;
    }

    return count;
}

int main() {
    srand(time(0));  // Seed for random number generation

    int numCoupons;
    std::cout << "Enter the number of different coupons: ";
    std::cin >> numCoupons;

    int numTrials;
    std::cout << "Enter the number of trials: ";
    std::cin >> numTrials;

    int totalAttempts = 0;
    for (int i = 0; i < numTrials; ++i) {
        totalAttempts += couponCollector(numCoupons);
    }

    double averageAttempts = static_cast<double>(totalAttempts) / numTrials;
    std::cout << "Average number of attempts to collect all coupons: " << averageAttempts << std::endl;

    return 0;
}
```

This program simulates the process of collecting coupons until all types have been collected at least once, and then calculates the average number of attempts over multiple trials. Note that for large `numCoupons`, this simulation approach might be computationally expensive, but it provides a good estimation of the average number of attempts.

### 1. Algorithms & Data Structures (C++): Cracking Linked List Interview Questions (Amazon, Facebook, Apple and Microsoft)

Certainly! Cracking linked list interview questions from top tech companies like Amazon, Facebook, Apple, and Microsoft often involve a deep understanding of linked list fundamentals and efficient manipulation techniques. Here are some common linked list interview questions along with their solutions in C++:

1. **Reverse a Linked List:**
   - **Problem:** Reverse a singly linked list.
   - **Solution:** Iterate through the list while maintaining pointers to the current, previous, and next nodes. Update pointers accordingly to reverse the list.

```cpp
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

ListNode* reverseList(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* curr = head;
    while (curr != nullptr) {
        ListNode* nextNode = curr->next;
        curr->next = prev;
        prev = curr;
        curr = nextNode;
    }
    return prev;
}
```

1. **Detect Cycle in a Linked List:**
   - **Problem:** Given a linked list, determine if it has a cycle in it.
   - **Solution:** Use Floyd's cycle detection algorithm with slow and fast pointers.

```cpp
bool hasCycle(ListNode *head) {
    if (head == nullptr || head->next == nullptr) return false;
    ListNode* slow = head;
    ListNode* fast = head->next;
    while (slow != fast) {
        if (fast == nullptr || fast->next == nullptr) return false;
        slow = slow->next;
        fast = fast->next->next;
    }
    return true;
}
```

1. **Find the Middle of a Linked List:**
   - **Problem:** Find the middle node of a singly linked list.
   - **Solution:** Use two pointers technique where one pointer moves one node at a time and another moves two nodes at a time. When the faster pointer reaches the end, the slower pointer will be at the middle.

```cpp
ListNode* middleNode(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
    }
    return slow;
}
```

These are some fundamental linked list interview questions. Depending on the company and the level of the interview, questions may vary in complexity.

### 1. Algorithms & Data Structures (C++): Cracking Recursion Interview Questions

Certainly! Recursion is a fundamental concept in computer science and is commonly tested in technical interviews. Here are some typical recursion interview questions along with their solutions in C++:

1. **Factorial Calculation**: Write a recursive function to calculate the factorial of a number.

```cpp
#include <iostream>
using namespace std;

int factorial(int n) {
    if (n <= 1)
        return 1;
    return n * factorial(n - 1);
}

int main() {
    int n;
    cout << "Enter a number: ";
    cin >> n;
    cout << "Factorial of " << n << " is " << factorial(n) << endl;
    return 0;
}
```

1. **Fibonacci Series**: Write a recursive function to generate the nth Fibonacci number.

```cpp
#include <iostream>
using namespace std;

int fibonacci(int n) {
    if (n <= 1)
        return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

int main() {
    int n;
    cout << "Enter a number: ";
    cin >> n;
    cout << "Fibonacci of " << n << " is " << fibonacci(n) << endl;
    return 0;
}
```

1. **Sum of Digits**: Write a recursive function to find the sum of digits of a number.

```cpp
#include <iostream>
using namespace std;

int sumOfDigits(int n) {
    if (n == 0)
        return 0;
    return n % 10 + sumOfDigits(n / 10);
}

int main() {
    int n;
    cout << "Enter a number: ";
    cin >> n;
    cout << "Sum of digits of " << n << " is " << sumOfDigits(n) << endl;
    return 0;
}
```

1. **Power Calculation**: Write a recursive function to calculate the power of a number.

```cpp
#include <iostream>
using namespace std;

double power(double base, int exponent) {
    if (exponent == 0)
        return 1;
    if (exponent < 0)
        return 1 / power(base, -exponent);
    return base * power(base, exponent - 1);
}

int main() {
    double base;
    int exponent;
    cout << "Enter base: ";
    cin >> base;
    cout << "Enter exponent: ";
    cin >> exponent;
    cout << base << " raised to the power " << exponent << " is " << power(base, exponent) << endl;
    return 0;
}
```

These are some common recursion interview questions in C++. Understanding these examples will help you tackle similar problems effectively during interviews.

### 1. Algorithms & Data Structures (C++): Cracking Stack and Queue Interview Questions (Amazon,Facebook, Apple, Microsoft)

Certainly! Cracking the coding interview for companies like Amazon, Facebook, Apple, and Microsoft often involves demonstrating proficiency in algorithms and data structures, including stacks and queues. Here are some common questions related to stacks and queues along with their solutions in C++:

#### Stack Interview Questions

1. **Implement a stack using arrays:**

   ```cpp
   #include <iostream>
   #define MAX_SIZE 1000

   class Stack {
   private:
       int top;
       int arr[MAX_SIZE];
   public:
       Stack() { top = -1; }
       bool push(int x);
       int pop();
       bool isEmpty();
   };

   bool Stack::push(int x) {
       if (top >= MAX_SIZE - 1) {
           std::cout << "Stack Overflow\n";
           return false;
       } else {
           arr[++top] = x;
           return true;
       }
   }

   int Stack::pop() {
       if (top < 0) {
           std::cout << "Stack Underflow\n";
           return -1;
       } else {
           return arr[top--];
       }
   }

   bool Stack::isEmpty() {
       return (top < 0);
   }
   ```

2. **Implement stack using two queues:**
   This can be implemented by using two queues. The idea is to use one queue for pushing elements and the other for popping elements.

3. **Implement a stack that supports push, pop, top, and retrieving the minimum element in constant time:**
   This can be solved using two stacks, one for storing the actual elements and the other for storing the minimum element at the top.

#### Queue Interview Questions

1. **Implement a queue using arrays:**

   ```cpp
   #include <iostream>
   #define MAX_SIZE 1000

   class Queue {
   private:
       int front, rear, size;
       int arr[MAX_SIZE];
   public:
       Queue() {
           front = rear = -1;
           size = 0;
       }
       bool enqueue(int x);
       int dequeue();
       bool isEmpty();
   };

   bool Queue::enqueue(int x) {
       if (rear == MAX_SIZE - 1) {
           std::cout << "Queue Overflow\n";
           return false;
       } else {
           if (front == -1)
               front = 0;
           arr[++rear] = x;
           size++;
           return true;
       }
   }

   int Queue::dequeue() {
       if (isEmpty()) {
           std::cout << "Queue Underflow\n";
           return -1;
       } else {
           int item = arr[front++];
           size--;
           if (front > rear)
               front = rear = -1;
           return item;
       }
   }

   bool Queue::isEmpty() {
       return (front == -1);
   }
   ```

2. **Implement a circular queue:**
   A circular queue can be implemented using arrays or linked lists. It has a fixed size and supports operations like enqueue and dequeue.

3. **Design a queue using stacks:**
   This can be done by using two stacks. One stack is used for enqueue operation and the other for dequeue operation.

These are some common interview questions related to stacks and queues. Practice solving them and understand their time complexities to perform well in interviews.

### 1. Algorithms & Data Structures (C++): Creating a Prime Number

Sure, creating a function to check if a number is prime in C++ is a common task. Here's a simple implementation:

```cpp
#include <iostream>

bool isPrime(int num) {
    if (num <= 1) {
        return false;
    }
    for (int i = 2; i * i <= num; ++i) {
        if (num % i == 0) {
            return false;
        }
    }
    return true;
}

int main() {
    int number;
    std::cout << "Enter a number: ";
    std::cin >> number;

    if (isPrime(number)) {
        std::cout << number << " is a prime number." << std::endl;
    } else {
        std::cout << number << " is not a prime number." << std::endl;
    }

    return 0;
}
```

This code defines a function `isPrime` that takes an integer `num` as input and returns true if it's a prime number, and false otherwise. The `main` function simply prompts the user to enter a number, calls `isPrime` to check if it's prime, and then prints the result.

The `isPrime` function works by iterating from 2 to the square root of the input number (`num`). If `num` is divisible by any number in this range, it returns false (indicating it's not prime). Otherwise, it returns true (indicating it's prime).

Feel free to ask if you have any questions or if you want to know more about prime number algorithms!

### 1. Algorithms & Data Structures (C++): Creating Triangles with Min Path

Creating triangles with minimum path is a classic problem in algorithms and dynamic programming. Given a triangle of numbers, you start from the top and move to adjacent numbers on the row below, finding the minimum sum of the numbers on the paths from the top to the bottom. Here's how you can implement it in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int minimumTotal(vector<vector<int>>& triangle) {
    int n = triangle.size();
    vector<int> dp(triangle.back());

    for (int layer = n - 2; layer >= 0; --layer) {
        for (int i = 0; i <= layer; ++i) {
            dp[i] = min(dp[i], dp[i + 1]) + triangle[layer][i];
        }
    }
    return dp[0];
}

int main() {
    vector<vector<int>> triangle = {
        {2},
        {3, 4},
        {6, 5, 7},
        {4, 1, 8, 3}
    };
    cout << "Minimum path sum: " << minimumTotal(triangle) << endl;
    return 0;
}
```

This program defines a function `minimumTotal` that takes a 2D vector `triangle` representing the triangle of numbers. It calculates the minimum path sum using dynamic programming and returns the result.

In the `main` function, a sample triangle is defined and passed to `minimumTotal`, and the result is printed out. You can replace the sample triangle with any other triangle you want to test.

### 1. Algorithms & Data Structures (C++): Cute Little Cat

Sure, let's create a simple example of a "Cute Little Cat" class in C++ along with some basic algorithms and data structures commonly associated with it. Here's a conceptual example:

```cpp
#include <iostream>
#include <string>

class CuteLittleCat {
private:
    std::string name;
    int age;
    std::string color;

public:
    // Constructor
    CuteLittleCat(std::string _name, int _age, std::string _color) : name(_name), age(_age), color(_color) {}

    // Destructor
    ~CuteLittleCat() {
        std::cout << "Goodbye, " << name << "!\n";
    }

    // Accessors
    std::string getName() const {
        return name;
    }

    int getAge() const {
        return age;
    }

    std::string getColor() const {
        return color;
    }

    // Setter for age
    void setAge(int newAge) {
        age = newAge;
    }

    // Display information
    void displayInfo() const {
        std::cout << "Name: " << name << "\n";
        std::cout << "Age: " << age << "\n";
        std::cout << "Color: " << color << "\n";
    }
};

int main() {
    // Create a cute little cat object
    CuteLittleCat myCat("Whiskers", 3, "White");

    // Display cat information
    myCat.displayInfo();

    // Change the age
    myCat.setAge(4);

    // Display updated cat information
    myCat.displayInfo();

    return 0;
}
```

This is a simple implementation of a `CuteLittleCat` class in C++. It has attributes such as name, age, and color, along with methods to access and modify these attributes (`getName()`, `getAge()`, `getColor()`, `setAge()`). The `displayInfo()` method is used to print out the cat's information.

This example doesn't specifically incorporate complex algorithms or data structures, but you could certainly extend it to include such things. For example, you might implement a linked list of cats, or a function to sort cats by age using a sorting algorithm like bubble sort or merge sort.

### 1. Algorithms & Data Structures (C++): Cute Little Cat (Trie + Hashing)

Sure! The "Cute Little Cat" problem sounds adorable! I assume you want a C++ implementation of a Trie data structure augmented with hashing for efficient string manipulation or lookup. Here's a basic outline of how you could implement it:

```cpp
#include <iostream>
#include <unordered_map>
#include <string>

using namespace std;

class TrieNode {
public:
    unordered_map<char, TrieNode*> children;
    bool isEndOfWord;

    TrieNode() {
        isEndOfWord = false;
    }
};

class Trie {
private:
    TrieNode* root;

public:
    Trie() {
        root = new TrieNode();
    }

    void insert(const string& word) {
        TrieNode* current = root;
        for (char c : word) {
            if (current->children.find(c) == current->children.end()) {
                current->children[c] = new TrieNode();
            }
            current = current->children[c];
        }
        current->isEndOfWord = true;
    }

    bool search(const string& word) {
        TrieNode* current = root;
        for (char c : word) {
            if (current->children.find(c) == current->children.end()) {
                return false;
            }
            current = current->children[c];
        }
        return current->isEndOfWord;
    }
};

int main() {
    Trie trie;
    trie.insert("cat");
    trie.insert("cats");
    trie.insert("cut");
    
    cout << "Searching for 'cat': " << (trie.search("cat") ? "Found" : "Not Found") << endl;
    cout << "Searching for 'cut': " << (trie.search("cut") ? "Found" : "Not Found") << endl;
    cout << "Searching for 'dog': " << (trie.search("dog") ? "Found" : "Not Found") << endl;

    return 0;
}
```

This code implements a Trie data structure in C++, which is a tree-like data structure used for storing a dynamic set of strings. It supports efficient insertion and search operations.

The `TrieNode` class represents each node in the trie, and the `Trie` class represents the trie itself. The `insert` function inserts a word into the trie, and the `search` function searches for a word in the trie.

This implementation can be further augmented with hashing techniques to improve performance, such as using hash maps instead of unordered maps for the children nodes, or employing hash functions to generate hash codes for strings.

Feel free to ask if you need further explanation or customization!

### 1. Algorithms & Data Structures (C++): Cutting Rods

Cutting Rods is a classic dynamic programming problem where you are given a rod of length n and prices for different lengths of the rod. The goal is to find the maximum revenue that can be obtained by cutting the rod into smaller pieces and selling them.

Here's a C++ implementation of the Cutting Rods problem using dynamic programming:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int maxRevenue(vector<int>& prices, int n) {
    vector<int> revenue(n + 1, 0);

    for (int i = 1; i <= n; ++i) {
        int max_val = INT_MIN;
        for (int j = 1; j <= i; ++j) {
            max_val = max(max_val, prices[j] + revenue[i - j]);
        }
        revenue[i] = max_val;
    }

    return revenue[n];
}

int main() {
    vector<int> prices = {0, 1, 5, 8, 9, 10, 17, 17, 20};
    int n = prices.size() - 1; // Length of the rod

    cout << "Maximum revenue: " << maxRevenue(prices, n) << endl;

    return 0;
}
```

In this implementation, `prices` is a vector containing the prices for rods of length 1 to n. `revenue` is another vector where `revenue[i]` represents the maximum revenue that can be obtained by cutting a rod of length `i`.

The `maxRevenue` function iterates over each possible length of the rod (from 1 to n) and calculates the maximum revenue that can be obtained for each length using dynamic programming. Finally, it returns the maximum revenue for a rod of length n.

In the `main` function, we define the prices vector and calculate the maximum revenue for a rod of length `n`.

### 1. Algorithms & Data Structures (C++): Dancing Algorithms

Dancing Links is a powerful algorithm primarily used to efficiently solve the Exact Cover problem. The Exact Cover problem involves finding a subset of a collection of sets that exactly covers every element in a given universe. This algorithm is notably used in solving various combinatorial problems like Sudoku, N-Queens, and solving polyomino tiling puzzles.

Here's a brief overview of how the Dancing Links algorithm works:

1. **Representation as a Matrix**: The problem is represented as a matrix where rows represent subsets and columns represent elements. An element is covered if it belongs to a chosen subset.

2. **Doubly Linked List Representation**: The matrix is transformed into a sparse, doubly linked list where each column contains all the rows (subsets) that contain that element. Each node in the list contains pointers to the node's neighbors in both the row and column directions.

3. **Algorithm Steps**:
   - **Choose Column**: Select a column (element) with the fewest rows (subsets) covering it.
   - **Cover Column**: Remove the selected column from the matrix and remove all rows containing a 1 in that column.
   - **Choose Row**: Choose a row from the remaining rows.
   - **Cover Rows and Columns**: Remove all columns and rows that are intersected by the chosen row (excluding the column that was initially selected).
   - **Repeat or Backtrack**: If the matrix is empty, a solution is found. Otherwise, recursively repeat the process. If no solution is found, backtrack to the previous choice.

4. **Backtracking**: If no solution is found with the current choice, the algorithm backtracks to the previous choice and tries an alternative path.

The key idea behind Dancing Links is its efficient handling of row and column removal through the use of doubly linked lists. This allows for a highly efficient implementation, especially when solving large instances of the Exact Cover problem.

Implementing Dancing Links efficiently in C++ typically involves careful management of memory, efficient data structures for representing the sparse matrix, and recursive backtracking. Libraries like Boost may offer some utilities to assist with efficient linked list management and other data structures required for implementing the algorithm.

### 1. Algorithms & Data Structures (C++): Dealing with Brackets in Infix Expression during Conversion

Dealing with brackets in infix expressions during conversion to postfix or prefix notation typically involves using a stack data structure to maintain the proper order of operations. Here's a general approach using C++:

1. **Scan the Infix Expression**: Start scanning the infix expression from left to right.

2. **Process Operand and Operators**: When you encounter an operand (number or variable), output it directly to the postfix expression. When you encounter an operator, decide whether to push it onto the stack or pop operators from the stack depending on its precedence.

3. **Handling Brackets**:
   - When an opening bracket '(' is encountered, push it onto the stack.
   - When a closing bracket ')' is encountered, pop operators from the stack and output them to the postfix expression until an opening bracket '(' is encountered. Discard the opening bracket '('.

4. **Output Remaining Operators**: After scanning the entire infix expression, if there are any operators left on the stack, pop them and output to the postfix expression.

Here's a C++ implementation:

```cpp
#include <iostream>
#include <stack>
#include <string>

using namespace std;

int precedence(char op) {
    if (op == '+' || op == '-')
        return 1;
    if (op == '*' || op == '/')
        return 2;
    return 0;
}

string infixToPostfix(const string& infix) {
    string postfix;
    stack<char> operators;

    for (char ch : infix) {
        if (ch == ' ') // Skip whitespace
            continue;

        if (isdigit(ch) || isalpha(ch)) {
            postfix += ch; // Operand, append to postfix
        } else if (ch == '(') {
            operators.push(ch); // Push opening bracket onto stack
        } else if (ch == ')') {
            while (!operators.empty() && operators.top() != '(') {
                postfix += operators.top(); // Pop and output operators until '('
                operators.pop();
            }
            operators.pop(); // Discard the '('
        } else { // Operator
            while (!operators.empty() && precedence(ch) <= precedence(operators.top())) {
                postfix += operators.top(); // Pop and output higher or equal precedence operators
                operators.pop();
            }
            operators.push(ch);
        }
    }

    // Output remaining operators
    while (!operators.empty()) {
        postfix += operators.top();
        operators.pop();
    }

    return postfix;
}

int main() {
    string infix = "a + (b * c - (d / e + f) * g) - h";
    cout << "Infix Expression: " << infix << endl;
    cout << "Postfix Expression: " << infixToPostfix(infix) << endl;
    return 0;
}
```

This implementation assumes that the infix expression contains only single-letter variables and no spaces within variable names. You may need to modify it to handle more complex expressions with multi-letter variable names or spaces. Additionally, you can extend this approach to convert infix expressions to prefix notation.

### 1. Algorithms & Data Structures (C++): Delay Time in Network

The "Delay Time in Network" problem typically involves finding the minimum time taken for a signal to travel from a source node to all other nodes in a network. This problem can be efficiently solved using Dijkstra's algorithm, which is a widely used algorithm for finding the shortest paths between nodes in a graph.

Here's a general outline of how you could approach solving this problem in C++:

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <climits>

using namespace std;

// Define the maximum number of nodes in the network
#define MAX_NODES 100

// Define a structure to represent edges in the network
struct Edge {
    int to;
    int weight;
    Edge(int t, int w) : to(t), weight(w) {}
};

// Define a structure to represent nodes in the network
struct Node {
    vector<Edge> edges;
};

// Function to find the minimum delay time using Dijkstra's algorithm
int minDelayTime(vector<Node>& graph, int source) {
    // Initialize distances array to store the minimum distances from the source node
    vector<int> distances(graph.size(), INT_MAX);

    // Priority queue to store nodes based on their tentative distances
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;

    // Initialize distance from source to itself as 0
    distances[source] = 0;

    // Add the source node to the priority queue
    pq.push({0, source});

    // Dijkstra's algorithm
    while (!pq.empty()) {
        int u = pq.top().second;  // Extract node with minimum distance
        pq.pop();

        // Iterate through all neighboring nodes of u
        for (const Edge& edge : graph[u].edges) {
            int v = edge.to;
            int weight = edge.weight;

            // Relaxation step: Update distance if a shorter path is found
            if (distances[v] > distances[u] + weight) {
                distances[v] = distances[u] + weight;
                pq.push({distances[v], v});
            }
        }
    }

    // Find the maximum distance (delay time) from the source node
    int maxDelayTime = 0;
    for (int i = 0; i < graph.size(); ++i) {
        if (distances[i] == INT_MAX) {
            // Node is unreachable
            return -1;
        }
        maxDelayTime = max(maxDelayTime, distances[i]);
    }
    return maxDelayTime;
}

int main() {
    // Example usage
    int numNodes, numEdges, sourceNode;
    cin >> numNodes >> numEdges >> sourceNode;

    // Create the graph
    vector<Node> graph(numNodes);
    for (int i = 0; i < numEdges; ++i) {
        int from, to, weight;
        cin >> from >> to >> weight;
        graph[from].edges.push_back(Edge(to, weight));
    }

    // Find the minimum delay time from the given source node
    int delayTime = minDelayTime(graph, sourceNode);
    if (delayTime == -1) {
        cout << "Some nodes are unreachable from the source." << endl;
    } else {
        cout << "Minimum delay time from node " << sourceNode << " is: " << delayTime << endl;
    }

    return 0;
}
```

In this code:

- `Node` represents a node in the graph, and each node contains a vector of edges.
- `Edge` represents a directed edge from one node to another with a certain weight.
- The `minDelayTime` function calculates the minimum delay time using Dijkstra's algorithm.
- The `main` function takes input for the number of nodes, number of edges, and the source node, constructs the graph, and then calculates and outputs the minimum delay time.

### 1. Algorithms & Data Structures (C++): Design A Course Schedule Considering Pre-reqs For Courses

Designing a course schedule considering prerequisites for courses involves representing courses and their prerequisites in a way that allows efficient checking and scheduling. We can use directed graphs to represent courses as nodes and prerequisites as directed edges between them. Here's how you can implement it in C++:

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
#include <queue>

using namespace std;

class CourseScheduler {
private:
    unordered_map<string, vector<string>> graph; // Course -> Prerequisites
    unordered_map<string, int> inDegree; // Course -> In-degree

public:
    void addCourse(const string& course, const vector<string>& prerequisites) {
        graph[course] = prerequisites;
        inDegree[course] = 0; // Initialize in-degree for each course
    }

    bool canFinish() {
        // Calculate in-degree for each course
        for (const auto& [course, prerequisites] : graph) {
            for (const string& prereq : prerequisites) {
                inDegree[course]++;
            }
        }

        // Queue for BFS
        queue<string> q;

        // Push courses with no prerequisites into the queue
        for (const auto& [course, degree] : inDegree) {
            if (degree == 0)
                q.push(course);
        }

        int count = 0; // Count of courses that can be finished
        while (!q.empty()) {
            string currCourse = q.front();
            q.pop();
            count++;

            // Decrement in-degree of courses that have currCourse as prerequisite
            for (const auto& [course, prerequisites] : graph) {
                if (find(prerequisites.begin(), prerequisites.end(), currCourse) != prerequisites.end()) {
                    inDegree[course]--;
                    if (inDegree[course] == 0)
                        q.push(course);
                }
            }
        }

        // If count of finished courses equals total courses, return true
        return count == graph.size();
    }
};

int main() {
    CourseScheduler scheduler;

    // Adding courses and their prerequisites
    scheduler.addCourse("CSC101", {});
    scheduler.addCourse("CSC102", {"CSC101"});
    scheduler.addCourse("CSC103", {"CSC101"});
    scheduler.addCourse("CSC201", {"CSC102", "CSC103"});

    // Checking if courses can be scheduled
    if (scheduler.canFinish()) {
        cout << "All courses can be scheduled." << endl;
    } else {
        cout << "Some courses cannot be scheduled due to prerequisites." << endl;
    }

    return 0;
}
```

This implementation first creates a directed graph where courses are nodes and prerequisites are directed edges. Then it calculates the in-degree of each course, representing the number of prerequisites it has. Finally, it performs a BFS (Breadth-First Search) traversal, updating the in-degrees of courses and checking if all courses can be scheduled by counting the number of finished courses.

### 1. Algorithms & Data Structures (C++): Design Tic-Tac-Toe

Designing Tic-Tac-Toe involves creating a data structure to represent the game board and implementing algorithms to handle player moves, check for a win, and manage game state. Here's a basic outline in C++:

```cpp
#include <iostream>
#include <vector>
using namespace std;

class TicTacToe {
private:
    vector<vector<char>> board;
    int size;

public:
    TicTacToe(int n) : size(n) {
        // Initialize the board with empty cells
        board = vector<vector<char>>(n, vector<char>(n, ' '));
    }

    bool makeMove(int row, int col, char player) {
        // Check if the move is within the board boundaries and the cell is empty
        if (row < 0 || row >= size || col < 0 || col >= size || board[row][col] != ' ')
            return false;

        // Make the move
        board[row][col] = player;
        return true;
    }

    bool checkWin(char player) {
        // Check rows and columns
        for (int i = 0; i < size; ++i) {
            bool winRow = true, winCol = true;
            for (int j = 0; j < size; ++j) {
                if (board[i][j] != player)
                    winRow = false;
                if (board[j][i] != player)
                    winCol = false;
            }
            if (winRow || winCol)
                return true;
        }

        // Check diagonals
        bool winDiag1 = true, winDiag2 = true;
        for (int i = 0; i < size; ++i) {
            if (board[i][i] != player)
                winDiag1 = false;
            if (board[i][size - i - 1] != player)
                winDiag2 = false;
        }
        if (winDiag1 || winDiag2)
            return true;

        return false;
    }

    bool isBoardFull() {
        // Check if the board is full
        for (int i = 0; i < size; ++i) {
            for (int j = 0; j < size; ++j) {
                if (board[i][j] == ' ')
                    return false;
            }
        }
        return true;
    }

    void printBoard() {
        // Print the current state of the board
        for (int i = 0; i < size; ++i) {
            for (int j = 0; j < size; ++j) {
                cout << board[i][j];
                if (j < size - 1)
                    cout << "|";
            }
            cout << endl;
            if (i < size - 1) {
                for (int k = 0; k < size * 2 - 1; ++k)
                    cout << "-";
                cout << endl;
            }
        }
    }
};

int main() {
    TicTacToe game(3); // Create a 3x3 Tic-Tac-Toe game
    char currentPlayer = 'X';

    while (true) {
        game.printBoard();
        int row, col;
        cout << "Player " << currentPlayer << ", enter your move (row and column): ";
        cin >> row >> col;

        if (game.makeMove(row, col, currentPlayer)) {
            if (game.checkWin(currentPlayer)) {
                cout << "Player " << currentPlayer << " wins!" << endl;
                break;
            } else if (game.isBoardFull()) {
                cout << "It's a draw!" << endl;
                break;
            } else {
                // Switch player
                currentPlayer = (currentPlayer == 'X') ? 'O' : 'X';
            }
        } else {
            cout << "Invalid move. Try again." << endl;
        }
    }

    return 0;
}
```

This code provides a basic implementation of Tic-Tac-Toe in C++. It allows players to make moves, checks for wins or draws, and switches between players until the game ends. You can further enhance it by adding features like input validation, smarter AI opponents, or a graphical user interface.

### 1. Algorithms & Data Structures (C++): Designing our own String Tokeniser

Designing your own string tokenizer in C++ can be a great exercise for understanding string manipulation and algorithm design. A string tokenizer is a function that splits a string into smaller parts based on a specified delimiter.

Here's a simple implementation of a string tokenizer in C++:

```cpp
#include <iostream>
#include <string>
#include <vector>

std::vector<std::string> tokenize(const std::string& str, char delimiter) {
    std::vector<std::string> tokens;
    std::string token;
    
    for (char c : str) {
        if (c != delimiter) {
            token += c;
        } else {
            if (!token.empty()) {
                tokens.push_back(token);
                token.clear();
            }
        }
    }
    
    if (!token.empty()) {
        tokens.push_back(token);
    }
    
    return tokens;
}

int main() {
    std::string str = "This is a sample string";
    char delimiter = ' ';
    
    std::vector<std::string> tokens = tokenize(str, delimiter);
    
    std::cout << "Tokens:" << std::endl;
    for (const auto& token : tokens) {
        std::cout << token << std::endl;
    }
    
    return 0;
}
```

This implementation defines a `tokenize` function that takes a string and a delimiter character as input and returns a vector of tokens. It iterates through each character of the string and builds tokens by appending characters until the delimiter is encountered. When the delimiter is encountered, it adds the token to the vector and clears the token string for the next token. Finally, it returns the vector of tokens.

You can customize this implementation according to your specific requirements, such as handling multiple delimiters, skipping empty tokens, or using different data structures to store tokens. Additionally, you may want to add error handling or consider performance optimizations for larger strings.

### 1. Algorithms & Data Structures (C++): Digit Dynammic Programming

Dynamic programming (DP) is a powerful technique in computer science and mathematics used to solve optimization problems by breaking them down into simpler subproblems and storing the results of these subproblems to avoid redundant calculations. One application of dynamic programming is solving problems related to digits, often referred to as "digit dynamic programming." This involves manipulating digits or numbers to find certain properties or solutions.

In C++, digit dynamic programming can be applied to a variety of problems, such as:

1. **Counting Digits**: Counting the occurrences of a particular digit in a range of numbers or in a single number.

2. **Digit Sum**: Finding the sum of digits in a number or range of numbers.

3. **Digit Factorials**: Calculating factorials of digits or using factorials in digit-related computations.

4. **Digit Operations**: Performing operations like addition, subtraction, multiplication, or division on digits or numbers.

5. **Digit Sequences**: Finding patterns or sequences within digits or numbers.

Here's a brief example of how you might implement digit dynamic programming in C++ to solve a simple problem, such as finding the count of a specific digit in a range of numbers:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Function to count occurrences of digit d in numbers from 1 to n
int countDigit(int n, int d) {
    if (n == 0)
        return 0;
    
    vector<int> dp(10, 0); // Initialize dp array to store count of digits from 0 to 9
    
    int power = 1;
    int result = 0;
    
    while (n) {
        int digit = n % 10; // Extract the least significant digit
        
        // Update dp array to count occurrences of digit d
        for (int i = 0; i < 10; ++i)
            dp[i] += (i < digit) ? power : ((i == digit) ? (n / 10 + 1) : 0);
        
        dp[digit] += n % power; // Update count for the current digit
        
        n /= 10; // Remove the least significant digit
        result += digit * (n * power); // Update result
        result += dp[d]; // Add count of digit d from dp array
        
        power *= 10; // Update power of 10
    }
    
    return result;
}

int main() {
    int n = 25;
    int d = 2;
    cout << "Count of digit " << d << " from 1 to " << n << " is " << countDigit(n, d) << endl;
    return 0;
}
```

This is a simple example, but it illustrates how you can use dynamic programming techniques to solve digit-related problems efficiently in C++. The specific implementation details may vary depending on the problem you're trying to solve.

### 1. Algorithms & Data Structures (C++): Digit Sum

To compute the digit sum of a number in C++, you can follow a simple algorithm that extracts digits from the number and sums them up. Here's a basic implementation:

```cpp
#include <iostream>

int digitSum(int n) {
    int sum = 0;
    while (n > 0) {
        sum += n % 10;  // Extract the last digit and add it to the sum
        n /= 10;        // Remove the last digit from the number
    }
    return sum;
}

int main() {
    int number;
    std::cout << "Enter a number: ";
    std::cin >> number;
    
    int sum = digitSum(number);
    std::cout << "The digit sum of " << number << " is " << sum << std::endl;
    
    return 0;
}
```

This code defines a function `digitSum` that calculates the digit sum of a given integer `n`. It iteratively extracts each digit from the number, adds it to the sum, and removes that digit from the number by integer division. Finally, it returns the sum.

In the `main()` function, it prompts the user to enter a number, calculates the digit sum using the `digitSum` function, and then prints the result.

### 1. Algorithms & Data Structures (C++): Digital Clock

Creating a digital clock involves handling time, which can be done using the `<ctime>` library in C++ to get the current time. Then, you can format and display it appropriately. Here's a simple implementation of a digital clock in C++:

```cpp
#include <iostream>
#include <ctime>
#include <iomanip>
#include <chrono>
#include <thread>

// Function to get the current time and return it as a string
std::string getCurrentTime() {
    // Get the current time
    auto now = std::chrono::system_clock::now();
    std::time_t current_time = std::chrono::system_clock::to_time_t(now);
    
    // Convert the current time to a string
    std::string timeString = std::ctime(&current_time);

    // Remove the newline character at the end of the string
    timeString.pop_back();

    return timeString;
}

int main() {
    while (true) {
        // Clear the screen
        std::cout << "\033[2J\033[1;1H";

        // Get the current time
        std::string currentTime = getCurrentTime();

        // Output the current time
        std::cout << "Digital Clock\n";
        std::cout << "-------------\n";
        std::cout << currentTime << std::endl;

        // Wait for one second
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }

    return 0;
}
```

This code uses `<ctime>` to get the current time, `<chrono>` to deal with time-related operations, and `<thread>` to pause the execution for one second between each update.

Please note that this code might not work on all platforms due to the use of escape sequences for clearing the screen (`\033[2J\033[1;1H`). You might need to find platform-specific ways to clear the screen if this doesn't work for you. Additionally, for production-level code, error handling and other considerations should be added.

### 1. Algorithms & Data Structures (C++): Displaying Permutations

Displaying permutations in C++ involves generating all possible arrangements of a given set of elements. One common approach is to use recursion to generate permutations.

Here's a simple example of how you can display permutations of a given set of elements in C++ using recursion:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// Function to display permutations
void displayPermutations(vector<int>& nums, int start, int end) {
    if (start == end) {
        for (int num : nums) {
            cout << num << " ";
        }
        cout << endl;
    } else {
        for (int i = start; i <= end; ++i) {
            // Swap the current element with the first element
            swap(nums[start], nums[i]);
            // Recursively generate permutations for the remaining elements
            displayPermutations(nums, start + 1, end);
            // Undo the swap to backtrack
            swap(nums[start], nums[i]);
        }
    }
}

int main() {
    vector<int> nums = {1, 2, 3};

    cout << "Permutations of the array: " << endl;
    displayPermutations(nums, 0, nums.size() - 1);

    return 0;
}
```

In this code:

- `displayPermutations` is a recursive function that generates permutations of the elements in the `nums` vector.
- It takes three parameters: the vector of elements (`nums`), the starting index of the current permutation (`start`), and the ending index (`end`).
- When `start` becomes equal to `end`, it means a permutation has been generated, so it prints the permutation.
- Otherwise, it recursively generates permutations for the remaining elements by swapping the current element with each of the subsequent elements and continuing the recursion.
- After printing each permutation, it backtracks by undoing the swap to ensure that the vector `nums` remains unchanged for subsequent permutations.

You can customize this code according to your needs by modifying the input array or changing the data type from `int` to any other data type as required.

### 1. Algorithms & Data Structures (C++): Distance Queries

Distance queries are a common problem in computer science and are frequently encountered in various applications such as geographical information systems, network analysis, and computational geometry. The problem typically involves finding the distance between two points, or the distance from a point to a set of other points, in a given space.

Here's a brief overview of how you might approach distance queries in C++ using algorithms and data structures:

1. **Brute Force Method**: The simplest approach is to calculate the distance between every pair of points and store them in a matrix or some other data structure. While straightforward, this approach has a time complexity of O(n^2) for n points, which can be inefficient for large datasets.

2. **Precomputation**: If the set of points is fixed and the queries are frequent, you can precompute the distances between all pairs of points and store them in a data structure like a 2D array or a hash table. This approach reduces query time to O(1), but requires O(n^2) space and may not be feasible for very large datasets.

3. **Spatial Data Structures**: For geometric problems involving points in space, spatial data structures like quad-trees, kd-trees, or R-trees can be used to efficiently organize and query the points. These structures partition the space into smaller regions, allowing for faster retrieval of points within a certain distance of a given point.

4. **Shortest Path Algorithms**: If the points represent vertices in a graph and the distances between them represent edge weights, you can use shortest path algorithms like Dijkstra's algorithm or Floyd-Warshall algorithm to find the shortest path between two points or the distances from a single source to all other points.

5. **Geometric Algorithms**: For specific geometric problems, such as finding the closest pair of points or computing the convex hull of a set of points, there are specialized algorithms that can be used to efficiently solve distance queries.

Here's a simple example in C++ using the brute force method to calculate the Euclidean distance between two points:

```cpp
#include <iostream>
#include <cmath>

struct Point {
    double x, y;
};

double distance(const Point& p1, const Point& p2) {
    return sqrt(pow(p2.x - p1.x, 2) + pow(p2.y - p1.y, 2));
}

int main() {
    Point p1 = {1.0, 2.0};
    Point p2 = {4.0, 6.0};

    double dist = distance(p1, p2);
    std::cout << "Distance between points: " << dist << std::endl;

    return 0;
}
```

This is a basic example, and depending on the specific requirements of your problem, you may need to use more sophisticated techniques and data structures to efficiently handle distance queries in C++.

### 1. Algorithms & Data Structures (C++): Distinct Candies

Certainly! The problem of finding the number of distinct candies can be solved using a hash set or a map to keep track of unique candies. Here's a C++ implementation:

```cpp
#include <iostream>
#include <vector>
#include <unordered_set>

int countDistinctCandies(std::vector<int>& candies) {
    std::unordered_set<int> distinctCandies;
    for (int candy : candies) {
        distinctCandies.insert(candy);
    }
    return distinctCandies.size();
}

int main() {
    // Example usage:
    std::vector<int> candies = {1, 1, 2, 3, 4, 4, 5, 6, 6};
    int distinctCount = countDistinctCandies(candies);
    std::cout << "Number of distinct candies: " << distinctCount << std::endl;
    return 0;
}
```

In this code:

- We define a function `countDistinctCandies` that takes a vector of integers representing the types of candies.
- Inside this function, we create an `unordered_set`, `distinctCandies`, to store unique candy types.
- We iterate through the input vector `candies`, inserting each candy type into the set.
- Finally, we return the size of the set, which represents the count of distinct candies.

You can use this function by passing a vector of candies to it, and it will return the count of distinct candies.

### 1. Algorithms & Data Structures (C++): Distinct Number in Windows

To find the distinct numbers in a sliding window of a given size in an array using C++, you can utilize a data structure like a set or unordered_set. Here's a simple implementation using unordered_set:

```cpp
#include <iostream>
#include <vector>
#include <unordered_set>

std::vector<int> distinctNumbersInWindow(const std::vector<int>& nums, int k) {
    std::vector<int> result;
    std::unordered_set<int> windowSet;

    for (int i = 0; i <= nums.size() - k; ++i) {
        windowSet.clear(); // Clear the set for each new window
        for (int j = i; j < i + k; ++j) {
            windowSet.insert(nums[j]);
        }
        result.push_back(windowSet.size());
    }

    return result;
}

int main() {
    std::vector<int> nums = {1, 2, 1, 3, 4, 2, 3};
    int k = 4;

    std::vector<int> result = distinctNumbersInWindow(nums, k);

    std::cout << "Distinct numbers in each window of size " << k << ":" << std::endl;
    for (int num : result) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

This code defines a function `distinctNumbersInWindow` that takes a vector of integers `nums` and an integer `k` representing the window size. It iterates through each window of size `k` in the input array, adds the elements to an unordered_set (which automatically handles duplicates), and then adds the size of the set to the result vector.

In the `main()` function, an example usage is shown with input array `{1, 2, 1, 3, 4, 2, 3}` and window size `4`. This will output the number of distinct elements in each window of size `4`.

### 1. Algorithms & Data Structures (C++): Distribute Coin In Binary Tree

To solve the problem of distributing coins in a binary tree, we can use a depth-first search (DFS) approach. Here's the basic algorithm:

1. Perform a post-order traversal of the binary tree.
2. For each node, calculate the excess or deficit of coins compared to its ideal state (1 coin). This value represents how many coins need to be moved through that node.
3. Accumulate the absolute values of these excess/deficit coins while traversing back up from the children to the parent nodes.
4. Return the total number of moves needed to balance the tree.

Here's how you can implement this algorithm in C++:

```cpp
#include <iostream>
#include <cmath>

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
    int distributeCoins(TreeNode* root) {
        int moves = 0;
        dfs(root, moves);
        return moves;
    }
    
    // Perform DFS traversal
    int dfs(TreeNode* node, int& moves) {
        if (!node) return 0;
        
        // Calculate excess/deficit coins for left and right subtrees
        int left = dfs(node->left, moves);
        int right = dfs(node->right, moves);
        
        // Calculate moves needed for the current node
        moves += abs(left) + abs(right);
        
        // Return the excess/deficit coins for the parent node
        return node->val + left + right - 1;
    }
};

int main() {
    // Example usage
    TreeNode* root = new TreeNode(3);
    root->left = new TreeNode(0);
    root->right = new TreeNode(0);
    Solution sol;
    cout << "Moves needed: " << sol.distributeCoins(root) << endl; // Output should be 2
    return 0;
}
```

This code defines a `TreeNode` structure and a `Solution` class with the `distributeCoins` method. In the `main` function, an example binary tree is created, and the `distributeCoins` method is called to find the minimum number of moves needed to distribute coins evenly.

### 1. Algorithms & Data Structures (C++): Divisor Game

The Divisor Game is a simple problem where two players take turns in choosing divisors of a given integer. The player who cannot make a move loses the game. If both players play optimally, your task is to determine whether the first player can win the game.

Here's a C++ implementation using dynamic programming to solve the Divisor Game problem:

```cpp
#include <iostream>
#include <vector>

using namespace std;

bool divisorGame(int N) {
    vector<bool> dp(N + 1, false); // Dynamic programming array to store the result for each N
    dp[1] = false; // Base case: First player cannot choose any divisor of 1

    for (int i = 2; i <= N; ++i) {
        for (int j = 1; j * j <= i; ++j) {
            if (i % j == 0 && !dp[i - j]) {
                dp[i] = true; // If there exists a divisor j such that second player loses, then first player wins
                break;
            }
        }
    }

    return dp[N];
}

int main() {
    int N;
    cout << "Enter the value of N: ";
    cin >> N;

    if (divisorGame(N))
        cout << "First player wins!" << endl;
    else
        cout << "First player loses!" << endl;

    return 0;
}
```

In this implementation:

- We create a dynamic programming array `dp`, where `dp[i]` indicates whether the first player can win the game if the current number is `i`.
- We iterate through all the numbers from 2 to N, and for each number `i`, we try to find a divisor `j` such that if the second player takes `j`, the first player would win (meaning `dp[i - j]` is false).
- If such a divisor `j` is found, the first player can win the game at number `i`, and we set `dp[i]` to true.
- Finally, we return `dp[N]`, which indicates whether the first player can win when the game starts with the number `N`.

This implementation should give you the desired result for the Divisor Game problem.

### 1. Algorithms & Data Structures (C++): DSA Project - LRU Cache

Creating an LRU (Least Recently Used) cache in C++ is a great project to reinforce your understanding of data structures and algorithms. Here's a basic outline of how you can implement it:

#### Step 1: Define the Node Structure

```cpp
struct Node {
    int key;
    int value;
    Node* prev;
    Node* next;
    Node(int k, int v) : key(k), value(v), prev(nullptr), next(nullptr) {}
};
```

#### Step 2: Implement the Doubly Linked List

```cpp
class DoublyLinkedList {
private:
    Node* head;
    Node* tail;
public:
    DoublyLinkedList();
    ~DoublyLinkedList();
    void addToFront(Node* node);
    void moveToHead(Node* node);
    Node* removeFromEnd();
};
```

#### Step 3: Implement the LRU Cache

```cpp
#include <unordered_map>

class LRUCache {
private:
    int capacity;
    unordered_map<int, Node*> map;
    DoublyLinkedList dll;
public:
    LRUCache(int capacity);
    ~LRUCache();
    int get(int key);
    void put(int key, int value);
};
```

#### Step 4: Implement the Methods

```cpp
DoublyLinkedList::DoublyLinkedList() : head(nullptr), tail(nullptr) {}

DoublyLinkedList::~DoublyLinkedList() {
    // Implement destructor
}

void DoublyLinkedList::addToFront(Node* node) {
    // Implement adding a node to the front of the list
}

void DoublyLinkedList::moveToHead(Node* node) {
    // Implement moving a node to the front of the list
}

Node* DoublyLinkedList::removeFromEnd() {
    // Implement removing a node from the end of the list
}

LRUCache::LRUCache(int capacity) : capacity(capacity) {}

LRUCache::~LRUCache() {
    // Implement destructor
}

int LRUCache::get(int key) {
    // Implement get method
}

void LRUCache::put(int key, int value) {
    // Implement put method
}
```

#### Step 5: Implement Methods

- `get(key)`: Retrieve the value associated with the key. If the key doesn't exist, return -1. Move the accessed item to the front of the list.
- `put(key, value)`: Insert or update the value if the key is already present. If the cache is at capacity, remove the least recently used item (which is at the end of the list) before adding the new item. Move the new item to the front of the list.

#### Step 6: Test Your Implementation

- Write test cases to ensure your LRU cache works correctly under different scenarios.

This should give you a good starting point for your LRU cache project in C++. Let me know if you need further clarification or assistance with any part of the implementation!

### 1. Algorithms & Data Structures (C++): Edit distance

The edit distance (also known as Levenshtein distance) between two strings is the minimum number of operations required to transform one string into the other. The allowed operations are insertion, deletion, or substitution of a single character. Implementing this algorithm in C++ involves dynamic programming.

Here's a basic implementation of the edit distance algorithm in C++:

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

using namespace std;

int editDistance(const string& word1, const string& word2) {
    int m = word1.size();
    int n = word2.size();

    // Create a 2D vector to store the distances
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

    // Initialize the base case values
    for (int i = 0; i <= m; ++i) {
        for (int j = 0; j <= n; ++j) {
            if (i == 0)
                dp[i][j] = j;
            else if (j == 0)
                dp[i][j] = i;
            else if (word1[i - 1] == word2[j - 1])
                dp[i][j] = dp[i - 1][j - 1];
            else
                dp[i][j] = 1 + min({ dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] });
        }
    }

    return dp[m][n];
}

int main() {
    string word1 = "kitten";
    string word2 = "sitting";

    cout << "Edit distance between '" << word1 << "' and '" << word2 << "' is: " << editDistance(word1, word2) << endl;

    return 0;
}
```

This program calculates the edit distance between two strings `word1` and `word2` using dynamic programming. It initializes a 2D array `dp` to store the distances. Then, it iterates through each position of the array, filling it based on the minimum edit distance between substrings of the two words. Finally, it returns the edit distance between the entire strings.

### 1. Algorithms & Data Structures (C++): Edit distance (problem)

The edit distance problem, also known as Levenshtein distance, is a classic algorithmic problem in computer science. It involves determining the minimum number of operations required to transform one string into another. The allowed operations are typically insertion, deletion, or substitution of a single character.

Here's a basic implementation of the edit distance algorithm in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int minDistance(string word1, string word2) {
    int m = word1.size();
    int n = word2.size();
    
    // Create a 2D array to store the edit distances
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
    
    // Initialize the base cases
    for (int i = 0; i <= m; ++i) {
        dp[i][0] = i;
    }
    for (int j = 0; j <= n; ++j) {
        dp[0][j] = j;
    }
    
    // Fill the dp array
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (word1[i - 1] == word2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = 1 + min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]});
            }
        }
    }
    
    // The edit distance is stored in dp[m][n]
    return dp[m][n];
}

int main() {
    string word1 = "kitten";
    string word2 = "sitting";
    
    cout << "Edit distance between '" << word1 << "' and '" << word2 << "': " << minDistance(word1, word2) << endl;
    
    return 0;
}
```

This implementation uses dynamic programming to efficiently compute the edit distance between two strings. It constructs a 2D array `dp` where `dp[i][j]` represents the edit distance between the first `i` characters of `word1` and the first `j` characters of `word2`. The algorithm then fills in this array using bottom-up dynamic programming, and finally returns `dp[m][n]`, where `m` and `n` are the lengths of the input strings.

### 1. Algorithms & Data Structures (C++): Edit distance (solution)

The edit distance algorithm, also known as Levenshtein distance, is a dynamic programming problem used to measure the similarity between two strings. It calculates the minimum number of operations (insertion, deletion, or substitution) required to transform one string into another. Here's a C++ implementation of the edit distance algorithm:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int minDistance(string word1, string word2) {
    int m = word1.length();
    int n = word2.length();

    // Create a 2D vector to store the edit distances
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

    // Initialize the first row and column
    for (int i = 0; i <= m; ++i)
        dp[i][0] = i;
    for (int j = 0; j <= n; ++j)
        dp[0][j] = j;

    // Calculate edit distance
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (word1[i - 1] == word2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = 1 + min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]});
            }
        }
    }

    // Return the edit distance between the two strings
    return dp[m][n];
}

int main() {
    string word1 = "intention";
    string word2 = "execution";

    cout << "Edit distance between '" << word1 << "' and '" << word2 << "': " << minDistance(word1, word2) << endl;

    return 0;
}
```

This code defines the `minDistance` function, which calculates the edit distance between two strings `word1` and `word2`. The main function demonstrates its usage by finding the edit distance between two example words, "intention" and "execution".

### 1. Algorithms & Data Structures (C++): Edit Distance Dynamic Programming

Edit distance, also known as Levenshtein distance, is a measure of similarity between two strings by counting the minimum number of operations required to transform one string into the other. These operations can be insertion, deletion, or substitution of a single character.

Here's how you can implement the edit distance algorithm using dynamic programming in C++:

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int editDistance(const string& word1, const string& word2) {
    int m = word1.length();
    int n = word2.length();

    // Create a 2D vector to store the distances
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

    // Initialize the first row and column
    for (int i = 0; i <= m; ++i) {
        dp[i][0] = i;
    }

    for (int j = 0; j <= n; ++j) {
        dp[0][j] = j;
    }

    // Fill the DP table
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (word1[i - 1] == word2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = 1 + min({dp[i - 1][j - 1],  // substitution
                                    dp[i][j - 1],      // insertion
                                    dp[i - 1][j]});    // deletion
            }
        }
    }

    // Return the bottom-right cell of the DP table
    return dp[m][n];
}

int main() {
    string word1 = "kitten";
    string word2 = "sitting";

    cout << "Edit distance between '" << word1 << "' and '" << word2 << "': " << editDistance(word1, word2) << endl;

    return 0;
}
```

This code defines a function `editDistance` that takes two strings `word1` and `word2` and returns their edit distance. The function uses a dynamic programming approach to compute the minimum number of operations required to transform `word1` into `word2`.

The main logic lies in the nested loops where we fill the DP table based on the characters of the two strings. The final result is stored in `dp[m][n]`, where `m` and `n` are the lengths of `word1` and `word2` respectively.

You can replace the `word1` and `word2` strings in the `main` function with any other strings to compute the edit distance between them.

### 1. Algorithms & Data Structures (C++): Edit Distance Memoization

Edit distance, also known as Levenshtein distance, measures the similarity between two strings by calculating the minimum number of operations required to transform one string into the other. These operations can be insertion, deletion, or substitution of a single character. Implementing it with memoization in C++ can optimize the solution, especially for large strings. Here's how you can do it:

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

using namespace std;

int minDistance(const string& word1, const string& word2, int i, int j, vector<vector<int>>& memo) {
    // If either string is empty, the distance is the length of the other string
    if (i == 0) return j;
    if (j == 0) return i;
    
    // If the distance for these indexes is already calculated, return it from memo
    if (memo[i][j] != -1) return memo[i][j];
    
    // If the characters at the current indexes are the same, no operation needed
    if (word1[i - 1] == word2[j - 1]) {
        memo[i][j] = minDistance(word1, word2, i - 1, j - 1, memo);
    } else {
        // Calculate the minimum of insertion, deletion, or substitution
        int insertOp = minDistance(word1, word2, i, j - 1, memo);
        int deleteOp = minDistance(word1, word2, i - 1, j, memo);
        int replaceOp = minDistance(word1, word2, i - 1, j - 1, memo);
        memo[i][j] = 1 + min({insertOp, deleteOp, replaceOp});
    }
    return memo[i][j];
}

int minDistance(const string& word1, const string& word2) {
    // Initialize memoization table with -1
    vector<vector<int>> memo(word1.size() + 1, vector<int>(word2.size() + 1, -1));
    // Call the recursive function
    return minDistance(word1, word2, word1.size(), word2.size(), memo);
}

int main() {
    string word1 = "kitten";
    string word2 = "sitting";
    cout << "Minimum edit distance between '" << word1 << "' and '" << word2 << "' is: " << minDistance(word1, word2) << endl;
    return 0;
}
```

In this implementation:

- `minDistance` function calculates the minimum distance recursively and memoizes the results in a 2D vector.
- `memo` is initialized with -1 to indicate that the result is not calculated yet.
- If the distance for a pair of indexes (i, j) is already calculated, it is returned directly from the memo table.
- Otherwise, it calculates the minimum of insertion, deletion, or substitution, updates the memo table, and returns the result.

This approach ensures that the algorithm doesn't recalculate distances for the same pairs of substrings, leading to improved performance, especially for longer strings.

### 1. Algorithms & Data Structures (C++): Edit Distance Recursive

The edit distance problem, also known as Levenshtein distance, measures the minimum number of operations required to transform one string into another. The operations allowed are insertion, deletion, or substitution of a single character. Below is a C++ implementation of the edit distance algorithm using recursion:

```cpp
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

int minDistance(string word1, string word2, int m, int n) {
    // If either of the strings is empty, return the length of the other string
    if (m == 0) return n;
    if (n == 0) return m;

    // If the last characters of the strings are the same, ignore them and recur for the remaining strings
    if (word1[m - 1] == word2[n - 1])
        return minDistance(word1, word2, m - 1, n - 1);

    // Otherwise, consider all three operations on the last character of the first string,
    // recursively compute the cost for all three operations and take the minimum.
    return 1 + min({ minDistance(word1, word2, m, n - 1), // Insert
                     minDistance(word1, word2, m - 1, n), // Remove
                     minDistance(word1, word2, m - 1, n - 1) // Replace
                   });
}

int main() {
    string word1 = "sitting";
    string word2 = "kitten";

    int distance = minDistance(word1, word2, word1.length(), word2.length());

    cout << "The edit distance between \"" << word1 << "\" and \"" << word2 << "\" is " << distance << endl;

    return 0;
}
```

In this implementation, `minDistance` is a recursive function that calculates the minimum edit distance between two strings `word1` and `word2`, with lengths `m` and `n` respectively. The function follows the recursive definition of the edit distance problem. The main function demonstrates its usage by computing the edit distance between two example strings.

### 1. Algorithms & Data Structures (C++): Edit distance: Complexity analysis

The edit distance algorithm is used to measure how dissimilar two strings are by counting the minimum number of operations required to transform one string into the other. These operations typically include insertion, deletion, and substitution of a single character.

Here's a brief overview of the algorithm and its complexity analysis:

#### Algorithm Overview

1. **Initialization:** Create a matrix of size `(m+1) x (n+1)`, where `m` and `n` are the lengths of the two strings.
2. **Base Case:** Initialize the first row and column of the matrix with values representing the cost of transforming an empty string to the corresponding prefix of the other string.
3. **Dynamic Programming:** Iterate through the matrix, filling in each cell with the minimum cost required to transform the substring of the first string to match the substring of the second string.
4. **Result:** The value in the bottom-right cell of the matrix represents the minimum edit distance between the two strings.

#### Complexity Analysis

- **Time Complexity:** The time complexity of the dynamic programming approach for edit distance is `O(m * n)`, where `m` and `n` are the lengths of the input strings. This is because we fill in an `(m+1) x (n+1)` matrix.
- **Space Complexity:** The space complexity is also `O(m * n)` because we use a matrix of the same size to store the intermediate results. However, this can be optimized to `O(min(m, n))` by only storing the current and previous rows of the matrix.

#### Example

Consider two strings, "kitten" and "sitting".

- The matrix would have dimensions `(7x8)` for these two strings.
- Filling in the matrix requires traversing all elements once, hence `O(7 * 8)` operations.

#### Conclusion

The edit distance algorithm is a classic example of dynamic programming, providing a solution to a problem with overlapping subproblems. Its time and space complexity make it efficient for comparing strings and is used in various applications such as spell checkers, DNA sequence analysis, and natural language processing.

### 1. Algorithms & Data Structures (C++): Erect the Fence

"Erect the Fence" is a classic computational geometry problem often encountered in algorithmic competitions and interviews. The problem involves finding the convex hull of a set of points in a plane. The convex hull is the smallest convex polygon that encloses all the points in the set.

The problem is usually stated as follows:

Given a set of points in the plane, determine the vertices of the convex hull in counterclockwise order. In other words, you need to find the outer boundary of the points, forming a convex polygon, such that all points are either on the boundary or inside the polygon.

There are several algorithms to solve this problem, with Graham's Scan and Jarvis March (Gift Wrapping) being two of the most popular ones.

Here's a brief overview of the Graham's Scan algorithm:

1. Find the point with the lowest y-coordinate (the leftmost point if there are ties). This point is guaranteed to be on the convex hull.

2. Sort the remaining points by the angle they make with the chosen point. This can be done using the polar angle formula or by using the atan2 function.

3. Traverse the sorted points and maintain a stack. For each point, check whether taking it makes a left turn or a right turn with the last two points on the stack. If it makes a right turn, pop the top element from the stack until a left turn is encountered.

4. Repeat step 3 until all points are processed. The points remaining on the stack form the convex hull.

The convex hull problem is fundamental in computational geometry and has applications in various fields such as computer graphics, geographical information systems, and robotics.

### 1. Algorithms & Data Structures (C++): Exercise: Array Chunk Problem Statement

Certainly! The array chunk problem is a common coding exercise where you're tasked with splitting an array into smaller chunks of a specified size. Here's a simple problem statement:

#### Problem Statement

Given an array of elements and a chunk size, divide the array into subarrays where each subarray has the specified chunk size except for the last subarray, which may have fewer elements if the original array's size is not a multiple of the chunk size.

Write a function `chunkArray(array, chunkSize)` that takes an array `array` and a positive integer `chunkSize` as input and returns a 2D array where each inner array represents a chunk of the original array.

#### Example

**Input:**

```cpp
array = {1, 2, 3, 4, 5, 6, 7}
chunkSize = 3
```

**Output:**

```cpp
{{1, 2, 3}, {4, 5, 6}, {7}}
```

#### Constraints

- The input array can contain any type of elements.
- The chunk size will always be a positive integer greater than zero.

#### Notes

- You can assume that the input array will not be empty.
- If the chunk size is greater than the length of the array, return the array as a single chunk.
- You are not allowed to use any built-in functions that directly solve this problem. You should implement the chunking algorithm yourself.

This problem can be approached using various techniques such as iteration or recursion. Would you like to see a solution using C++?

### 1. Algorithms & Data Structures (C++): Exercise: FizzBuzz Problem Statement

Sure, here's the problem statement for the classic FizzBuzz problem:

#### Problem Statement: FizzBuzz

Write a program that prints the numbers from 1 to n. But for multiples of three, print "Fizz" instead of the number, and for the multiples of five, print "Buzz". For numbers which are multiples of both three and five, print "FizzBuzz".

**Input:**

- An integer n (1 ≤ n ≤ 100).

**Output:**

- Print numbers from 1 to n, following the rules mentioned above.

**Example:**

```bash
Input: 15
Output:
1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
```

Your task is to implement a C++ program that fulfills this specification. Let me know if you need further clarification or assistance!

### 1. Algorithms & Data Structures (C++): Exercise: General Matrix Spirals

Certainly! The exercise of traversing a matrix in a spiral order is a classic one and can be a good exercise for practicing algorithms and data structures. Here's a general approach to solve this problem in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

vector<int> spiralOrder(const vector<vector<int>>& matrix) {
    vector<int> result;
    if (matrix.empty()) return result;
    
    int top = 0, bottom = matrix.size() - 1;
    int left = 0, right = matrix[0].size() - 1;
    
    while (top <= bottom && left <= right) {
        // Traverse top row
        for (int i = left; i <= right; ++i)
            result.push_back(matrix[top][i]);
        top++;

        // Traverse right column
        for (int i = top; i <= bottom; ++i)
            result.push_back(matrix[i][right]);
        right--;

        // Traverse bottom row
        if (top <= bottom) {
            for (int i = right; i >= left; --i)
                result.push_back(matrix[bottom][i]);
            bottom--;
        }

        // Traverse left column
        if (left <= right) {
            for (int i = bottom; i >= top; --i)
                result.push_back(matrix[i][left]);
            left++;
        }
    }
    
    return result;
}

int main() {
    vector<vector<int>> matrix = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    vector<int> result = spiralOrder(matrix);

    cout << "Spiral Order: ";
    for (int num : result) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}
```

This code defines a function `spiralOrder` that takes a 2D vector representing the matrix as input and returns a 1D vector containing elements traversed in spiral order. The main function demonstrates the usage of this function with an example matrix.

You can adjust the `matrix` variable in the `main` function with any matrix you want to test the algorithm with.

### 1. Algorithms & Data Structures (C++): Exercise: Integer Reversal

Sure! The exercise "Integer Reversal" typically involves writing a function that takes an integer as input and returns the integer with its digits reversed. Here's how you could implement it in C++:

```cpp
#include <iostream>

int reverseInteger(int num) {
    int reversed = 0;
    while (num != 0) {
        int digit = num % 10;
        reversed = reversed * 10 + digit;
        num /= 10;
    }
    return reversed;
}

int main() {
    int num;
    std::cout << "Enter an integer: ";
    std::cin >> num;
    int reversed = reverseInteger(num);
    std::cout << "Reversed integer: " << reversed << std::endl;
    return 0;
}
```

This program defines a function `reverseInteger` that takes an integer as input, and returns the integer with its digits reversed. The main function reads an integer from the user, calls `reverseInteger`, and then prints the reversed integer.

For example:

```bash
Enter an integer: 12345
Reversed integer: 54321
```

This algorithm works by repeatedly taking the last digit of the number using the modulo operator `%`, appending it to the result by multiplying the result by 10 and adding the new digit, and then removing the last digit from the number by integer division `/`. This process continues until the original number becomes zero.

### 1. Algorithms & Data Structures (C++): Exercise: Palindromes

Sure! Writing a program to check if a string is a palindrome is a classic exercise in algorithms and data structures. Here's a simple implementation in C++:

```cpp
#include <iostream>
#include <string>
#include <algorithm>

// Function to check if a string is a palindrome
bool isPalindrome(const std::string& str) {
    // Create a copy of the string
    std::string strCopy = str;
    
    // Remove spaces and convert to lowercase
    strCopy.erase(std::remove_if(strCopy.begin(), strCopy.end(), ::isspace), strCopy.end());
    std::transform(strCopy.begin(), strCopy.end(), strCopy.begin(), ::tolower);
    
    // Check if the string is equal to its reverse
    return strCopy == std::string(strCopy.rbegin(), strCopy.rend());
}

int main() {
    std::string input;
    std::cout << "Enter a string: ";
    std::getline(std::cin, input);
    
    if (isPalindrome(input)) {
        std::cout << "The string is a palindrome." << std::endl;
    } else {
        std::cout << "The string is not a palindrome." << std::endl;
    }
    
    return 0;
}
```

This program first removes spaces and converts the input string to lowercase. Then, it compares the string with its reverse using iterators `rbegin()` and `rend()`. If the string is equal to its reverse, it's a palindrome.

You can test this program with various strings to see if it correctly identifies palindromes.

### 1. Algorithms & Data Structures (C++): Exercise: Reversing an Int

Sure, here's a simple C++ function to reverse an integer:

```cpp
#include <iostream>

int reverseInteger(int num) {
    int reversed = 0;
    while (num != 0) {
        int digit = num % 10;
        reversed = reversed * 10 + digit;
        num /= 10;
    }
    return reversed;
}

int main() {
    int num;
    std::cout << "Enter an integer: ";
    std::cin >> num;

    int reversedNum = reverseInteger(num);
    std::cout << "Reversed integer: " << reversedNum << std::endl;

    return 0;
}
```

This function iteratively extracts the digits of the input integer from the least significant digit to the most significant one. For each iteration, it multiplies the current value of the reversed number by 10 and adds the current digit. This effectively builds the reversed integer digit by digit.

### 1. Algorithms & Data Structures (C++): Expected Throws - N Consecutive Heads

In C++, you can simulate flipping a coin with a random number generator, and then count how many flips it takes to get a certain number of consecutive heads. Here's an example using the `<random>` library:

```cpp
#include <iostream>
#include <random>

// Function to simulate flipping a coin
bool flipCoin(std::mt19937& rng) {
    std::uniform_int_distribution<int> dist(0, 1);
    return dist(rng) == 0; // 0 for heads, 1 for tails
}

// Function to count flips until N consecutive heads
int countConsecutiveHeads(int N) {
    std::random_device rd;
    std::mt19937 rng(rd());
    
    int flips = 0;
    int consecutiveHeads = 0;
    
    while (consecutiveHeads < N) {
        if (flipCoin(rng)) { // If heads
            consecutiveHeads++;
        } else { // If tails
            consecutiveHeads = 0;
        }
        flips++;
    }
    
    return flips;
}

int main() {
    int N;
    std::cout << "Enter the number of consecutive heads to simulate: ";
    std::cin >> N;
    
    int flips = countConsecutiveHeads(N);
    std::cout << "Number of flips to get " << N << " consecutive heads: " << flips << std::endl;
    
    return 0;
}
```

This program first prompts the user to enter the number of consecutive heads they want to simulate. Then, it simulates flipping a coin until it gets that number of consecutive heads and outputs the total number of flips needed.

### 1. Algorithms & Data Structures (C++): Expected Throws - Two Consecutive Heads

Sure, let's discuss how you might implement an algorithm in C++ to simulate the tossing of a fair coin until two consecutive heads appear. This can be achieved using a simple random number generation technique. Here's a basic outline of the algorithm:

1. Initialize variables to keep track of the number of consecutive heads and the total number of coin tosses.
2. Use a loop to simulate the tossing of a coin until two consecutive heads are obtained.
3. Inside the loop, generate a random number (0 or 1) to represent heads or tails.
4. Check if the current toss results in a head. If it does, increment the consecutive heads counter.
5. If the consecutive heads counter reaches 2, break out of the loop.
6. If not, reset the consecutive heads counter if the current toss results in a tail.
7. Increment the total number of coin tosses after each iteration.
8. After exiting the loop, output the total number of coin tosses.

Here's a sample implementation in C++:

```cpp
#include <iostream>
#include <cstdlib> // For rand() and srand()
#include <ctime>   // For time()

int main() {
    // Seed the random number generator
    srand(static_cast<unsigned int>(time(nullptr)));

    int consecutiveHeads = 0;
    int totalTosses = 0;

    while (consecutiveHeads < 2) {
        // Generate a random number: 0 for tails, 1 for heads
        int toss = rand() % 2;

        // If it's a head
        if (toss == 1) {
            consecutiveHeads++;
        } else { // It's a tail
            consecutiveHeads = 0; // Reset consecutive heads counter
        }

        totalTosses++; // Increment total number of tosses
    }

    std::cout << "Total number of coin tosses until two consecutive heads: " << totalTosses << std::endl;

    return 0;
}
```

Remember, this is a simple implementation. Depending on your needs, you might want to add error checking, validation, or even optimize the algorithm for better performance.

### 1. Algorithms & Data Structures (C++): Facebook Array Question: Move Zeroes

The "Move Zeroes" problem involves manipulating an array such that all the zeroes are shifted to the end while maintaining the relative order of the non-zero elements. Here's a C++ implementation to solve this problem:

```cpp
#include <iostream>
#include <vector>

using namespace std;

void moveZeroes(vector<int>& nums) {
    int nonZeroIndex = 0;
    // Iterate through the array
    for (int i = 0; i < nums.size(); ++i) {
        // If the current element is non-zero, move it to the front of the array
        if (nums[i] != 0) {
            nums[nonZeroIndex] = nums[i];
            // Move the non-zero index forward
            nonZeroIndex++;
        }
    }
    // Fill the remaining positions with zeroes
    while (nonZeroIndex < nums.size()) {
        nums[nonZeroIndex] = 0;
        nonZeroIndex++;
    }
}

int main() {
    vector<int> nums = {0, 1, 0, 3, 12};
    moveZeroes(nums);
    // Output the modified array
    for (int num : nums) {
        cout << num << " ";
    }
    return 0;
}
```

This implementation maintains a separate index (`nonZeroIndex`) to keep track of the position where the next non-zero element should be placed. It iterates through the array, and whenever it encounters a non-zero element, it places it at the `nonZeroIndex` and increments the index. Finally, it fills the remaining positions with zeroes. This approach has a time complexity of O(n) where n is the size of the array.

### 1. Algorithms & Data Structures (C++): Facebook Backtracking question: Subsets

Sure, here's an example implementation of the Subsets problem using backtracking in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Backtracking function to generate subsets
void backtrack(vector<int>& nums, int start, vector<int>& subset, vector<vector<int>>& subsets) {
    subsets.push_back(subset); // Add the current subset to the list of subsets

    // Explore all possible subsets by recursively adding elements
    for (int i = start; i < nums.size(); ++i) {
        subset.push_back(nums[i]); // Include the current element
        backtrack(nums, i + 1, subset, subsets); // Explore further
        subset.pop_back(); // Backtrack and remove the current element
    }
}

// Function to generate all subsets
vector<vector<int>> subsets(vector<int>& nums) {
    vector<vector<int>> result;
    vector<int> subset;
    backtrack(nums, 0, subset, result);
    return result;
}

// Function to print the subsets
void printSubsets(const vector<vector<int>>& subsets) {
    cout << "Subsets: " << endl;
    for (const auto& subset : subsets) {
        cout << "[";
        for (int i = 0; i < subset.size(); ++i) {
            cout << subset[i];
            if (i < subset.size() - 1) cout << ", ";
        }
        cout << "]" << endl;
    }
}

int main() {
    vector<int> nums = {1, 2, 3};
    vector<vector<int>> result = subsets(nums);
    printSubsets(result);
    return 0;
}
```

This code will generate all possible subsets of a given set of integers `{1, 2, 3}` using backtracking. The `backtrack` function is the heart of this algorithm, which recursively explores all possible subsets by including and excluding elements at each step. Finally, the `subsets` function initializes the necessary variables and calls `backtrack` to start generating subsets.

### 1. Algorithms & Data Structures (C++): Facebook Dynamic Programming Question: Best Time To Buy And Sell Stocks

The "Best Time to Buy and Sell Stocks" problem is a classic dynamic programming question often asked in coding interviews. The problem statement usually goes something like this:

You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.

Here's a simple C++ solution using dynamic programming to solve this problem:

```cpp
#include <vector>
#include <algorithm>

int maxProfit(std::vector<int>& prices) {
    int n = prices.size();
    if (n == 0) return 0;
    
    // dp[i] represents the maximum profit that can be made by the ith day
    std::vector<int> dp(n, 0);
    
    // Initialize the minimum price as the first day's price
    int min_price = prices[0];
    
    for (int i = 1; i < n; ++i) {
        // Update the minimum price seen so far
        min_price = std::min(min_price, prices[i]);
        
        // Calculate the profit if we sell the stock on the current day
        // (price on the current day - minimum price seen so far)
        dp[i] = std::max(dp[i - 1], prices[i] - min_price);
    }
    
    // The maximum profit is the maximum value in the dp array
    return dp[n - 1];
}

int main() {
    std::vector<int> prices = {7, 1, 5, 3, 6, 4};
    int max_profit = maxProfit(prices);
    std::cout << "Maximum profit: " << max_profit << std::endl;
    return 0;
}
```

This solution has a time complexity of O(n) where n is the size of the prices array. It iterates through the prices array once, updating the maximum profit that can be made at each day using dynamic programming.

### 1. Algorithms & Data Structures (C++): Facebook Hash Tables / Dictionaries question: Group Anagrams

To solve the "Group Anagrams" problem efficiently, you can use a hash table (unordered_map in C++) where the key is the sorted form of each word, and the value is a list of words that are anagrams of each other. Here's how you can implement it in C++:

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
#include <algorithm>

using namespace std;

vector<vector<string>> groupAnagrams(vector<string>& strs) {
    unordered_map<string, vector<string>> hash_map;

    for (const string& str : strs) {
        string sorted_str = str;
        sort(sorted_str.begin(), sorted_str.end());
        hash_map[sorted_str].push_back(str);
    }

    vector<vector<string>> result;
    for (auto& pair : hash_map) {
        result.push_back(pair.second);
    }

    return result;
}

int main() {
    vector<string> input = {"eat", "tea", "tan", "ate", "nat", "bat"};
    vector<vector<string>> result = groupAnagrams(input);

    // Output the grouped anagrams
    for (const auto& group : result) {
        for (const string& word : group) {
            cout << word << " ";
        }
        cout << endl;
    }

    return 0;
}
```

This code will output:

```bash
eat tea ate 
tan nat 
bat 
```

Explanation:

- We iterate through each word in the input vector.
- For each word, we sort its characters to get a canonical form.
- We then use this sorted form as a key in the hash table.
- We push the original word into the corresponding vector stored in the hash table.
- Finally, we iterate through the hash table and push each vector of anagrams into the result vector.

This solution has a time complexity of O(n *k* log(k)), where n is the number of words and k is the maximum length of a word. This is because we sort each word, which takes O(k * log(k)) time, and we do this for each of the n words.

### 1. Algorithms & Data Structures (C++): Facebook Interview Questions

Facebook, like many tech companies, focuses heavily on algorithms and data structures during their interviews. Here are some common types of questions they might ask, along with examples:

1. **Arrays and Strings**:
   - **Example**: Given an array of integers, find the maximum sum of a contiguous subarray.
   - **Example**: Reverse a string in-place.

2. **Linked Lists**:
   - **Example**: Detect if a linked list has a cycle.
   - **Example**: Merge two sorted linked lists into one sorted linked list.

3. **Trees and Graphs**:
   - **Example**: Implement depth-first search (DFS) and breadth-first search (BFS) on a graph.
   - **Example**: Given a binary tree, find its maximum depth or check if it's balanced.

4. **Dynamic Programming**:
   - **Example**: Find the longest common subsequence between two strings.
   - **Example**: Calculate the nth Fibonacci number efficiently using dynamic programming.

5. **Sorting and Searching**:
   - **Example**: Implement binary search on a sorted array.
   - **Example**: Sort an array of integers using quicksort or mergesort.

6. **Bit Manipulation**:
   - **Example**: Given an integer, swap the 1st and 0th bits, 2nd and 3rd bits, and so on.
   - **Example**: Determine the number of bits required to convert integer A to integer B.

7. **Design and Analysis**:
   - **Example**: Design a data structure to support the following operations: insert, delete, getRandom, all in constant time.
   - **Example**: Design a system to efficiently store and retrieve user posts in a social media platform like Facebook.

8. **Concurrency and Multithreading**:
   - **Example**: Implement a thread-safe singleton pattern.
   - **Example**: Solve the classic dining philosophers problem using mutexes and threads.

9. **System Design**:
   - **Example**: Design a scalable news feed system for a social media platform like Facebook.
   - **Example**: Design a distributed cache system to handle heavy read and write loads.

10. **Miscellaneous**:
    - **Example**: Given a matrix representing a board game, implement a function to find the shortest path from start to finish.

Remember, the key to success in these interviews is not just solving the problem but also explaining your thought process, considering edge cases, and optimizing your solution if possible.

### 1. Algorithms & Data Structures (C++): Facebook Math Question: Add Binary

Certainly! Adding binary numbers is a fundamental operation in computer science. In C++, you can perform this operation by converting the binary strings into integers, adding them, and then converting the sum back into a binary string. Here's a simple implementation:

```cpp
#include <iostream>
#include <algorithm>

std::string addBinary(std::string a, std::string b) {
    std::string result = "";
    int carry = 0;
    
    // Pad the shorter string with zeros
    int maxLength = std::max(a.size(), b.size());
    std::string paddedA(maxLength - a.size(), '0');
    std::string paddedB(maxLength - b.size(), '0');
    a = paddedA + a;
    b = paddedB + b;
    
    // Iterate through each bit, starting from the least significant bit
    for (int i = maxLength - 1; i >= 0; --i) {
        int sum = (a[i] - '0') + (b[i] - '0') + carry;
        result.insert(result.begin(), sum % 2 + '0');
        carry = sum / 2;
    }
    
    // If there's still a carry, prepend it to the result
    if (carry)
        result.insert(result.begin(), '1');
    
    return result;
}

int main() {
    std::string a = "1010"; // Binary representation of 10
    std::string b = "1011"; // Binary representation of 11
    
    std::cout << "The sum is: " << addBinary(a, b) << std::endl;
    
    return 0;
}
```

In this implementation:

- We first pad the shorter binary number with leading zeros to make both strings equal in length.
- Then, we iterate through each bit of the binary numbers from right to left (least significant bit to most significant bit), adding corresponding bits along with the carry.
- The sum of two bits and the carry is inserted at the beginning of the result string.
- Finally, if there is any carry left after the iteration, it is prepended to the result.

You can adjust the input binary strings `a` and `b` in the `main` function to test different binary additions.

### 1. Algorithms & Data Structures (C++): Facebook Trees question: Lowest Common Ancestor of a Binary Tree

The Lowest Common Ancestor (LCA) problem in a binary tree is a common algorithmic problem often encountered in computer science, including during technical interviews. In the context of Facebook or any other tech company, you might encounter this problem during coding interviews or while working on tree-related features.

Here's how you could approach solving the Lowest Common Ancestor problem for a binary tree in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr || root == p || root == q) {
            return root;
        }

        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);

        if (left != nullptr && right != nullptr) {
            return root; // Found the common ancestor
        } else if (left != nullptr) {
            return left; // LCA is in the left subtree
        } else {
            return right; // LCA is in the right subtree
        }
    }
};

int main() {
    // Example usage
    Solution solution;
    TreeNode* root = new TreeNode(3);
    root->left = new TreeNode(5);
    root->right = new TreeNode(1);
    root->left->left = new TreeNode(6);
    root->left->right = new TreeNode(2);
    root->right->left = new TreeNode(0);
    root->right->right = new TreeNode(8);
    root->left->right->left = new TreeNode(7);
    root->left->right->right = new TreeNode(4);

    TreeNode* p = root->left;
    TreeNode* q = root->right;

    TreeNode* lca = solution.lowestCommonAncestor(root, p, q);
    if (lca)
        cout << "Lowest Common Ancestor of " << p->val << " and " << q->val << " is " << lca->val << endl;
    else
        cout << "No common ancestor found" << endl;

    // Deallocate memory
    // Code for deallocation depends on actual tree implementation
    // Left out here for simplicity
    return 0;
}
```

In this code:

- The `lowestCommonAncestor` function recursively traverses the binary tree, looking for the nodes `p` and `q`.
- Once it finds either `p` or `q` (or reaches the end of the tree), it returns that node.
- When the function returns from both left and right subtrees, it checks whether both `p` and `q` are found in different subtrees. If so, the current node is the lowest common ancestor. Otherwise, it continues the search in the subtree where `p` or `q` was found.

This solution has a time complexity of O(n), where n is the number of nodes in the tree, since it traverses each node once.

### 1. Algorithms & Data Structures (C++): Find pair that sums up to k

Certainly! Finding pairs in an array that sum up to a given value `k` is a classic problem. One way to solve it efficiently is by using hashing (unordered_map in C++) to store elements and their indices. Here's a simple implementation in C++:

```cpp
#include <iostream>
#include <unordered_map>
#include <vector>

using namespace std;

vector<pair<int, int>> findPairsWithSum(const vector<int>& nums, int k) {
    unordered_map<int, int> indices; // Map to store number and its index
    vector<pair<int, int>> pairs; // Vector to store pairs

    for (int i = 0; i < nums.size(); ++i) {
        int complement = k - nums[i];
        if (indices.find(complement) != indices.end()) {
            pairs.push_back({nums[i], complement});
        }
        indices[nums[i]] = i; // Store the number and its index
    }

    return pairs;
}

int main() {
    vector<int> nums = {1, 4, 2, 6, 5, 3};
    int k = 7;
    vector<pair<int, int>> pairs = findPairsWithSum(nums, k);

    if (pairs.size() > 0) {
        cout << "Pairs with sum " << k << " are:" << endl;
        for (const auto& pair : pairs) {
            cout << pair.first << ", " << pair.second << endl;
        }
    } else {
        cout << "No pairs with sum " << k << " found." << endl;
    }

    return 0;
}
```

This code finds pairs of numbers in the given vector `nums` whose sum equals `k`. It iterates through the vector once, keeping track of the indices of the elements it has seen so far using an unordered_map. For each element `nums[i]`, it calculates its complement `k - nums[i]` and checks if this complement exists in the map. If it does, it adds the pair `(nums[i], complement)` to the result vector. Finally, it returns the vector containing all pairs.

### 1. Algorithms & Data Structures (C++): Find pair that sums up to k: Complexity analysis

Finding pairs that sum up to a given value \( k \) in an array involves iterating through the array once and for each element, checking if there exists another element in the array that sums up to \( k \). Here's a basic algorithm for this task in C++:

```cpp
#include <iostream>
#include <unordered_set>
#include <vector>

std::vector<std::pair<int, int>> findPairs(std::vector<int>& nums, int k) {
    std::vector<std::pair<int, int>> pairs;
    std::unordered_set<int> complementSet;

    for (int num : nums) {
        int complement = k - num;
        if (complementSet.find(complement) != complementSet.end()) {
            pairs.push_back(std::make_pair(num, complement));
        }
        complementSet.insert(num);
    }

    return pairs;
}

int main() {
    std::vector<int> nums = {1, 2, 3, 4, 5, 6, 7};
    int k = 8;
    std::vector<std::pair<int, int>> pairs = findPairs(nums, k);

    for (const auto& pair : pairs) {
        std::cout << pair.first << ", " << pair.second << std::endl;
    }

    return 0;
}
```

Now, let's analyze the complexity of this algorithm:

- **Time Complexity**:
  - The algorithm iterates through the array once, which gives us a time complexity of \( O(n) \), where \( n \) is the number of elements in the array.
  - For each element, it performs a constant-time lookup in the unordered set to check if the complement exists. On average, this operation takes \( O(1) \) time.
  - So, overall, the time complexity is \( O(n) \) due to the linear scan of the array.

- **Space Complexity**:
  - We use an unordered set to store the complements of the elements seen so far. In the worst case, this set can store all the elements of the array, so the space complexity is \( O(n) \).
  - Additionally, the space complexity of the vector that stores the pairs is also proportional to the number of pairs found, which could be \( O(n) \) in the worst case.
  - Therefore, the overall space complexity is \( O(n) \).

This algorithm provides an efficient solution to the problem, achieving linear time complexity in the average case.

### 1. Algorithms & Data Structures (C++): Finding Cabs

To find cabs in a given area using C++ programming language, you could employ various algorithms and data structures. Here's a simple approach using a distance-based filtering method and a data structure like a priority queue:

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <cmath>

using namespace std;

struct Cab {
    int id;
    double x, y; // coordinates
};

double calculateDistance(double x1, double y1, double x2, double y2) {
    return sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));
}

class CompareDistance {
public:
    bool operator()(const pair<double, Cab>& a, const pair<double, Cab>& b) {
        return a.first > b.first;
    }
};

vector<Cab> findNearbyCabs(vector<Cab>& allCabs, double userX, double userY, double maxDistance, int numCabs) {
    priority_queue<pair<double, Cab>, vector<pair<double, Cab>>, CompareDistance> pq;

    // Calculate distances and store in priority queue
    for (const auto& cab : allCabs) {
        double distance = calculateDistance(userX, userY, cab.x, cab.y);
        if (distance <= maxDistance) {
            pq.push({distance, cab});
        }
    }

    // Retrieve the nearest cabs
    vector<Cab> nearbyCabs;
    while (!pq.empty() && numCabs-- > 0) {
        nearbyCabs.push_back(pq.top().second);
        pq.pop();
    }

    return nearbyCabs;
}

int main() {
    // Example usage
    vector<Cab> allCabs = {{1, 10.5, 20.5}, {2, 15.0, 25.0}, {3, 12.0, 18.0}, {4, 8.0, 22.0}};
    double userX = 13.0;
    double userY = 21.0;
    double maxDistance = 5.0;
    int numCabs = 2;

    vector<Cab> nearbyCabs = findNearbyCabs(allCabs, userX, userY, maxDistance, numCabs);

    // Print nearby cabs
    cout << "Nearby cabs:" << endl;
    for (const auto& cab : nearbyCabs) {
        cout << "ID: " << cab.id << ", Distance: " << calculateDistance(userX, userY, cab.x, cab.y) << endl;
    }

    return 0;
}
```

In this code:

- We define a `Cab` struct to represent each cab with an ID and coordinates (x, y).
- `calculateDistance` calculates the Euclidean distance between two points.
- `findNearbyCabs` takes a vector of all cabs, user's coordinates, maximum distance, and the number of cabs to find.
- It calculates distances between the user and all cabs, filters out those within the maximum distance, and stores them in a priority queue based on their distances.
- Finally, it retrieves the nearest cabs based on the user's location and the specified number of cabs.
- In `main()`, you can input the cabs' data and call `findNearbyCabs` to get nearby cabs.
- The example demonstrates finding nearby cabs for a user at coordinates (13.0, 21.0), within a maximum distance of 5.0 units, and wanting to find 2 cabs.

### 1. Algorithms & Data Structures (C++): Finding Primes

Finding prime numbers efficiently is a common problem in computer science. One of the most efficient algorithms for this task is the Sieve of Eratosthenes. Here's a simple implementation of the Sieve of Eratosthenes algorithm in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

vector<int> sieveOfEratosthenes(int n) {
    // Create a boolean vector "prime[0..n]" and initialize all entries as true.
    // A value in prime[i] will finally be false if i is Not a prime, else true.
    vector<bool> prime(n+1, true);

    for (int p = 2; p * p <= n; p++) {
        // If prime[p] is not changed, then it is a prime
        if (prime[p] == true) {
            // Update all multiples of p
            for (int i = p * p; i <= n; i += p)
                prime[i] = false;
        }
    }

    // Create a vector to store prime numbers
    vector<int> primes;
    for (int p = 2; p <= n; p++) {
        if (prime[p])
            primes.push_back(p);
    }
    return primes;
}

int main() {
    int n;
    cout << "Enter the value of n: ";
    cin >> n;

    vector<int> primes = sieveOfEratosthenes(n);
    
    cout << "Prime numbers less than or equal to " << n << " are:\n";
    for (int prime : primes) {
        cout << prime << " ";
    }
    cout << endl;

    return 0;
}
```

This program takes an integer `n` as input and prints all prime numbers less than or equal to `n`. The `sieveOfEratosthenes` function generates all prime numbers up to `n` using the Sieve of Eratosthenes algorithm.

Here's a brief overview of the algorithm:

1. Create a boolean array `prime[0..n]` and initialize all entries as `true`. This array will store whether a number is prime or not.
2. Iterate through all numbers from 2 to the square root of `n`. For each number `p`:
   - If `prime[p]` is `true`, then `p` is prime. Update all multiples of `p` as not prime.
3. Store all prime numbers in a separate vector and return it.

This algorithm has a time complexity of O(n log log n), which makes it quite efficient for finding prime numbers.

### 1. Algorithms & Data Structures (C++): Finding Roots

In computer science, finding roots of equations is a fundamental problem. The most common methods for finding roots include:

1. **Bisection Method**: This is a simple numerical method to find a root within a given interval. It relies on the intermediate value theorem, which states that if a continuous function has different signs at two points in an interval, then it has at least one root in that interval.

2. **Newton-Raphson Method**: Also known as the Newton's method, it is an iterative numerical method for finding roots of a differentiable function. It starts with an initial guess and iteratively improves the guess until a sufficiently accurate solution is reached.

3. **Secant Method**: Similar to the Newton-Raphson method, the secant method is another iterative method for finding roots of a function. Instead of using the derivative of the function like Newton's method, it approximates the derivative using the slope of a secant line.

4. **Root-finding Algorithms in Libraries**: Many libraries like the GNU Scientific Library (GSL) or the Boost C++ Libraries provide implementations of various root-finding algorithms, including those mentioned above.

Here's a simple implementation of the bisection method in C++:

```cpp
#include <iostream>
#include <cmath>

double func(double x) {
    // Define your function here
    return x * x - 4; // Example: f(x) = x^2 - 4
}

double bisection(double a, double b, double tol) {
    if (func(a) * func(b) >= 0) {
        std::cout << "Bisection method cannot guarantee convergence for the given interval." << std::endl;
        return 0.0;
    }

    double c = a;
    while ((b - a) >= tol) {
        // Find the midpoint
        c = (a + b) / 2;
        
        // Check if the midpoint is the root
        if (func(c) == 0.0)
            break;

        // Decide the side to repeat the steps
        if (func(c) * func(a) < 0)
            b = c;
        else
            a = c;
    }
    return c;
}

int main() {
    double a = 0.0; // Left endpoint of the interval
    double b = 3.0; // Right endpoint of the interval
    double tolerance = 0.0001; // Tolerance for convergence

    double root = bisection(a, b, tolerance);

    std::cout << "Root: " << root << std::endl;
    return 0;
}
```

Remember to replace the `func` function with the function you want to find the root for. Also, ensure that the initial interval `[a, b]` contains only one root of the function.

### 1. Algorithms & Data Structures (C++): Finding Subsequences

Finding subsequences of a given sequence is a fundamental problem in computer science and is often used in various applications such as string matching, text processing, and bioinformatics. In C++, you can implement algorithms to find subsequences efficiently using techniques like recursion, dynamic programming, or bitwise operations. Here's a simple example using recursion:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Function to find all subsequences of a given string
void findSubsequences(string s, int index, string current, vector<string>& subsequences) {
    // Base case: when we reach the end of the string
    if (index == s.length()) {
        if (!current.empty()) // Ensure current subsequence is not empty
            subsequences.push_back(current); // Add current subsequence to the result
        return;
    }

    // Two cases for each character in the string: include it in the subsequence or skip it
    // Case 1: include the current character
    findSubsequences(s, index + 1, current + s[index], subsequences);
    // Case 2: skip the current character
    findSubsequences(s, index + 1, current, subsequences);
}

int main() {
    string input = "abc";
    vector<string> subsequences;
    findSubsequences(input, 0, "", subsequences);

    // Displaying the subsequences
    cout << "Subsequences of '" << input << "':" << endl;
    for (const string& subseq : subsequences) {
        cout << subseq << endl;
    }

    return 0;
}
```

This code recursively generates all possible subsequences of a given string. It explores two possibilities for each character in the string: either include it in the current subsequence or skip it. The base case is when we reach the end of the string, at which point we add the current subsequence to the result.

This implementation has an exponential time complexity of O(2^n), where n is the length of the input string, because there are 2^n possible subsequences for a string of length n. However, this can be optimized further using dynamic programming or other techniques to achieve better time complexity.

### 1. Algorithms & Data Structures (C++): Finding Subsets

Sure, finding subsets of a set is a common problem in computer science and can be solved using various algorithms. One common approach is to use a recursive algorithm to generate all possible subsets. Here's a simple C++ code snippet to achieve this:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Function to generate all subsets of a set
void generateSubsets(vector<int>& nums, vector<int>& subset, int index, vector<vector<int>>& subsets) {
    // Add the current subset to the list of subsets
    subsets.push_back(subset);

    // Iterate through the remaining elements
    for (int i = index; i < nums.size(); ++i) {
        // Include the current element in the subset
        subset.push_back(nums[i]);

        // Recursively generate subsets including the current element
        generateSubsets(nums, subset, i + 1, subsets);

        // Exclude the current element from the subset (backtrack)
        subset.pop_back();
    }
}

// Function to print all subsets
void printSubsets(vector<vector<int>>& subsets) {
    cout << "All subsets:\n";
    for (const auto& subset : subsets) {
        cout << "{ ";
        for (int num : subset) {
            cout << num << " ";
        }
        cout << "}\n";
    }
}

int main() {
    vector<int> nums = {1, 2, 3};
    vector<vector<int>> subsets;
    vector<int> subset;

    // Generate subsets
    generateSubsets(nums, subset, 0, subsets);

    // Print subsets
    printSubsets(subsets);

    return 0;
}
```

In this code:

- The `generateSubsets` function recursively generates all subsets of the input set `nums`. It takes parameters:
  - `nums`: the original set of numbers.
  - `subset`: the current subset being generated.
  - `index`: the current index in the set `nums`.
  - `subsets`: the vector of vectors to store all generated subsets.
- The `printSubsets` function simply prints all subsets.
- In the `main` function, we define a set of numbers `nums`, an empty subset `subset`, and an empty vector `subsets` to store all subsets. Then we call `generateSubsets` to populate `subsets`, followed by printing all subsets using `printSubsets`.

This code will generate and print all possible subsets of the set {1, 2, 3}. You can modify it as needed to work with different types of sets or to perform other operations on the subsets.

### 1. Algorithms & Data Structures (C++): Fizz Buzz

Sure! FizzBuzz is a classic programming problem often used in interviews to test basic programming skills. The task is to write a program that prints the numbers from 1 to N. But for multiples of 3, print "Fizz" instead of the number, and for the multiples of 5, print "Buzz". For numbers which are multiples of both 3 and 5, print "FizzBuzz". Here's a simple implementation in C++:

```cpp
#include <iostream>

void fizzBuzz(int n) {
    for (int i = 1; i <= n; ++i) {
        if (i % 3 == 0 && i % 5 == 0) {
            std::cout << "FizzBuzz" << std::endl;
        } else if (i % 3 == 0) {
            std::cout << "Fizz" << std::endl;
        } else if (i % 5 == 0) {
            std::cout << "Buzz" << std::endl;
        } else {
            std::cout << i << std::endl;
        }
    }
}

int main() {
    int n;
    std::cout << "Enter a number: ";
    std::cin >> n;
    fizzBuzz(n);
    return 0;
}
```

This program takes an integer input `n` from the user and prints Fizz, Buzz, or FizzBuzz accordingly for each number from 1 to `n`.

### 1. Algorithms & Data Structures (C++): FizzBuzz

Sure, FizzBuzz is a classic programming problem. It's often used as a simple exercise in programming interviews to demonstrate basic loop control and conditional statements. The problem is as follows:

Write a program that prints the numbers from 1 to n. But for multiples of three, print "Fizz" instead of the number, and for the multiples of five, print "Buzz". For numbers which are multiples of both three and five, print "FizzBuzz".

Here's a simple implementation in C++:

```cpp
#include <iostream>

void fizzBuzz(int n) {
    for (int i = 1; i <= n; ++i) {
        if (i % 3 == 0 && i % 5 == 0) {
            std::cout << "FizzBuzz ";
        } else if (i % 3 == 0) {
            std::cout << "Fizz ";
        } else if (i % 5 == 0) {
            std::cout << "Buzz ";
        } else {
            std::cout << i << " ";
        }
    }
}

int main() {
    int n;
    std::cout << "Enter a number: ";
    std::cin >> n;
    fizzBuzz(n);
    return 0;
}
```

This program defines a function `fizzBuzz()` that takes an integer `n` as input and prints the FizzBuzz sequence up to `n`. In the `main()` function, it prompts the user to enter a number and then calls the `fizzBuzz()` function with that number.

### 1. Algorithms & Data Structures (C++): Flipping An Image

Sure, flipping an image horizontally or vertically is a common operation in image processing. Here's how you can implement flipping an image in C++:

```cpp
#include <iostream>
#include <vector>

// Function to flip the image horizontally
std::vector<std::vector<int>> flipHorizontal(const std::vector<std::vector<int>>& image) {
    std::vector<std::vector<int>> flippedImage;
    for (const auto& row : image) {
        std::vector<int> flippedRow(row.rbegin(), row.rend());
        flippedImage.push_back(flippedRow);
    }
    return flippedImage;
}

// Function to flip the image vertically
std::vector<std::vector<int>> flipVertical(const std::vector<std::vector<int>>& image) {
    std::vector<std::vector<int>> flippedImage(image.rbegin(), image.rend());
    return flippedImage;
}

// Function to display an image
void displayImage(const std::vector<std::vector<int>>& image) {
    for (const auto& row : image) {
        for (int pixel : row) {
            std::cout << pixel << " ";
        }
        std::cout << std::endl;
    }
}

int main() {
    // Example image
    std::vector<std::vector<int>> image = {{1, 0, 0},
                                            {0, 1, 0},
                                            {0, 0, 1}};

    std::cout << "Original Image:" << std::endl;
    displayImage(image);

    // Flip horizontally
    std::vector<std::vector<int>> flippedHorizontal = flipHorizontal(image);
    std::cout << "Image after horizontal flip:" << std::endl;
    displayImage(flippedHorizontal);

    // Flip vertically
    std::vector<std::vector<int>> flippedVertical = flipVertical(image);
    std::cout << "Image after vertical flip:" << std::endl;
    displayImage(flippedVertical);

    return 0;
}
```

This code defines two functions: `flipHorizontal` and `flipVertical`, which take an input image represented as a 2D vector of integers, and return a new image after flipping it horizontally or vertically, respectively. Then there's a `displayImage` function to print out the images, and finally, the `main` function demonstrates how to use these functions with a sample image.

### 1. Algorithms & Data Structures (C++): Flipping Coins

Flipping Coins is a classic problem in algorithms and data structures where you're given a sequence of coins, each showing either heads (H) or tails (T). The task is to perform a series of operations on this sequence. Each operation involves flipping a contiguous segment of coins.

Here's a general approach to solve this problem:

1. **Representation**: Represent the sequence of coins using an array or a linked list. You can use a simple boolean array to represent heads and tails, where true represents heads and false represents tails.

2. **Perform Operations**: You'll need to perform a series of operations on this sequence. Each operation involves flipping a contiguous segment of coins. You can iterate through the sequence and flip the coins accordingly.

3. **Handling Flips**: When flipping a segment of coins, you can simply iterate through that segment and toggle the value of each coin (i.e., if it's heads, make it tails, and vice versa). This can be efficiently done using a loop.

4. **Optimization**: You might want to optimize the flipping process. Instead of actually flipping the coins one by one, you can keep track of the number of flips performed on each coin and deduce its final state based on that. This can help in reducing the time complexity.

5. **Time Complexity**: Analyze the time complexity of your algorithm. The straightforward approach would involve iterating through each operation and each coin in the worst case, resulting in O(N * M) time complexity, where N is the number of coins and M is the number of operations. However, optimizations can reduce this complexity.

Here's a simple pseudo-code illustrating the algorithm:

```plaintext
function flipCoins(coins, operations):
    for each operation in operations:
        start = operation.start
        end = operation.end
        // Flip the coins in the specified segment
        for i from start to end:
            coins[i] = !coins[i]

// Example operation representation
class Operation:
    int start
    int end

// Example usage
coins = [H, T, H, H, T, T, H]
operations = [Operation(1, 3), Operation(2, 5)]
flipCoins(coins, operations)
```

This pseudo-code flips the specified segments of coins as per the given operations. You can implement this in C++ by translating the logic into appropriate C++ syntax.

### 1. Algorithms & Data Structures (C++): Flowers using segment tree

Sure! Here's an example of implementing a segment tree in C++ to solve a problem related to flowers:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Node structure for the segment tree
struct Node {
    int sum; // Sum of values in the segment
};

// Function to build the segment tree
void buildSegmentTree(vector<int>& arr, vector<Node>& segmentTree, int low, int high, int pos) {
    if (low == high) {
        segmentTree[pos].sum = arr[low];
        return;
    }

    int mid = (low + high) / 2;
    buildSegmentTree(arr, segmentTree, low, mid, 2 * pos + 1);
    buildSegmentTree(arr, segmentTree, mid + 1, high, 2 * pos + 2);
    
    segmentTree[pos].sum = segmentTree[2 * pos + 1].sum + segmentTree[2 * pos + 2].sum;
}

// Function to update a value in the segment tree
void updateSegmentTree(vector<Node>& segmentTree, int idx, int newVal, int low, int high, int pos) {
    if (low == high) {
        segmentTree[pos].sum = newVal;
        return;
    }

    int mid = (low + high) / 2;
    if (idx <= mid)
        updateSegmentTree(segmentTree, idx, newVal, low, mid, 2 * pos + 1);
    else
        updateSegmentTree(segmentTree, idx, newVal, mid + 1, high, 2 * pos + 2);

    segmentTree[pos].sum = segmentTree[2 * pos + 1].sum + segmentTree[2 * pos + 2].sum;
}

// Function to query the sum in a range
int query(vector<Node>& segmentTree, int qlow, int qhigh, int low, int high, int pos) {
    // Total overlap
    if (qlow <= low && qhigh >= high)
        return segmentTree[pos].sum;

    // No overlap
    if (qlow > high || qhigh < low)
        return 0;

    // Partial overlap
    int mid = (low + high) / 2;
    return query(segmentTree, qlow, qhigh, low, mid, 2 * pos + 1) +
           query(segmentTree, qlow, qhigh, mid + 1, high, 2 * pos + 2);
}

int main() {
    // Example usage
    vector<int> arr = {2, 4, 1, 7, 3, 9, 6, 5};
    int n = arr.size();

    // Size of segment tree array
    int segTreeSize = 2 * n - 1;

    // Initialize segment tree
    vector<Node> segmentTree(segTreeSize);

    // Build segment tree
    buildSegmentTree(arr, segmentTree, 0, n - 1, 0);

    // Query example
    int sum = query(segmentTree, 1, 4, 0, n - 1, 0);
    cout << "Sum of elements in range [1, 4]: " << sum << endl;

    // Update example
    updateSegmentTree(segmentTree, 2, 5, 0, n - 1, 0);
    sum = query(segmentTree, 1, 4, 0, n - 1, 0);
    cout << "Updated sum of elements in range [1, 4]: " << sum << endl;

    return 0;
}
```

This code demonstrates how to build a segment tree from an array of values and perform range sum queries efficiently. You can modify the `Node` structure and the operations within the functions to fit different requirements or problems.

### 1. Algorithms & Data Structures (C++): Flowers using segment tree

Sure! Here's an example of implementing a segment tree in C++ to solve a problem related to flowers:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Node structure for the segment tree
struct Node {
    int sum; // Sum of values in the segment
};

// Function to build the segment tree
void buildSegmentTree(vector<int>& arr, vector<Node>& segmentTree, int low, int high, int pos) {
    if (low == high) {
        segmentTree[pos].sum = arr[low];
        return;
    }

    int mid = (low + high) / 2;
    buildSegmentTree(arr, segmentTree, low, mid, 2 * pos + 1);
    buildSegmentTree(arr, segmentTree, mid + 1, high, 2 * pos + 2);
    
    segmentTree[pos].sum = segmentTree[2 * pos + 1].sum + segmentTree[2 * pos + 2].sum;
}

// Function to update a value in the segment tree
void updateSegmentTree(vector<Node>& segmentTree, int idx, int newVal, int low, int high, int pos) {
    if (low == high) {
        segmentTree[pos].sum = newVal;
        return;
    }

    int mid = (low + high) / 2;
    if (idx <= mid)
        updateSegmentTree(segmentTree, idx, newVal, low, mid, 2 * pos + 1);
    else
        updateSegmentTree(segmentTree, idx, newVal, mid + 1, high, 2 * pos + 2);

    segmentTree[pos].sum = segmentTree[2 * pos + 1].sum + segmentTree[2 * pos + 2].sum;
}

// Function to query the sum in a range
int query(vector<Node>& segmentTree, int qlow, int qhigh, int low, int high, int pos) {
    // Total overlap
    if (qlow <= low && qhigh >= high)
        return segmentTree[pos].sum;

    // No overlap
    if (qlow > high || qhigh < low)
        return 0;

    // Partial overlap
    int mid = (low + high) / 2;
    return query(segmentTree, qlow, qhigh, low, mid, 2 * pos + 1) +
           query(segmentTree, qlow, qhigh, mid + 1, high, 2 * pos + 2);
}

int main() {
    // Example usage
    vector<int> arr = {2, 4, 1, 7, 3, 9, 6, 5};
    int n = arr.size();

    // Size of segment tree array
    int segTreeSize = 2 * n - 1;

    // Initialize segment tree
    vector<Node> segmentTree(segTreeSize);

    // Build segment tree
    buildSegmentTree(arr, segmentTree, 0, n - 1, 0);

    // Query example
    int sum = query(segmentTree, 1, 4, 0, n - 1, 0);
    cout << "Sum of elements in range [1, 4]: " << sum << endl;

    // Update example
    updateSegmentTree(segmentTree, 2, 5, 0, n - 1, 0);
    sum = query(segmentTree, 1, 4, 0, n - 1, 0);
    cout << "Updated sum of elements in range [1, 4]: " << sum << endl;

    return 0;
}
```

This code demonstrates how to build a segment tree from an array of values and perform range sum queries efficiently. You can modify the `Node` structure and the operations within the functions to fit different requirements or problems.

### 1. Algorithms & Data Structures (C++): Fractional Knapsack Problem

The Fractional Knapsack Problem is a classic optimization problem in computer science and algorithms. It's a variation of the Knapsack Problem, where instead of needing to choose whole items, you can take fractions of items to maximize the total value while not exceeding the capacity of the knapsack.

Here's how it typically works:

1. **Input**: You're given a set of items, each with a weight \( w_i \) and a value \( v_i \), and a knapsack with a maximum weight capacity, \( W \).

2. **Objective**: The goal is to fill the knapsack with items to maximize the total value, while ensuring that the total weight does not exceed \( W \).

3. **Approach**: Unlike the 0/1 Knapsack Problem, where you can either take an item completely or not at all, in the Fractional Knapsack Problem, you can take fractions of items.

Here's a basic approach using a greedy algorithm:

1. **Calculate the value-to-weight ratio** for each item.
2. **Sort the items** based on this ratio in non-increasing order.
3. **Take items in order of decreasing ratio**, adding them to the knapsack until it's full.
4. If the knapsack isn't full but the items are exhausted, take fractions of the last item to fill the knapsack to its capacity.

Here's a simple C++ implementation of this approach:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct Item {
    int value;
    int weight;
    double valuePerWeight; // Value per unit weight
};

bool compare(Item i1, Item i2) {
    return i1.valuePerWeight > i2.valuePerWeight;
}

double fractionalKnapsack(int W, vector<Item>& items) {
    sort(items.begin(), items.end(), compare);

    double totalValue = 0.0;
    int currentWeight = 0;

    for (const Item& item : items) {
        if (currentWeight + item.weight <= W) {
            // Take the whole item
            totalValue += item.value;
            currentWeight += item.weight;
        } else {
            // Take a fraction of the item
            double remainingWeight = W - currentWeight;
            totalValue += (remainingWeight / item.weight) * item.value;
            break; // Knapsack full
        }
    }

    return totalValue;
}

int main() {
    int W = 50; // Knapsack capacity
    vector<Item> items = {{60, 10}, {100, 20}, {120, 30}}; // value, weight pairs

    double maxValue = fractionalKnapsack(W, items);
    cout << "Maximum value in Knapsack = " << maxValue << endl;

    return 0;
}
```

This code defines a struct `Item` to represent items with their value, weight, and value-to-weight ratio. Then, it sorts the items based on this ratio and iterates over them, adding items to the knapsack until it's full. If the knapsack isn't full but the items are exhausted, it takes a fraction of the last item to fill the knapsack to its capacity.

### 1. Algorithms & Data Structures (C++): Frequency Count

Frequency count is a common operation in algorithms and data structures where you count the occurrences of each element in a data structure, such as an array or a linked list. In C++, you can implement a frequency count using various data structures like arrays, hash maps, or binary search trees, depending on the requirements and characteristics of the data.

Here's a basic example of how you can implement frequency count using an `std::map` in C++:

```cpp
#include <iostream>
#include <map>
#include <vector>

// Function to count frequencies of elements in a vector
std::map<int, int> countFrequency(const std::vector<int>& arr) {
    std::map<int, int> frequencyMap;
    
    for (int elem : arr) {
        // If the element is already present in the map, increment its count
        if (frequencyMap.find(elem) != frequencyMap.end()) {
            frequencyMap[elem]++;
        } else {
            // Otherwise, add the element to the map with count 1
            frequencyMap[elem] = 1;
        }
    }
    
    return frequencyMap;
}

int main() {
    std::vector<int> arr = {1, 2, 3, 4, 1, 2, 2, 3, 4, 5, 3, 3};
    
    // Count frequencies of elements
    std::map<int, int> frequencyMap = countFrequency(arr);
    
    // Print frequencies
    for (const auto& pair : frequencyMap) {
        std::cout << "Element: " << pair.first << ", Frequency: " << pair.second << std::endl;
    }
    
    return 0;
}
```

This program first defines a function `countFrequency` which takes a vector of integers and returns a map where keys represent unique elements in the vector and values represent the frequency of each element. Then, in the `main` function, it demonstrates how to use this function to count frequencies of elements in a sample array.

This implementation has a time complexity of O(n log n), where n is the number of elements in the input array, due to the insertion and lookup operations in the map. If you know that the elements have a limited range (for example, they are integers within a certain range), you can use an array instead of a map for better performance.

### 1. Algorithms & Data Structures (C++): Friend's Pairing Problem

The "Friend's Pairing Problem" is a classic problem in combinatorial mathematics and can be solved using dynamic programming. The problem statement typically goes like this:

Suppose you have \( n \) friends who want to go to a party on bikes. Each friend can either go alone on one bike or pair up with another friend on one bike. Your task is to find the number of ways in which friends can go to the party.

The recursive formula for this problem can be defined as follows:

\[ \text{ways}(n) = \text{ways}(n-1) + (n-1) \times \text{ways}(n-2) \]

Here, \(\text{ways}(n-1)\) represents the number of ways when the last friend goes alone, and \((n-1) \times \text{ways}(n-2)\) represents the number of ways when the last friend pairs up with any one of the \(n-1\) remaining friends.

Here's how you can implement this in C++:

```cpp
#include <iostream>
using namespace std;

int countWays(int n) {
    if (n <= 2)
        return n;
    
    int a = 1, b = 2, temp;
    for (int i = 3; i <= n; i++) {
        temp = b;
        b = b + (i - 1) * a;
        a = temp;
    }
    return b;
}

int main() {
    int n;
    cout << "Enter the number of friends: ";
    cin >> n;
    cout << "Number of ways friends can go to the party: " << countWays(n) << endl;
    return 0;
}
```

In this code, the `countWays` function calculates the number of ways the friends can go to the party using dynamic programming. The main function takes the number of friends as input and prints the result.

This solution has a time complexity of O(n) and a space complexity of O(1).

### 1. Algorithms & Data Structures (C++): Friends pairing Problem

The "Friends Pairing Problem" is a classic problem in combinatorial mathematics and computer science. The problem can be stated as follows:

Suppose you have n friends, and you want to pair them up such that each person is either paired with another person or remains unpaired. Your task is to count the total number of ways in which you can form such pairs.

Here's a C++ implementation of the solution using dynamic programming:

```cpp
#include <iostream>
using namespace std;

// Function to count the number of ways to pair friends
int countWays(int n) {
    // Base cases
    if (n <= 2)
        return n;

    // Create a table to store results of subproblems
    int dp[n + 1];

    // Initialize table with base cases
    dp[0] = 0;
    dp[1] = 1;
    dp[2] = 2;

    // Fill the rest of the table using recursive formula
    for (int i = 3; i <= n; i++)
        dp[i] = dp[i - 1] + (i - 1) * dp[i - 2];

    return dp[n];
}

int main() {
    int n;
    cout << "Enter the number of friends: ";
    cin >> n;
    cout << "Total number of ways to pair up friends: " << countWays(n) << endl;
    return 0;
}
```

This code uses dynamic programming to solve the problem efficiently. The function `countWays` calculates the number of ways to pair up friends using a bottom-up approach, and `main` function takes input from the user and displays the result.

The time complexity of this solution is O(n) and the space complexity is O(n), where n is the number of friends.

### 1. Algorithms & Data Structures (C++): Frog Jump 2 (AtCoder)

The "Frog Jump 2" problem on AtCoder is a dynamic programming problem that asks you to find the minimum cost to reach the end of an array of stones, where each stone has a cost associated with it, and you can jump at most K steps at a time.

Here's the problem statement and a solution approach in C++:

#### Problem Statement

You are given an array `h` of length `n`, where `h[i]` represents the height of the `i-th` stone. You are also given an integer `K`. Initially, you are at the first stone (i.e., at position `0`).

You want to reach the last stone (position `n-1`). You can jump from `i-th` stone to `(i+j)-th` stone if and only if `1 <= j <= K`. When you jump from `i-th` stone to `(i+j)-th` stone, the cost of the jump will be `(h[i] - h[i+j])^2`.

You need to minimize the total cost to reach the last stone.

#### Solution Approach (Dynamic Programming)

This problem can be solved using dynamic programming. We can define `dp[i]` as the minimum cost to reach the `i-th` stone. Then, `dp[i]` can be calculated as the minimum of costs of jumping from the previous stones within the range of `K`.

Here's the C++ code implementing this approach:

```cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <climits>

using namespace std;

int main() {
    int n, k;
    cin >> n >> k;
    
    vector<int> h(n);
    for (int i = 0; i < n; ++i) {
        cin >> h[i];
    }
    
    vector<int> dp(n, INT_MAX);
    dp[0] = 0; // Cost to reach the first stone is 0
    
    for (int i = 1; i < n; ++i) {
        for (int j = 1; j <= k && i - j >= 0; ++j) {
            dp[i] = min(dp[i], dp[i - j] + (h[i] - h[i - j]) * (h[i] - h[i - j]));
        }
    }
    
    cout << dp[n - 1] << endl;
    
    return 0;
}
```

This code reads the input, computes the minimum cost using dynamic programming, and outputs the minimum cost required to reach the last stone.

### 1. Algorithms & Data Structures (C++): Frog's Min Cost-I

Sure, the problem you're referring to seems like a variation of the classic "frog jumping" problem, where a frog wants to cross a river by jumping on stones in the river. Each stone has a cost associated with it, and the frog wants to minimize the total cost of reaching the other side.

Here's a simple dynamic programming approach in C++ to solve this problem:

```cpp
#include <iostream>
#include <vector>
#include <limits>

using namespace std;

int minCost(vector<int>& stones, int k) {
    int n = stones.size();
    vector<int> dp(n, numeric_limits<int>::max()); // dp[i] stores the minimum cost to reach stone i
    dp[0] = 0; // Base case: minimum cost to reach the first stone is 0
    
    for (int i = 0; i < n; ++i) {
        for (int j = i + 1; j < n && stones[j] - stones[i] <= k; ++j) {
            dp[j] = min(dp[j], dp[i] + abs(stones[j] - stones[i]));
        }
    }
    
    return dp[n - 1]; // Return the minimum cost to reach the last stone
}

int main() {
    vector<int> stones = {0, 1, 3, 5, 6, 8, 12, 17}; // Example stones positions
    int k = 3; // Maximum jump distance
    
    cout << "Minimum cost to cross the river: " << minCost(stones, k) << endl;
    
    return 0;
}
```

This code defines a function `minCost` that takes a vector of stones positions and the maximum jump distance `k` as input and returns the minimum cost to cross the river.

Explanation:

- We initialize a dynamic programming array `dp` of size `n`, where `n` is the number of stones. Each element `dp[i]` stores the minimum cost to reach stone `i`.
- We iterate over each stone and for each stone, we try to jump to all the stones reachable within distance `k`. We update the minimum cost to reach those stones if it is less than the previous minimum cost.
- Finally, we return `dp[n-1]`, which represents the minimum cost to reach the last stone.

This algorithm has a time complexity of O(n^2), where n is the number of stones.

### 1. Algorithms & Data Structures (C++): Frogs

In computer science, the "Frogs" problem is a classic puzzle often used to demonstrate concepts in algorithms and data structures, particularly recursion and backtracking. The problem is as follows:

You have a row of N lily pads, labeled from 1 to N, where each pad can either be empty or occupied by a frog. The frogs are of two types: green frogs, denoted by 'G', and brown frogs, denoted by 'B'. Frogs of the same type are indistinguishable from each other.

The goal is to rearrange the frogs so that all the green frogs are on the left side of all the brown frogs. However, frogs can only move by jumping over another frog to an empty lily pad. A frog can only jump to an adjacent empty pad, either to the left or to the right. Frogs cannot jump over other frogs of the same color.

For example, given a row of lily pads like this: "BGBGBGB", one possible solution would be to rearrange the frogs as "GGGBBBB" by making the following moves:

1. The first green frog jumps one step to the right.
2. The second green frog jumps two steps to the right.
3. The third green frog jumps one step to the right.

Now, all green frogs are on the left side, and all brown frogs are on the right side.

To solve this problem, various algorithms and data structures can be employed, such as recursive backtracking, dynamic programming, or even greedy algorithms, depending on the constraints and requirements of the problem.

Would you like to dive deeper into any specific aspect of this problem?

### 1. Algorithms & Data Structures (C++): From N given numbers Find Prime Numbers

To find prime numbers among N given numbers in C++, you can use the Sieve of Eratosthenes algorithm, which efficiently identifies prime numbers within a given range. Here's how you can implement it:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Function to find prime numbers using Sieve of Eratosthenes
vector<int> findPrimes(int N) {
    vector<bool> isPrime(N + 1, true); // Initialize all numbers as prime
    vector<int> primes;

    isPrime[0] = isPrime[1] = false; // 0 and 1 are not prime

    // Mark multiples of primes starting from 2
    for (int i = 2; i * i <= N; ++i) {
        if (isPrime[i]) {
            // Mark all multiples of i as not prime
            for (int j = i * i; j <= N; j += i) {
                isPrime[j] = false;
            }
        }
    }

    // Collect all prime numbers
    for (int i = 2; i <= N; ++i) {
        if (isPrime[i]) {
            primes.push_back(i);
        }
    }

    return primes;
}

int main() {
    int N;
    cout << "Enter the number of elements: ";
    cin >> N;

    vector<int> numbers(N);
    cout << "Enter the numbers:\n";
    for (int i = 0; i < N; ++i) {
        cin >> numbers[i];
    }

    vector<int> primeNumbers = findPrimes(*max_element(numbers.begin(), numbers.end()));

    cout << "Prime numbers among the given numbers are: ";
    for (int num : numbers) {
        if (binary_search(primeNumbers.begin(), primeNumbers.end(), num)) {
            cout << num << " ";
        }
    }
    cout << endl;

    return 0;
}
```

In this code:

- The `findPrimes` function implements the Sieve of Eratosthenes algorithm to generate all prime numbers up to a given limit.
- In the `main` function, it takes input for the number of elements and the numbers themselves.
- It then finds all prime numbers up to the maximum of the given numbers using the `findPrimes` function.
- Finally, it prints out the prime numbers among the given set of numbers.

### 1. Algorithms & Data Structures (C++): Full & Complete Binary Trees - Interview Question - Number Of Nodes In Complete Tree

To find the number of nodes in a complete binary tree, we can use a formula. A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.

Let's denote:

- \( h \) as the height of the tree (the number of levels)
- \( n \) as the number of nodes in the complete binary tree

In a complete binary tree:

- The last level might not be completely filled, but it's filled from left to right.
- The total number of nodes in a complete binary tree with height \( h \) is \( 2^h - 1 \).

Here's how you can calculate the number of nodes in a complete binary tree in C++:

```cpp
#include <iostream>
#include <cmath>

// Function to calculate the number of nodes in a complete binary tree
int numberOfNodesInCompleteTree(int height) {
    return (int)pow(2, height) - 1;
}

int main() {
    int height;
    std::cout << "Enter the height of the complete binary tree: ";
    std::cin >> height;

    int nodes = numberOfNodesInCompleteTree(height);
    std::cout << "Number of nodes in the complete binary tree: " << nodes << std::endl;

    return 0;
}
```

You can use this code to find the number of nodes in a complete binary tree by providing its height.

### 1. Algorithms & Data Structures (C++): Game of Coins

The Game of Coins is a classic algorithmic problem where two players take turns removing coins from a pile. The game is played with a pile of n coins, and on each turn, a player can remove either 1, 2, or 3 coins from the pile. The player who removes the last coin wins the game.

Here's a simple implementation of the Game of Coins in C++:

```cpp
#include <iostream>

using namespace std;

// Function to determine the winner of the game
string findWinner(int n) {
    // If the number of coins is divisible by 4, the first player loses
    if (n % 4 == 0)
        return "Second Player";
    else
        return "First Player";
}

int main() {
    int n;
    cout << "Enter the number of coins in the pile: ";
    cin >> n;

    string winner = findWinner(n);
    cout << "The winner is: " << winner << endl;

    return 0;
}
```

In this implementation, we have a function `findWinner` that takes the number of coins in the pile as input and returns the name of the winner. The logic is simple: if the number of coins is divisible by 4, the first player will lose the game; otherwise, the first player will win.

You can test this code by entering the number of coins in the pile, and it will output the winner of the game according to the specified rules.

### 1. Algorithms & Data Structures (C++): Game of Nim

The Game of Nim is a classic two-player game that involves removing objects (such as stones or matchsticks) from piles. The game is typically played with heaps of objects, and players take turns removing any number of objects from a single heap. The player who removes the last object wins.

Here's a simple implementation of the Game of Nim in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Function to display the current state of heaps
void displayHeaps(const vector<int>& heaps) {
    cout << "Current heaps: ";
    for (int i = 0; i < heaps.size(); ++i) {
        cout << "Heap " << i + 1 << ": " << heaps[i] << " ";
    }
    cout << endl;
}

// Function to check if the game is over (all heaps are empty)
bool gameOver(const vector<int>& heaps) {
    for (int heap : heaps) {
        if (heap != 0)
            return false;
    }
    return true;
}

// Function to check if a move is valid
bool isValidMove(const vector<int>& heaps, int heapIndex, int objects) {
    if (heapIndex < 0 || heapIndex >= heaps.size() || heaps[heapIndex] < objects)
        return false;
    return true;
}

// Function to perform a move
void makeMove(vector<int>& heaps, int heapIndex, int objects) {
    heaps[heapIndex] -= objects;
}

// Function to determine the winning move for the computer player
void computerMove(vector<int>& heaps) {
    // Simple strategy: take one object from the first non-empty heap
    for (int i = 0; i < heaps.size(); ++i) {
        if (heaps[i] > 0) {
            cout << "Computer removes " << 1 << " object(s) from Heap " << i + 1 << endl;
            makeMove(heaps, i, 1);
            return;
        }
    }
}

int main() {
    int heapCount;
    cout << "Enter the number of heaps: ";
    cin >> heapCount;

    vector<int> heaps(heapCount);

    for (int i = 0; i < heapCount; ++i) {
        cout << "Enter the number of objects in Heap " << i + 1 << ": ";
        cin >> heaps[i];
    }

    displayHeaps(heaps);

    bool playerTurn = true; // Player starts

    while (!gameOver(heaps)) {
        if (playerTurn) {
            cout << "Your turn:" << endl;
            int heapIndex, objects;
            cout << "Enter the heap index and number of objects to remove: ";
            cin >> heapIndex >> objects;

            if (isValidMove(heaps, heapIndex - 1, objects)) {
                makeMove(heaps, heapIndex - 1, objects);
                displayHeaps(heaps);
                playerTurn = false;
            } else {
                cout << "Invalid move. Try again." << endl;
            }
        } else {
            cout << "Computer's turn:" << endl;
            computerMove(heaps);
            displayHeaps(heaps);
            playerTurn = true;
        }
    }

    if (playerTurn) {
        cout << "You win!" << endl;
    } else {
        cout << "Computer wins!" << endl;
    }

    return 0;
}
```

This implementation allows the player to play against the computer. The computer's strategy is simple: it always removes one object from the first non-empty heap. You can enhance the computer's strategy to make it more challenging if desired.

### 1. Algorithms & Data Structures (C++): Game Routes

"Game Routes" is a classic dynamic programming problem. In this problem, you're given a game with several levels, each connected by a directed edge. You need to find the number of different ways to reach the final level starting from the first level, given that you can only move to the next level if it's connected by an edge.

Here's a high-level approach to solve this problem:

1. **Input Parsing**: Parse the input to build a graph representing the connections between levels.

2. **Dynamic Programming**: Use dynamic programming to calculate the number of ways to reach each level. You start with 1 way to reach the first level (the base case), and then recursively calculate the number of ways to reach each subsequent level based on the number of ways to reach its incoming connected levels.

3. **Topological Sorting**: If the levels are not already sorted topologically, you may need to perform a topological sort to ensure that you're processing levels in the correct order.

4. **Counting**: Once you've calculated the number of ways to reach the final level, output the result.

Here's a pseudocode implementation:

```plaintext
function countPaths(graph):
    n = number of levels
    paths = array of size n initialized with 0
    paths[0] = 1  // Base case: There's one way to reach the first level

    for each level in topologically sorted order:
        for each neighbor of level:
            paths[level] += paths[neighbor]

    return paths[n-1]

function topologicalSort(graph):
    // Perform topological sort using DFS or Kahn's algorithm

// Main function
function gameRoutes(levels, edges):
    graph = buildGraph(levels, edges)
    sortedLevels = topologicalSort(graph)
    return countPaths(graph)
```

In C++, you would implement functions like `buildGraph`, `topologicalSort`, and `countPaths` accordingly. You can represent the graph using an adjacency list or an adjacency matrix.

Here's a C++ implementation using adjacency lists:

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

typedef vector<vector<int>> Graph;

int countPaths(const Graph& graph) {
    int n = graph.size();
    vector<long long> paths(n, 0); // Using long long to avoid overflow
    paths[0] = 1;

    for (int i = 0; i < n; ++i) {
        for (int j : graph[i]) {
            paths[j] += paths[i];
            paths[j] %= 1000000007; // Modulo to avoid overflow
        }
    }

    return paths[n-1];
}

// Perform topological sort using DFS
void dfs(int node, const Graph& graph, vector<bool>& visited, vector<int>& sorted) {
    visited[node] = true;
    for (int neighbor : graph[node]) {
        if (!visited[neighbor]) {
            dfs(neighbor, graph, visited, sorted);
        }
    }
    sorted.push_back(node);
}

vector<int> topologicalSort(const Graph& graph) {
    int n = graph.size();
    vector<bool> visited(n, false);
    vector<int> sorted;

    for (int i = 0; i < n; ++i) {
        if (!visited[i]) {
            dfs(i, graph, visited, sorted);
        }
    }

    reverse(sorted.begin(), sorted.end());
    return sorted;
}

Graph buildGraph(int n, const vector<vector<int>>& edges) {
    Graph graph(n);
    for (const auto& edge : edges) {
        int u = edge[0] - 1; // Adjust index
        int v = edge[1] - 1; // Adjust index
        graph[u].push_back(v);
    }
    return graph;
}

int main() {
    int n, m;
    cin >> n >> m;

    vector<vector<int>> edges(m, vector<int>(2));
    for (int i = 0; i < m; ++i) {
        cin >> edges[i][0] >> edges[i][1];
    }

    Graph graph = buildGraph(n, edges);
    int result = countPaths(graph);
    cout << result << endl;

    return 0;
}
```

This implementation uses adjacency lists to represent the graph and performs a topological sort using DFS. The `countPaths` function calculates the number of paths using dynamic programming.

### 1. Algorithms & Data Structures (C++): Generate Brackets

Generating balanced brackets is a classic problem in computer science. Here's a C++ implementation of a recursive algorithm to generate all valid combinations of brackets:

```cpp
#include <iostream>
#include <vector>
#include <string>

using namespace std;

void generateBracketsHelper(vector<string>& result, string current, int open, int close, int n) {
    if (current.length() == 2 * n) {
        result.push_back(current);
        return;
    }
    
    if (open < n) {
        generateBracketsHelper(result, current + "(", open + 1, close, n);
    }
    if (close < open) {
        generateBracketsHelper(result, current + ")", open, close + 1, n);
    }
}

vector<string> generateBrackets(int n) {
    vector<string> result;
    generateBracketsHelper(result, "", 0, 0, n);
    return result;
}

int main() {
    int n = 3; // Number of pairs of brackets
    vector<string> brackets = generateBrackets(n);
    for (const auto& bracket : brackets) {
        cout << bracket << endl;
    }
    return 0;
}
```

This code recursively generates all combinations of brackets by adding an open bracket if there are still remaining to be added, and a closing bracket if it would not violate the balancing condition. The `generateBrackets` function initializes the recursion, and `generateBracketsHelper` is the recursive function that builds up the bracket combinations. Finally, the `main` function demonstrates how to use this function by generating and printing combinations for a given number of bracket pairs.

### 1. Algorithms & Data Structures (C++): Gold mine (problem)

The Gold Mine problem is a classic dynamic programming problem that involves finding the maximum amount of gold that can be collected from a gold mine with a given layout. Here's a brief overview of the problem and a potential solution approach:

#### Problem Statement

You are given a 2D grid representing a gold mine. Each cell in the grid contains a certain amount of gold. You start from the first column and can move to the right, right-up, or right-down. You cannot move up or down directly. Find the maximum amount of gold you can collect.

#### Example

Consider the following grid:

```bash
{ {1, 3, 1, 5},
  {2, 2, 4, 1},
  {5, 0, 2, 3},
  {0, 6, 1, 2} }
```

The maximum amount of gold you can collect in this case is 16 (3 + 2 + 5 + 6).

#### Solution Approach

You can solve this problem using dynamic programming. The idea is to start from the last column and move to the first column, calculating the maximum amount of gold that can be collected at each cell. At each cell, you have three possible moves: right, right-up, and right-down. You keep track of the maximum amount of gold that can be collected from each cell, considering the maximum amount of gold that can be collected from the next possible cells.

Here's a high-level algorithm:

1. Create a 2D array `dp` of the same size as the gold mine grid to store the maximum amount of gold that can be collected from each cell.
2. Start from the last column and for each cell in that column, the maximum amount of gold that can be collected is simply the amount of gold in that cell.
3. For each cell in the remaining columns, calculate the maximum amount of gold that can be collected by considering the three possible moves: right, right-up, and right-down.
4. Update the `dp` array accordingly.
5. The maximum amount of gold that can be collected will be the maximum value in the first column of the `dp` array.

Would you like to see a sample code implementation in C++?

### 1. Algorithms & Data Structures (C++): Gold mine (solution)

Sure, let's discuss a classic problem: the Gold Mine Problem. In this problem, you're given a gold mine, and you need to find out the maximum amount of gold you can collect, starting from any position in the first column and moving either right, right-up, or right-down. This problem can be efficiently solved using dynamic programming.

Here's a simple recursive solution followed by its dynamic programming approach:

#### Recursive Approach (Naive)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int MAX_ROWS = 100;
const int MAX_COLS = 100;

int getMaxGoldUtil(vector<vector<int>>& mine, int row, int col) {
    if (row < 0 || row >= mine.size() || col >= mine[0].size())
        return 0;

    int right = getMaxGoldUtil(mine, row, col + 1);
    int right_up = getMaxGoldUtil(mine, row - 1, col + 1);
    int right_down = getMaxGoldUtil(mine, row + 1, col + 1);

    return mine[row][col] + max(right, max(right_up, right_down));
}

int getMaxGold(vector<vector<int>>& mine, int rows, int cols) {
    int max_gold = 0;
    for (int i = 0; i < rows; ++i) {
        max_gold = max(max_gold, getMaxGoldUtil(mine, i, 0));
    }
    return max_gold;
}

int main() {
    int rows, cols;
    cin >> rows >> cols;
    vector<vector<int>> mine(rows, vector<int>(cols));

    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            cin >> mine[i][j];
        }
    }

    cout << "Maximum amount of gold that can be collected: " << getMaxGold(mine, rows, cols) << endl;

    return 0;
}
```

#### Dynamic Programming Approach

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int MAX_ROWS = 100;
const int MAX_COLS = 100;

int getMaxGold(vector<vector<int>>& mine, int rows, int cols) {
    vector<vector<int>> dp(rows, vector<int>(cols));

    // Copying the last column as it is to dp array
    for (int i = 0; i < rows; ++i) {
        dp[i][cols - 1] = mine[i][cols - 1];
    }

    for (int j = cols - 2; j >= 0; --j) {
        for (int i = 0; i < rows; ++i) {
            int right = (i == rows - 1) ? 0 : dp[i + 1][j + 1];
            int right_up = (i == 0) ? 0 : dp[i - 1][j + 1];
            int right_down = dp[i][j + 1];

            dp[i][j] = mine[i][j] + max(right, max(right_up, right_down));
        }
    }

    int max_gold = 0;
    for (int i = 0; i < rows; ++i) {
        max_gold = max(max_gold, dp[i][0]);
    }

    return max_gold;
}

int main() {
    int rows, cols;
    cin >> rows >> cols;
    vector<vector<int>> mine(rows, vector<int>(cols));

    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            cin >> mine[i][j];
        }
    }

    cout << "Maximum amount of gold that can be collected: " << getMaxGold(mine, rows, cols) << endl;

    return 0;
}
```

Both approaches solve the Gold Mine Problem. However, the dynamic programming approach is more efficient because it avoids recomputation of overlapping subproblems.

### 1. Algorithms & Data Structures (C++): Google Array Question: Boats to save people

Certainly! The problem you're referring to is a common algorithmic question often encountered in technical interviews. Here's the problem statement:

#### Problem Statement

You are given an array `people` where `people[i]` is the weight of the `i-th` person, and an integer `limit` representing the maximum weight a boat can carry. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most `limit`.

Return the minimum number of boats to carry every person in `people`.

Note that the given weights of people may not be sorted.

#### Example

```plaintext
Input: people = [1,2], limit = 3
Output: 1
Explanation: 1 boat (1, 2)

Input: people = [3,2,2,1], limit = 3
Output: 3
Explanation: 3 boats (1, 2), (2) and (3)

Input: people = [3,5,3,4], limit = 5
Output: 4
Explanation: 4 boats (3), (3), (4), (5)
```

#### Approach

To solve this problem efficiently, you can use the two-pointer technique. Sort the array first and then try to fit the heaviest person with the lightest person. If the sum of their weights exceeds the limit, only the heaviest person can go in the boat. Move the pointer of the heavier person inward and repeat until both pointers meet. Count the number of boats required during this process.

Here's the implementation in C++:

```cpp
#include <vector>
#include <algorithm>

using namespace std;

int numRescueBoats(vector<int>& people, int limit) {
    sort(people.begin(), people.end());
    int boats = 0;
    int left = 0, right = people.size() - 1;
    
    while (left <= right) {
        if (people[left] + people[right] <= limit) {
            left++;
        }
        right--;
        boats++;
    }
    
    return boats;
}

// Example usage:
int main() {
    vector<int> people1 = {1, 2};
    int limit1 = 3;
    cout << numRescueBoats(people1, limit1) << endl; // Output: 1

    vector<int> people2 = {3, 2, 2, 1};
    int limit2 = 3;
    cout << numRescueBoats(people2, limit2) << endl; // Output: 3

    vector<int> people3 = {3, 5, 3, 4};
    int limit3 = 5;
    cout << numRescueBoats(people3, limit3) << endl; // Output: 4

    return 0;
}
```

This code sorts the `people` array and then uses two pointers to iterate through it. The time complexity of this approach is O(n log n), where n is the number of people.

### 1. Algorithms & Data Structures (C++): Google Array question: first bad version

The "first bad version" problem is a classic algorithmic question commonly asked in technical interviews. The problem is typically presented as follows:

You are given a sorted array of integers where each integer represents a version of a software product. Some of the versions are good, and some are bad. You need to find the first bad version, which is the earliest version in the array that is considered bad. Once a version is bad, all subsequent versions are also bad.

Here's a step-by-step guide to solving this problem in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Sample function to check if a version is bad
bool isBadVersion(int version) {
    // Example implementation
    // For demonstration, let's assume bad versions start from 5
    return version >= 5;
}

int firstBadVersion(int n) {
    int left = 1;
    int right = n;
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (isBadVersion(mid)) {
            // If current version is bad, search in the left half
            right = mid;
        } else {
            // If current version is good, search in the right half
            left = mid + 1;
        }
    }
    
    // At this point, left and right will converge to the first bad version
    return left;
}

int main() {
    int n = 10; // Example array size
    cout << "The first bad version is: " << firstBadVersion(n) << endl;
    return 0;
}
```

In this code:

- We use a binary search approach to efficiently find the first bad version.
- The `firstBadVersion` function takes an integer `n` representing the number of versions.
- It initializes two pointers, `left` and `right`, to keep track of the search range.
- In each iteration of the binary search loop, it calculates the middle version.
- If the middle version is bad, it narrows the search range to the left half. Otherwise, it narrows it to the right half.
- The loop continues until `left` and `right` converge, at which point the first bad version is found.

You can customize the `isBadVersion` function to match the specific logic for determining whether a version is bad or good based on the requirements of the problem.

### 1. Algorithms & Data Structures (C++): Google Array Question: Valid mountain array

The "Valid Mountain Array" problem is a classic interview question that tests your understanding of array manipulation. Here's the problem statement:

**Problem:**

Given an array of integers `arr`, return `true` if and only if it is a valid mountain array.

Recall that `arr` is a mountain array if and only if:

1. `arr.length >= 3`
2. There exists some `i` with `0 < i < arr.length - 1` such that:
   - `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`
   - `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`

You will be provided with an integer array `arr`.

**Example 1:**

```bash
Input: arr = [2,1]
Output: false
```

**Example 2:**

```bash
Input: arr = [3,5,5]
Output: false
```

**Example 3:**

```bash
Input: arr = [0,3,2,1]
Output: true
```

**Approach:**

We can approach this problem by traversing the array from left to right until we find the peak element (the highest point in the mountain). Then, we check if both the left and right portions of the array after the peak satisfy the mountain property. If they do, then the array is a valid mountain array.

Here's a sample C++ implementation:

```cpp
#include <iostream>
#include <vector>

using namespace std;

bool validMountainArray(vector<int>& arr) {
    int n = arr.size();
    int i = 0;

    // Walk up
    while (i + 1 < n && arr[i] < arr[i + 1]) {
        i++;
    }

    // Peak can't be the first or last element
    if (i == 0 || i == n - 1) {
        return false;
    }

    // Walk down
    while (i + 1 < n && arr[i] > arr[i + 1]) {
        i++;
    }

    return i == n - 1;
}

int main() {
    // Example usage
    vector<int> arr1 = {2, 1};
    vector<int> arr2 = {3, 5, 5};
    vector<int> arr3 = {0, 3, 2, 1};

    cout << validMountainArray(arr1) << endl; // Output: false
    cout << validMountainArray(arr2) << endl; // Output: false
    cout << validMountainArray(arr3) << endl; // Output: true

    return 0;
}
```

This approach has a time complexity of O(n), where n is the size of the input array.

### 1. Algorithms & Data Structures (C++): Google Dynamic Programming Question: Coin Change

The Coin Change problem is a classic dynamic programming problem often asked in coding interviews, and it's commonly used as an exercise to understand dynamic programming concepts. The problem statement is as follows:

Given a set of coins with different denominations and a total amount of money, find the minimum number of coins needed to make up that amount of money. If it's not possible to make the amount using the given coins, return -1.

Here's a typical solution to the Coin Change problem using dynamic programming in C++:

```cpp
#include <bits/stdc++.h>
using namespace std;

int coinChange(vector<int>& coins, int amount) {
    vector<int> dp(amount + 1, amount + 1);
    dp[0] = 0; // Base case: 0 coins needed to make 0 amount
    
    for (int i = 1; i <= amount; ++i) {
        for (int coin : coins) {
            if (coin <= i) {
                dp[i] = min(dp[i], dp[i - coin] + 1);
            }
        }
    }
    
    return dp[amount] > amount ? -1 : dp[amount];
}

int main() {
    vector<int> coins = {1, 2, 5}; // Example coin denominations
    int amount = 11; // Example total amount

    int minCoins = coinChange(coins, amount);
    if (minCoins == -1) {
        cout << "It's not possible to make up the amount using the given coins." << endl;
    } else {
        cout << "Minimum number of coins needed: " << minCoins << endl;
    }

    return 0;
}
```

In this solution:

- We use a vector `dp` to store the minimum number of coins needed to make up each amount from 0 to the given `amount`.
- We initialize `dp[0] = 0` since it takes 0 coins to make 0 amount.
- We iterate through each amount from 1 to the given `amount`, and for each amount, we try all possible coin denominations to find the minimum number of coins needed.
- The recurrence relation `dp[i] = min(dp[i], dp[i - coin] + 1)` calculates the minimum number of coins needed to make up the amount `i`, considering the current coin denomination.

This solution has a time complexity of O(n * m), where n is the amount and m is the number of coin denominations, and a space complexity of O(n).

### 1. Algorithms & Data Structures (C++): Google Dynamic Programming Question: House Robber

The House Robber problem is a classic dynamic programming question often asked in coding interviews, including those at Google. Here's how it typically goes:

#### Problem Statement

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

```plaintext
Input: [2, 7, 9, 3, 1]
Output: 12
Explanation: Rob house 1 (money = 2) and then rob house 3 (money = 9). Total amount you can rob = 2 + 9 = 11.
```

#### Approach

We can solve this problem using dynamic programming. The key idea is to recognize that at each house, we have two choices: either rob it or skip it. If we decide to rob the current house, we should add the current house's loot to the loot we accumulated till the previous house where we skipped. If we skip the current house, then the loot will remain the same as the loot accumulated till the previous house (whether robbed or skipped).

We can use an array to keep track of the maximum loot we can obtain up to the current house. We initialize two variables, `prevRobbed` and `prevSkipped`, representing the maximum loot we can obtain up to the previous house where we either robbed or skipped. Then, we iterate through the houses, updating `prevRobbed` and `prevSkipped` for each house. Finally, the maximum loot will be the maximum of `prevRobbed` and `prevSkipped`.

#### C++ Code

```cpp
#include <vector>
#include <algorithm>

using namespace std;

int rob(vector<int>& nums) {
    int prevRobbed = 0, prevSkipped = 0;
    for (int num : nums) {
        int currRobbed = prevSkipped + num; // if rob current house
        int currSkipped = max(prevRobbed, prevSkipped); // if skip current house
        prevSkipped = currSkipped;
        prevRobbed = currRobbed;
    }
    return max(prevRobbed, prevSkipped);
}
```

This code runs in O(n) time complexity, where n is the number of houses, and O(1) space complexity. It's efficient and provides the maximum loot you can obtain without alerting the police.

### 1. Algorithms & Data Structures (C++): Google Hash Tables / Dictionaries question: Contains Duplicate

To solve the "Contains Duplicate" problem using Google Hash Tables or Dictionaries in C++, you can follow these steps:

1. Iterate through the array of elements.
2. For each element, check if it exists in the hash table.
3. If it exists, return true, indicating that the array contains a duplicate.
4. If it doesn't exist, add it to the hash table.
5. If the loop completes without finding a duplicate, return false.

Here's a C++ implementation:

```cpp
#include <iostream>
#include <vector>
#include <unordered_set>

bool containsDuplicate(std::vector<int>& nums) {
    std::unordered_set<int> seen;
    for (int num : nums) {
        if (seen.find(num) != seen.end()) {
            return true; // Duplicate found
        }
        seen.insert(num);
    }
    return false; // No duplicate found
}

int main() {
    std::vector<int> nums = {1, 2, 3, 1}; // Example input
    if (containsDuplicate(nums)) {
        std::cout << "Array contains duplicate." << std::endl;
    } else {
        std::cout << "Array does not contain duplicate." << std::endl;
    }
    return 0;
}
```

This code uses an `unordered_set` to store the elements encountered so far. The `find()` operation on a hash set has an average time complexity of O(1), which makes this solution efficient. The overall time complexity of this solution is O(n), where n is the number of elements in the array.

### 1. Algorithms & Data Structures (C++): Google Hash Tables / Dictionaries question: Majority Element

The "Majority Element" problem is a classic algorithmic question that involves finding an element in an array that appears more than ⌊n/2⌋ times, where n is the size of the array. One efficient way to solve this problem is by utilizing a hash table (unordered_map in C++) to count the occurrences of each element in the array.

Here's a step-by-step approach to solve the Majority Element problem using a hash table in C++:

1. Traverse the array and count the occurrences of each element using a hash table.
2. After counting, iterate through the hash table and find the element with the highest count.
3. Check if the count of the majority element is greater than ⌊n/2⌋, where n is the size of the array.
4. If the count of the majority element satisfies the condition, return the majority element. Otherwise, return -1 or indicate that there is no majority element.

Here's the implementation of the above approach in C++:

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>

using namespace std;

int majorityElement(vector<int>& nums) {
    unordered_map<int, int> counts;
    int n = nums.size();
    
    // Count occurrences of each element
    for (int num : nums) {
        counts[num]++;
    }
    
    // Find the element with the highest count
    int majority = -1;
    int maxCount = 0;
    for (auto& pair : counts) {
        if (pair.second > maxCount) {
            majority = pair.first;
            maxCount = pair.second;
        }
    }
    
    // Check if the count of the majority element satisfies the condition
    if (maxCount > n / 2) {
        return majority;
    } else {
        return -1; // No majority element
    }
}

int main() {
    vector<int> nums = {3, 3, 4, 2, 4, 4, 2, 4, 4};
    int majority = majorityElement(nums);
    if (majority != -1) {
        cout << "The majority element is: " << majority << endl;
    } else {
        cout << "There is no majority element." << endl;
    }
    return 0;
}
```

In this implementation, we traverse the array once to count the occurrences of each element, then iterate through the hash table to find the element with the highest count. Finally, we check if the count of the majority element satisfies the condition and return the result accordingly.

### 1. Algorithms & Data Structures (C++): Google Hash Tables / Dictionaries question: Two Sum

Certainly! The "Two Sum" problem is a classic coding interview question frequently asked to test your understanding of hash tables (or dictionaries in Python). The problem statement typically goes like this:

Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.

For example:

```bash
Input: nums = [2, 7, 11, 15], target = 9
Output: [0, 1]
Explanation: nums[0] + nums[1] = 2 + 7 = 9, so the answer is [0, 1].
```

Here's a C++ solution using a hash table (unordered_map) to store the indices of previously visited numbers:

```cpp
#include <vector>
#include <unordered_map>

std::vector<int> twoSum(std::vector<int>& nums, int target) {
    std::unordered_map<int, int> numIndices;
    std::vector<int> result;

    for (int i = 0; i < nums.size(); ++i) {
        int complement = target - nums[i];
        if (numIndices.find(complement) != numIndices.end()) {
            result.push_back(numIndices[complement]);
            result.push_back(i);
            break; // Found the solution, exit loop
        }
        numIndices[nums[i]] = i;
    }

    return result;
}
```

Explanation:

1. We use an unordered_map `numIndices` to store the indices of the elements we have seen so far.
2. For each element `nums[i]`, we calculate its complement (the number needed to reach the target) as `target - nums[i]`.
3. If the complement exists in the map, we found the solution. We return the indices of `nums[i]` and its complement.
4. If not found, we store the current number and its index in the map.
5. If no solution is found, an empty vector is returned.

This solution has a time complexity of O(n), where n is the number of elements in the array, because the average time complexity of unordered_map operations is O(1).

### 1. Algorithms & Data Structures (C++): Google Interview Questions

Sure, here are some common algorithms and data structures that are often asked about in Google interviews:

1. **Arrays and Strings**:
   - Implementations of basic array manipulation (e.g., reversing an array, finding the maximum subarray sum).
   - String manipulation problems (e.g., string reversal, palindrome detection, anagram detection).

2. **Linked Lists**:
   - Basic operations on linked lists (insertion, deletion, traversal).
   - Problems involving linked list manipulation, such as reversing a linked list or detecting cycles in a linked list.

3. **Stacks and Queues**:
   - Implementations of stacks and queues using arrays or linked lists.
   - Problems involving stack or queue operations, such as implementing a queue using stacks or solving problems using a stack-based approach.

4. **Trees and Graphs**:
   - Basic tree and graph traversals (e.g., depth-first search, breadth-first search).
   - Tree-related problems, such as finding the lowest common ancestor or checking if a tree is balanced.
   - Graph-related problems, such as finding shortest paths or detecting cycles in a graph.

5. **Sorting and Searching**:
   - Implementations and analysis of sorting algorithms (e.g., quicksort, mergesort).
   - Searching algorithms, including binary search and variations like ternary search.
   - Problems involving sorting and searching, such as finding the k-th smallest/largest element in an array.

6. **Dynamic Programming**:
   - Understanding dynamic programming principles and solving problems using dynamic programming (e.g., Fibonacci sequence, longest common subsequence).
   - Recognizing and solving optimization problems using dynamic programming techniques.

7. **Bit Manipulation**:
   - Basic bit manipulation operations (e.g., setting, clearing, toggling bits).
   - Problems involving bitwise operations, such as finding the single non-repeating element in an array or counting the number of set bits in an integer.

8. **Miscellaneous**:
   - Miscellaneous algorithmic problems, such as designing algorithms to solve specific problems (e.g., design an algorithm to find the median of a stream of integers).

Remember, in addition to solving these problems, it's essential to focus on writing clean, efficient, and bug-free code. Additionally, be prepared to discuss the time and space complexity of your solutions and to optimize them if possible. Good luck with your preparation!

### 1. Algorithms & Data Structures (C++): Google Linked list question: Merge K sorted lists

To merge K sorted lists efficiently, you can use a min-heap (priority queue). Here's how you can implement it in C++:

```cpp
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

// Custom comparator for the priority queue
struct CompareNodes {
    bool operator()(ListNode* a, ListNode* b) {
        return a->val > b->val;
    }
};

class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        // Priority queue to keep track of minimum elements
        priority_queue<ListNode*, vector<ListNode*>, CompareNodes> minHeap;
        
        // Push the heads of all lists onto the heap
        for (ListNode* list : lists) {
            if (list)
                minHeap.push(list);
        }
        
        ListNode dummy(0);
        ListNode* tail = &dummy;
        
        // Keep popping the minimum element and add its next to the heap
        while (!minHeap.empty()) {
            ListNode* minNode = minHeap.top();
            minHeap.pop();
            tail->next = minNode;
            tail = tail->next;
            if (minNode->next)
                minHeap.push(minNode->next);
        }
        
        return dummy.next;
    }
};

// Utility function to create a linked list from a vector
ListNode* createList(const vector<int>& v) {
    ListNode dummy(0);
    ListNode* current = &dummy;
    for (int val : v) {
        current->next = new ListNode(val);
        current = current->next;
    }
    return dummy.next;
}

// Utility function to print a linked list
void printList(ListNode* head) {
    while (head) {
        cout << head->val << " ";
        head = head->next;
    }
    cout << endl;
}

int main() {
    Solution solution;

    // Example usage
    vector<vector<int>> listsData = {{1, 4, 5}, {1, 3, 4}, {2, 6}};
    vector<ListNode*> lists;
    for (auto& listData : listsData)
        lists.push_back(createList(listData));

    ListNode* mergedList = solution.mergeKLists(lists);
    printList(mergedList);

    // Clean up the memory
    while (mergedList) {
        ListNode* temp = mergedList;
        mergedList = mergedList->next;
        delete temp;
    }

    return 0;
}
```

This implementation has a time complexity of O(N log K), where N is the total number of elements across all lists and K is the number of lists. This is because each node is added and removed from the priority queue once, and the size of the priority queue can be at most K.

### 1. Algorithms & Data Structures (C++): Google Stack Question: Min Stack

Sure, let's discuss the Min Stack problem.

The Min Stack problem is a common interview question where you need to design a stack that supports the following operations:

1. `push(x)`: Pushes element `x` onto the stack.
2. `pop()`: Removes the element on the top of the stack.
3. `top()`: Returns the element on the top of the stack without removing it.
4. `getMin()`: Returns the minimum element in the stack.

The tricky part of this problem is to support the `getMin()` operation with constant time complexity (O(1)).

One approach to solve this problem efficiently is to use an additional stack to keep track of the minimum element so far. Here's how it can be done in C++:

```cpp
#include <stack>
#include <climits>

class MinStack {
private:
    std::stack<int> dataStack;
    std::stack<int> minStack;
    
public:
    MinStack() {
        // Constructor
    }
    
    void push(int x) {
        dataStack.push(x);
        if (minStack.empty() || x <= minStack.top()) {
            minStack.push(x);
        }
    }
    
    void pop() {
        if (dataStack.top() == minStack.top()) {
            minStack.pop();
        }
        dataStack.pop();
    }
    
    int top() {
        return dataStack.top();
    }
    
    int getMin() {
        return minStack.top();
    }
};
```

In this implementation, the `dataStack` stores all the elements pushed onto the stack, and the `minStack` stores the minimum elements encountered so far. Whenever a new element is pushed onto the stack, if it's less than or equal to the current minimum element (or if the `minStack` is empty), it's also pushed onto the `minStack`. When an element is popped from the stack, if it's the minimum element, it's also popped from the `minStack`. This way, `getMin()` can retrieve the minimum element in constant time by simply looking at the top of the `minStack`.

This solution ensures that all operations - push, pop, top, and getMin - have constant time complexity, making it an efficient solution for the Min Stack problem.

### 1. Algorithms & Data Structures (C++): Google Trees question: Maximum Depth of a Binary Tree

To find the maximum depth of a binary tree, you can use a recursive algorithm known as depth-first search (DFS). Here's how you can implement it in C++:

```cpp
#include <iostream>
#include <algorithm> // for max function

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

int maxDepth(TreeNode* root) {
    if (root == nullptr) {
        return 0;
    } else {
        int leftDepth = maxDepth(root->left);
        int rightDepth = maxDepth(root->right);
        return 1 + std::max(leftDepth, rightDepth);
    }
}

int main() {
    // Example usage:
    TreeNode* root = new TreeNode(3);
    root->left = new TreeNode(9);
    root->right = new TreeNode(20);
    root->right->left = new TreeNode(15);
    root->right->right = new TreeNode(7);

    std::cout << "Maximum depth of the binary tree: " << maxDepth(root) << std::endl;

    // Remember to free memory allocated for the tree nodes
    delete root->right->right;
    delete root->right->left;
    delete root->right;
    delete root->left;
    delete root;

    return 0;
}
```

In this code:

1. The `maxDepth` function takes a pointer to the root of a binary tree and returns the maximum depth of that tree.
2. If the root is `nullptr`, it means the tree is empty, so the depth is 0.
3. Otherwise, it recursively calculates the maximum depth of the left subtree and the right subtree, then returns the maximum of the two depths plus 1 (to account for the current node).
4. In the `main` function, an example binary tree is created and its maximum depth is printed. Remember to free the allocated memory for the tree nodes to prevent memory leaks.

This algorithm has a time complexity of O(n), where n is the number of nodes in the tree, since it visits each node exactly once.

### 1. Algorithms & Data Structures (C++): Graham's Scan algorithm

Graham's Scan algorithm is a method used in computational geometry to find the convex hull of a set of points in a plane. The convex hull is the smallest convex polygon that contains all the points in the set. Graham's Scan is an efficient algorithm for computing the convex hull, with a time complexity of O(n log n), where n is the number of input points.

Here's a brief overview of how Graham's Scan works:

1. **Choose a Pivot Point**: First, choose the point with the lowest y-coordinate. If there are multiple points with the same y-coordinate, choose the one with the lowest x-coordinate. This point will serve as the pivot.

2. **Sort by Polar Angle**: Sort all other points based on their polar angles with respect to the pivot point. If two points have the same polar angle, keep the one that is closer to the pivot first.

3. **Scan**: Starting from the pivot point, traverse the sorted list of points. For each point encountered, check if taking a left turn at this point forms a convex angle with the two previous points in the convex hull. If it does, add the point to the convex hull. If it forms a concave angle, remove the previous point from the convex hull until a convex angle is formed again.

4. **Output**: The stack containing the convex hull points after the scan is completed represents the convex hull of the input points.

Here's a simple implementation of Graham's Scan algorithm in C++:

```cpp
#include <iostream>
#include <stack>
#include <vector>
#include <algorithm>

using namespace std;

struct Point {
    int x, y;
};

// Returns the square of the Euclidean distance between two points
int distSq(Point p1, Point p2) {
    return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);
}

// Returns orientation of triplet (p, q, r)
// 0 --> p, q, r are colinear
// 1 --> Clockwise
// 2 --> Counterclockwise
int orientation(Point p, Point q, Point r) {
    int val = (q.y - p.y) * (r.x - q.x) -
              (q.x - p.x) * (r.y - q.y);
    
    if (val == 0) return 0;  // colinear
    return (val > 0) ? 1 : 2; // clock or counterclock wise
}

// Comparator for sorting points based on polar angle
bool compare(Point p1, Point p2) {
    int orientation_val = orientation(p0, p1, p2);
    if (orientation_val == 0)
        return (distSq(p0, p2) >= distSq(p0, p1));
    
    return (orientation_val == 2);
}

// Implementation of Graham's Scan algorithm
vector<Point> convexHull(vector<Point> points) {
    int n = points.size();
    if (n < 3) return {}; // Convex hull not possible
    
    // Find the bottommost point (pivot)
    int ymin = points[0].y, min_idx = 0;
    for (int i = 1; i < n; i++) {
        int y = points[i].y;
        
        // Pick the bottom-most or chose the leftmost point in case of tie
        if ((y < ymin) || (ymin == y && points[i].x < points[min_idx].x))
            ymin = points[i].y, min_idx = i;
    }
    
    // Place the pivot at first position
    swap(points[0], points[min_idx]);
    p0 = points[0];
    
    // Sort the rest based on polar angle
    sort(points.begin() + 1, points.end(), compare);
    
    // Initialize stack
    stack<Point> s;
    s.push(points[0]);
    s.push(points[1]);
    s.push(points[2]);
    
    // Process remaining points
    for (int i = 3; i < n; i++) {
        while (orientation(nextToTop(s), s.top(), points[i]) != 2)
            s.pop();
        s.push(points[i]);
    }
    
    // Return the convex hull
    vector<Point> convex_hull;
    while (!s.empty()) {
        convex_hull.push_back(s.top());
        s.pop();
    }
    reverse(convex_hull.begin(), convex_hull.end());
    return convex_hull;
}

// Driver code
int main() {
    vector<Point> points = {{0, 3}, {2, 2}, {1, 1}, {2, 1}, {3, 0},
                            {0, 0}, {3, 3}};
    vector<Point> hull = convexHull(points);
    cout << "Convex Hull points:\n";
    for (auto p : hull) {
        cout << "(" << p.x << ", " << p.y << ")\n";
    }
    return 0;
}
```

This code demonstrates the basic implementation of Graham's Scan algorithm in C++. You may need to define the `Point` struct and some utility functions like `nextToTop` to make it work.

### 1. Algorithms & Data Structures (C++): Graphs: Interview Question: Course Scheduler

The Course Scheduler problem is a classic interview question that often involves graphs. Here's the problem statement:

**Problem Statement:**
You are given a list of courses that need to be taken, along with prerequisites for each course. The task is to determine if it is possible to take all the courses, respecting the prerequisites. If it is possible, return the order in which the courses can be taken.

**Example:**

```bash
Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
Output: [0,1,2,3] or [0,2,1,3]
Explanation: There are a total of 4 courses to take. To take course 3, you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one possible course schedule is [0,1,2,3]. Another possible course schedule is [0,2,1,3].
```

**Approach:**
This problem can be solved using topological sorting, which is a linear ordering of vertices in a directed acyclic graph (DAG) such that for every directed edge `u -> v`, vertex `u` comes before `v` in the ordering. If the graph has a cycle, no topological ordering exists, and thus it's impossible to schedule the courses.

Here's a high-level approach:

1. Build a graph from the prerequisites.
2. Perform topological sorting on the graph.
3. If a valid ordering is found, return it.

**Implementation in C++:**

```cpp
#include <vector>
#include <queue>
using namespace std;

vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
    vector<vector<int>> graph(numCourses);
    vector<int> indegree(numCourses, 0);
    
    // Build the graph and calculate indegrees
    for (const auto& edge : prerequisites) {
        graph[edge[1]].push_back(edge[0]);
        indegree[edge[0]]++;
    }
    
    // Perform topological sorting using BFS
    queue<int> q;
    for (int i = 0; i < numCourses; ++i) {
        if (indegree[i] == 0)
            q.push(i);
    }
    
    vector<int> order;
    while (!q.empty()) {
        int curr = q.front();
        q.pop();
        order.push_back(curr);
        for (int neighbor : graph[curr]) {
            indegree[neighbor]--;
            if (indegree[neighbor] == 0)
                q.push(neighbor);
        }
    }
    
    // Check if there's a cycle
    if (order.size() != numCourses)
        return {};
    return order;
}
```

This implementation utilizes Kahn's algorithm for topological sorting, which has a time complexity of O(V + E), where V is the number of vertices and E is the number of edges.

### 1. Algorithms & Data Structures (C++): Graphs: Interview Question: Network Time Delay

Certainly! One common interview question related to graphs is the "Network Time Delay" problem, which is often framed in the context of analyzing a network of nodes where each node represents a computer and edges represent connections between them. The problem goes as follows:

#### Problem Statement

Given a network of nodes where each node represents a computer and each directed edge represents a connection between two computers, along with a starting node `source`, determine the minimum time it takes for a signal to reach all other nodes in the network from the `source` node. If it's not possible to reach all nodes, return -1.

Additionally, you are provided with the following information:

- An array `times`, where `times[i]` represents the time it takes for a signal to travel from node `source` to node `i`.
- The network has `N` nodes (numbered from 1 to N), and `times.length == N`.
- The number of edges in the network is `E`, where `E[i] = (u, v, w)` represents a directed edge from node `u` to node `v` with a time delay of `w`.

#### Example

```cpp
Input: 
N = 4, E = 3, source = 2
times = [0, 2, 1, 3]
Edges = [[2,1,1],[2,3,1],[3,4,1]]

Output: 2

Explanation: 
Signal from node 2 travels to node 1 in 1 unit of time (total time = 1).
Signal from node 2 travels to node 3 in 1 unit of time (total time = 1).
Signal from node 3 travels to node 4 in 1 unit of time (total time = 2).
```

#### Approach (Dijkstra's Algorithm)

1. Start from the source node and initialize a distance array `dist[]` with values as `INT_MAX`, except for the source node with distance `0`.
2. Use a priority queue (min-heap) to store nodes. The priority queue will contain pairs `(time, node)`, where `time` is the minimum time taken to reach the `node`.
3. Traverse through the priority queue, updating the distances of adjacent nodes if a shorter path is found.
4. Repeat until all nodes are processed or the priority queue becomes empty.

#### C++ Code

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <climits>

using namespace std;

int networkDelayTime(vector<vector<int>>& times, int N, int source) {
    vector<int> dist(N + 1, INT_MAX);
    dist[source] = 0;
    
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    pq.push({0, source});
    
    while (!pq.empty()) {
        int u = pq.top().second;
        pq.pop();
        
        for (auto& edge : times) {
            int v = edge[1];
            int w = edge[2];
            
            if (edge[0] == u && dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
        }
    }
    
    int maxDelay = 0;
    for (int i = 1; i <= N; ++i) {
        if (dist[i] == INT_MAX) return -1;
        maxDelay = max(maxDelay, dist[i]);
    }
    
    return maxDelay;
}

int main() {
    vector<vector<int>> times = {{2,1,1},{2,3,1},{3,4,1}};
    int N = 4;
    int source = 2;
    cout << "Network Time Delay: " << networkDelayTime(times, N, source) << endl;
    return 0;
}
```

This code implements Dijkstra's algorithm to find the network time delay from a given source node in a directed graph represented by an adjacency list.

### 1. Algorithms & Data Structures (C++): Graphs: Interview Question: Network Time Delay: Greedy Method

Sure! Here's an example of an interview question related to graphs and network time delay, solved using a greedy method in C++:

Problem Statement:
You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges times[i] = (u, v, w), where u is the source node, v is the target node, and w is the time it takes for a signal to travel from node u to node v.

We need to calculate the minimum time taken for a signal to reach all nodes in the network, if the signal starts from node k. If it's impossible for the signal to reach all nodes, return -1.

Solution (Greedy Method in C++):

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
#include <climits>

using namespace std;

int networkDelayTime(vector<vector<int>>& times, int n, int k) {
    vector<vector<pair<int, int>>> graph(n + 1); // 1-indexed graph
    // Construct the graph
    for (const auto& time : times) {
        int u = time[0], v = time[1], w = time[2];
        graph[u].push_back({v, w});
    }

    vector<int> dist(n + 1, INT_MAX); // Distance array to store minimum time taken to reach each node
    dist[k] = 0; // Distance to source node k is 0

    // Custom comparator for priority queue based on distance
    auto cmp = [](pair<int, int>& a, pair<int, int>& b) { return a.second > b.second; };
    priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> pq(cmp);

    pq.push({k, 0});

    while (!pq.empty()) {
        int u = pq.top().first;
        int d = pq.top().second;
        pq.pop();
        
        if (d > dist[u]) continue; // Skip if we've found a shorter path

        for (const auto& edge : graph[u]) {
            int v = edge.first;
            int w = edge.second;
            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                pq.push({v, dist[v]});
            }
        }
    }

    int max_time = 0;
    for (int i = 1; i <= n; ++i) {
        if (dist[i] == INT_MAX) return -1; // Node i is unreachable
        max_time = max(max_time, dist[i]);
    }
    return max_time;
}

int main() {
    vector<vector<int>> times = {{2,1,1},{2,3,1},{3,4,1}};
    int n = 4; // Number of nodes
    int k = 2; // Starting node
    cout << "Minimum time taken: " << networkDelayTime(times, n, k) << endl;
    return 0;
}
```

In this solution, Dijkstra's algorithm is used to find the minimum time taken for the signal to reach all nodes. The priority queue stores nodes along with their current shortest distances from the source. At each step, the node with the shortest distance is chosen and its neighbors are relaxed. Finally, the maximum time taken to reach any node is returned as the answer.

### 1. Algorithms & Data Structures (C++): Graphs: Interview Question: Network Time Delay: Time And Space Complexity

The "Network Time Delay" problem is a classic graph algorithm question often encountered in technical interviews. The problem typically involves finding the minimum time it takes for a signal to reach all nodes in a network, given the delays between each pair of nodes. This problem can be solved efficiently using Dijkstra's algorithm or Bellman-Ford algorithm, both of which have different time and space complexities.

Here's a brief overview of the time and space complexities for solving the "Network Time Delay" problem using Dijkstra's algorithm:

#### Dijkstra's Algorithm

**Time Complexity:**  

- With a naive implementation using an adjacency matrix: O(V^2) where V is the number of vertices. This is because we need to iterate through all vertices to find the minimum distance vertex at each step, and then update distances for all adjacent vertices.
- With a more efficient implementation using a priority queue (min-heap): O((V + E) * log(V)), where E is the number of edges. This is because the priority queue reduces the time complexity of finding the next vertex with the minimum distance to O(log(V)).

**Space Complexity:**  

- O(V) for storing distances and visited flags for each vertex.
- O(E) for storing the graph, assuming an adjacency list representation.
- O(V) for the priority queue, if using a binary heap.

#### Bellman-Ford Algorithm

**Time Complexity:**  

- O(VE), where V is the number of vertices and E is the number of edges. Bellman-Ford algorithm has a worst-case time complexity of O(VE), making it less efficient than Dijkstra's algorithm in most cases.

**Space Complexity:**  

- O(V) for storing distances and predecessor information for each vertex.
- O(E) for storing the graph, assuming an adjacency list representation.

In terms of time complexity, Dijkstra's algorithm with a priority queue is generally faster than the Bellman-Ford algorithm for sparse graphs (graphs with fewer edges). However, if negative weight cycles are present in the graph, Bellman-Ford is preferred as it can detect and handle them.

In summary, for the "Network Time Delay" problem, Dijkstra's algorithm with a priority queue is often the preferred choice due to its faster average-case performance, unless there are negative weight cycles in the graph, in which case Bellman-Ford algorithm should be used.

### 1. Algorithms & Data Structures (C++): Graphs: Interview Question: Time Needed to Inform All Employees

Certainly! The problem you're referring to is often known as "Time Needed to Inform All Employees" or a variation of it. Here's the problem statement:

### Problem Statement

There are `N` employees in a company, each having a unique ID between `0` and `N-1`. The head of the company is the employee with ID `headID`.

Each employee in the company can inform their immediate subordinates about an important piece of news. The `informTime[i]` represents the time needed for an employee with ID `i` to inform all their subordinates.

Return the total time needed for all employees to be informed, given that it takes `0` time for the head to inform all employees.

### Example

```bash
Input: n = 6, headID = 2, manager = [2,2,-1,2,3,3], informTime = [0,0,1,1,3,3]
Output: 9
Explanation: 
The head of the company with ID = 2 is the first employee.
The time needed to inform employees under the head is 1 and 3.
So the time needed for the entire company to be informed is 1 + 3 + 3 = 9.
```

### Approach

One way to solve this problem efficiently is by using Depth First Search (DFS) to traverse the company's hierarchy. At each step, we calculate the time taken for each employee to inform their subordinates recursively. The maximum time taken among all the paths represents the time taken for the entire company to be informed.

Here's a pseudocode representation of the algorithm:

1. Define a function `dfs` to perform Depth First Search.
2. In the `dfs` function, iterate over the subordinates of the current employee.
3. For each subordinate, recursively call the `dfs` function and update the maximum time taken.
4. Return the maximum time taken.

In C++, the implementation may look like this:

```cpp
#include <vector>
#include <unordered_map>
#include <algorithm>

using namespace std;

class Solution {
public:
    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {
        unordered_map<int, vector<int>> graph;
        for (int i = 0; i < n; ++i) {
            if (manager[i] != -1)
                graph[manager[i]].push_back(i);
        }
        return dfs(graph, headID, informTime);
    }
    
    int dfs(unordered_map<int, vector<int>>& graph, int headID, vector<int>& informTime) {
        int maxTime = 0;
        for (int subordinate : graph[headID]) {
            maxTime = max(maxTime, dfs(graph, subordinate, informTime));
        }
        return informTime[headID] + maxTime;
    }
};
```

This algorithm has a time complexity of O(N), where N is the number of employees.

### 1. Algorithms & Data Structures (C++): Greedy Indian Coin Change

The Greedy Indian Coin Change problem is a classic problem in computer science and algorithms. The problem is to find the minimum number of coins required to make a given value using a set of Indian coins denominations.

In India, coins are available in denominations of 1, 2, 5, 10, 20, 50, 100, 500, and 1000. The task is to find the minimum number of coins required to make a given value V.

Here's a C++ implementation of the greedy algorithm to solve the Indian Coin Change problem:

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to find the minimum number of coins
int minCoins(int value) {
    // Array to store denominations of Indian coins
    vector<int> coins = {1000, 500, 100, 50, 20, 10, 5, 2, 1};
    int count = 0; // Initialize the count of coins needed
    int i = 0;

    // Iterate through all denominations
    while (value > 0) {
        // If current denomination can be used
        if (value >= coins[i]) {
            // Add the number of coins of this denomination
            count += value / coins[i];
            // Reduce value by subtracting coins used
            value %= coins[i];
        }
        // Move to next denomination
        i++;
    }
    return count;
}

int main() {
    int value;
    cout << "Enter the value: ";
    cin >> value;
    int coinsNeeded = minCoins(value);
    cout << "Minimum number of coins needed: " << coinsNeeded << endl;
    return 0;
}
```

This algorithm iterates through the coin denominations in decreasing order. At each step, it selects the largest denomination that is less than or equal to the remaining value and adds the count of that denomination to the total count. Then, it updates the remaining value by subtracting the value of the selected coins. This process continues until the remaining value becomes zero.

### 1. Algorithms & Data Structures (C++): Grid Unique Path

The problem of finding unique paths in a grid is a classic dynamic programming challenge. In this problem, you're typically given a grid with dimensions \( m \times n \), and you need to find the number of unique paths from the top-left corner to the bottom-right corner, moving only down or right.

Here's how you can implement this algorithm in C++ using dynamic programming:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int uniquePaths(int m, int n) {
    // Create a 2D vector to store the number of paths for each cell
    vector<vector<int>> dp(m, vector<int>(n, 0));

    // Base case: there is only one way to reach any cell in the first row or column
    for (int i = 0; i < m; ++i)
        dp[i][0] = 1;
    for (int j = 0; j < n; ++j)
        dp[0][j] = 1;

    // Fill up the dp array using dynamic programming
    for (int i = 1; i < m; ++i) {
        for (int j = 1; j < n; ++j) {
            // The number of paths to reach cell (i, j) is the sum of the paths to reach the cell above and the cell to the left
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }

    // The result is stored in the bottom-right cell
    return dp[m - 1][n - 1];
}

int main() {
    int m, n;
    cout << "Enter the number of rows and columns: ";
    cin >> m >> n;
    cout << "Number of unique paths: " << uniquePaths(m, n) << endl;
    return 0;
}
```

In this code:

- We create a 2D vector `dp` to store the number of paths for each cell in the grid.
- We initialize the base cases: there is only one way to reach any cell in the first row or column (moving either down or right).
- We fill up the `dp` array iteratively using dynamic programming. The number of paths to reach cell `(i, j)` is the sum of the paths to reach the cell above `(i-1, j)` and the cell to the left `(i, j-1)`.
- Finally, we return the number of unique paths stored in the bottom-right cell of the `dp` array.

This algorithm has a time complexity of O(m *n) and a space complexity of O(m* n), where m and n are the dimensions of the grid.

### 1. Algorithms & Data Structures (C++): Grid Ways

"Grid Ways" is a problem-solving concept that involves finding the number of ways to navigate through a grid from a starting point to an ending point, while obeying certain constraints or rules. This is a common problem in computer science, particularly in algorithm and data structure courses.

Here's a basic outline of how you might approach solving a grid ways problem using C++:

1. **Define the Problem**: Understand the constraints and rules of movement within the grid. For example, in some cases, you might only be able to move in certain directions (e.g., up, down, left, right), while in other cases, you might be able to move diagonally as well.

2. **Represent the Grid**: Use a data structure to represent the grid. This could be a 2D array/vector, where each cell represents a location in the grid and contains information about that location (e.g., whether it's open or blocked).

3. **Implement the Algorithm**: Depending on the problem constraints, you can use various algorithms to find the number of ways to navigate through the grid. Common algorithms include:

   - **Depth-First Search (DFS)**: Traverse through the grid recursively, exploring all possible paths from the starting point to the ending point. Count the number of valid paths found.

   - **Breadth-First Search (BFS)**: Traverse through the grid iteratively, exploring all possible paths level by level from the starting point to the ending point. Count the number of valid paths found.

   - **Dynamic Programming (DP)**: If the problem exhibits overlapping subproblems, you can use dynamic programming to efficiently compute the number of ways to reach each cell in the grid.

4. **Handle Constraints**: Implement any additional constraints specified in the problem description, such as obstacles or restricted movement.

5. **Output the Result**: Print or return the number of ways found to navigate through the grid from the starting point to the ending point.

Here's a simplified example of how you might implement a DFS-based solution in C++ to find the number of ways to navigate through a grid:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int countWays(vector<vector<int>>& grid, int x, int y, int targetX, int targetY) {
    // Base cases
    if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] == 0)
        return 0;
    if (x == targetX && y == targetY)
        return 1;

    // Recursive cases
    int ways = 0;
    grid[x][y] = 0; // Mark the cell as visited
    ways += countWays(grid, x + 1, y, targetX, targetY); // Move right
    ways += countWays(grid, x - 1, y, targetX, targetY); // Move left
    ways += countWays(grid, x, y + 1, targetX, targetY); // Move down
    ways += countWays(grid, x, y - 1, targetX, targetY); // Move up
    grid[x][y] = 1; // Reset the cell to unvisited for backtracking
    return ways;
}

int main() {
    // Example grid
    vector<vector<int>> grid = {
        {1, 1, 1},
        {1, 0, 1},
        {1, 1, 1}
    };

    int startX = 0, startY = 0;
    int targetX = 2, targetY = 2;

    int ways = countWays(grid, startX, startY, targetX, targetY);
    cout << "Number of ways: " << ways << endl;

    return 0;
}
```

This is a basic implementation and can be extended or optimized based on specific requirements or constraints of the problem.

### 1. Algorithms & Data Structures (C++): Grid Ways - Math Trick

Sure, let's delve into a popular algorithm problem commonly referred to as "Grid Ways" or "Grid Paths." The problem typically involves finding the number of unique paths from the top-left corner to the bottom-right corner of a grid, with certain restrictions (such as obstacles or limited movements).

One of the efficient ways to solve this problem involves dynamic programming. However, if we're looking for a math trick, we can exploit the properties of combinations (binomial coefficients) and permutations.

Here's a simple explanation of the math trick:

Let's consider a grid of size \( (m \times n) \), where \( m \) represents the number of rows and \( n \) represents the number of columns.

To move from the top-left corner to the bottom-right corner, you need to take \( (m-1) \) steps downward and \( (n-1) \) steps to the right, regardless of the path you take.

So, the total number of steps you need to take is \( (m-1) + (n-1) = m + n - 2 \).

Now, you need to choose \( (m-1) \) steps to go downward out of \( (m + n - 2) \) total steps. This can be calculated using combinations (denoted as \( C(n, k) \) or \( \binom{n}{k} \)).

So, the number of unique paths can be calculated as:

\[ \binom{m + n - 2}{m - 1} = \frac{(m + n - 2)!}{(m - 1)!(n - 1)!} \]

This formula gives the number of unique paths without any obstacles. If there are obstacles, you need to adjust the formula accordingly. For example, you can subtract the number of paths that encounter obstacles from the total number of paths.

This mathematical approach is efficient and avoids the need for recursion or dynamic programming when obstacles are not involved. However, for more complex scenarios, dynamic programming might still be necessary.

### 1. Algorithms & Data Structures (C++): Guess the Number

Sure! "Guess the Number" is a classic game where one player thinks of a secret number within a certain range, and the other player tries to guess it by making a series of guesses. The game typically proceeds with the guesser making guesses, and the one who knows the secret number providing feedback such as "too high", "too low", or "correct".

Here's a simple implementation of the game in C++:

```cpp
#include <iostream>
#include <cstdlib>
#include <ctime>

using namespace std;

int main() {
    srand(time(0)); // Seed for random number generation
    int secretNumber = rand() % 100 + 1; // Generate random number between 1 and 100
    int guess;
    int attempts = 0;

    cout << "Welcome to Guess the Number game!\n";
    cout << "I have selected a number between 1 and 100. Try to guess it!\n";

    do {
        cout << "Enter your guess: ";
        cin >> guess;
        attempts++;

        if (guess > secretNumber) {
            cout << "Too high! Try again.\n";
        } else if (guess < secretNumber) {
            cout << "Too low! Try again.\n";
        } else {
            cout << "Congratulations! You've guessed the number (" << secretNumber << ") in " << attempts << " attempts!\n";
        }
    } while (guess != secretNumber);

    return 0;
}
```

In this implementation:

- We use `srand(time(0))` to seed the random number generator with the current time so that the generated numbers appear more random.
- We use `rand() % 100 + 1` to generate a random number between 1 and 100.
- The user keeps guessing until they correctly guess the secret number.
- After each guess, the program provides feedback (too high, too low, or correct).
- The number of attempts taken to guess the correct number is displayed at the end.

Feel free to modify and extend this code according to your needs or preferences!

### 1. Algorithms & Data Structures (C++): Hamming Distance

Sure, the Hamming distance between two strings of equal length is the number of positions at which the corresponding symbols are different. In C++, you can implement a function to calculate the Hamming distance between two strings like this:

```cpp
#include <iostream>
#include <string>

int hammingDistance(const std::string& str1, const std::string& str2) {
    // Check if the strings have equal length
    if (str1.length() != str2.length()) {
        std::cerr << "Error: Strings must have equal length!" << std::endl;
        return -1; // Return an error code
    }

    int distance = 0;
    // Calculate Hamming distance
    for (size_t i = 0; i < str1.length(); ++i) {
        if (str1[i] != str2[i]) {
            ++distance;
        }
    }

    return distance;
}

int main() {
    std::string s1 = "karolin";
    std::string s2 = "kathrin";

    int distance = hammingDistance(s1, s2);
    if (distance >= 0) {
        std::cout << "Hamming Distance: " << distance << std::endl;
    }
    return 0;
}
```

This code first checks if the input strings have equal lengths. If they do, it iterates over each character in the strings and increments the distance counter whenever it encounters characters that are different. Finally, it returns the calculated Hamming distance.

### 1. Algorithms & Data Structures (C++): Hand of Straights

"Hand of Straights" is a problem that can be solved using algorithms and data structures. Here's a brief overview of the problem and a possible solution in C++:

#### Problem Description

You are given an array of integers `hand` representing the player's hand. Each integer represents a card. A hand is considered to be valid if it can be rearranged into groups of W consecutive cards. Each group must contain W cards, and each card in a group must be consecutive.

Return true if and only if the given hand is valid.

#### Example

```cpp
Input: hand = [1,2,3,6,2,3,4,7,8], W = 3
Output: true
Explanation: The hand can be rearranged into [1,2,3],[2,3,4],[6,7,8].
```

#### Approach

1. First, we need to count the frequency of each card in the hand.
2. Then, we iterate through the hand and for each card, we try to build a group of W consecutive cards.
3. If we can't build such a group, the hand is invalid. Otherwise, it's valid.

#### C++ Code

```cpp
#include <iostream>
#include <unordered_map>
#include <vector>
#include <algorithm>

bool isNStraightHand(std::vector<int>& hand, int W) {
    int n = hand.size();
    if (n % W != 0) return false; // If the hand size is not divisible by W, it can't be rearranged into valid groups.

    std::unordered_map<int, int> freq; // Count frequency of each card
    for (int card : hand) {
        freq[card]++;
    }

    // Iterate through the hand and try to build groups of W consecutive cards
    for (int i = 0; i < n / W; ++i) {
        int start = -1;
        for (auto& entry : freq) {
            if (entry.second > 0) {
                if (start == -1) start = entry.first; // Start building a new group
                else if (entry.first != start + 1) return false; // If the current card can't be added to the current group, the hand is invalid
                entry.second--; // Decrease frequency of the current card
                start++; // Move to the next card
            }
        }
        if (start != -1 && start != W + start - 1) return false; // If the group doesn't contain W consecutive cards, the hand is invalid
    }
    return true;
}

int main() {
    std::vector<int> hand = {1, 2, 3, 6, 2, 3, 4, 7, 8};
    int W = 3;
    std::cout << (isNStraightHand(hand, W) ? "true" : "false") << std::endl;
    return 0;
}
```

This code first checks if the hand size is divisible by W. Then, it counts the frequency of each card and iterates through the hand, trying to build groups of W consecutive cards. If it succeeds for each group, the function returns true; otherwise, it returns false.

### 1. Algorithms & Data Structures (C++): House Robber

The House Robber problem is a classic dynamic programming problem where you're given an array representing houses and the amount of money present in each house. The constraint is that you cannot rob two adjacent houses because they are connected by a security system. The task is to find the maximum amount of money you can rob without alerting the security system.

Here's a simple approach to solving this problem using dynamic programming:

```cpp
#include <vector>
#include <algorithm>

int rob(std::vector<int>& nums) {
    int n = nums.size();
    if (n == 0) return 0;
    if (n == 1) return nums[0];
    
    // Create a DP array to store the maximum amount of money
    // that can be robbed up to the ith house.
    std::vector<int> dp(n);
    
    // Base cases
    dp[0] = nums[0];
    dp[1] = std::max(nums[0], nums[1]);
    
    // Iteratively fill the DP array
    for (int i = 2; i < n; ++i) {
        // At each house, we have two choices:
        // 1. Rob the current house along with the money from two houses back.
        // 2. Skip the current house and stick with the money from the previous house.
        dp[i] = std::max(nums[i] + dp[i - 2], dp[i - 1]);
    }
    
    // Return the maximum amount of money that can be robbed
    return dp[n - 1];
}
```

This algorithm has a time complexity of O(n), where n is the number of houses. It iterates through the array once, filling up the DP array, and space complexity of O(n) as well for the DP array.

### 1. Algorithms & Data Structures (C++): House Robber - Arrays

Sure, the "House Robber" problem is a classic dynamic programming problem. Here's the problem statement:

You are a robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

To solve this problem efficiently, you can use dynamic programming. Here's a simple implementation in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int rob(vector<int>& nums) {
    int n = nums.size();
    if (n == 0) return 0;
    if (n == 1) return nums[0];
    
    // Create a DP array to store the maximum amount of money robbed up to the ith house
    vector<int> dp(n);
    
    // Base cases
    dp[0] = nums[0];
    dp[1] = max(nums[0], nums[1]);
    
    // Fill DP array iteratively
    for (int i = 2; i < n; ++i) {
        // At each house, decide whether to rob it or not
        // If we rob the ith house, we can't rob the (i-1)th house
        // So, the maximum amount of money we can get at the ith house is the sum of the value of the ith house and the maximum amount of money we can get at the (i-2)th house
        // If we choose not to rob the ith house, then the maximum amount of money we can get at the ith house is the same as the maximum amount of money we can get at the (i-1)th house
        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);
    }
    
    return dp[n - 1];
}

int main() {
    vector<int> nums = {2, 7, 9, 3, 1};
    cout << "Maximum amount of money that can be robbed: " << rob(nums) << endl;
    return 0;
}
```

This code finds the maximum amount of money that can be robbed without alerting the police. You can modify the `nums` vector with the values of money in each house as per the problem statement.

### 1. Algorithms & Data Structures (C++): House Robber - Dynamic Programming

Certainly! The House Robber problem is a classic dynamic programming problem where you're given an array representing houses and the amount of money in each house. You cannot rob two adjacent houses, and you want to maximize the amount of money you can rob without alerting the police. Here's a C++ implementation using dynamic programming:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int rob(std::vector<int>& nums) {
    int n = nums.size();
    if (n == 0) return 0;
    if (n == 1) return nums[0];
    
    // Create a DP array to store the maximum amount robbed till the ith house.
    std::vector<int> dp(n);
    
    // Base cases
    dp[0] = nums[0];
    dp[1] = std::max(nums[0], nums[1]);
    
    // Fill up the DP array
    for (int i = 2; i < n; ++i) {
        // At each house, decide whether to rob it or not based on previous optimal solutions
        // If robbing current house, add current loot and loot of the house two steps behind
        // If not, carry forward previous maximum loot
        dp[i] = std::max(dp[i - 1], dp[i - 2] + nums[i]);
    }
    
    // The last element of the DP array holds the maximum amount robbed overall
    return dp[n - 1];
}

int main() {
    std::vector<int> houses = {2, 7, 9, 3, 1}; // Example array of house values
    std::cout << "Maximum amount robbed: " << rob(houses) << std::endl;
    return 0;
}
```

This implementation uses a bottom-up dynamic programming approach. It iterates through the given array, calculating the maximum amount that can be robbed at each house by considering the maximum amount robbed till the previous house. The final answer is stored in the last element of the `dp` array.

Feel free to replace the `houses` vector with your own data to test different scenarios.

### 1. Algorithms & Data Structures (C++): House robber (problem)

The House Robber problem is a classic dynamic programming problem. The problem statement typically goes like this:

You are a robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected, and it will automatically contact the police if two adjacent houses are broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

Here's a simple approach to solve this problem using dynamic programming in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int rob(vector<int>& nums) {
    int n = nums.size();
    if (n == 0) return 0;
    if (n == 1) return nums[0];
    
    // Create an array to store the maximum money robbed up to the ith house
    vector<int> dp(n);
    
    // Base cases
    dp[0] = nums[0];
    dp[1] = max(nums[0], nums[1]);
    
    // Fill the dp array using dynamic programming
    for (int i = 2; i < n; ++i) {
        // The maximum amount of money that can be robbed up to the ith house
        // is either the maximum amount robbed up to the (i-2)th house + money in the current house,
        // or the maximum amount robbed up to the (i-1)th house.
        dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
    }
    
    // Return the maximum amount of money robbed up to the last house
    return dp[n - 1];
}

int main() {
    vector<int> houses = {2, 7, 9, 3, 1};
    cout << "Maximum amount of money that can be robbed: " << rob(houses) << endl;
    return 0;
}
```

This implementation has a time complexity of O(n) since we iterate through the array of houses only once, and a space complexity of O(n) to store the dynamic programming array.

### 1. Algorithms & Data Structures (C++): House robber (solution)

The House Robber problem is a classic dynamic programming problem where you're tasked with finding the maximum amount of money you can rob from a street of houses, with the constraint that you cannot rob two adjacent houses because they are connected by an alarm system.

Here's a simple dynamic programming solution in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int rob(vector<int>& nums) {
    int n = nums.size();
    if (n == 0) return 0;
    if (n == 1) return nums[0];

    vector<int> dp(n, 0);
    dp[0] = nums[0];
    dp[1] = max(nums[0], nums[1]);

    for (int i = 2; i < n; ++i) {
        // At each house, we decide whether to rob it or not.
        // If we rob the current house, we add the loot from this house to the loot from two houses back.
        // If we don't rob the current house, the loot stays the same as the loot from the previous house.
        dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
    }

    return dp[n - 1];
}

int main() {
    vector<int> nums = {2, 7, 9, 3, 1};
    cout << "Maximum amount of money that can be robbed: " << rob(nums) << endl;
    return 0;
}
```

This solution utilizes dynamic programming where `dp[i]` represents the maximum amount of money that can be robbed from the first `i` houses. We fill in the `dp` array iteratively, considering the maximum loot we can get at each house by comparing robbing it versus not robbing it. Finally, we return `dp[n - 1]`, which represents the maximum loot we can get from all the houses.

### 1. Algorithms & Data Structures (C++): House Robber Problem using Dynamic Programming

The House Robber problem is a classic dynamic programming problem where you're given an array representing houses and the amount of money in each house. You cannot rob two adjacent houses due to security systems. The task is to determine the maximum amount of money you can rob without alerting the police. Here's how you can solve it using dynamic programming in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int maxMoney(std::vector<int>& nums) {
    int n = nums.size();
    if (n == 0) return 0;
    if (n == 1) return nums[0];
    
    std::vector<int> dp(n, 0);
    dp[0] = nums[0];
    dp[1] = std::max(nums[0], nums[1]);
    
    for (int i = 2; i < n; ++i) {
        // At each house, we either choose to rob it and add its value to the value
        // of the house two steps back, or we skip it and take the value from the
        // previous house.
        dp[i] = std::max(nums[i] + dp[i - 2], dp[i - 1]);
    }
    
    return dp[n - 1];
}

int main() {
    std::vector<int> nums = {2, 7, 9, 3, 1};
    std::cout << "Maximum amount of money that can be robbed: " << maxMoney(nums) << std::endl;
    return 0;
}
```

In this solution, we use a dynamic programming approach where we maintain an array `dp` to store the maximum money we can rob up to the `i-th` house. We iterate through the array, and at each step, we choose whether to rob the current house or not. The maximum amount of money we can rob up to the `i-th` house is either the sum of the money in the current house and the money in the house two steps back, or the maximum amount we can rob up to the previous house. Finally, we return `dp[n-1]`, which represents the maximum money we can rob up to the last house.

### 1. Algorithms & Data Structures (C++): Housing Implementation

Implementing housing data structures in C++ can be quite versatile, depending on the specific requirements and the scale of the application. Below, I'll outline a basic implementation for a housing system using classes in C++:

```cpp
#include <iostream>
#include <vector>
#include <string>

using namespace std;

// Define a class for Address
class Address {
public:
    string street;
    string city;
    string state;
    string zipCode;

    // Constructor
    Address(string street, string city, string state, string zipCode) : 
        street(street), city(city), state(state), zipCode(zipCode) {}

    // Function to display address details
    void display() {
        cout << street << ", " << city << ", " << state << " " << zipCode << endl;
    }
};

// Define a class for House
class House {
public:
    int houseNumber;
    int bedrooms;
    double bathrooms;
    double squareFootage;
    Address address;

    // Constructor
    House(int houseNumber, int bedrooms, double bathrooms, double squareFootage, Address address) :
        houseNumber(houseNumber), bedrooms(bedrooms), bathrooms(bathrooms), squareFootage(squareFootage), address(address) {}

    // Function to display house details
    void display() {
        cout << "House Number: " << houseNumber << endl;
        cout << "Bedrooms: " << bedrooms << endl;
        cout << "Bathrooms: " << bathrooms << endl;
        cout << "Square Footage: " << squareFootage << " sq. ft." << endl;
        cout << "Address: ";
        address.display();
    }
};

// Define a class for Housing Agency
class HousingAgency {
private:
    vector

<HousingAgency> class might hold instances of houses and provide functionality to manage them. Here's a continuation of the code:

```cpp
public:
    vector





```cpp


```cpp
    House> houses; // Vector to store houses

public:
    // Function to add a new house to the agency
    void addHouse(House house) {
        houses.push_back(house);
    }

    // Function to display all houses managed by the agency
    void displayHouses() {
        cout << "Houses managed by the agency:" << endl;
        for (const auto& house : houses) {
            house.display();
            cout << "------------------------" << endl;
        }
    }
};

int main() {
    // Create addresses
    Address address1("123 Main St", "Cityville", "Stateville", "12345");
    Address address2("456 Elm St", "Townburg", "Stateville", "54321");

    // Create houses
    House house1(1, 3, 2.5, 2000, address1);
    House house2(2, 4, 3, 2500, address2);

    // Create housing agency
    HousingAgency agency;

    // Add houses to the agency
    agency.addHouse(house1);
    agency.addHouse(house2);

    // Display houses managed by the agency
    agency.displayHouses();

    return 0;
}
```

This code provides a basic implementation of a housing system in C++. It defines classes for Address, House, and HousingAgency. The main function demonstrates how to create houses with addresses, add them to a housing agency, and display the details of all houses managed by the agency.

### 1. Algorithms & Data Structures (C++): How to evaluate Polish or Reverse Polish Notations

Evaluating Polish (prefix) and Reverse Polish (postfix) notations involves using a stack data structure to keep track of operands and applying operators in the correct order. Here's a general approach to evaluating both notations:

#### Polish Notation (Prefix)

1. Start scanning the expression from right to left.
2. If the token is an operand, push it onto the stack.
3. If the token is an operator, pop two operands from the stack, perform the operation, and push the result back onto the stack.
4. Continue until the entire expression is scanned.
5. The result will be the value left on the stack.

Example:

```bash
+ * 2 3 4
```

Evaluation:

1. Start from the right: `4` (operand), `3` (operand), `2` (operand), `*` (operator), `+` (operator).
2. Perform `2 * 3 = 6`, push `6` onto the stack.
3. Perform `6 + 4 = 10`, the result.

### Reverse Polish Notation (Postfix)

1. Start scanning the expression from left to right.
2. If the token is an operand, push it onto the stack.
3. If the token is an operator, pop two operands from the stack, perform the operation, and push the result back onto the stack.
4. Continue until the entire expression is scanned.
5. The result will be the value left on the stack.

Example:

```bash
2 3 * 4 +
```

Evaluation:

1. Start from the left: `2` (operand), `3` (operand), `*` (operator).
2. Perform `2 * 3 = 6`, push `6` onto the stack.
3. `4` (operand), `+` (operator).
4. Perform `6 + 4 = 10`, the result.

### C++ Implementation

```cpp
#include <iostream>
#include <stack>
#include <string>
#include <sstream>

using namespace std;

int evaluatePolish(string expression) {
    stack<int> operands;
    stringstream ss(expression);
    string token;

    while (ss >> token) {
        if (isdigit(token[0])) {
            operands.push(stoi(token));
        } else {
            int op2 = operands.top();
            operands.pop();
            int op1 = operands.top();
            operands.pop();

            if (token == "+") {
                operands.push(op1 + op2);
            } else if (token == "-") {
                operands.push(op1 - op2);
            } else if (token == "*") {
                operands.push(op1 * op2);
            } else if (token == "/") {
                operands.push(op1 / op2);
            }
        }
    }

    return operands.top();
}

int main() {
    string polishExpression = "+ * 2 3 4";
    cout << "Result: " << evaluatePolish(polishExpression) << endl;
    return 0;
}
```

This code evaluates a Polish notation expression. You can easily adapt it to evaluate a Reverse Polish notation by changing the input expression format or the evaluation logic.

### 1. Algorithms & Data Structures (C++): Insert interval

Inserting an interval into a set of intervals is a common problem in computer science, often encountered in tasks like interval scheduling, calendar applications, and database management systems. Below is a C++ function that inserts an interval into a sorted set of non-overlapping intervals:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct Interval {
    int start;
    int end;
    Interval() : start(0), end(0) {}
    Interval(int s, int e) : start(s), end(e) {}
};

vector<Interval> insertInterval(vector<Interval>& intervals, Interval newInterval) {
    vector<Interval> result;
    int n = intervals.size();
    int i = 0;

    // Insert all intervals that come before newInterval
    while (i < n && intervals[i].end < newInterval.start) {
        result.push_back(intervals[i]);
        i++;
    }

    // Merge overlapping intervals
    while (i < n && intervals[i].start <= newInterval.end) {
        newInterval.start = min(newInterval.start, intervals[i].start);
        newInterval.end = max(newInterval.end, intervals[i].end);
        i++;
    }

    // Insert the merged interval
    result.push_back(newInterval);

    // Insert all intervals that come after newInterval
    while (i < n) {
        result.push_back(intervals[i]);
        i++;
    }

    return result;
}

void printIntervals(const vector<Interval>& intervals) {
    for (const auto& interval : intervals) {
        cout << "[" << interval.start << ", " << interval.end << "] ";
    }
    cout << endl;
}

int main() {
    vector<Interval> intervals = {{1, 3}, {6, 9}};
    Interval newInterval(2, 5);

    cout << "Original intervals: ";
    printIntervals(intervals);

    cout << "New interval: [" << newInterval.start << ", " << newInterval.end << "]" << endl;

    vector<Interval> mergedIntervals = insertInterval(intervals, newInterval);

    cout << "Merged intervals: ";
    printIntervals(mergedIntervals);

    return 0;
}
```

This code first iterates through the existing intervals to find the correct position to insert the new interval. Then, it merges overlapping intervals with the new one, if any. Finally, it inserts the new interval into the result and returns the merged set of intervals.

You can test this code by running it and observing the output, which should show the original intervals, the new interval, and the merged intervals.

### 1. Algorithms & Data Structures (C++): Insert interval: Complexity analysis

The complexity analysis of inserting an interval into a data structure depends on the underlying data structure used. Let's consider a few scenarios:

1. **Array-based Data Structure**:
   If intervals are stored in an array sorted by their start points, inserting a new interval would require finding the correct position to insert it while maintaining the sorted order. This would typically have a time complexity of O(n) for finding the insertion position and O(n) for shifting elements to accommodate the new interval, resulting in an overall time complexity of O(n).

2. **Balanced Binary Search Tree (BST)**:
   If intervals are stored in a balanced binary search tree based on their start points, inserting a new interval would require traversing the tree to find the correct position to insert it. The insertion operation in a balanced BST takes O(log n) time on average, where n is the number of intervals already in the tree.

3. **Augmented Data Structures**:
   Augmented data structures, such as interval trees or segment trees, are specifically designed to handle interval-related operations efficiently. In an augmented data structure, additional information is stored at each node to facilitate efficient interval-related queries and modifications. Inserting an interval into such a data structure would typically involve updating the structure based on the characteristics of the particular data structure used. The time complexity would depend on the specific implementation but would often be O(log n) for balanced structures like interval trees or segment trees.

4. **Skip List**:
   Skip lists are a probabilistic alternative to balanced trees. They maintain a dynamic set of elements in sorted order. Inserting an interval into a skip list would involve finding the correct position to insert the interval, which can be done in O(log n) time on average.

In summary, the time complexity for inserting an interval into a data structure can range from O(n) in simple structures like arrays to O(log n) in more sophisticated data structures like balanced trees, interval trees, segment trees, or skip lists, depending on the specific implementation and characteristics of the data structure.

### 1. Algorithms & Data Structures (C++): Integer Replacement

Integer replacement is a classic problem that can be solved using recursion or dynamic programming. The task is to find the minimum number of replacements needed to convert one integer to another. Here's a C++ implementation using dynamic programming:

```cpp
#include <iostream>
#include <unordered_map>

using namespace std;

unordered_map<int, int> memo;

int minReplacements(int n) {
    if (n == 1) return 0;
    if (memo.find(n) != memo.end()) return memo[n];

    if (n % 2 == 0) {
        memo[n] = 1 + minReplacements(n / 2);
    } else {
        memo[n] = 1 + min(minReplacements(n - 1), minReplacements(n + 1));
    }
    return memo[n];
}

int main() {
    int num;
    cout << "Enter the number: ";
    cin >> num;

    cout << "Minimum replacements needed: " << minReplacements(num) << endl;

    return 0;
}
```

This code uses memoization to avoid redundant calculations. The function `minReplacements` calculates the minimum replacements recursively, considering two cases: if the number is even, halving it, and if it's odd, either incrementing or decrementing it and choosing the minimum of the two.

### 1. Algorithms & Data Structures (C++): Integer Reversal

Sure, here's a simple C++ function to reverse an integer:

```cpp
#include <iostream>

int reverseInteger(int x) {
    int reversed = 0;
    
    while (x != 0) {
        int digit = x % 10;
        reversed = reversed * 10 + digit;
        x /= 10;
    }
    
    return reversed;
}

int main() {
    int num;
    std::cout << "Enter an integer: ";
    std::cin >> num;
    
    int reversed = reverseInteger(num);
    
    std::cout << "Reversed integer: " << reversed << std::endl;
    
    return 0;
}
```

This function `reverseInteger` takes an integer `x` as input and returns its reverse. It repeatedly takes the last digit of `x` by using the modulus operator `%`, adds it to the `reversed` variable after multiplying it by 10 to shift the digits, and then removes the last digit from `x` by integer division `/`. The process repeats until `x` becomes 0. Finally, it returns the reversed integer.

### 1. Algorithms & Data Structures (C++): Interface Design - Interview Question - Monarchy

Sure! Let's design an interface for a monarchy system in C++. A monarchy system typically involves a hierarchy of royalty, with a king or queen at the top, followed by their children, grandchildren, and so on. Here's a basic outline of the interface:

```cpp
#include <string>
#include <vector>

class Person {
private:
    std::string name;
    std::vector<Person*> children;
    // Other relevant attributes like birthdate, etc. can be added.

public:
    Person(const std::string& name) : name(name) {}

    // Getters and setters for name and other attributes if needed

    const std::string& getName() const {
        return name;
    }

    void addChild(Person* child) {
        children.push_back(child);
    }

    const std::vector<Person*>& getChildren() const {
        return children;
    }
};

class Monarchy {
private:
    Person* kingOrQueen;

public:
    Monarchy(Person* kingOrQueen) : kingOrQueen(kingOrQueen) {}

    // Getters and setters for king/queen if needed

    Person* getKingOrQueen() const {
        return kingOrQueen;
    }

    // Other methods to manage the monarchy hierarchy, like adding heirs, etc.
};
```

This interface includes two classes: `Person` and `Monarchy`.

- The `Person` class represents an individual in the monarchy system. Each `Person` object has a name and a vector of children (other `Person` objects). You can add other relevant attributes such as birthdate, etc., as needed.

- The `Monarchy` class represents the monarchy itself. It contains a pointer to the king or queen (`Person` object). Additional methods can be added to manage the monarchy, such as adding heirs, checking the line of succession, etc.

This is a basic design, and depending on the requirements, you might need to add more functionality or modify existing methods. For example, you could include methods to remove heirs, search for a person in the hierarchy, or determine the next in line to the throne.

### 1. Algorithms & Data Structures (C++): Interview Question - Implement Prefix Trie

Sure, implementing a prefix trie (also known as a trie or prefix tree) is a common interview question. A trie is a tree-like data structure that stores a dynamic set of strings, where each node represents a single character of the string. Here's how you can implement it in C++:

```cpp
#include <iostream>
#include <unordered_map>
using namespace std;

// Trie Node
class TrieNode {
public:
    unordered_map<char, TrieNode*> children;
    bool isEndOfWord;

    TrieNode() {
        isEndOfWord = false;
    }
};

// Trie
class Trie {
public:
    TrieNode* root;

    Trie() {
        root = new TrieNode();
    }

    // Insert a word into the trie
    void insert(string word) {
        TrieNode* curr = root;
        for (char c : word) {
            if (curr->children.find(c) == curr->children.end()) {
                curr->children[c] = new TrieNode();
            }
            curr = curr->children[c];
        }
        curr->isEndOfWord = true;
    }

    // Search for a word in the trie
    bool search(string word) {
        TrieNode* curr = root;
        for (char c : word) {
            if (curr->children.find(c) == curr->children.end()) {
                return false;
            }
            curr = curr->children[c];
        }
        return curr->isEndOfWord;
    }

    // Check if a word with the given prefix exists in the trie
    bool startsWith(string prefix) {
        TrieNode* curr = root;
        for (char c : prefix) {
            if (curr->children.find(c) == curr->children.end()) {
                return false;
            }
            curr = curr->children[c];
        }
        return true;
    }
};

// Example usage
int main() {
    Trie trie;

    trie.insert("apple");
    cout << (trie.search("apple") ? "Found" : "Not found") << endl;   // Output: Found
    cout << (trie.search("app") ? "Found" : "Not found") << endl;     // Output: Not found
    cout << (trie.startsWith("app") ? "Found" : "Not found") << endl; // Output: Found

    return 0;
}
```

In this implementation:

- `TrieNode` represents a single node in the trie, which contains a map of child nodes for each character and a boolean flag indicating if the node marks the end of a word.
- `Trie` represents the trie data structure, containing operations to insert a word into the trie, search for a word, and check if a word with a given prefix exists in the trie.
- The `insert` function inserts a word character by character into the trie, creating new nodes as necessary.
- The `search` function searches for a given word in the trie, traversing down the trie character by character.
- The `startsWith` function checks if there is any word in the trie that starts with a given prefix by traversing the trie according to the prefix.

This implementation is efficient both in terms of time complexity and space complexity.

### 1. Algorithms & Data Structures (C++): Interview Question - Start And End Of Target In A Sorted Array

Sure! This question involves finding the start and end positions of a target value in a sorted array. This problem can be efficiently solved using a modified binary search algorithm. Here's how you can approach it in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

vector<int> searchRange(vector<int>& nums, int target) {
    int start = -1, end = -1;
    
    // Search for the start position
    int low = 0, high = nums.size() - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (nums[mid] == target) {
            start = mid;
            high = mid - 1; // Keep searching towards left for the start
        } else if (nums[mid] < target) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    
    // Search for the end position
    low = 0, high = nums.size() - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (nums[mid] == target) {
            end = mid;
            low = mid + 1; // Keep searching towards right for the end
        } else if (nums[mid] < target) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    
    return {start, end};
}

int main() {
    vector<int> nums = {5, 7, 7, 8, 8, 10};
    int target = 8;
    vector<int> result = searchRange(nums, target);
    
    cout << "Start position: " << result[0] << endl;
    cout << "End position: " << result[1] << endl;
    
    return 0;
}
```

This code first searches for the start position of the target value by repeatedly narrowing down the search space from both ends until it finds the target. Once the start position is found, it updates the high boundary to continue searching towards the left for the start position. Then, it searches for the end position by repeating a similar process, but this time updating the low boundary to continue searching towards the right for the end position. Finally, it returns the start and end positions as a vector.

### 1. Algorithms & Data Structures (C++): Interview Question: Kth Largest Element

Certainly! The problem of finding the Kth largest element in an array is a classic algorithm question that often comes up in technical interviews. Here's a common approach to solve it in C++ using various techniques:

#### Method 1: Sorting

One of the simplest ways to solve this problem is to sort the array in descending order and then return the Kth element.

```cpp
#include <vector>
#include <algorithm>

int findKthLargest(std::vector<int>& nums, int k) {
    std::sort(nums.begin(), nums.end(), std::greater<int>());
    return nums[k - 1];
}
```

#### Method 2: Using Priority Queue (Min Heap)

Another approach is to use a min-heap (priority queue) to keep track of the K largest elements. By maintaining a heap of size K, you can efficiently find the Kth largest element.

```cpp
#include <queue>
#include <vector>

int findKthLargest(std::vector<int>& nums, int k) {
    std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;
    for (int num : nums) {
        minHeap.push(num);
        if (minHeap.size() > k)
            minHeap.pop();
    }
    return minHeap.top();
}
```

#### Method 3: Using Quickselect Algorithm

Quickselect is a variation of the quicksort algorithm that selects the Kth smallest/largest element in an unordered list. It has an average time complexity of O(n), making it more efficient than sorting if you only need to find a single element.

```cpp
#include <vector>
#include <cstdlib>

int partition(std::vector<int>& nums, int left, int right) {
    int pivot = nums[right];
    int i = left - 1;
    for (int j = left; j < right; j++) {
        if (nums[j] >= pivot) {
            i++;
            std::swap(nums[i], nums[j]);
        }
    }
    std::swap(nums[i + 1], nums[right]);
    return i + 1;
}

int quickSelect(std::vector<int>& nums, int left, int right, int k) {
    if (left == right) return nums[left];
    int pivotIndex = partition(nums, left, right);
    if (pivotIndex == k) return nums[pivotIndex];
    else if (pivotIndex < k) return quickSelect(nums, pivotIndex + 1, right, k);
    else return quickSelect(nums, left, pivotIndex - 1, k);
}

int findKthLargest(std::vector<int>& nums, int k) {
    return quickSelect(nums, 0, nums.size() - 1, k - 1);
}
```

#### Example Usage

```cpp
#include <iostream>

int main() {
    std::vector<int> nums = {3, 2, 1, 5, 6, 4};
    int k = 2;
    std::cout << "The " << k << "nd largest element is: " << findKthLargest(nums, k) << std::endl;
    return 0;
}
```

These are some common methods to find the Kth largest element in an array. Each method has its pros and cons, and the best choice depends on factors like the size of the array and the value of K.

### 1. Algorithms & Data Structures (C++): Interview Questions: Arrays

Certainly! Here are some common interview questions related to arrays in the context of algorithms and data structures, along with their solutions in C++:

1. **Find the Missing Number**: Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.

    ```cpp
    int missingNumber(vector<int>& nums) {
        int n = nums.size();
        int total = n * (n + 1) / 2;
        int sum = accumulate(nums.begin(), nums.end(), 0);
        return total - sum;
    }
    ```

2. **Find the Duplicate Number**: Given an array containing n + 1 integers where each integer is between 1 and n (inclusive), find the duplicate one.

    ```cpp
    int findDuplicate(vector<int>& nums) {
        int slow = nums[0];
        int fast = nums[nums[0]];

        while (slow != fast) {
            slow = nums[slow];
            fast = nums[nums[fast]];
        }

        fast = 0;
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }

        return slow;
    }
    ```

3. **Find the Maximum Product of Two Integers in an Array**: Given an integer array, find the pair of integers that have the maximum product and return that product.

    ```cpp
    int maxProduct(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int n = nums.size();
        return max(nums[0] * nums[1], nums[n - 1] * nums[n - 2]);
    }
    ```

4. **Rotate Array**: Given an array, rotate the array to the right by k steps, where k is non-negative.

    ```cpp
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        k = k % n;
        reverse(nums.begin(), nums.end());
        reverse(nums.begin(), nums.begin() + k);
        reverse(nums.begin() + k, nums.end());
    }
    ```

5. **Merge Sorted Array**: Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.

    ```cpp
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int i = m - 1, j = n - 1, k = m + n - 1;
        while (i >= 0 && j >= 0) {
            if (nums1[i] > nums2[j])
                nums1[k--] = nums1[i--];
            else
                nums1[k--] = nums2[j--];
        }
        while (j >= 0) {
            nums1[k--] = nums2[j--];
        }
    }
    ```

These are just a few examples of array-related interview questions in C++. Understanding and practicing these can provide a good foundation for tackling similar problems in interviews.

### 1. Algorithms & Data Structures (C++): Interview Questions: Dynamic Programming

Certainly! Dynamic programming is a crucial topic in algorithms and often comes up in technical interviews. Here are some common interview questions related to dynamic programming in C++:

1. **Fibonacci Series**: Implement a function to find the nth Fibonacci number using dynamic programming.

```cpp
#include <iostream>
#include <vector>

int fibonacci(int n) {
    std::vector<int> dp(n + 1, 0);
    dp[1] = 1;
    for (int i = 2; i <= n; ++i) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}

int main() {
    int n = 10;
    std::cout << "Fibonacci(" << n << ") = " << fibonacci(n) << std::endl;
    return 0;
}
```

1. **Coin Change Problem**: Given a set of coins and a target amount, find the minimum number of coins needed to make up that amount.

```cpp
#include <iostream>
#include <vector>
#include <climits>

int minCoins(std::vector<int>& coins, int amount) {
    std::vector<int> dp(amount + 1, INT_MAX);
    dp[0] = 0;
    for (int i = 1; i <= amount; ++i) {
        for (int coin : coins) {
            if (coin <= i && dp[i - coin] != INT_MAX) {
                dp[i] = std::min(dp[i], dp[i - coin] + 1);
            }
        }
    }
    return dp[amount] == INT_MAX ? -1 : dp[amount];
}

int main() {
    std::vector<int> coins = {1, 2, 5};
    int amount = 11;
    std::cout << "Minimum coins required: " << minCoins(coins, amount) << std::endl;
    return 0;
}
```

1. **Longest Common Subsequence (LCS)**: Given two strings, find the length of the longest subsequence present in both of them.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int lcsLength(std::string& s1, std::string& s2) {
    int m = s1.length(), n = s2.length();
    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1, 0));

    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (s1[i - 1] == s2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = std::max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    return dp[m][n];
}

int main() {
    std::string s1 = "AGGTAB";
    std::string s2 = "GXTXAYB";
    std::cout << "Length of LCS is " << lcsLength(s1, s2) << std::endl;
    return 0;
}
```

These are just a few examples. Dynamic programming can be applied to a wide range of problems, and understanding its principles will greatly aid in solving algorithmic challenges in interviews.

### 1. Algorithms & Data Structures (C++): Inversion Count

Inversion count is a concept used in algorithms and data structures to measure how far an array is from being sorted. An inversion occurs when two elements in an array are out of order with respect to each other. For instance, in an array [2, 4, 1, 3], the pair (2, 1) and the pair (4, 1) are inversions because the first element in each pair is greater than the second.

The inversion count of an array is the total number of inversions present in the array. This count can be useful in various applications, such as analyzing the similarity between two rankings, sorting algorithms like Merge Sort, and more.

Here's a simple algorithm to calculate the inversion count of an array, implemented in C++ using a modified version of the Merge Sort algorithm:

```cpp
#include <iostream>
#include <vector>

using namespace std;

long long merge(vector<int> &arr, vector<int> &temp, int left, int mid, int right) {
    int i = left; // Index for left subarray
    int j = mid + 1; // Index for right subarray
    int k = left; // Index for temporary merged subarray
    long long inversionCount = 0;

    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++];
        } else {
            // If arr[i] > arr[j], it means arr[i] > all elements from arr[j] to arr[mid]
            // So, count all such elements and add to inversionCount
            inversionCount += mid - i + 1;
            temp[k++] = arr[j++];
        }
    }

    // Copy the remaining elements of left subarray
    while (i <= mid) {
        temp[k++] = arr[i++];
    }

    // Copy the remaining elements of right subarray
    while (j <= right) {
        temp[k++] = arr[j++];
    }

    // Copy the merged elements back to the original array
    for (int p = left; p <= right; p++) {
        arr[p] = temp[p];
    }

    return inversionCount;
}

long long mergeSort(vector<int> &arr, vector<int> &temp, int left, int right) {
    long long inversionCount = 0;
    if (left < right) {
        int mid = (left + right) / 2;

        // Recursively sort both halves and get inversion counts
        inversionCount += mergeSort(arr, temp, left, mid);
        inversionCount += mergeSort(arr, temp, mid + 1, right);

        // Merge the sorted halves
        inversionCount += merge(arr, temp, left, mid, right);
    }
    return inversionCount;
}

long long countInversions(vector<int> &arr) {
    int n = arr.size();
    vector<int> temp(n); // Temporary array for merge operation
    return mergeSort(arr, temp, 0, n - 1);
}

int main() {
    vector<int> arr = {1, 20, 6, 4, 5};
    cout << "Inversion count: " << countInversions(arr) << endl;
    return 0;
}
```

This code implements the Merge Sort algorithm with a modification to count the inversions while merging two sorted halves. It recursively divides the array into halves until each subarray has only one element and then merges them while counting the inversions. Finally, it returns the total inversion count.

### 1. Algorithms & Data Structures (C++): Inversion Count (Multiple Ways of solving it)

Sure! Inversion count is a classic problem in algorithms where you're given an array of integers and you need to find out how far each element in the array is from being sorted. An inversion occurs when two elements in the array are out of order. There are several ways to solve this problem, each with its own time complexity and approach. Here are a few common methods:

1. **Brute Force Approach**:
   - This approach involves iterating through all pairs of elements in the array and checking if they form an inversion.
   - Time Complexity: O(n^2)

2. **Merge Sort Based Approach**:
   - The idea is to use a modified version of the merge sort algorithm.
   - While merging two sorted halves of the array, count the inversions.
   - Time Complexity: O(n log n)

```cpp
#include <iostream>
#include <vector>

using namespace std;

int merge(vector<int>& arr, vector<int>& temp, int left, int mid, int right) {
    int inv_count = 0;
    int i = left; // Index for the left subarray
    int j = mid;  // Index for the right subarray
    int k = left; // Index for the merged array

    while ((i <= mid - 1) && (j <= right)) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
            inv_count += (mid - i); // Count inversions
        }
    }

    // Copy the remaining elements of left subarray
    while (i <= mid - 1) {
        temp[k++] = arr[i++];
    }

    // Copy the remaining elements of right subarray
    while (j <= right) {
        temp[k++] = arr[j++];
    }

    // Copy back the merged elements to the original array
    for (i = left; i <= right; i++) {
        arr[i] = temp[i];
    }

    return inv_count;
}

int mergeSort(vector<int>& arr, vector<int>& temp, int left, int right) {
    int inv_count = 0;
    if (left < right) {
        int mid = (left + right) / 2;
        inv_count += mergeSort(arr, temp, left, mid);     // Count inversions in left subarray
        inv_count += mergeSort(arr, temp, mid + 1, right); // Count inversions in right subarray
        inv_count += merge(arr, temp, left, mid + 1, right); // Merge the two halves
    }
    return inv_count;
}

int inversionCount(vector<int>& arr) {
    int n = arr.size();
    vector<int> temp(n);
    return mergeSort(arr, temp, 0, n - 1);
}

int main() {
    vector<int> arr = {1, 20, 6, 4, 5};
    cout << "Number of inversions: " << inversionCount(arr) << endl;
    return 0;
}
```

1. **Binary Indexed Tree or Fenwick Tree**:
   - You can also solve the inversion count problem using a Fenwick Tree.
   - Time Complexity: O(n log n)

These are some common methods for solving the inversion count problem. Each has its own trade-offs in terms of time complexity and implementation complexity.

### 1. Algorithms & Data Structures (C++): Inversion Count Using Fenwick Tree

Sure! Inversion count is a common problem in computer science that involves counting the number of pairs of elements in an array that are out of order. One efficient way to solve this problem is by using a Fenwick tree (also known as a Binary Indexed Tree or BIT). Here's how you can implement inversion count using a Fenwick tree in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// Implementation of Fenwick Tree
class FenwickTree {
private:
    vector<int> tree;

public:
    FenwickTree(int size) : tree(size + 1, 0) {}

    // Updates the value of the element at index idx by val
    void update(int idx, int val) {
        while (idx < tree.size()) {
            tree[idx] += val;
            idx += idx & -idx;
        }
    }

    // Returns the sum of elements from index 1 to idx
    int query(int idx) {
        int sum = 0;
        while (idx > 0) {
            sum += tree[idx];
            idx -= idx & -idx;
        }
        return sum;
    }
};

// Function to count inversions using Fenwick Tree
long long countInversions(vector<int>& nums) {
    int n = nums.size();
    long long inversions = 0;
    int maxNum = *max_element(nums.begin(), nums.end());

    FenwickTree tree(maxNum);

    for (int i = n - 1; i >= 0; --i) {
        inversions += tree.query(nums[i] - 1); // Query how many elements less than nums[i] exist
        tree.update(nums[i], 1); // Update the Fenwick Tree with current element
    }

    return inversions;
}

int main() {
    vector<int> nums = {5, 2, 6, 1};
    cout << "Inversion count: " << countInversions(nums) << endl;
    return 0;
}
```

In this implementation:

- We define a FenwickTree class to represent the Fenwick tree data structure. It supports two main operations: update and query.
- The `update` method is used to update the Fenwick tree with a new value at a given index.
- The `query` method is used to find the sum of elements from index 1 to a given index.
- The `countInversions` function takes a vector of integers and returns the count of inversions using the Fenwick tree approach.
- Inside `countInversions`, we iterate through the input array in reverse order, updating the Fenwick tree and counting inversions as we go.
- Finally, we test the implementation with a sample input array and output the inversion count.

This implementation has a time complexity of O(n log n), where n is the size of the input array.

### 1. Algorithms & Data Structures (C++): Inversion Count using PBDS

To implement an inversion count using PBDS (Policy Based Data Structures) in C++, you can use `std::set` along with `std::distance()` to find the number of inversions. Here's a sample implementation:

```cpp
#include <iostream>
#include <vector>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;

long long merge(ordered_set &oset, vector<int> &arr, int l, int mid, int r) {
    long long inversionCount = 0;
    vector<int> temp(r - l + 1);
    int i = l, j = mid + 1, k = 0;

    while (i <= mid && j <= r) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
            inversionCount += (mid - i + 1); // Count inversions
        }
    }

    while (i <= mid) {
        temp[k++] = arr[i++];
    }

    while (j <= r) {
        temp[k++] = arr[j++];
    }

    for (int p = 0; p < k; ++p) {
        arr[l + p] = temp[p];
    }

    return inversionCount;
}

long long mergeSort(ordered_set &oset, vector<int> &arr, int l, int r) {
    if (l >= r) return 0;
    int mid = l + (r - l) / 2;
    long long inversionCount = 0;
    inversionCount += mergeSort(oset, arr, l, mid);
    inversionCount += mergeSort(oset, arr, mid + 1, r);
    inversionCount += merge(oset, arr, l, mid, r);
    return inversionCount;
}

long long countInversions(vector<int> &arr) {
    ordered_set oset;
    return mergeSort(oset, arr, 0, arr.size() - 1);
}

int main() {
    vector<int> arr = {1, 20, 6, 4, 5};
    cout << "Inversion Count: " << countInversions(arr) << endl; // Output: 5
    return 0;
}
```

This implementation uses a modified merge sort to count inversions. The `ordered_set` data structure is used to maintain the sorted order of elements along with fast insertion and deletion. In the `merge()` function, the count of inversions is updated when elements are merged. Finally, the `mergeSort()` function recursively splits the array into halves and counts inversions while merging.

### 1. Algorithms & Data Structures (C++): irst Recurring Character

The problem of finding the first recurring character in a string involves iterating through the string and identifying the first character that appears more than once. We can solve this efficiently using a hash table (unordered_map in C++). Here's a C++ implementation:

```cpp
#include <iostream>
#include <unordered_map>

char firstRecurringChar(const std::string& str) {
    std::unordered_map<char, int> charCount;

    for (char c : str) {
        if (charCount[c] > 0) {
            return c; // Found the first recurring character
        } else {
            charCount[c]++;
        }
    }

    return '\0'; // No recurring character found
}

int main() {
    std::string input;
    std::cout << "Enter a string: ";
    std::cin >> input;

    char result = firstRecurringChar(input);
    if (result != '\0') {
        std::cout << "First recurring character: " << result << std::endl;
    } else {
        std::cout << "No recurring character found." << std::endl;
    }

    return 0;
}
```

In this code:

- We iterate through each character of the input string.
- We maintain a hash table (`charCount`) to store the count of each character encountered so far.
- If we encounter a character that already exists in the hash table with a count greater than 0, it means we've found the first recurring character, and we return it.
- If no recurring character is found, we return '\0'.

This solution has a time complexity of O(n) since it iterates through the string once, where 'n' is the length of the string, and the operations inside the loop are O(1) on average due to the constant-time lookup in the hash table.

### 1. Algorithms & Data Structures (C++): Jewels and Stones

Sure! The "Jewels and Stones" problem is a common algorithmic problem. Here's the problem statement:

You're given strings `J` representing the types of stones that are jewels, and `S` representing the stones you have. Each character in `S` is a type of stone you have. You want to know how many of the stones you have are also jewels.

The letters in `J` are guaranteed distinct, and all characters in `J` and `S` are letters. Letters are case sensitive, so `"a"` is considered a different type of stone from `"A"`.

Here's a C++ solution for this problem:

```cpp
#include <iostream>
#include <unordered_set>
using namespace std;

int numJewelsInStones(string J, string S) {
    unordered_set<char> jewelSet;
    for (char j : J) {
        jewelSet.insert(j);
    }

    int count = 0;
    for (char s : S) {
        if (jewelSet.find(s) != jewelSet.end()) {
            count++;
        }
    }

    return count;
}

int main() {
    string jewels = "aA";
    string stones = "aAAbbbb";
    cout << "Number of jewels in stones: " << numJewelsInStones(jewels, stones) << endl;
    return 0;
}
```

This code defines a function `numJewelsInStones` that takes two strings `J` and `S` and returns the count of jewels in stones. It does so by creating an unordered set `jewelSet` to store the types of jewels, then iterates over each character in `S` to count the jewels.

In the `main` function, we provide sample inputs `"aA"` for jewels and `"aAAbbbb"` for stones, and print the result of the function call.

### 1. Algorithms & Data Structures (C++): Job Sequencing with Deadlines

Sure, job sequencing with deadlines is a classic problem in computer science where you're given a set of jobs, each with a deadline and profit associated with it. The goal is to maximize the profit by scheduling the jobs in such a way that no deadline is missed. Here's a simple implementation in C++:

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

struct Job {
    char id;
    int deadline;
    int profit;
};

// Function to sort jobs based on profit
bool compare(Job a, Job b) {
    return (a.profit > b.profit);
}

// Function to find the maximum deadline among all jobs
int findMaxDeadline(vector

Sure, here's the completion of the code:

```cpp
// Function to find the maximum deadline among all jobs
int findMaxDeadline(vector

```cpp
    <Job>& arr) {
    int maxDeadline = INT_MIN;
    for (int i = 0; i < arr.size(); i++) {
        maxDeadline = max(maxDeadline, arr[i].deadline);
    }
    return maxDeadline;
}

// Function to perform job sequencing with deadlines
void jobSequencing(vector

```cpp
    <Job>& arr) {
    // Sort the jobs based on profit in non-increasing order
    sort(arr.begin(), arr.end(), compare);

    // Find the maximum deadline among all jobs
    int maxDeadline = findMaxDeadline(arr);

    // Initialize result array to store the scheduled jobs
    char result[maxDeadline];
    bool slot[maxDeadline];

    // Initialize all slots as free
    for (int i = 0; i < maxDeadline; i++) {
        slot[i] = false;
    }

    // Iterate through all jobs
    for (int i = 0; i < arr.size(); i++) {
        // Find a free slot before the deadline and schedule the job
        for (int j = min(maxDeadline, arr[i].deadline) - 1; j >= 0; j--) {
            if (!slot[j]) {
                result[j] = arr[i].id;
                slot[j] = true;
                break;
            }
        }
    }

    // Display the scheduled jobs
    cout << "Scheduled Jobs: ";
    for (int i = 0; i < maxDeadline; i++) {
        if (slot[i]) {
            cout << result[i] << " ";
        }
    }
    cout << endl;
}

int main() {
    vector

```cpp
    <Job> jobs = { {'a', 2, 100}, {'b', 1, 19}, {'c', 2, 27}, {'d', 1, 25}, {'e', 3, 15} };
    // Perform job sequencing
    jobSequencing(jobs);

    return 0;
}
```

This code defines a `Job` struct to represent each job, sorts the jobs in decreasing order of profit, finds the maximum deadline among all jobs, schedules the jobs using a greedy approach by iterating through each job and finding a free slot before its deadline, and finally displays the scheduled jobs. In the `main()` function, a sample set of jobs is provided, and the job sequencing function is called to demonstrate the scheduling.

### 1. Algorithms & Data Structures (C++): Josephus Circle

The Josephus problem is a classic problem in computer science and mathematics. It goes like this: There are \( n \) people standing in a circle waiting to be executed. Starting with the first person, every \( k \)th person will be executed, until only one person remains. The task is to find the position of the last survivor.

Here's a C++ implementation of the Josephus problem using a circular linked list:

```cpp
#include <iostream>

using namespace std;

// Node structure for circular linked list
struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

// Function to find the position of the last survivor
int josephus(int n, int k) {
    Node* head = new Node(1);
    Node* prev = head;
    for (int i = 2; i <= n; ++i) {
        prev->next = new Node(i);
        prev = prev->next;
    }
    prev->next = head; // Make the list circular

    Node* current = head;
    Node* prevToDelete = nullptr;
    int count = 0;

    // Traverse the circle until only one node remains
    while (current->next != current) {
        count++;
        if (count == k) {
            // Remove the current node
            prevToDelete->next = current->next;
            Node* temp = current;
            current = current->next;
            delete temp;
            count = 0;
        } else {
            prevToDelete = current;
            current = current->next;
        }
    }
    int survivor = current->data;
    delete current; // Delete the last remaining node
    return survivor;
}

int main() {
    int n = 7; // Number of people
    int k = 3; // Every k-th person is executed
    cout << "The position of the last survivor is: " << josephus(n, k) << endl;
    return 0;
}
```

In this implementation, we create a circular linked list with \( n \) nodes representing the people. We then traverse the list and remove every \( k \)th person until only one person remains. Finally, we return the position of the last survivor.

### 1. Algorithms & Data Structures (C++): Juggling Balls

The "Juggling Balls" problem is a classic algorithmic problem that involves rotating the elements of an array in a certain pattern. The problem statement usually goes like this:

You are given an array of size n representing n elements to be rotated. Also, given a positive integer k, you need to rotate the array to the right by k steps.

The challenge is to perform this rotation in-place with O(1) extra space. One popular solution to this problem is called the "Juggling Algorithm."

Here's how the Juggling Algorithm works:

1. Initialize a variable to count the number of elements rotated, let's call it `count`.
2. Start from index 0 and move to the next index by adding k to the current index.
3. If the next index is greater than or equal to n, take the modulus (remainder) of the next index with n to get the correct position in the array.
4. Swap the elements at the current index and the next index.
5. Increment the count by 1.
6. If count is less than n, repeat steps 2-5; otherwise, stop.

Here's a simple implementation of the Juggling Algorithm in C++:

```cpp
#include <iostream>
#include <vector>

void swap(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}

int gcd(int a, int b) {
    if (b == 0)
        return a;
    return gcd(b, a % b);
}

void rotate(std::vector<int>& nums, int k) {
    int n = nums.size();
    k = k % n; // Normalize k if it's greater than n
    int sets = gcd(n, k); // Find the number of sets to rotate
    for (int i = 0; i < sets; ++i) {
        int j = i;
        int temp = nums[j];
        while (true) {
            int next = (j + k) % n;
            if (next == i) // Back to the starting point of the set
                break;
            nums[j] = nums[next];
            j = next;
        }
        nums[j] = temp;
    }
}

int main() {
    std::vector<int> nums = {1, 2, 3, 4, 5, 6, 7};
    int k = 3;
    rotate(nums, k);
    for (int num : nums) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    return 0;
}
```

This implementation first calculates the greatest common divisor (gcd) of n and k to determine the number of sets of elements to be rotated. Then, it iterates through each set, swapping the elements within the set until it reaches the original starting point of the set. Finally, it updates the input array with the rotated elements.

### 1. Algorithms & Data Structures (C++): Jump Game

The "Jump Game" problem is a classic algorithmic problem where you're given an array of non-negative integers representing the maximum jump length from each position in the array. You need to determine if you can reach the last index starting from the first index.

Here's a C++ solution using a greedy approach:

```cpp
#include <vector>

bool canJump(std::vector<int>& nums) {
    int n = nums.size();
    int maxReach = 0; // maximum index that can be reached
    for (int i = 0; i < n; ++i) {
        if (maxReach < i) // if the current index is not reachable
            return false;
        maxReach = std::max(maxReach, i + nums[i]); // update the maximum reachable index
        if (maxReach >= n - 1) // if the last index is reachable
            return true;
    }
    return false;
}
```

Explanation:

- We iterate through the array. At each index `i`, we update `maxReach` to be the maximum index that can be reached from the indices `0` to `i`.
- If `maxReach` becomes less than `i`, it means that the current index `i` is not reachable from any previous index. In this case, we return `false`.
- If `maxReach` is greater than or equal to the last index (`n - 1`), it means we can reach the end of the array. In this case, we return `true`.
- Otherwise, we continue iterating through the array.
- If we finish the loop without reaching the last index, we return `false`.

This solution has a time complexity of O(n) where n is the size of the input array, and a space complexity of O(1).

### 1. Algorithms & Data Structures (C++): Jump Game - Arrays

In C++, solving the Jump Game problem involves designing an algorithm to determine whether you can reach the last index of an array starting from the first index. Here's a straightforward approach using arrays:

```cpp
#include <iostream>
#include <vector>

using namespace std;

bool canJump(vector<int>& nums) {
    int maxReach = 0;
    int n = nums.size();
    
    for (int i = 0; i < n; i++) {
        if (i > maxReach) {
            // If we cannot reach this index, return false
            return false;
        }
        maxReach = max(maxReach, i + nums[i]);
        
        if (maxReach >= n - 1) {
            // If we can reach or exceed the last index, return true
            return true;
        }
    }
    
    return false;
}

int main() {
    vector<int> nums = {2, 3, 1, 1, 4};
    if (canJump(nums)) {
        cout << "Yes, you can jump to the end of the array." << endl;
    } else {
        cout << "No, you cannot jump to the end of the array." << endl;
    }
    return 0;
}
```

In this solution:

- `maxReach` keeps track of the furthest index you can reach.
- We iterate through the array, updating `maxReach` with the maximum reachable index from the current position.
- If at any point `maxReach` is less than the current index, it means we can't move forward anymore, hence return false.
- If `maxReach` reaches or exceeds the last index, it means we can reach the end, so return true.
- Finally, if we iterate through the entire array without reaching the end, return false.

### 1. Algorithms & Data Structures (C++): Jump Game - Dynamic Programming

Sure! The "Jump Game" problem is a classic algorithmic problem where you are given an array of non-negative integers representing the maximum length you can jump at each position in the array. You need to determine if you can reach the last index starting from the first index.

Here's a dynamic programming approach to solve this problem efficiently in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

bool canJump(vector<int>& nums) {
    int n = nums.size();
    if (n == 0) return false;

    // dp[i] represents whether we can reach index i from index 0
    vector<bool> dp(n, false);
    dp[0] = true;

    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            // If we can reach index j and we can jump from index j to index i
            if (dp[j] && j + nums[j] >= i) {
                dp[i] = true;
                break;
            }
        }
    }

    return dp[n - 1];
}

int main() {
    vector<int> nums = {2, 3, 1, 1, 4}; // Example input
    if (canJump(nums)) {
        cout << "Yes, you can reach the last index from the first index." << endl;
    } else {
        cout << "No, you cannot reach the last index from the first index." << endl;
    }
    return 0;
}
```

In this solution, we use a boolean array `dp[]` where `dp[i]` represents whether we can reach index `i` from index `0`. We iterate through the array and update `dp[i]` based on whether we can reach any previous index `j` where `dp[j]` is `true` and the distance from `j` to `i` is within the jump range.

The time complexity of this solution is O(n^2), where n is the length of the input array `nums`. However, this solution can be optimized further to achieve a linear time complexity.

### 1. Algorithms & Data Structures (C++): K-Dimensional Dynammic Programming

K-dimensional dynamic programming (K-D DP) is an extension of traditional dynamic programming to handle problems with multiple dimensions. While traditional dynamic programming typically involves solving problems with a single dimension (e.g., sequences, strings), K-D DP deals with problems that have multiple independent dimensions, often represented by arrays, matrices, or higher-dimensional data structures.

Here's a general approach to solving problems using K-D DP:

1. **Identify the dimensions**: Understand the problem and identify the multiple independent dimensions involved. Each dimension typically represents some aspect of the problem that changes independently.

2. **Define the state**: Define a state that represents the combination of values across all dimensions. This state encapsulates all the information needed to make a decision at a particular point in the problem space.

3. **Formulate the recurrence relation**: Develop a recurrence relation that describes the optimal/suboptimal solution to the problem in terms of smaller subproblems. The recurrence relation should relate the current state to the states of smaller subproblems.

4. **Design the dynamic programming table**: Create a multidimensional table (often implemented using arrays or other data structures) to store the solutions to subproblems. The table should have dimensions corresponding to the dimensions of the problem.

5. **Fill the table**: Iterate over the dimensions of the table and fill in the entries using the recurrence relation. This is typically done in a bottom-up manner to ensure that all necessary subproblems are solved before solving larger ones.

6. **Retrieve the solution**: Once the table is filled, extract the solution from the final entry or entries of the table, depending on the problem's requirements.

Here's a simplified example of K-D DP in C++ to find the shortest path in a 2D grid:

```cpp
#include <iostream>
#include <vector>
#include <climits>
using namespace std;

int minPathSum(vector<vector<int>>& grid) {
    int m = grid.size();
    int n = grid[0].size();

    // Create a DP table
    vector<vector<int>> dp(m, vector<int>(n, 0));

    // Base case: DP table initialization
    dp[0][0] = grid[0][0];
    for (int i = 1; i < m; ++i)
        dp[i][0] = dp[i - 1][0] + grid[i][0];
    for (int j = 1; j < n; ++j)
        dp[0][j] = dp[0][j - 1] + grid[0][j];

    // Fill the DP table
    for (int i = 1; i < m; ++i) {
        for (int j = 1; j < n; ++j) {
            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
        }
    }

    // Return the solution
    return dp[m - 1][n - 1];
}

int main() {
    vector<vector<int>> grid = {{1, 3, 1}, {1, 5, 1}, {4, 2, 1}};
    cout << "Minimum path sum: " << minPathSum(grid) << endl;
    return 0;
}
```

This example demonstrates how to use 2D dynamic programming to find the minimum path sum in a 2D grid, using the bottom-up approach. The `minPathSum` function calculates the minimum path sum from the top-left corner to the bottom-right corner of the grid.

### 1. Algorithms & Data Structures (C++): K-Reverse

Sure, the K-Reverse algorithm is a common problem in computer science that involves reversing every K nodes of a linked list. Here's a basic implementation of the K-Reverse algorithm in C++:

```cpp
#include <iostream>

using namespace std;

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

ListNode* reverseKGroup(ListNode* head, int k) {
    if (head == nullptr || k == 1) return head;
    
    ListNode* dummy = new ListNode(-1);
    dummy->next = head;
    ListNode* prev = dummy;
    
    int count = 0;
    ListNode* curr = head;
    
    // Count the number of nodes in the linked list
    while (curr != nullptr) {
        count++;
        curr = curr->next;
    }
    
    while (count >= k) {
        curr = prev->next;
        ListNode* next_node = curr->next;
        for (int i = 1; i < k; i++) {
            curr->next = next_node->next;
            next_node->next = prev->next;
            prev->next = next_node;
            next_node = curr->next;
        }
        prev = curr;
        count -= k;
    }
    
    return dummy->next;
}

// Function to print the linked list
void printList(ListNode* head) {
    ListNode* curr = head;
    while (curr != nullptr) {
        cout << curr->val << " ";
        curr = curr->next;
    }
    cout << endl;
}

int main() {
    // Create a sample linked list: 1 -> 2 -> 3 -> 4 -> 5
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);
    
    int k = 2; // Reverse every 2 nodes
    
    cout << "Original linked list: ";
    printList(head);
    
    head = reverseKGroup(head, k);
    
    cout << "Linked list after K-Reverse: ";
    printList(head);
    
    return 0;
}
```

This code defines a `ListNode` struct representing a node in a singly-linked list and implements the `reverseKGroup` function to reverse every K nodes in the linked list. Finally, it provides a sample usage in the `main` function.

### 1. Algorithms & Data Structures (C++): K-Rotate

The K-Rotate algorithm is used to rotate an array in C++ by K positions to the right. Here's a simple implementation of the K-Rotate algorithm:

```cpp
#include <iostream>
#include <vector>

using namespace std;

void rotate(vector<int>& nums, int k) {
    int n = nums.size();
    // If k is greater than n, take modulo to avoid unnecessary rotations
    k = k % n;
    
    // Reverse the entire array
    reverse(nums.begin(), nums.end());
    // Reverse the first k elements
    reverse(nums.begin(), nums.begin() + k);
    // Reverse the remaining elements
    reverse(nums.begin() + k, nums.end());
}

int main() {
    vector<int> nums = {1, 2, 3, 4, 5};
    int k = 3;
    
    cout << "Original array: ";
    for (int num : nums) {
        cout << num << " ";
    }
    cout << endl;
    
    rotate(nums, k);
    
    cout << "Array after rotating " << k << " positions to the right: ";
    for (int num : nums) {
        cout << num << " ";
    }
    cout << endl;
    
    return 0;
}
```

This implementation first reverses the entire array, then reverses the first k elements, and finally reverses the remaining elements. This effectively rotates the array to the right by k positions.

### 1. Algorithms & Data Structures (C++): K-th Last

"K-th Last" is a common problem in algorithms and data structures where you're asked to find the k-th element from the end of a linked list. This problem can be efficiently solved using the two-pointer technique. Here's how you can implement it in C++:

```cpp
#include <iostream>
using namespace std;

// Node definition for the linked list
struct Node {
    int data;
    Node* next;
    Node(int value) : data(value), next(nullptr) {}
};

// Function to find the k-th last element of a linked list
Node* kthLast(Node* head, int k) {
    if (head == nullptr || k <= 0) return nullptr;

    Node* slow = head;
    Node* fast = head;

    // Move the fast pointer k positions ahead
    for (int i = 0; i < k; ++i) {
        if (fast == nullptr) return nullptr; // List has less than k nodes
        fast = fast->next;
    }

    // Move both pointers until the fast pointer reaches the end
    while (fast != nullptr) {
        slow = slow->next;
        fast = fast->next;
    }

    // Now, slow pointer is at k-th last node
    return slow;
}

// Function to print the linked list
void printList(Node* head) {
    while (head != nullptr) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

int main() {
    // Example usage
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);
    head->next->next->next->next = new Node(5);

    cout << "Original List: ";
    printList(head);

    int k = 2;
    Node* kthLastNode = kthLast(head, k);
    if (kthLastNode != nullptr)
        cout << "The " << k << "-th last element is: " << kthLastNode->data << endl;
    else
        cout << "The list has less than " << k << " elements." << endl;

    return 0;
}
```

This program defines a linked list structure and implements the `kthLast` function to find the k-th last element using the two-pointer technique. The `printList` function is for printing the linked list elements, and the `main` function demonstrates its usage.

### 1. Algorithms & Data Structures (C++): K-th Smallest Value

To find the K-th smallest value in an array or any collection of elements, you can use various algorithms. One of the efficient algorithms to solve this problem is the QuickSelect algorithm, which is a variation of the quicksort algorithm.

Here's how you can implement the K-th smallest value algorithm in C++ using the QuickSelect algorithm:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// Helper function to partition the array around a pivot
int partition(vector<int>& arr, int left, int right) {
    int pivot = arr[right]; // Choosing the rightmost element as pivot
    int i = left - 1; // Index of smaller element

    for (int j = left; j < right; ++j) {
        if (arr[j] <= pivot) {
            ++i;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i + 1], arr[right]);
    return i + 1;
}

// Function to find the K-th smallest element using QuickSelect algorithm
int kthSmallest(vector<int>& arr, int left, int right, int k) {
    if (k > 0 && k <= right - left + 1) {
        int pos = partition(arr, left, right);

        // If the position is the same as K
        if (pos - left == k - 1)
            return arr[pos];
        // If the position is more, recurse for the left subarray
        if (pos - left > k - 1)
            return kthSmallest(arr, left, pos - 1, k);
        // Else recurse for the right subarray
        return kthSmallest(arr, pos + 1, right, k - pos + left - 1);
    }
    // If k is out of bounds
    return INT_MAX;
}

int main() {
    vector<int> arr = {12, 3, 5, 7, 4, 19, 26};
    int k = 3; // Finding the 3rd smallest element

    int kth_smallest = kthSmallest(arr, 0, arr.size() - 1, k);

    cout << "The " << k << "-th smallest element is: " << kth_smallest << endl;

    return 0;
}
```

This code will output:

```bash
The 3-th smallest element is: 5
```

This code takes an array of integers `arr`, the indices of the leftmost and rightmost elements of the array (`left` and `right`), and the value of `k`, which represents the K-th smallest element to find. It uses the QuickSelect algorithm recursively to find the K-th smallest element.

### 1. Algorithms & Data Structures (C++): Keys and Rooms

The "Keys and Rooms" problem is a classic algorithmic problem that involves traversing through a graph to determine whether all rooms can be visited starting from one particular room. Here's a high-level approach to solve this problem using depth-first search (DFS) algorithm in C++:

```cpp
#include <iostream>
#include <vector>
#include <stack>
#include <unordered_set>

using namespace std;

bool canVisitAllRooms(vector<vector<int>>& rooms) {
    int n = rooms.size();
    vector<bool> visited(n, false);
    stack<int> stk;
    stk.push(0); // Start from room 0
    
    while (!stk.empty()) {
        int room = stk.top();
        stk.pop();
        if (!visited[room]) {
            visited[room] = true;
            for (int key : rooms[room]) {
                stk.push(key);
            }
        }
    }
    
    // Check if all rooms are visited
    for (bool v : visited) {
        if (!v) return false;
    }
    
    return true;
}

int main() {
    // Example usage
    vector<vector<int>> rooms = {{1, 3}, {3, 0, 1}, {2}, {0}};
    if (canVisitAllRooms(rooms)) {
        cout << "All rooms can be visited!" << endl;
    } else {
        cout << "All rooms cannot be visited!" << endl;
    }
    return 0;
}
```

In this code:

1. We initialize a vector `visited` to keep track of whether each room has been visited or not. Initially, all rooms are marked as unvisited.
2. We start DFS traversal from room 0. We use a stack to keep track of the rooms to visit next.
3. In each step of the DFS traversal, we pop a room from the stack, mark it as visited, and push all the keys in that room onto the stack if they haven't been visited yet.
4. After the DFS traversal is complete, we check if all rooms have been visited. If any room remains unvisited, then it means all rooms cannot be visited starting from room 0, so we return false. Otherwise, we return true.

This algorithm has a time complexity of O(n + m), where n is the number of rooms and m is the total number of keys in all rooms.

### 1. Algorithms & Data Structures (C++): Knapsack

The Knapsack problem is a classic optimization problem in computer science. Given a set of items, each with a weight and a value, determine the number of each item to include in a collection so that the total weight does not exceed a given limit and the total value is maximized.

In C++, you can solve the 0/1 Knapsack problem using dynamic programming. Here's a simple implementation:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Function to solve the 0/1 Knapsack problem
int knapsack(int W, const vector<int>& wt, const vector<int>& val, int n) {
    vector<vector<int>> dp(n + 1, vector<int>(W + 1, 0));

    for (int i = 0; i <= n; ++i) {
        for (int w = 0; w <= W; ++w) {
            if (i == 0 || w == 0)
                dp[i][w] = 0;
            else if (wt[i - 1] <= w)
                dp[i][w] = max(val[i - 1] + dp[i - 1][w - wt[i - 1]], dp[i - 1][w]);
            else
                dp[i][w] = dp[i - 1][w];
        }
    }

    return dp[n][W];
}

int main() {
    vector<int> val = {60, 100, 120};
    vector<int> wt = {10, 20, 30};
    int W = 50;
    int n = val.size();
    cout << "Maximum value that can be obtained: " << knapsack(W, wt, val, n) << endl;
    return 0;
}
```

In this implementation, the function `knapsack()` takes the total capacity of the knapsack `W`, the weights of the items `wt`, the values of the items `val`, and the number of items `n`. It returns the maximum value that can be obtained.

The dynamic programming table `dp` is filled iteratively to find the maximum value. The cell `dp[i][w]` represents the maximum value that can be obtained with the first `i` items and a knapsack capacity of `w`.

### 1. Algorithms & Data Structures (C++): Knapsack Problem

The Knapsack Problem is a classic optimization problem in computer science and is often used to demonstrate dynamic programming techniques. There are two main variations: the 0/1 knapsack problem and the fractional knapsack problem.

1. **0/1 Knapsack Problem**: In this variation, each item can either be selected (1) or rejected (0), meaning you can't take a fraction of an item. The goal is to maximize the total value of items selected while ensuring that the total weight does not exceed the capacity of the knapsack.

2. **Fractional Knapsack Problem**: In this version, items can be broken into smaller pieces, allowing fractions of items to be taken. The objective is still to maximize the total value of items selected while ensuring the total weight does not exceed the capacity of the knapsack.

Here's a basic implementation of the 0/1 Knapsack Problem in C++ using dynamic programming:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int knapsack(int capacity, const vector<int>& weights, const vector<int>& values, int n) {
    vector<vector<int>> dp(n + 1, vector<int>(capacity + 1, 0));

    for (int i = 1; i <= n; ++i) {
        for (int w = 1; w <= capacity; ++w) {
            if (weights[i - 1] > w) {
                dp[i][w] = dp[i - 1][w];
            } else {
                dp[i][w] = max(dp[i - 1][w], values[i - 1] + dp[i - 1][w - weights[i - 1]]);
            }
        }
    }

    return dp[n][capacity];
}

int main() {
    vector<int> values = {60, 100, 120};
    vector<int> weights = {10, 20, 30};
    int capacity = 50;
    int n = values.size();

    int maxValue = knapsack(capacity, weights, values, n);
    cout << "Maximum value that can be obtained: " << maxValue << endl;

    return 0;
}
```

In this implementation, `knapsack()` function calculates the maximum value that can be obtained given the capacity of the knapsack, weights, and values of items. The `dp` table stores the maximum value that can be obtained using the items up to index `i` and a knapsack of capacity `w`. The time complexity of this solution is O(n * capacity), where `n` is the number of items and `capacity` is the capacity of the knapsack.

### 1. Algorithms & Data Structures (C++): Knapsack Problem Bottom Up

Sure, the bottom-up approach to solving the Knapsack Problem in C++ involves building a table to store the maximum value that can be attained at each combination of item and weight. Here's a sample implementation:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// Structure to represent each item
struct Item {
    int weight;
    int value;
};

// Function to solve the Knapsack problem
int knapsack(int capacity, const vector<Item>& items) {
    int n = items.size();
    // Create a table to store results of subproblems
    vector<vector<int>> dp(n + 1, vector<int>(capacity + 1, 0));

    // Build table dp[][] in bottom up manner
    for (int i = 0; i <= n; ++i) {
        for (int w = 0; w <= capacity; ++w) {
            if (i == 0 || w == 0)
                dp[i][w] = 0;
            else if (items[i - 1].weight <= w)
                dp[i][w] = max(items[i - 1].value + dp[i - 1][w - items[i - 1].weight], dp[i - 1][w]);
            else
                dp[i][w] = dp[i - 1][w];
        }
    }

    return dp[n][capacity];
}

int main() {
    vector<Item> items = {{10, 60}, {20, 100}, {30, 120}};
    int capacity = 50;
    cout << "Maximum value that can be obtained: " << knapsack(capacity, items) << endl;
    return 0;
}
```

In this implementation:

- The `Item` struct represents each item with its weight and value.
- The `knapsack` function takes the knapsack capacity and a vector of items as input and returns the maximum value that can be attained.
- It initializes a 2D vector `dp` to store the maximum value that can be attained at each combination of items and capacities.
- The nested loops iterate over each item and capacity, filling the `dp` table according to the Knapsack problem's recurrence relation.
- Finally, it returns `dp[n][capacity]`, which represents the maximum value that can be attained using all items and the given capacity.

### 1. Algorithms & Data Structures (C++): Knapsack Problem Recursive

The knapsack problem is a classic optimization problem in computer science where given a set of items, each with a weight and a value, determine the number of each item to include in a collection so that the total weight is less than or equal to a given limit and the total value is maximized.

Here's a recursive solution to the 0/1 knapsack problem in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Function to solve 0/1 knapsack recursively
int knapsackRecursive(int W, vector<int>& weights, vector<int>& values, int n) {
    // Base case
    if (n == 0 || W == 0)
        return 0;

    // If weight of the nth item is more than knapsack capacity W,
    // then this item cannot be included in the optimal solution
    if (weights[n - 1] > W)
        return knapsackRecursive(W, weights, values, n - 1);

    // Return the maximum of two cases:
    // (1) nth item included
    // (2) not included
    else
        return max(values[n - 1] + knapsackRecursive(W - weights[n - 1], weights, values, n - 1),
                   knapsackRecursive(W, weights, values, n - 1));
}

int main() {
    vector<int> values = {60, 100, 120};
    vector<int> weights = {10, 20, 30};
    int W = 50; // Knapsack capacity
    int n = values.size(); // Number of items

    cout << "Maximum value that can be obtained: "
         << knapsackRecursive(W, weights, values, n) << endl;

    return 0;
}
```

In this code:

- `knapsackRecursive` is the recursive function that solves the problem.
- `W` is the maximum weight the knapsack can hold.
- `weights` and `values` are vectors representing the weights and values of items respectively.
- `n` is the number of items.

This recursive solution has exponential time complexity, so it's not suitable for large inputs. However, it serves as a good starting point for understanding the problem and developing more efficient dynamic programming solutions.

### 1. Algorithms & Data Structures (C++): Koch Curves

The Koch curve is a famous fractal curve, named after the Swedish mathematician Helge von Koch. It's constructed by starting with an equilateral triangle and iteratively replacing each line segment with four smaller segments, each one-third the length of the original. Here's a C++ implementation of the Koch curve using recursion:

```cpp
#include <iostream>
#include <cmath>

using namespace std;

struct Point {
    double x, y;
};

void drawKochCurve(Point start, Point end, int depth) {
    if (depth == 0) {
        cout << start.x << " " << start.y << endl;
        cout << end.x << " " << end.y << endl;
    } else {
        Point p1, p2, p3, p4, p5;
        
        p1.x = start.x + (end.x - start.x) / 3.0;
        p1.y = start.y + (end.y - start.y) / 3.0;

        p3.x = end.x - (end.x - start.x) / 3.0;
        p3.y = end.y - (end.y - start.y) / 3.0;

        double angle = M_PI / 3.0;
        p2.x = p1.x + (p3.x - p1.x) * cos(angle) - (p3.y - p1.y) * sin(angle);
        p2.y = p1.y + (p3.x - p1.x) * sin(angle) + (p3.y - p1.y) * cos(angle);

        drawKochCurve(start, p1, depth - 1);
        drawKochCurve(p1, p2, depth - 1);
        drawKochCurve(p2, p3, depth - 1);
        drawKochCurve(p3, end, depth - 1);
    }
}

int main() {
    Point start, end;
    int depth;

    cout << "Enter the starting point (x y): ";
    cin >> start.x >> start.y;
    cout << "Enter the ending point (x y): ";
    cin >> end.x >> end.y;
    cout << "Enter the depth of recursion: ";
    cin >> depth;

    cout << "Koch Curve Coordinates:" << endl;
    drawKochCurve(start, end, depth);

    return 0;
}
```

This program takes the starting and ending points of a line segment as input, along with the depth of recursion. It then outputs the coordinates of the points defining the Koch curve. You can run this code and play with different starting points and depths to see how the Koch curve evolves.

### 1. Algorithms & Data Structures (C++): Koko Eating Bananas

The "Koko Eating Bananas" problem is a classic algorithmic problem that can be solved using binary search. Here's an overview of the problem and a C++ implementation:

#### Problem Statement

Koko loves to eat bananas. There are `n` piles of bananas, the `i-th` pile has `piles[i]` bananas. The guards have gone and will come back in `H` hours.

Koko can decide her bananas-per-hour eating speed of `k`. Each hour, she chooses some pile of bananas and eats `k` bananas from that pile. If the pile has fewer than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.

Koko wants to eat as many bananas as possible within the `H` hours. Return the minimum integer `k` such that she can eat all the bananas within `H` hours.

#### Example

```bash
Input: piles = [3,6,7,11], H = 8
Output: 4
Explanation: If k = 4, she can eat [3,4,4,4] in 7 hours and [11] in the 8th hour.
```

#### Implementation (C++)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class Solution {
public:
    int minEatingSpeed(vector<int>& piles, int H) {
        int left = 1, right = *max_element(piles.begin(), piles.end());
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (!canEatAll(piles, H, mid))
                left = mid + 1;
            else
                right = mid;
        }
        return left;
    }

private:
    bool canEatAll(const vector<int>& piles, int H, int k) {
        int hours = 0;
        for (int bananas : piles) {
            hours += (bananas + k - 1) / k; // ceiling division
        }
        return hours <= H;
    }
};

int main() {
    Solution sol;
    vector<int> piles = {3, 6, 7, 11};
    int H = 8;
    cout << "Minimum eating speed: " << sol.minEatingSpeed(piles, H) << endl;
    return 0;
}
```

This implementation defines a `Solution` class with a `minEatingSpeed` method that takes the piles and `H` as input and returns the minimum eating speed. It uses binary search to find the optimal eating speed. The `canEatAll` function checks if it's possible to eat all bananas within `H` hours with a given eating speed.

### 1. Algorithms & Data Structures (C++): Large Factorials

Calculating large factorials can quickly exceed the range of built-in numeric types in most programming languages. For large factorials, it's common to use libraries that handle arbitrary-precision arithmetic or implement your own algorithms for the same purpose. Here's a C++ implementation using the Boost Multiprecision library for calculating large factorials:

```cpp
#include <iostream>
#include <boost/multiprecision/cpp_int.hpp>

namespace mp = boost::multiprecision;
using namespace std;

mp::cpp_int factorial(int n) {
    if (n == 0 || n == 1)
        return 1;
    mp::cpp_int result = 1;
    for (int i = 2; i <= n; ++i)
        result *= i;
    return result;
}

int main() {
    int n;
    cout << "Enter a number to calculate its factorial: ";
    cin >> n;
    cout << "Factorial of " << n << " is: " << factorial(n) << endl;
    return 0;
}
```

In this code:

- We include the necessary headers for input/output (`iostream`) and the Boost Multiprecision library (`boost/multiprecision/cpp_int.hpp`).
- We define a function `factorial` that calculates the factorial of a given integer `n`. It uses `mp::cpp_int` from Boost Multiprecision to handle large integers.
- In the `main` function, we prompt the user to enter a number and then calculate its factorial using the `factorial` function.

Remember to link against the Boost library when compiling your code. If you don't have the Boost library installed, you can download it from the official website (<https://www.boost.org/>) and follow the installation instructions. Alternatively, you can use other arbitrary-precision arithmetic libraries like GMP (GNU Multiple Precision Arithmetic Library) or implement your own algorithms for handling large integers.

### 1. Algorithms & Data Structures (C++): Largest Island

To find the largest island in a grid using C++, you can implement a Depth First Search (DFS) algorithm. Here's a basic outline of how you can do it:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Define directions for navigating neighboring cells
const int directions[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

// Function to perform DFS to find the size of the island
int dfs(vector<vector<int>>& grid, int row, int col) {
    int n = grid.size();
    int m = grid[0].size();
    
    // Base cases for out of bounds and water cells
    if (row < 0 || row >= n || col < 0 || col >= m || grid[row][col] == 0)
        return 0;
    
    // Mark cell as visited
    grid[row][col] = 0;
    
    // Initialize island size to 1
    int size = 1;
    
    // Explore neighboring cells
    for (int i = 0; i < 4; ++i) {
        int newRow = row + directions[i][0];
        int newCol = col + directions[i][1];
        size += dfs(grid, newRow, newCol);
    }
    
    return size;
}

// Function to find the largest island
int largestIsland(vector<vector<int>>& grid) {
    int n = grid.size();
    int m = grid[0].size();
    
    int maxIslandSize = 0;
    
    // Iterate through each cell
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (grid[i][j] == 1) {
                // If the cell is land, perform DFS to find the size of the island
                int islandSize = dfs(grid, i, j);
                // Update maxIslandSize if needed
                maxIslandSize = max(maxIslandSize, islandSize);
            }
        }
    }
    
    return maxIslandSize;
}

int main() {
    vector<vector<int>> grid = {
        {1, 1, 0, 0, 0},
        {1, 1, 0, 0, 0},
        {0, 0, 0, 1, 1},
        {0, 0, 0, 1, 1}
    };

    cout << "Size of largest island: " << largestIsland(grid) << endl;
    
    return 0;
}
```

This code defines a function `largestIsland` which takes a 2D grid representing the map where 1's represent land and 0's represent water. It then iterates through each cell of the grid, and if it encounters land (a cell with value 1), it performs DFS to find the size of the island connected to that cell. Finally, it returns the size of the largest island found.

### 1. Algorithms & Data Structures (C++): Last Index of Duplicate Numbers

To find the last index of duplicate numbers in an array using C++, you can iterate through the array from the end to the beginning, keeping track of the last index where each number occurs. Here's a simple implementation:

```cpp
#include <iostream>
#include <unordered_map>

int lastIndexDuplicate(const int arr[], int n) {
    std::unordered_map<int, int> lastIndexMap;
    int lastIndex = -1;

    for (int i = n - 1; i >= 0; --i) {
        if (lastIndexMap.find(arr[i]) == lastIndexMap.end()) {
            lastIndexMap[arr[i]] = i;
        } else {
            lastIndex = std::max(lastIndex, lastIndexMap[arr[i]]);
        }
    }

    return lastIndex;
}

int main() {
    int arr[] = {1, 2, 3, 4, 5, 2, 6, 7, 8, 2};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    int lastIndex = lastIndexDuplicate(arr, n);
    
    if (lastIndex != -1) {
        std::cout << "Last index of duplicate number: " << lastIndex << std::endl;
    } else {
        std::cout << "No duplicate numbers found." << std::endl;
    }

    return 0;
}
```

In this code:

1. We iterate through the array from the end to the beginning.
2. We maintain a `std::unordered_map` to store the last index of each number encountered.
3. If a number is encountered for the first time, we store its index in the map.
4. If a number is encountered again, we update the `lastIndex` variable with the maximum of its current value and the index stored in the map.
5. Finally, we return the `lastIndex`, which represents the last index of a duplicate number encountered in the array. If no duplicate numbers are found, we return -1.

### 1. Algorithms & Data Structures (C++): LCA

In computer science, "LCA" typically stands for Lowest Common Ancestor, a common problem in trees and graphs. The Lowest Common Ancestor of two nodes in a tree (or a Directed Acyclic Graph) is the shared ancestor that is located farthest from the root. It's a fundamental problem with various applications, like finding the nearest common ancestor of two nodes in a family tree or determining the closest common manager in an organizational hierarchy.

Here's a simple approach to finding the Lowest Common Ancestor in a binary tree using C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Utility function to find the path from root to a given node
bool findPath(TreeNode* root, int target, vector<int>& path) {
    if (root == nullptr) return false;
    
    path.push_back(root->val);
    
    if (root->val == target) return true;
    
    if (findPath(root->left, target, path) || findPath(root->right, target, path))
        return true;
    
    path.pop_back();
    return false;
}

// Function to find LCA of two nodes in a binary tree
int findLCA(TreeNode* root, int node1, int node2) {
    vector<int> path1, path2;
    
    if (!findPath(root, node1, path1) || !findPath(root, node2, path2)) {
        return -1; // If either of the nodes doesn't exist in the tree
    }
    
    int i;
    for (i = 0; i < min(path1.size(), path2.size()); i++) {
        if (path1[i] != path2[i]) {
            break;
        }
    }
    
    return path1[i-1];
}

int main() {
    TreeNode* root = new TreeNode(3);
    root->left = new TreeNode(5);
    root->right = new TreeNode(1);
    root->left->left = new TreeNode(6);
    root->left->right = new TreeNode(2);
    root->right->left = new TreeNode(0);
    root->right->right = new TreeNode(8);
    root->left->right->left = new TreeNode(7);
    root->left->right->right = new TreeNode(4);
    
    int node1 = 5, node2 = 1;
    int lca = findLCA(root, node1, node2);
    
    if (lca != -1) {
        cout << "Lowest Common Ancestor of " << node1 << " and " << node2 << " is " << lca << endl;
    } else {
        cout << "One or both of the nodes are not present in the tree." << endl;
    }
    
    return 0;
}
```

This code first finds the paths from the root to the two given nodes, then compares the paths to find the last common node. This node is the Lowest Common Ancestor. This approach works for binary trees. For more complex trees or graphs, different algorithms like Tarjan's algorithm or using dynamic programming may be employed.

### 1. Algorithms & Data Structures (C++): LCA Brute Force

Sure, let's start with the basics. LCA stands for Lowest Common Ancestor, a common problem in computer science and specifically in tree data structures.

In the context of a binary tree, the lowest common ancestor of two nodes `u` and `v` is the lowest (i.e., deepest) node that has both `u` and `v` as descendants.

A brute force approach to finding the LCA involves traversing from the root to each of the nodes and recording the path taken. Then, you compare the paths to find the deepest node that is common to both paths. Here's how you can implement this in C++:

```cpp

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

// Function to find the path from root to a given node
bool findPath(TreeNode* root, int target, vector<TreeNode*>& path) {
    // Base case: if root is null, return false
    if (root == nullptr)
        return false;
    
    // Add the current node to the path
    path.push_back(root);
    
    // If the current node is the target node, return true
    if (root->val == target)
        return true;
    
    // If the target is present in the left or right subtree, return true
    if ((root->left && findPath(root->left, target, path)) || (root->right && findPath(root->right, target, path)))
        return true;
    
    // If target is not present in the subtree rooted with the current node, remove it from the path and return false
    path.pop_back();
    return false;
}

// Function to find the lowest common ancestor of two nodes in a binary tree
TreeNode* lowestCommonAncestor(TreeNode* root, int p, int q) {
    // Vector to store the paths from root to p and q
    vector<TreeNode*> path1, path2;
    
    // Find paths from root to p and q
    if (!findPath(root, p, path1) || !findPath(root, q, path2))
        return nullptr;
    
    // Compare paths to find the lowest common ancestor
    TreeNode* lca = nullptr;
    for (int i = 0; i < min(path1.size(), path2.size()); ++i) {
        if (path1[i] == path2[i])
            lca = path1[i];
        else
            break; // Stop if paths diverge
    }
    
    return lca;
}

// Helper function to create a binary tree from an array
TreeNode* createTree(const vector<int>& nodes, int index) {
    TreeNode* root = nullptr;
    if (index < nodes.size() && nodes[index] != -1) {
        root = new TreeNode(nodes[index]);
        root->left = createTree(nodes, 2 * index + 1);
        root->right = createTree(nodes, 2 * index + 2);
    }
    return root;
}

int main() {
    // Example usage
    vector<int> nodes = {3, 5, 1, 6, 2, 0, 8, -1, -1, 7, 4}; // Example binary tree
    TreeNode* root = createTree(nodes, 0);
    
    // Find LCA of nodes with values 5 and 1
    TreeNode* lca = lowestCommonAncestor(root, 5, 1);
    
    if (lca != nullptr)
        cout << "Lowest Common Ancestor: " << lca->val << endl;
    else
        cout << "One or both nodes not found in the tree." << endl;
    
    return 0;
}
```

This code first defines a structure for a binary tree node. Then it implements two functions: `findPath` to find the path from the root to a given node, and `lowestCommonAncestor` to find the lowest common ancestor of two nodes using brute force method. Finally, it demonstrates the usage of these functions with an example binary tree.

### 1. Algorithms & Data Structures (C++): LCA using Binary Lifting

To implement Lowest Common Ancestor (LCA) using Binary Lifting in C++, you'll need to create a data structure to represent your tree and then implement the binary lifting algorithm. Here's a basic implementation:

```cpp
#include <iostream>
#include <vector>
#include <cmath>

using namespace std;

const int MAXN = 10005; // Maximum number of nodes in the tree
const int LOGN = 20;    // Logarithm of maximum number of nodes

vector<int> tree[MAXN];
int depth[MAXN];
int parent[MAXN][LOGN]; // parent[i][j] stores the 2^j-th ancestor of node i

void dfs(int node, int par, int dep) {
    parent[node][0] = par;
    depth[node] = dep;
    for (int i = 0; i < tree[node].size(); ++i) {
        int child = tree[node][i];
        if (child != par) {
            dfs(child, node, dep + 1);
        }
    }
}

void binaryLift(int n) {
    for (int j = 1; j < LOGN; ++j) {
        for (int i = 1; i <= n; ++i) {
            if (parent[i][j - 1] != -1) {
                parent[i][j] = parent[parent[i][j - 1]][j - 1];
            }
        }
    }
}

int lca(int u, int v) {
    if (depth[u] < depth[v]) swap(u, v);
    int diff = depth[u] - depth[v];
    // Lift u up to the same level as v
    for (int i = 0; i < LOGN; ++i) {
        if ((diff >> i) & 1) {
            u = parent[u][i];
        }
    }
    if (u == v) return u;
    // Now both u and v are at the same depth
    for (int i = LOGN - 1; i >= 0; --i) {
        if (parent[u][i] != parent[v][i]) {
            u = parent[u][i];
            v = parent[v][i];
        }
    }
    return parent[u][0];
}

int main() {
    int n; // Number of nodes
    cin >> n;
    for (int i = 1; i < n; ++i) {
        int u, v;
        cin >> u >> v;
        tree[u].push_back(v);
        tree[v].push_back(u);
    }
    // Initialize parent array with -1
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j < LOGN; ++j) {
            parent[i][j] = -1;
        }
    }
    // Depth-first search to set depths and parents
    dfs(1, -1, 0);
    // Precompute parent array using binary lifting
    binaryLift(n);
    int q; // Number of queries
    cin >> q;
    while (q--) {
        int u, v; // Nodes for which LCA is to be found
        cin >> u >> v;
        cout << "LCA of " << u << " and " << v << " is " << lca(u, v) << endl;
    }
    return 0;
}
```

This code defines a tree with a maximum of `MAXN` nodes and implements LCA using Binary Lifting. You can input the tree structure and then query for the LCA of different pairs of nodes.

### 1. Algorithms & Data Structures (C++): License Key Formatting

The License Key Formatting problem is a common algorithmic problem where you're given a string representing the license key which consists only alphanumeric characters and dashes. The string is separated into N+1 groups by N dashes. You need to reformat the string such that each group contains exactly K characters, except for the first group which could be shorter than K but still must contain at least one character. Also, there should be no dashes in the reformatted string, and all the characters should be converted to uppercase.

Here's a simple approach to solve this problem in C++:

```cpp
#include <iostream>
#include <string>

using namespace std;

string licenseKeyFormatting(string S, int K) {
    string result = "";

    int count = 0;
    for (int i = S.size() - 1; i >= 0; i--) {
        if (S[i] != '-') {
            result = (char)toupper(S[i]) + result;
            count++;
            if (count % K == 0)
                result = '-' + result;
        }
    }

    if (!result.empty() && result[0] == '-')
        result = result.substr(1);

    return result;
}

int main() {
    string S = "2-4A0r7-4k";
    int K = 4;
    cout << licenseKeyFormatting(S, K) << endl;
    return 0;
}
```

This code will take a string `S` and an integer `K` as input, where `S` represents the license key and `K` represents the group size. It then returns the formatted license key according to the specified rules. The `main()` function demonstrates how to use this function.

The time complexity of this solution is O(n), where n is the length of the original string `S`.

### 1. Algorithms & Data Structures (C++): Linear Diophantine Equation - Family of Solutions

Linear Diophantine equations are equations of the form \( ax + by = c \), where \( a \), \( b \), and \( c \) are integers, and \( x \) and \( y \) are unknowns to be solved for. Solving such equations involves finding integer solutions for \( x \) and \( y \).

Here's a simple C++ implementation to find a solution for a linear Diophantine equation:

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

// Function to find the solution to the linear Diophantine equation ax + by = c
// Returns true if a solution exists, false otherwise
bool findDiophantineSolution(int a, int b, int c, int &x, int &y) {
    int gcd = __gcd(a, b);

    // Check if c is divisible by gcd(a, b)
    if (c % gcd != 0) return false;

    // Extended Euclidean Algorithm to find x and y
    int x0 = 1, y0 = 0, x1 = 0, y1 = 1;
    int q, r, x2, y2;

    while (b) {
        q = a / b;
        r = a % b;
        x2 = x0 - q * x1;
        y2 = y0 - q * y1;
        a = b;
        b = r;
        x0 = x1;
        y0 = y1;
        x1 = x2;
        y1 = y2;
    }

    x = x0 * (c / gcd);
    y = y0 * (c / gcd);

    return true;
}

int main() {
    int a, b, c, x, y;

    cout << "Enter coefficients a, b, and c for the equation ax + by = c: ";
    cin >> a >> b >> c;

    if (findDiophantineSolution(a, b, c, x, y)) {
        cout << "Solution: x = " << x << ", y = " << y << endl;
    } else {
        cout << "No solution exists.\n";
    }

    return 0;
}
```

This program uses the Extended Euclidean Algorithm to find \( x \) and \( y \) such that \( ax + by = \text{gcd}(a, b) \), then scales the solution appropriately to satisfy \( ax + by = c \).

### 1. Algorithms & Data Structures (C++): Linear Diophantine Equations

Linear Diophantine equations are polynomial equations of the form:

ax + by = c

where a, b, and c are integers, and x and y are unknown integers to be solved for. Solving such equations involves finding integer solutions for x and y that satisfy the equation.

Here's an algorithm to solve linear Diophantine equations of the form ax + by = c:

1. **Check if a and b are relatively prime**: If gcd(a, b) does not divide c evenly (i.e., c % gcd(a, b) ≠ 0), then the equation has no integer solutions.

2. **Find one solution**: Use the Extended Euclidean Algorithm to find one solution (x0, y0) to the equation ax + by = gcd(a, b).

3. **Generalize the solution**: Any other solution can be found by adding (b/gcd(a, b)) *k to x0 and subtracting (a/gcd(a, b))* k from y0, where k is an integer. This step ensures that the solution remains valid.

Here's how you can implement this algorithm in C++:

```cpp
#include <iostream>
using namespace std;

// Function to find gcd(a, b) using Euclidean algorithm
int gcd(int a, int b, int &x, int &y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    int x1, y1;
    int d = gcd(b, a % b, x1, y1);
    x = y1;
    y = x1 - (a / b) * y1;
    return d;
}

// Function to solve linear Diophantine equation ax + by = c
bool solveDiophantine(int a, int b, int c, int &x, int &y) {
    int x0, y0;
    int d = gcd(a, b, x0, y0);

    // If c is not divisible by gcd(a, b), no solution exists
    if (c % d != 0)
        return false;

    // Multiply the initial solution by c/d to get a solution to ax + by = c
    x = x0 * (c / d);
    y = y0 * (c / d);
    return true;
}

int main() {
    int a, b, c;
    cout << "Enter coefficients of the equation (ax + by = c): ";
    cin >> a >> b >> c;

    int x, y;
    if (solveDiophantine(a, b, c, x, y)) {
        cout << "One solution is: x = " << x << ", y = " << y << endl;
    } else {
        cout << "No solution exists." << endl;
    }

    return 0;
}
```

This code takes coefficients a, b, and c as input and outputs one solution to the given Diophantine equation ax + by = c if it exists.

### 1. Algorithms & Data Structures (C++): Longest Band

The "Longest Band" problem involves finding the length of the longest contiguous sequence of integers such that the difference between any two consecutive elements is either 0 or 1. Here's a simple approach to solve it using C++:

```cpp
#include <iostream>
#include <unordered_set>
#include <vector>

using namespace std;

int longestBand(vector<int> arr) {
    unordered_set<int> elements(arr.begin(), arr.end());
    int maxBandLength = 0;

    for (int num : elements) {
        if (elements.find(num - 1) != elements.end()) continue; // Skip if num-1 exists, as it will be part of another band

        int currentNum = num;
        int currentBandLength = 0;

        while (elements.find(currentNum) != elements.end()) {
            currentBandLength++;
            currentNum++;
        }

        maxBandLength = max(maxBandLength, currentBandLength);
    }

    return maxBandLength;
}

int main() {
    vector<int> arr = {1, 9, 3, 0, 18, 5, 2, 4, 10, 7, 12, 6};
    cout << "Length of the longest band: " << longestBand(arr) << endl;
    return 0;
}
```

Explanation:

- We first convert the array into an unordered set to quickly check for the presence of elements.
- Then, for each unique element in the set, we check if the previous number (current number - 1) exists in the set. If it does, it means the current number is part of another band, so we skip it.
- For each element that starts a potential band, we count the length of that band by incrementing the current number until there is no consecutive number present in the set.
- We update the maxBandLength whenever we find a longer band.
- Finally, we return the maximum band length found.

This solution has a time complexity of O(n), where n is the number of elements in the array.

### 1. Algorithms & Data Structures (C++): Longest Common Path

The longest common path problem is a classic computer science problem that deals with finding the longest path that is common between two given paths in a file system. This problem can be solved using dynamic programming.

Here's a basic outline of how you can approach solving the longest common path problem in C++:

```cpp
#include <iostream>
#include <vector>
#include <string>

using namespace std;

// Function to find the longest common path
string longestCommonPath(const string& path1, const string& path2) {
    // Split the paths into directories
    vector<string> dirs1;
    vector<string> dirs2;

    size_t pos = 0;
    string token;

    while ((pos = path1.find('/')) != string::npos) {
        token = path1.substr(0, pos);
        dirs1.push_back(token);
        path1.erase(0, pos + 1);
    }
    dirs1.push_back(path1);

    pos = 0;
    while ((pos = path2.find('/')) != string::npos) {
        token = path2.substr(0, pos);
        dirs2.push_back(token);
        path2.erase(0, pos + 1);
    }
    dirs2.push_back(path2);

    // Initialize a 2D array for dynamic programming
    int m = dirs1.size();
    int n = dirs2.size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

    // Fill the dp array
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (dirs1[i - 1] == dirs2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    // Reconstruct the longest common path
    string result;
    int i = m, j = n;
    while (i > 0 && j > 0) {
        if (dirs1[i - 1] == dirs2[j - 1]) {
            result = "/" + dirs1[i - 1] + result;
            i--;
            j--;
        } else if (dp[i - 1][j] > dp[i][j - 1]) {
            i--;
        } else {
            j--;
        }
    }

    return result;
}

int main() {
    string path1 = "/home/user/documents/folder1";
    string path2 = "/home/user/documents/folder2";

    string longestCommon = longestCommonPath(path1, path2);
    if (!longestCommon.empty()) {
        cout << "Longest Common Path: " << longestCommon << endl;
    } else {
        cout << "No common path found." << endl;
    }

    return 0;
}
```

This code snippet demonstrates how to find the longest common path between two given paths. You can customize it further based on your requirements, such as error handling, input validation, or handling edge cases.

### 1. Algorithms & Data Structures (C++): Longest Common Prefix

To find the longest common prefix among a set of strings, you can use the following algorithm:

1. Start with the first string as the initial prefix candidate.
2. Iterate through the remaining strings, comparing each character of the prefix candidate with the corresponding character of the current string.
3. If at any point a mismatch is found or the prefix candidate reaches the end of its length, return the prefix up to the mismatch position.
4. If all strings have been compared and no mismatches occurred, return the prefix candidate.

Here's a C++ implementation of this algorithm:

```cpp
#include <iostream>
#include <vector>
#include <string>

using namespace std;

string longestCommonPrefix(vector<string>& strs) {
    if (strs.empty()) return ""; // If the vector is empty, return an empty string

    // Start with the first string as the initial prefix candidate
    string prefix = strs[0];
    
    for (int i = 1; i < strs.size(); ++i) {
        int j = 0;
        // Compare each character of the prefix candidate with the corresponding character of the current string
        while (j < prefix.size() && j < strs[i].size() && prefix[j] == strs[i][j]) {
            ++j;
        }
        // If a mismatch is found or the prefix candidate reaches the end of its length, return the prefix up to the mismatch position
        prefix = prefix.substr(0, j);
        if (prefix.empty()) return "";
    }
    
    return prefix;
}

int main() {
    // Example usage
    vector<string> strs = {"flower", "flow", "flight"};
    cout << "Longest common prefix: " << longestCommonPrefix(strs) << endl;
    return 0;
}
```

This code will output:

```bash
Longest common prefix: fl
```

This is because the longest common prefix among the strings "flower", "flow", and "flight" is "fl".

### 1. Algorithms & Data Structures (C++): Longest Common Sequence Problem

The Longest Common Subsequence (LCS) problem is a classic problem in computer science and is commonly used in bioinformatics, text comparison, and version control systems. The problem is defined as finding the longest subsequence that is present in two given sequences (strings).

Here's a basic approach to solve the Longest Common Subsequence problem using dynamic programming in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// Function to find the length of the longest common subsequence
int longestCommonSubsequence(string text1, string text2) {
    int m = text1.size();
    int n = text2.size();
    
    // Create a 2D vector to store the lengths of LCS
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
    
    // Fill the dp array
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (text1[i - 1] == text2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    
    // Length of LCS is stored in dp[m][n]
    return dp[m][n];
}

int main() {
    string text1 = "abcdef";
    string text2 = "acbcf";
    cout << "Length of longest common subsequence: " << longestCommonSubsequence(text1, text2) << endl;
    return 0;
}
```

This code calculates the length of the longest common subsequence of two given strings `text1` and `text2`. The function `longestCommonSubsequence` returns the length of the LCS.

The time complexity of this solution is O(m * n), where m and n are the lengths of the input strings `text1` and `text2`, respectively. This is because we are filling up a 2D array of size (m+1) x (n+1) and each cell takes constant time to compute.

### 1. Algorithms & Data Structures (C++): Longest Common Sub Sequence

Implementing the Longest Common Subsequence (LCS) algorithm in C++ involves dynamic programming. Here's a basic implementation:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

std::string longestCommonSubsequence(const std::string& str1, const std::string& str2) {
    int m = str1.length();
    int n = str2.length();
    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1, 0));

    // Building the dp table
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (str1[i - 1] == str2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = std::max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    // Backtracking to find the LCS
    int length = dp[m][n];
    std::string result(length, ' ');
    int i = m, j = n;
    while (i > 0 && j > 0) {
        if (str1[i - 1] == str2[j - 1]) {
            result[--length] = str1[i - 1];
            --i;
            --j;
        } else if (dp[i - 1][j] > dp[i][j - 1]) {
            --i;
        } else {
            --j;
        }
    }

    return result;
}

int main() {
    std::string str1 = "ABCDGH";
    std::string str2 = "AEDFHR";
    std::string lcs = longestCommonSubsequence(str1, str2);
    std::cout << "Longest Common Subsequence: " << lcs << std::endl;
    return 0;
}
```

This code first constructs a 2D dynamic programming table `dp`, where `dp[i][j]` represents the length of the longest common subsequence of `str1.substr(0, i)` and `str2.substr(0, j)`. Then, it backtracks through this table to reconstruct the actual LCS.

You can replace `str1` and `str2` in the `main()` function with your desired strings. The `longestCommonSubsequence()` function returns the longest common subsequence of the two strings provided.

### 1. Algorithms & Data Structures (C++): Longest common subsequence

Sure, I can help you with that. The longest common subsequence (LCS) problem is a classic problem in computer science. Given two sequences (e.g., strings), you want to find the longest subsequence that is present in both of them. Here's a basic C++ implementation of the LCS problem using dynamic programming:

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

using namespace std;

int longestCommonSubsequence(const string& text1, const string& text2) {
    int m = text1.size();
    int n = text2.size();
    
    // Create a 2D vector to store the lengths of LCS for each combination of prefixes
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

    // Fill the dp table
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (text1[i - 1] == text2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    
    // The length of LCS is stored at the bottom-right corner of the dp table
    return dp[m][n];
}

int main() {
    string text1 = "AGGTAB";
    string text2 = "GXTXAYB";
    
    int lcs_length = longestCommonSubsequence(text1, text2);
    
    cout << "Length of Longest Common Subsequence: " << lcs_length << endl;
    
    return 0;
}
```

This implementation uses a bottom-up dynamic programming approach. We create a 2D vector `dp` to store the lengths of the longest common subsequences for all combinations of prefixes of the two input strings. We then fill the table iteratively based on whether the characters of the two strings match or not. Finally, we return the value at `dp[m][n]`, where `m` and `n` are the lengths of the two strings respectively, which represents the length of the LCS.

### 1. Algorithms & Data Structures (C++): Longest Common Subsequence - Dynamic Programming

Implementing the Longest Common Subsequence (LCS) problem using dynamic programming in C++ involves creating a table to store the lengths of the LCS of substrings of the input strings. Here's a basic implementation:

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

string longestCommonSubsequence(const string& str1, const string& str2) {
    int m = str1.length();
    int n = str2.length();

    // Create and initialize the LCS table
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

    // Fill the table using dynamic programming
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (str1[i - 1] == str2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    // Retrieve the longest common subsequence
    int length = dp[m][n];
    string lcs(length, ' ');

    int i = m, j = n;
    while (i > 0 && j > 0) {
        if (str1[i - 1] == str2[j - 1]) {
            lcs[--length] = str1[i - 1];
            i--;
            j--;
        } else if (dp[i - 1][j] > dp[i][j - 1]) {
            i--;
        } else {
            j--;
        }
    }

    return lcs;
}

int main() {
    string str1 = "AGGTAB";
    string str2 = "GXTXAYB";

    cout << "Longest Common Subsequence: " << longestCommonSubsequence(str1, str2) << endl;

    return 0;
}
```

This code computes the length of the longest common subsequence of two input strings `str1` and `str2` and then constructs the LCS itself. The `dp` table is filled in a bottom-up manner using dynamic programming. Finally, the LCS is constructed by backtracking through the table.

### 1. Algorithms & Data Structures (C++): Longest common subsequence (problem)

The longest common subsequence (LCS) problem is a classic problem in computer science, often used in algorithm design and dynamic programming. Given two sequences, the problem is to find the longest subsequence present in both of them. A subsequence is a sequence that appears in the same relative order, but not necessarily contiguous.

Here's a high-level overview of the algorithm to solve the LCS problem using dynamic programming:

1. **Initialization**: Create a matrix (2D array) to store the lengths of LCS for each combination of prefixes of the two sequences. Initialize the first row and first column of the matrix to zeros.

2. **Iteration**: Traverse the matrices and fill in the values based on the following rules:
   - If the characters of both sequences match at a given position (i, j), the value at that position in the matrix is one plus the value at the previous diagonal position (i-1, j-1).
   - If the characters do not match, take the maximum of the value directly above (i-1, j) and the value directly to the left (i, j-1).

3. **Backtracking**: Once the matrix is filled, trace back from the bottom-right corner to reconstruct the longest common subsequence.

Here's a simple implementation of the LCS algorithm in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

std::string longest_common_subsequence(const std::string& str1, const std::string& str2) {
    int m = str1.length();
    int n = str2.length();

    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1, 0));

    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (str1[i - 1] == str2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = std::max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    int len = dp[m][n];
    std::string lcs(len, ' ');

    int i = m, j = n;
    while (i > 0 && j > 0) {
        if (str1[i - 1] == str2[j - 1]) {
            lcs[--len] = str1[i - 1];
            --i;
            --j;
        } else if (dp[i - 1][j] > dp[i][j - 1]) {
            --i;
        } else {
            --j;
        }
    }

    return lcs;
}

int main() {
    std::string str1 = "AGGTAB";
    std::string str2 = "GXTXAYB";

    std::cout << "Longest Common Subsequence: " << longest_common_subsequence(str1, str2) << std::endl;

    return 0;
}
```

This implementation uses a bottom-up approach to fill the DP matrix and then backtracks to find the actual LCS.

### 1. Algorithms & Data Structures (C++): Longest common subsequence (solution)

Sure! Here's a C++ implementation of the longest common subsequence (LCS) problem using dynamic programming:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

std::string longest_common_subsequence(const std::string& s1, const std::string& s2) {
    int m = s1.length();
    int n = s2.length();

    // Create a 2D vector to store the lengths of common subsequences
    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1, 0));

    // Building the dp table
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (s1[i - 1] == s2[j - 1])
                dp[i][j] = dp[i - 1][j - 1] + 1;
            else
                dp[i][j] = std::max(dp[i - 1][j], dp[i][j - 1]);
        }
    }

    // Retrieving the longest common subsequence
    int i = m, j = n;
    std::string result;
    while (i > 0 && j > 0) {
        if (s1[i - 1] == s2[j - 1]) {
            result = s1[i - 1] + result;
            i--;
            j--;
        } else if (dp[i - 1][j] > dp[i][j - 1]) {
            i--;
        } else {
            j--;
        }
    }

    return result;
}

int main() {
    std::string s1 = "ABCBDAB";
    std::string s2 = "BDCAB";

    std::cout << "Longest Common Subsequence: " << longest_common_subsequence(s1, s2) << std::endl;

    return 0;
}
```

This code calculates the longest common subsequence of two strings `s1` and `s2` using dynamic programming. It creates a 2D table `dp` to store the lengths of common subsequences, then fills it iteratively based on whether characters match or not. Finally, it retrieves the longest common subsequence by tracing back through the filled table.

### 1. Algorithms & Data Structures (C++): Longest Common Subsequence Dynamic Programming

Certainly! The Longest Common Subsequence (LCS) problem is a classic problem in computer science and is often solved using dynamic programming. In this problem, you're given two sequences, and you need to find the length of the longest subsequence present in both of them.

Here's the dynamic programming approach to solve the Longest Common Subsequence problem in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int longestCommonSubsequence(const std::string& text1, const std::string& text2) {
    int m = text1.length();
    int n = text2.length();

    // Create a 2D vector to store the lengths of longest common subsequences
    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1, 0));

    // Fill the dp table in a bottom-up manner
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (text1[i - 1] == text2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = std::max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    // The length of the longest common subsequence is stored in dp[m][n]
    return dp[m][n];
}

int main() {
    std::string text1 = "abcde";
    std::string text2 = "ace";

    int length = longestCommonSubsequence(text1, text2);
    std::cout << "Length of Longest Common Subsequence: " << length << std::endl;

    return 0;
}
```

In this code:

- We define a function `longestCommonSubsequence` which takes two strings `text1` and `text2` as input and returns the length of the longest common subsequence.
- We create a 2D vector `dp` to store the lengths of longest common subsequences. `dp[i][j]` represents the length of the longest common subsequence of `text1.substr(0, i)` and `text2.substr(0, j)`.
- We fill the `dp` table using a bottom-up approach. If the characters at positions `i` and `j` in `text1` and `text2` respectively are equal, then we add 1 to the length of the LCS obtained by excluding these characters from both strings. Otherwise, we take the maximum of the lengths of LCS obtained by excluding one character at a time from either of the strings.
- Finally, the length of the longest common subsequence is stored in `dp[m][n]`, where `m` and `n` are the lengths of `text1` and `text2` respectively.

You can replace the example strings `text1` and `text2` in the `main` function with any other strings to find the length of their longest common subsequence.

### 1. Algorithms & Data Structures (C++): Longest Common Subsequence Memoization

Certainly! Here's a C++ implementation of the Longest Common Subsequence (LCS) problem using memoization:

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring> // for memset
using namespace std;

// Function to find the length of the Longest Common Subsequence using memoization
int LCSLength(const string& s1, const string& s2, int m, int n, vector<vector<int>>& memo) {
    // Base case: if either of the strings is empty, LCS length is 0
    if (m == 0 || n == 0)
        return 0;

    // If the value is already computed, return it from memoization table
    if (memo[m][n] != -1)
        return memo[m][n];

    // If the last characters of both sequences match
    if (s1[m - 1] == s2[n - 1])
        return memo[m][n] = 1 + LCSLength(s1, s2, m - 1, n - 1, memo);

    // If the last characters of both sequences don't match
    return memo[m][n] = max(LCSLength(s1, s2, m, n - 1, memo), LCSLength(s1, s2, m - 1, n, memo));
}

// Function to initialize memoization table and call LCSLength function
int LongestCommonSubsequence(const string& s1, const string& s2) {
    int m = s1.length();
    int n = s2.length();
    // Create a memoization table initialized with -1
    vector<vector<int>> memo(m + 1, vector<int>(n + 1, -1));

    // Call the recursive function
    return LCSLength(s1, s2, m, n, memo);
}

int main() {
    string s1 = "AGGTAB";
    string s2 = "GXTXAYB";

    cout << "Length of Longest Common Subsequence is " << LongestCommonSubsequence(s1, s2) << endl;

    return 0;
}
```

This code finds the length of the Longest Common Subsequence (LCS) of two given strings `s1` and `s2` using memoization technique in C++. The memoization table `memo` is used to store the lengths of the LCS of the substrings of `s1` and `s2`. If the length of the LCS for a particular pair of substrings is already computed, it is retrieved from the memoization table to avoid redundant calculations. This approach optimizes the time complexity of the LCS problem from exponential to polynomial.

### 1. Algorithms & Data Structures (C++): Longest Common Subsequence recursive

Certainly! The Longest Common Subsequence (LCS) problem involves finding the longest subsequence that is common to two given sequences. Here's a recursive approach to solve it using C++:

```cpp
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

// Recursive function to find the length of the longest common subsequence
int longestCommonSubsequence(const string& s1, const string& s2, int m, int n) {
    // Base case: If either of the strings is empty, return 0
    if (m == 0 || n == 0)
        return 0;

    // If the last characters of both strings match
    if (s1[m - 1] == s2[n - 1])
        return 1 + longestCommonSubsequence(s1, s2, m - 1, n - 1);

    // If the last characters don't match, return the maximum of two possibilities:
    // 1. Exclude the last character of s1 and find LCS of the remaining strings
    // 2. Exclude the last character of s2 and find LCS of the remaining strings
    return max(longestCommonSubsequence(s1, s2, m, n - 1), longestCommonSubsequence(s1, s2, m - 1, n));
}

int main() {
    string s1 = "AGGTAB";
    string s2 = "GXTXAYB";

    int m = s1.length();
    int n = s2.length();

    cout << "Length of Longest Common Subsequence: " << longestCommonSubsequence(s1, s2, m, n) << endl;

    return 0;
}
```

This code defines a function `longestCommonSubsequence` which takes two strings `s1` and `s2`, along with their lengths `m` and `n` respectively. It returns the length of the longest common subsequence between `s1` and `s2`.

In the `main` function, two example strings are provided (`s1` and `s2`), and the length of the longest common subsequence is printed. You can modify `s1` and `s2` with your own strings for testing.

### 1. Algorithms & Data Structures (C++): Longest common subsequence: Complexity analysis

The longest common subsequence (LCS) problem is a classic algorithmic problem often encountered in computer science and bioinformatics. Given two sequences, finding the longest subsequence present in both sequences, not necessarily contiguous, is the objective. Here's a complexity analysis of a typical dynamic programming solution for this problem:

#### Complexity Analysis

1. **Time Complexity:**

   - The naive recursive approach has exponential time complexity, specifically O(2^n), where n is the length of the input sequences. This is because it explores all possible subsequences.

   - Dynamic programming is employed to optimize the time complexity to O(m*n), where m and n are the lengths of the input sequences. This is achieved by storing the results of intermediate subproblems in a table and reusing them instead of recalculating. Each cell computation takes constant time.

2. **Space Complexity:**

   - The space complexity of the dynamic programming solution is O(m*n), where m and n are the lengths of the input sequences. This is because a 2D array of size (m+1) x (n+1) is used to store the results of intermediate subproblems.

   - However, space optimization can be done to reduce it to O(min(m, n)) by observing that in dynamic programming, we only need the current row and the previous row to calculate the values for the next row. Therefore, we can use only two rows instead of the entire matrix.

#### Summary

- **Time Complexity:** O(m*n)
- **Space Complexity:** O(m*n) or O(min(m, n))

#### Example

Here's a simple C++ implementation of the dynamic programming solution:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int longestCommonSubsequence(const string& text1, const string& text2) {
    int m = text1.size();
    int n = text2.size();
    
    // Create a 2D DP table
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
    
    // Fill the DP table
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (text1[i - 1] == text2[j - 1])
                dp[i][j] = dp[i - 1][j - 1] + 1;
            else
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
        }
    }
    
    return dp[m][n]; // Length of LCS
}

int main() {
    string text1 = "abcde";
    string text2 = "ace";
    cout << "Length of LCS: " << longestCommonSubsequence(text1, text2) << endl;
    return 0;
}
```

This implementation has a time complexity of O(m*n) and a space complexity of O(m*n) due to the 2D DP table.

### 1. Algorithms & Data Structures (C++): Longest Consecutive Run of 1s in Binary

To find the longest consecutive run of 1s in a binary representation of a number, you can use bitwise operations. Here's a C++ function to achieve this:

```cpp
#include <iostream>
using namespace std;

int longestConsecutiveRunOfOnes(int num) {
    int maxCount = 0;
    int currentCount = 0;

    while (num > 0) {
        if (num & 1) {
            currentCount++;
            maxCount = max(maxCount, currentCount);
        } else {
            currentCount = 0;
        }
        num >>= 1; // Shift right by 1 bit
    }

    return maxCount;
}

int main() {
    int num;
    cout << "Enter a number: ";
    cin >> num;
    cout << "Longest consecutive run of 1s: " << longestConsecutiveRunOfOnes(num) << endl;
    return 0;
}
```

Here's how this function works:

1. It initializes two variables: `maxCount` to keep track of the longest consecutive run of 1s seen so far and `currentCount` to keep track of the current consecutive run of 1s.
2. It iterates through the bits of the number using bitwise shifting (`num >>= 1`).
3. If the least significant bit is 1, it increments `currentCount` and updates `maxCount` if necessary. If the least significant bit is 0, it resets `currentCount` to 0.
4. Finally, it returns `maxCount`, which holds the length of the longest consecutive run of 1s.

### 1. Algorithms & Data Structures (C++): Longest consecutive sequence

To find the longest consecutive sequence of elements in an array using C++, you can utilize a set or unordered_set to store the elements for efficient lookup. Here's a basic outline of how you could implement this:

```cpp
#include <iostream>
#include <unordered_set>
#include <vector>

using namespace std;

int longestConsecutiveSequence(vector<int>& nums) {
    unordered_set<int> numSet(nums.begin(), nums.end());
    int longestSequence = 0;

    for (int num : nums) {
        // Only process the current number if it's the start of a sequence
        if (numSet.find(num - 1) == numSet.end()) {
            int currentNum = num;
            int currentSequence = 1;

            // Count consecutive numbers from the current number onwards
            while (numSet.find(currentNum + 1) != numSet.end()) {
                currentNum++;
                currentSequence++;
            }

            // Update the longest sequence found so far
            longestSequence = max(longestSequence, currentSequence);
        }
    }

    return longestSequence;
}

int main() {
    vector<int> nums = {100, 4, 200, 1, 3, 2};
    cout << "Longest consecutive sequence length: " << longestConsecutiveSequence(nums) << endl;
    return 0;
}
```

This program defines a function `longestConsecutiveSequence` that takes a vector of integers as input and returns the length of the longest consecutive sequence. It iterates through the array once, and for each element, it checks if it's the start of a sequence (i.e., if its predecessor is not present in the set). If it's the start, it iterates forward to count the consecutive elements and updates the longest sequence length accordingly.

The main function demonstrates how to use this function with a sample array.

### 1. Algorithms & Data Structures (C++): Longest Consecutive Sequence - Dynamic Programming

Certainly! The Longest Consecutive Sequence problem can be efficiently solved using dynamic programming. Here's how you can implement it in C++:

```cpp
#include <iostream>
#include <unordered_set>
#include <vector>

using namespace std;

int longestConsecutive(vector<int>& nums) {
    unordered_set<int> num_set;
    
    // Insert all elements into a set
    for (int num : nums) {
        num_set.insert(num);
    }
    
    int longestStreak = 0;
    
    // Iterate over the set
    for (int num : num_set) {
        // Check if the current number is the start of a sequence
        if (num_set.find(num - 1) == num_set.end()) {
            int currentNum = num;
            int currentStreak = 1;
            
            // Increment current number to find the consecutive elements
            while (num_set.find(currentNum + 1) != num_set.end()) {
                currentNum++;
                currentStreak++;
            }
            
            // Update longestStreak if necessary
            longestStreak = max(longestStreak, currentStreak);
        }
    }
    
    return longestStreak;
}

int main() {
    vector<int> nums = {100, 4, 200, 1, 3, 2};
    cout << "Longest consecutive sequence length: " << longestConsecutive(nums) << endl;
    return 0;
}
```

Explanation:

- We first insert all elements from the input vector `nums` into an unordered set `num_set`.
- Then, we iterate through each element in the set. For each element `num`, we check if `num - 1` exists in the set. If not, it means `num` is the start of a sequence.
- We then increment `num` until the consecutive elements are found, updating the `currentStreak` accordingly.
- Finally, we update `longestStreak` with the maximum streak found.
- We return `longestStreak` as the result.

This implementation has a time complexity of O(n), where n is the number of elements in the input vector `nums`, since both the insertion into the set and the iteration through the set take linear time.

### 1. Algorithms & Data Structures (C++): Longest consecutive sequence: Complexity analysis

To analyze the complexity of finding the longest consecutive sequence in C++ using algorithms and data structures, let's first outline a basic approach and then discuss its complexity:

1. **Sort the Array**: First, we can sort the array in ascending order. Sorting can be done in O(n log n) time complexity using algorithms like quicksort or mergesort.

2. **Find Consecutive Sequences**: Once the array is sorted, we can iterate through it to find consecutive sequences. We can do this by keeping track of the current sequence length and the maximum sequence length found so far.

3. **Update Maximum Sequence Length**: During the iteration, whenever we find consecutive elements, we update the maximum sequence length if the current sequence length surpasses it.

4. **Return Maximum Sequence Length**: Finally, we return the maximum sequence length found.

Let's analyze the complexity of each step:

1. **Sorting**: Sorting takes O(n log n) time complexity using efficient sorting algorithms like quicksort or mergesort.

2. **Finding Consecutive Sequences**: After sorting, iterating through the array takes O(n) time complexity, where n is the number of elements in the array. During each iteration, we perform constant time operations, so the overall complexity remains O(n).

3. **Updating Maximum Sequence Length**: Again, during each iteration, we perform constant time operations, so it remains O(n).

4. **Returning Maximum Sequence Length**: This is a constant-time operation, so it's O(1).

Combining these complexities, the overall complexity of finding the longest consecutive sequence using this approach is dominated by the sorting step, which is O(n log n).

So, the overall time complexity of the algorithm is O(n log n) due to sorting, where n is the number of elements in the array. However, the space complexity of this algorithm is O(1) because it doesn't use any additional space apart from the input array.

### 1. Algorithms & Data Structures (C++): Longest Increasing Sequence

Sure, let's implement the Longest Increasing Subsequence (LIS) algorithm in C++. The LIS problem is to find the length of the longest subsequence of a given sequence such that all elements of the subsequence are sorted in increasing order.

Here's a dynamic programming approach to solve this problem:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int lis(vector<int>& nums) {
    int n = nums.size();
    if (n == 0) return 0;
    
    vector<int> dp(n, 1);
    
    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (nums[i] > nums[j]) {
                dp[i] = max(dp[i], dp[j] + 1);
            }
        }
    }
    
    return *max_element(dp.begin(), dp.end());
}

int main() {
    vector<int> nums = {10, 22, 9, 33, 21, 50, 41, 60, 80};
    cout << "Length of Longest Increasing Subsequence: " << lis(nums) << endl;
    return 0;
}
```

In this code:

- We maintain a dynamic programming array `dp` where `dp[i]` represents the length of the longest increasing subsequence ending at index `i`.
- We iterate through each element of the input array `nums`, and for each element, we iterate through all previous elements to find the longest increasing subsequence ending at that element.
- The time complexity of this approach is O(n^2), where n is the size of the input array.

### 1. Algorithms & Data Structures (C++): Longest Increasing Sequences

In C++, you can find the longest increasing subsequence (LIS) using dynamic programming efficiently. The LIS problem can be solved in \(O(n \log n)\) time complexity using binary search. Here's a sample implementation:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int longestIncreasingSubsequence(std::vector<int>& nums) {
    std::vector<int> dp;
    
    for (int num : nums) {
        auto it = std::lower_bound(dp.begin(), dp.end(), num);
        if (it == dp.end())
            dp.push_back(num);
        else
            *it = num;
    }
    
    return dp.size();
}

int main() {
    std::vector<int> nums = {10, 22, 9, 33, 21, 50, 41, 60, 80};
    int lis_length = longestIncreasingSubsequence(nums);
    std::cout << "Length of the Longest Increasing Subsequence: " << lis_length << std::endl;
    return 0;
}
```

This code will output:

```bash
Length of the Longest Increasing Subsequence: 6
```

Explanation:

- `dp` array is used to store the increasing subsequence.
- We iterate through the input array `nums`, and for each element, we find its position in `dp` using binary search (`std::lower_bound`).
- If the element is greater than all elements in `dp`, we push it to the back of `dp`.
- Otherwise, we replace the element at the found position with the current element.
- Finally, the length of `dp` is the length of the LIS.

This algorithm runs in \(O(n \log n)\) time complexity, where \(n\) is the size of the input array `nums`.

### 1. Algorithms & Data Structures (C++): Longest increasing subsequence

Sure, the longest increasing subsequence problem is a classic problem in computer science and can be solved efficiently using dynamic programming. Here's how you can implement it in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int lis(vector<int>& nums) {
    int n = nums.size();
    if (n == 0) return 0;

    // dp[i] will store the length of the longest increasing subsequence ending at nums[i]
    vector<int> dp(n, 1);

    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (nums[i] > nums[j]) {
                dp[i] = max(dp[i], dp[j] + 1);
            }
        }
    }

    // The longest increasing subsequence will be the maximum value in dp
    return *max_element(dp.begin(), dp.end());
}

int main() {
    vector<int> nums = {10, 22, 9, 33, 21, 50, 41, 60};
    cout << "Length of longest increasing subsequence: " << lis(nums) << endl;
    return 0;
}
```

This code defines a function `lis` that takes a vector of integers as input and returns the length of the longest increasing subsequence. The main function demonstrates how to use this function with a sample vector of integers.

The time complexity of this solution is O(n^2), where n is the size of the input vector.

### 1. Algorithms & Data Structures (C++): Longest Increasing Subsequence - Dynamic Programming

Sure, I can outline the dynamic programming approach to find the Longest Increasing Subsequence (LIS) in C++. The LIS problem is to find the length of the longest subsequence of a given sequence such that all elements of the subsequence are sorted in increasing order.

Here's a dynamic programming solution to find the length of the LIS:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int lengthOfLIS(vector<int>& nums) {
    int n = nums.size();
    if (n == 0) return 0;

    // dp[i] will store the length of the LIS ending at nums[i]
    vector<int> dp(n, 1);

    // Iterate through the array
    for (int i = 1; i < n; i++) {
        // For each element, check all previous elements
        for (int j = 0; j < i; j++) {
            // If nums[i] is greater than nums[j], we can extend the LIS ending at nums[j] by including nums[i]
            if (nums[i] > nums[j]) {
                dp[i] = max(dp[i], dp[j] + 1);
            }
        }
    }

    // Find the maximum value in dp[] which represents the length of the LIS
    int max_len = 0;
    for (int i = 0; i < n; i++) {
        max_len = max(max_len, dp[i]);
    }

    return max_len;
}

int main() {
    vector<int> nums = {10, 22, 9, 33, 21, 50, 41, 60};
    cout << "Length of Longest Increasing Subsequence: " << lengthOfLIS(nums) << endl;
    return 0;
}
```

This code defines a function `lengthOfLIS()` that takes a vector of integers as input and returns the length of the longest increasing subsequence. It iterates through the array using nested loops, maintaining a dynamic programming table `dp[]`. `dp[i]` represents the length of the LIS ending at `nums[i]`. Finally, it finds the maximum value in `dp[]`, which represents the length of the overall LIS.

### 1. Algorithms & Data Structures (C++): Longest increasing subsequence (problem)

The Longest Increasing Subsequence (LIS) problem is a classic problem in computer science and dynamic programming. Given an array of integers, the task is to find the length of the longest subsequence in it such that all elements of the subsequence are sorted in increasing order.

Here's a simple approach to solve this problem using dynamic programming in C++:

```cpp
#include <iostream>
#include <vector>

int lis(std::vector<int>& nums) {
    int n = nums.size();
    std::vector<int> dp(n, 1); // dp[i] stores the length of LIS ending at index i

    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (nums[i] > nums[j]) {
                dp[i] = std::max(dp[i], dp[j] + 1);
            }
        }
    }

    int max_length = 0;
    for (int i = 0; i < n; ++i) {
        max_length = std::max(max_length, dp[i]);
    }

    return max_length;
}

int main() {
    std::vector<int> nums = {10, 22, 9, 33, 21, 50, 41, 60};
    std::cout << "Length of the longest increasing subsequence: " << lis(nums) << std::endl;
    return 0;
}
```

This code defines a function `lis` which takes a vector of integers and returns the length of the longest increasing subsequence. It uses dynamic programming to solve the problem in O(n^2) time complexity.

You can customize the `main` function to test this with different arrays.

### 1. Algorithms & Data Structures (C++): Longest increasing subsequence (solution)

Sure! Here's a C++ implementation of the longest increasing subsequence problem using dynamic programming:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int longestIncreasingSubsequence(vector<int>& nums) {
    int n = nums.size();
    if (n == 0) return 0;
    
    vector<int> dp(n, 1);
    int maxLength = 1;
    
    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (nums[i] > nums[j]) {
                dp[i] = max(dp[i], dp[j] + 1);
            }
        }
        maxLength = max(maxLength, dp[i]);
    }
    
    return maxLength;
}

int main() {
    vector<int> nums = {10, 9, 2, 5, 3, 7, 101, 18};
    cout << "Length of longest increasing subsequence: " << longestIncreasingSubsequence(nums) << endl;
    return 0;
}
```

This implementation uses dynamic programming to solve the problem in O(n^2) time complexity, where n is the number of elements in the input array `nums`. The `dp` vector is used to store the length of the longest increasing subsequence ending at each index. The final result is the maximum value in the `dp` vector.

### 1. Algorithms & Data Structures (C++): Longest increasing subsequence: Complexity analysis

The Longest Increasing Subsequence (LIS) problem is a classic problem in computer science, commonly used to demonstrate dynamic programming techniques. The problem statement is as follows:

Given an array of integers, find the length of the longest subsequence in the array such that all elements of the subsequence are sorted in strictly increasing order.

One common approach to solving this problem efficiently is using dynamic programming. Here's a dynamic programming solution and its complexity analysis:

#### Dynamic Programming Solution

1. **Initialization**: Create an array `dp` of the same size as the input array, initialized with 1 for each element. This array will store the length of the longest increasing subsequence ending at that index.

2. **Dynamic Programming Iteration**:
   - For each index `i` from 1 to `n-1` (where `n` is the size of the input array):
     - For each index `j` from 0 to `i-1`:
       - If `array[i] > array[j]`, update `dp[i] = max(dp[i], dp[j] + 1)`.

3. **Find the Maximum**: The length of the longest increasing subsequence will be the maximum value in the `dp` array.

#### Complexity Analysis

- **Time Complexity**:
  - The outer loop runs `n` times, where `n` is the size of the input array.
  - The inner loop runs `i` times in the worst case for each outer iteration.
  - Thus, the time complexity is O(n^2).

- **Space Complexity**:
  - We use an additional array `dp` of size `n`.
  - Thus, the space complexity is O(n).

#### Example

Let's consider an example to illustrate this:

Input array: [10, 22, 9, 33, 21, 50, 41, 60, 80]

- Initialize `dp` as [1, 1, 1, 1, 1, 1, 1, 1, 1]
- After iteration:
  - `dp` becomes [1, 2, 1, 3, 2, 4, 4, 5, 6]
- Maximum value in `dp` is 6, so the length of the longest increasing subsequence is 6.

This analysis shows that the dynamic programming solution offers an efficient way to solve the Longest Increasing Subsequence problem, with a time complexity of O(n^2) and a space complexity of O(n).

### 1. Algorithms & Data Structures (C++): Longest k-sum Subarray

To find the longest subarray with a sum equal to k in C++, you can use a hashmap to store the prefix sum of the array elements encountered so far. Here's how you can implement it:

```cpp
#include <iostream>
#include <unordered_map>
#include <vector>

using namespace std;

int longestKSumSubarray(vector<int>& nums, int k) {
    unordered_map<int, int> prefixSum; // Map to store prefix sum
    int maxLength = 0;
    int sum = 0;

    for (int i = 0; i < nums.size(); ++i) {
        sum += nums[i];

        // If the sum is equal to k, the entire subarray from the beginning to the current index is a candidate
        if (sum == k)
            maxLength = i + 1;

        // If the (sum - k) exists in the map, it means there is a subarray with sum k between the two indices
        else if (prefixSum.find(sum - k) != prefixSum.end())
            maxLength = max(maxLength, i - prefixSum[sum - k]);

        // Store the current prefix sum along with its index
        if (prefixSum.find(sum) == prefixSum.end())
            prefixSum[sum] = i;
    }

    return maxLength;
}

int main() {
    vector<int> nums = {1, -1, 5, -2, 3};
    int k = 3;

    cout << "Length of longest subarray with sum " << k << ": " << longestKSumSubarray(nums, k) << endl;

    return 0;
}
```

This code maintains a running sum of the elements encountered so far in the variable `sum`. It uses a hashmap `prefixSum` to store the index at which each prefix sum is encountered. If the current sum minus the target sum `k` exists in the hashmap, it means there is a subarray with sum `k` between the indices stored in the hashmap. It updates the `maxLength` whenever it finds a longer subarray.

### 1. Algorithms & Data Structures (C++): Lost Numbers

"Lost Numbers" typically refers to a problem where you're given an array of integers containing some numbers in a sequence and some missing numbers, and the task is to find those missing numbers. Here's a C++ implementation to find the missing numbers in a given range:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

vector<int> findLostNumbers(const vector<int>& nums, int start, int end) {
    vector<int> lostNumbers;

    // Sort the input array
    vector<int> sortedNums = nums;
    sort(sortedNums.begin(), sortedNums.end());

    int index = 0;
    int current = start;
    
    // Traverse from start to end
    while (current <= end) {
        // If current number matches the number in the array
        // Move to the next number in the array
        if (index < sortedNums.size() && current == sortedNums[index]) {
            index++;
        } else { // If current number is missing, add it to lostNumbers
            lostNumbers.push_back(current);
        }
        current++;
    }

    return lostNumbers;
}

int main() {
    // Example usage
    vector<int> nums = {1, 3, 5, 7, 10};
    int start = 1;
    int end = 10;
    
    vector<int> lostNumbers = findLostNumbers(nums, start, end);
    
    cout << "Missing numbers are: ";
    for (int num : lostNumbers) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}
```

In this implementation, `findLostNumbers` function takes the array of numbers `nums`, the starting number `start`, and the ending number `end` of the range. It sorts the input array, then iterates through the range from `start` to `end`, checking if each number exists in the array. If a number is missing, it adds it to the `lostNumbers` vector. Finally, it returns the vector containing the missing numbers.

### 1. Algorithms & Data Structures (C++): LRU

LRU stands for Least Recently Used and is a popular algorithm used in computer science, especially in the context of cache management. It is particularly useful in scenarios where cache space is limited and needs to be efficiently managed.

In the context of cache management, the LRU algorithm works by evicting the least recently used items from the cache when the cache reaches its maximum capacity and a new item needs to be inserted.

Here's a basic outline of how the LRU algorithm works:

1. Maintain a data structure (often a doubly linked list) to keep track of the order in which items are accessed.
2. Maintain a hash table (often a hashmap) that maps keys to their corresponding values in the cache.
3. When an item is accessed, it is moved to the front of the list (indicating that it is the most recently used item).
4. When a new item needs to be inserted into the cache and the cache is full, the least recently used item (which will be at the end of the list) is evicted from the cache.
5. Updating the cache involves updating both the data structure (list) and the hash table.

In C++, you can implement an LRU cache using a combination of a doubly linked list and a hashmap. Here's a high-level overview of how you might implement it:

```cpp
#include <unordered_map>
#include <list>

using namespace std;

class LRUCache {
private:
    int capacity;
    list<pair<int, int>> cacheList; // Doubly linked list of (key, value) pairs
    unordered_map<int, list<pair<int, int>>::iterator> cacheMap; // Hashmap for quick access to list iterators

public:
    LRUCache(int capacity) {
        this->capacity = capacity;
    }

    int get(int key) {
        auto it = cacheMap.find(key);
        if (it == cacheMap.end()) {
            return -1; // Key not found in cache
        }
        // Move the accessed item to the front of the list
        cacheList.splice(cacheList.begin(), cacheList, it->second);
        return it->second->second; // Return the value associated with the key
    }

    void put(int key, int value) {
        auto it = cacheMap.find(key);
        if (it != cacheMap.end()) {
            // If key already exists, update the value and move it to the front
            it->second->second = value;
            cacheList.splice(cacheList.begin(), cacheList, it->second);
        } else {
            // If cache is full, evict the least recently used item
            if (cacheList.size() == capacity) {
                int keyToRemove = cacheList.back().first;
                cacheMap.erase(keyToRemove);
                cacheList.pop_back();
            }
            // Insert the new item at the front of the list
            cacheList.emplace_front(key, value);
            cacheMap[key] = cacheList.begin();
        }
    }
};
```

This implementation uses a doubly linked list to maintain the order of items based on their access time, and a hashmap to provide constant-time access to list nodes. The operations `get` and `put` both have an average time complexity of O(1) due to the use of the hashmap for quick key lookup and the doubly linked list for efficient item reordering.

### 1. Algorithms & Data Structures (C++): LRU Cache

An LRU (Least Recently Used) cache is a data structure that maintains a fixed-size cache of items and removes the least recently used item when the cache is full and a new item is added. This is particularly useful for caching in scenarios where resources are limited and frequently accessed data needs to be stored for quick access.

Here's a basic implementation of an LRU Cache in C++ using a combination of a doubly linked list and a hashmap:

```cpp
#include <unordered_map>
#include <list>
#include <iostream>

using namespace std;

class LRUCache {
private:
    int capacity;
    unordered_map<int, pair<int, list<int>::iterator>> cache; // key -> {value, iterator to corresponding list node}
    list<int> lruList; // list to maintain the order of keys based on their usage

public:
    LRUCache(int capacity) {
        this->capacity = capacity;
    }
    
    int get(int key) {
        if (cache.find(key) == cache.end()) {
            return -1; // Key not found in cache
        }
        
        // Move the key to the front of the list as it's now the most recently used
        lruList.splice(lruList.begin(), lruList, cache[key].second);
        
        return cache[key].first; // Return the value associated with the key
    }
    
    void put(int key, int value) {
        if (cache.find(key) != cache.end()) {
            // If key already exists, update its value and move it to the front of the list
            cache[key].first = value;
            lruList.splice(lruList.begin(), lruList, cache[key].second);
            return;
        }
        
        if (cache.size() >= capacity) {
            // If cache is full, remove the least recently used key from both cache and list
            int leastUsed = lruList.back();
            lruList.pop_back();
            cache.erase(leastUsed);
        }
        
        // Add the new key to the front of the list and update the cache
        lruList.push_front(key);
        cache[key] = {value, lruList.begin()};
    }
};

int main() {
    LRUCache cache(2); // Capacity is 2

    cache.put(1, 1);
    cache.put(2, 2);
    cout << cache.get(1) << endl;    // returns 1
    cache.put(3, 3); // evicts key 2
    cout << cache.get(2) << endl;    // returns -1 (not found)
    cache.put(4, 4); // evicts key 1
    cout << cache.get(1) << endl;    // returns -1 (not found)
    cout << cache.get(3) << endl;    // returns 3
    cout << cache.get(4) << endl;    // returns 4
    return 0;
}
```

In this implementation, a doubly linked list `lruList` is used to maintain the order of keys based on their usage, with the most recently used key at the front and the least recently used key at the back. The `cache` hashmap stores the key-value pairs along with iterators pointing to the corresponding nodes in the linked list. This allows constant time access, insertion, and deletion operations for both cache and list.

The `get` function retrieves the value associated with a given key and moves the corresponding node to the front of the list to mark it as the most recently used. The `put` function inserts or updates a key-value pair, removing the least recently used key if the cache is full.

### 1. Algorithms & Data Structures (C++): LRU Cache explain

An LRU (Least Recently Used) Cache is a data structure used for storing a fixed number of elements/items. It is designed to efficiently manage which items to keep and which to discard when the cache reaches its maximum capacity.

The basic idea behind an LRU Cache is to keep track of the order in which items are accessed. When an item is accessed (read or written), it moves to the front of the cache, indicating that it's the most recently used item. When the cache is full and a new item needs to be added, the least recently used item (i.e., the one at the end of the cache) is removed to make space for the new item.

Here's a simple explanation of how an LRU Cache can be implemented in C++:

1. **Data Structure**: You can implement the cache using a combination of a doubly linked list and a hash map.

   - Doubly Linked List: This maintains the order of items based on their access time. The most recently used item is at the front, while the least recently used item is at the end.
   - Hash Map: This provides fast access to items in the cache. Each item in the cache is associated with a key, and the hash map allows quick retrieval of items based on their keys.

2. **Operations**:
   - **Get(key)**: If the key exists in the cache, you retrieve the corresponding value and move the item to the front of the list to indicate it's the most recently used. If the key doesn't exist, you return a default value (like NULL).
   - **Put(key, value)**: If the key already exists in the cache, you update its value and move it to the front of the list. If the key doesn't exist:
     - If the cache is not full, you add the new key-value pair to the front of the list and insert it into the hash map.
     - If the cache is full, you remove the least recently used item from the end of the list and from the hash map, and then add the new key-value pair to the front.

3. **Complexity**:
   - Get and Put operations both have O(1) time complexity, assuming that accessing elements in the hash map and doubly linked list is O(1).
   - Space complexity is also O(n), where n is the maximum capacity of the cache.

Implementing an LRU Cache efficiently involves careful management of the doubly linked list to ensure that items are moved appropriately and efficiently updating the hash map for quick lookups. It's a fundamental data structure used in various scenarios, such as caching frequently accessed data in memory to improve performance.

### 1. Algorithms & Data Structures (C++): LRU Cache LRU Data Structure

An LRU (Least Recently Used) cache is a type of cache where the least recently used items are discarded first when the cache reaches its maximum capacity. It's a common caching strategy used in computer science and is particularly useful in scenarios where you want to retain the most frequently accessed items in memory to improve access times.

In C++, you can implement an LRU cache using a combination of a doubly linked list and a hash map. The doubly linked list keeps track of the order of items based on their usage, with the most recently used items at the front and the least recently used items at the end. The hash map allows for fast lookups of items based on their keys.

Here's a basic outline of how you can implement an LRU cache in C++:

```cpp
#include <unordered_map>
#include <list>

using namespace std;

class LRUCache {
private:
    int capacity;
    unordered_map<int, pair<int, list<int>::iterator>> cache;
    list<int> lru; // doubly linked list to track usage order

public:
    LRUCache(int capacity) {
        this->capacity = capacity;
    }

    int get(int key) {
        if (cache.find(key) == cache.end()) {
            return -1; // Key not found
        }

        // Move the accessed key to the front
        lru.erase(cache[key].second);
        lru.push_front(key);
        cache[key].second = lru.begin();

        return cache[key].first;
    }

    void put(int key, int value) {
        if (cache.find(key) != cache.end()) {
            // If key already exists, update the value and move it to the front
            lru.erase(cache[key].second);
        } else {
            if (cache.size() >= capacity) {
                // Evict the least recently used item (at the back of the list)
                cache.erase(lru.back());
                lru.pop_back();
            }
        }

        // Insert the new key-value pair
        lru.push_front(key);
        cache[key] = {value, lru.begin()};
    }
};
```

In this implementation:

- The `cache` map stores key-value pairs, where the key is the cache key, and the value is a pair consisting of the cached value and an iterator pointing to the corresponding position in the `lru` list.
- The `lru` list maintains the order of keys based on their usage. The most recently used key is at the front of the list, and the least recently used key is at the back.
- When a key is accessed (via the `get` method), it is moved to the front of the list to indicate that it's been recently used.
- When a new key-value pair is inserted (via the `put` method), if the cache is full, the least recently used item is evicted before adding the new item.

This implementation provides O(1) time complexity for both the `get` and `put` operations, as they only involve operations on the hash map and doubly linked list, both of which support constant-time operations.

### 1. Algorithms & Data Structures (C++): Magnetic Force Between Two Balls

To calculate the magnetic force between two balls, you can use a binary search approach. Here's how you can implement it in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// Function to check if the current distance is feasible
bool isFeasible(vector<int>& position, int distance, int m) {
    int count = 1;
    int last_position = position[0];
    
    for (int i = 1; i < position.size(); ++i) {
        if (position[i] - last_position >= distance) {
            last_position = position[i];
            count++;
        }
    }
    
    return count >= m;
}

// Function to calculate maximum magnetic force
int maxDistance(vector<int>& position, int m) {
    sort(position.begin(), position.end());
    
    int left = 1; // Minimum possible distance
    int right = position.back() - position.front(); // Maximum possible distance
    
    int result = -1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (isFeasible(position, mid, m)) {
            result = mid;
            left = mid + 1; // Try to maximize the distance
        } else {
            right = mid - 1; // Try to minimize the distance
        }
    }
    
    return result;
}

int main() {
    vector<int> position = {1, 2, 3, 4, 7};
    int m = 3;
    
    cout << "Maximum magnetic force: " << maxDistance(position, m) << endl;
    
    return 0;
}
```

In this code:

- `isFeasible` checks if the current distance is feasible for placing `m` balls.
- `maxDistance` uses binary search to find the maximum magnetic force.
- In the `main` function, you can adjust the `position` vector to contain the positions of the balls and set `m` to the number of balls you want to place.

### 1. Algorithms & Data Structures (C++): Magnetic Force Between Two Balls - Binary Search

To solve the problem of finding the maximum magnetic force between two balls given positions of balls on a line, we can use binary search. Here's how you can implement it in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// Function to check if it's possible to place balls with a certain minimum distance
bool canPlaceBalls(vector<int>& position, int m, int minDistance) {
    int count = 1;
    int lastPosition = position[0];
    for (int i = 1; i < position.size(); ++i) {
        if (position[i] - lastPosition >= minDistance) {
            lastPosition = position[i];
            count++;
            if (count >= m) return true;
        }
    }
    return false;
}

// Function to calculate the maximum magnetic force
int maxDistance(vector<int>& position, int m) {
    sort(position.begin(), position.end());
    int left = 1; // Minimum possible distance
    int right = position.back() - position.front(); // Maximum possible distance
    int maxForce = 0;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (canPlaceBalls(position, m, mid)) {
            maxForce = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return maxForce;
}

int main() {
    vector<int> position = {1, 2, 4, 8, 9};
    int m = 3;
    cout << "Maximum Magnetic Force: " << maxDistance(position, m) << endl;
    return 0;
}
```

This code first defines a function `canPlaceBalls` that checks if it's possible to place `m` balls with a minimum distance `minDistance`. Then, the `maxDistance` function calculates the maximum magnetic force using binary search on possible minimum distances. Finally, in the `main` function, you can provide the positions of the balls and the number of balls (`m`) and get the maximum magnetic force.

### 1. Algorithms & Data Structures (C++): Majority Element

A "majority element" in an array is an element that appears more than n/2 times, where n is the size of the array. One common algorithm to find the majority element is the Boyer-Moore Voting Algorithm. Here's how you can implement it in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int findMajorityElement(vector<int>& nums) {
    int majorityElement = nums[0];
    int count = 1;

    for (int i = 1; i < nums.size(); ++i) {
        if (nums[i] == majorityElement) {
            count++;
        } else {
            count--;
        }

        if (count == 0) {
            majorityElement = nums[i];
            count = 1;
        }
    }

    // At this point, majorityElement might be the majority, but we need to verify.
    count = 0;
    for (int num : nums) {
        if (num == majorityElement) {
            count++;
        }
    }

    if (count > nums.size() / 2) {
        return majorityElement;
    } else {
        return -1; // No majority element found
    }
}

int main() {
    vector<int> nums = {3, 3, 4, 2, 4, 4, 2, 4, 4}; // Example array

    int majority = findMajorityElement(nums);
    if (majority != -1) {
        cout << "The majority element is: " << majority << endl;
    } else {
        cout << "No majority element found." << endl;
    }

    return 0;
}
```

This code first finds a potential candidate for the majority element using the Boyer-Moore Voting Algorithm. Then, it verifies if that candidate appears more than n/2 times in the array. If it does, it returns that element; otherwise, it returns -1 indicating that no majority element exists.

### 1. Algorithms & Data Structures (C++): Majority Element - Sorting

In algorithms and data structures, finding the majority element in a sequence is a common problem. The majority element is defined as the element that appears more than n/2 times in an array of size n. Sorting is one of the approaches to solve this problem. Here's how you can implement it in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

// Function to find the majority element using sorting
int findMajorityElement(std::vector<int>& nums) {
    // Sort the array
    std::sort(nums.begin(), nums.end());

    int count = 1;
    int majorityElement = nums[0];
    int maxCount = 1;

    // Traverse the sorted array to find the element with the highest frequency
    for (int i = 1; i < nums.size(); ++i) {
        if (nums[i] == nums[i - 1]) {
            count++;
            if (count > maxCount) {
                maxCount = count;
                majorityElement = nums[i];
            }
        } else {
            count = 1;
        }
    }

    // Check if the majority element exists
    if (maxCount > nums.size() / 2) {
        return majorityElement;
    } else {
        // If there is no majority element
        return -1;
    }
}

int main() {
    std::vector<int> nums = {3, 3, 4, 2, 4, 4, 2, 4, 4}; // Example array
    int majorityElement = findMajorityElement(nums);
    if (majorityElement != -1) {
        std::cout << "The majority element is: " << majorityElement << std::endl;
    } else {
        std::cout << "No majority element found." << std::endl;
    }
    return 0;
}
```

This code first sorts the array and then traverses it to find the element with the highest frequency. If the frequency of the majority element is greater than n/2, it returns that element; otherwise, it returns -1 indicating no majority element exists.

### 1. Algorithms & Data Structures (C++): Make It Equal

Sure! "Make It Equal" is a classic problem in algorithms and data structures where you're given an array of integers and you need to make all elements in the array equal by performing a minimum number of operations. Here's a basic outline of how you could approach this problem in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// Function to find the minimum number of operations to make all elements equal
int makeItEqual(vector<int>& nums) {
    int n = nums.size();
    sort(nums.begin(), nums.end());
    int median = nums[n/2];
    int operations = 0;
    for(int i = 0; i < n; ++i) {
        operations += abs(nums[i] - median);
    }
    return operations;
}

int main() {
    // Input
    vector<int> nums = {1, 2, 4, 6, 8};
    
    // Output
    int minOperations = makeItEqual(nums);
    cout << "Minimum operations required to make all elements equal: " << minOperations << endl;

    return 0;
}
```

In this code:

- We first sort the array of integers.
- Then, we find the median of the array. Since the array is sorted, the median is the middle element.
- We calculate the absolute difference between each element and the median and sum them up to get the total number of operations required.

This approach assumes that the minimum number of operations to make all elements equal is achieved when they are all equal to the median. You can adjust the logic based on specific requirements or constraints of the problem.

### 1. Algorithms & Data Structures (C++): Make Network Connected

To create a connected network in C++, you can use various data structures and algorithms. One common approach is to use the Union-Find algorithm to efficiently connect nodes. Here's a basic implementation:

```cpp
#include <iostream>
#include <vector>

using namespace std;

class UnionFind {
private:
    vector<int> parent;
    vector<int> rank;

public:
    UnionFind(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        for (int i = 0; i < n; ++i) {
            parent[i] = i;
        }
    }

    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    void unite(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);

        if (rootX == rootY) return;

        if (rank[rootX] < rank[rootY]) {
            parent[rootX] = rootY;
        } else if (rank[rootX] > rank[rootY]) {
            parent[rootY] = rootX;
        } else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }
    }
};

void makeNetworkConnected(int n, vector<vector<int>>& connections) {
    UnionFind uf(n);

    int extraEdges = 0;

    for (auto& connection : connections) {
        int u = connection[0];
        int v = connection[1];

        if (uf.find(u) != uf.find(v)) {
            uf.unite(u, v);
        } else {
            extraEdges++;
        }
    }

    int components = 0;
    for (int i = 0; i < n; ++i) {
        if (uf.find(i) == i) {
            components++;
        }
    }

    if (extraEdges >= components - 1) {
        cout << "The network is connected.\n";
    } else {
        cout << "The network is not connected.\n";
    }
}

int main() {
    int n = 6;
    vector<vector<int>> connections = {{0, 1}, {0, 2}, {0, 3}, {1, 2}, {4, 5}};

    makeNetworkConnected(n, connections);

    return 0;
}
```

This code defines a Union-Find data structure to efficiently manage the connectivity of nodes in the network. The `makeNetworkConnected` function takes the number of nodes `n` and a vector of connections between nodes. It then uses Union-Find to determine whether the network is connected or not.

### 1. Algorithms & Data Structures (C++): MaxArea of islands

To find the maximum area of islands in a grid using C++, you can use depth-first search (DFS) algorithm to traverse through the grid and find connected components (islands). Here's a simple implementation:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Function to perform DFS to find the area of an island
int dfs(vector<vector<int>>& grid, int row, int col) {
    // Base cases: if out of bounds or grid value is 0
    if (row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || grid[row][col] == 0)
        return 0;
    
    // Mark the current cell as visited
    grid[row][col] = 0;
    
    // Recursive DFS in all four directions
    int area = 1; // Current cell contributes to the area
    area += dfs(grid, row + 1, col); // Down
    area += dfs(grid, row - 1, col); // Up
    area += dfs(grid, row, col + 1); // Right
    area += dfs(grid, row, col - 1); // Left
    
    return area;
}

// Function to find the maximum area of islands
int maxAreaOfIsland(vector<vector<int>>& grid) {
    int maxArea = 0;
    
    // Traverse through the grid
    for (int i = 0; i < grid.size(); ++i) {
        for (int j = 0; j < grid[0].size(); ++j) {
            // If current cell is part of an island
            if (grid[i][j] == 1) {
                int area = dfs(grid, i, j); // Find the area of the island
                maxArea = max(maxArea, area); // Update maxArea if needed
            }
        }
    }
    
    return maxArea;
}

int main() {
    // Example usage
    vector<vector<int>> grid = {
        {1, 1, 0, 0, 0},
        {1, 1, 0, 0, 0},
        {0, 0, 0, 1, 1},
        {0, 0, 0, 1, 1}
    };

    cout << "Maximum area of islands: " << maxAreaOfIsland(grid) << endl;

    return 0;
}
```

This code defines a function `maxAreaOfIsland` which takes a 2D vector representing the grid as input and returns the maximum area of islands in the grid. The `dfs` function is a helper function used to perform depth-first search to calculate the area of each island.

### 1. Algorithms & Data Structures (C++): Maximum Non Adjacent Sum

To find the maximum sum of non-adjacent elements in an array, you can use dynamic programming. Here's a C++ implementation for this problem:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int maxNonAdjacentSum(const std::vector<int>& nums) {
    int n = nums.size();
    if (n == 0) return 0;
    
    int incl = nums[0]; // Maximum sum including the previous element
    int excl = 0;       // Maximum sum excluding the previous element
    
    for (int i = 1; i < n; ++i) {
        // Update incl and excl:
        // 1. If we include current element, then the new incl will be excl + nums[i]
        // 2. If we exclude current element, then the new excl will be max of incl and excl
        int new_incl = excl + nums[i];
        excl = std::max(incl, excl);
        incl = new_incl;
    }
    
    // Return the maximum of incl and excl
    return std::max(incl, excl);
}

int main() {
    std::vector<int> nums = {3, 2, 7, 10};
    std::cout << "Maximum Non Adjacent Sum: " << maxNonAdjacentSum(nums) << std::endl;
    return 0;
}
```

This code calculates the maximum sum of non-adjacent elements in the given vector `nums`. The `maxNonAdjacentSum` function iterates through the array once, keeping track of the maximum sum including and excluding the current element. Finally, it returns the maximum of the two sums.

### 1. Algorithms & Data Structures (C++): Maximum number of coins

To find the maximum number of coins that can be collected from a given grid in a game-like scenario, you can use dynamic programming. Here's a simple C++ implementation using dynamic programming:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int maxCoins(vector<vector<int>>& grid) {
    int m = grid.size();
    int n = grid[0].size();

    // Create a DP table to store maximum coins at each cell
    vector<vector<int>> dp(m, vector<int>(n, 0));

    // Base case: Initialize the first cell
    dp[0][0] = grid[0][0];

    // Fill the first row
    for (int j = 1; j < n; ++j) {
        dp[0][j] = dp[0][j - 1] + grid[0][j];
    }

    // Fill the first column
    for (int i = 1; i < m; ++i) {
        dp[i][0] = dp[i - 1][0] + grid[i][0];
    }

    // Fill the rest of the DP table
    for (int i = 1; i < m; ++i) {
        for (int j = 1; j < n; ++j) {
            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
        }
    }

    // Maximum coins will be stored in the bottom-right cell
    return dp[m - 1][n - 1];
}

int main() {
    // Example grid
    vector<vector<int>> grid = {
        {1, 3, 1},
        {2, 2, 4},
        {5, 0, 2}
    };

    cout << "Maximum number of coins: " << maxCoins(grid) << endl;

    return 0;
}
```

This code defines a function `maxCoins` that takes a 2D vector representing the grid of coins as input and returns the maximum number of coins that can be collected. The dynamic programming approach is used to efficiently compute the maximum coins by considering all possible paths. The `main` function provides an example of how to use this function with a sample grid.

### 1. Algorithms & Data Structures (C++): Maximum Number of Events That Can Be Attended

To solve the problem of finding the maximum number of events that can be attended, you can use a greedy algorithm approach. Here's how you can do it in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct Event {
    int start;
    int end;
};

bool sortByEnd(const Event &a, const Event &b) {
    return a.end < b.end;
}

int maxEvents(vector<Event>& events) {
    sort(events.begin(), events.end(), sortByEnd); // Sort events by end time
    int maxEvents = 0;
    int currEnd = 0;

    for (const auto& event : events) {
        if (event.start > currEnd) { // If the event starts after the current end time
            maxEvents++; // Attend this event
            currEnd = event.end; // Update current end time
        }
    }

    return maxEvents;
}

int main() {
    vector<Event> events = {{1, 3}, {2, 4}, {3, 6}, {4, 7}, {5, 8}};
    cout << "Maximum number of events that can be attended: " << maxEvents(events) << endl;
    return 0;
}
```

In this code:

1. We define a `struct` for representing events, containing their start and end times.
2. We define a custom comparator function `sortByEnd` to sort the events based on their end times.
3. In the `maxEvents` function, we sort the events by their end times using the custom comparator.
4. We iterate through the sorted events and check if the current event starts after the current end time. If it does, we attend the event and update the current end time.
5. Finally, we return the maximum number of events that can be attended.

This solution has a time complexity of O(n log n), where n is the number of events.

### 1. Algorithms & Data Structures (C++): Maximum path sum

Sure! The maximum path sum problem is a classic algorithmic problem where you're given a binary tree and you need to find the maximum sum path from any node to any other node in the tree. Here's a C++ implementation using a recursive approach:

```cpp
#include <iostream>
#include <climits>

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

// Function to find the maximum sum path
int maxPathSumUtil(TreeNode* root, int &maxSum) {
    if (root == nullptr)
        return 0;

    // Get the maximum sum from left and right subtrees
    int leftSum = max(0, maxPathSumUtil(root->left, maxSum));
    int rightSum = max(0, maxPathSumUtil(root->right, maxSum));

    // Update the maximum sum if necessary
    maxSum = max(maxSum, root->val + leftSum + rightSum);

    // Return the maximum sum path starting from this node
    return root->val + max(leftSum, rightSum);
}

// Function to find the maximum path sum
int maxPathSum(TreeNode* root) {
    int maxSum = INT_MIN;
    maxPathSumUtil(root, maxSum);
    return maxSum;
}

int main() {
    // Example usage
    TreeNode* root = new TreeNode(10);
    root->left = new TreeNode(2);
    root->right = new TreeNode(10);
    root->left->left = new TreeNode(20);
    root->left->right = new TreeNode(1);
    root->right->right = new TreeNode(-25);
    root->right->right->left = new TreeNode(3);
    root->right->right->right = new TreeNode(4);

    cout << "Maximum path sum is " << maxPathSum(root) << endl;

    // Free memory
    delete root->right->right->right;
    delete root->right->right->left;
    delete root->right->right;
    delete root->left->right;
    delete root->left->left;
    delete root->right;
    delete root->left;
    delete root;

    return 0;
}
```

This code defines a binary tree node structure (`TreeNode`) and implements two functions: `maxPathSumUtil` and `maxPathSum`. The `maxPathSumUtil`

function is a helper function that recursively calculates the maximum sum path starting from the current node. It returns the maximum sum path starting from the current node. The `maxPathSum` function initializes the maximum sum variable and calls `maxPathSumUtil` to update it with the maximum sum path found in the tree.

In the `main` function, an example binary tree is constructed, and the `maxPathSum` function is called to find the maximum path sum. Finally, memory for the dynamically allocated tree nodes is deallocated.

You can adjust the example tree in the `main` function to test different cases.

### 1. Algorithms & Data Structures (C++): Maximum path sum: Complexity analysis

The maximum path sum problem typically deals with finding the maximum sum of a path in a tree, where the path may start and end at any node in the tree. The complexity analysis depends on the specific algorithm used to solve the problem.

One common approach to solve this problem is to use a recursive algorithm, typically based on depth-first search (DFS). Here's a brief overview of the complexity analysis for this approach:

1. **Time Complexity**:
   - The time complexity of a basic DFS traversal of a tree is O(V + E), where V is the number of vertices (nodes) and E is the number of edges in the tree.
   - In the case of a binary tree, the number of edges E is roughly V-1, so the time complexity simplifies to O(V).
   - Within each DFS call, we perform constant-time operations for each node, so the overall time complexity of the DFS-based algorithm is O(V).
   - However, if the tree is not balanced, the time complexity might be higher due to potentially deeper recursive calls.

2. **Space Complexity**:
   - The space complexity of the DFS algorithm depends on the maximum depth of the recursion stack.
   - In the worst case scenario, where the tree is skewed and unbalanced, the maximum depth of the recursion stack can be equal to the number of nodes in the tree.
   - Therefore, the space complexity of the DFS algorithm is O(V).

There are also other approaches to solving the maximum path sum problem, such as using dynamic programming or modifying the DFS algorithm to keep track of the maximum sum as the traversal progresses. These approaches may have different complexities, but they often provide similar results in terms of time and space complexity.

It's worth noting that if the problem involves a binary search tree (BST), there are more efficient algorithms that can achieve a time complexity of O(log N), where N is the number of nodes in the tree. This is because of the ordered nature of the BST, which allows for more efficient traversal and calculation of the maximum path sum.

### 1. Algorithms & Data Structures (C++): Maximum Product Subarray

The Maximum Product Subarray problem is a classic dynamic programming problem where you're given an array of integers, and you need to find the contiguous subarray within that array which has the largest product. Here's a C++ implementation using dynamic programming:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int maxProductSubarray(vector<int>& nums) {
    int n = nums.size();
    if (n == 0) return 0;

    int maxProd = nums[0];
    int minProd = nums[0];
    int maxProduct = nums[0];

    for (int i = 1; i < n; ++i) {
        if (nums[i] < 0)
            swap(maxProd, minProd);

        maxProd = max(nums[i], maxProd * nums[i]);
        minProd = min(nums[i], minProd * nums[i]);

        maxProduct = max(maxProduct, maxProd);
    }

    return maxProduct;
}

int main() {
    vector<int> nums = {2, 3, -2, 4}; // Example input
    cout << "Maximum product of a subarray: " << maxProductSubarray(nums) << endl;
    return 0;
}
```

In this implementation:

- We use three variables `maxProd`, `minProd`, and `maxProduct`.
- `maxProd` keeps track of the maximum product ending at the current position.
- `minProd` keeps track of the minimum product ending at the current position.
- `maxProduct` keeps track of the maximum product found so far.
- We iterate through the array, updating these values accordingly.
- Whenever we encounter a negative number, we swap `maxProd` and `minProd` because multiplying a negative number by a negative number can result in a larger positive number.
- At each iteration, we update `maxProduct` with the maximum product found so far.
- Finally, we return `maxProduct` which contains the maximum product of a subarray.

### 1. Algorithms & Data Structures (C++): Maximum Product Subarray - Arrays

Certainly! The Maximum Product Subarray problem is a classic algorithmic problem that can be solved efficiently using dynamic programming. The problem statement is to find the contiguous subarray within an array (containing at least one number) which has the largest product.

Here's a C++ implementation of the algorithm:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int maxProductSubarray(vector<int>& nums) {
    if (nums.empty()) return 0;
    
    int max_product = nums[0];
    int min_product = nums[0];
    int result = nums[0];
    
    for (int i = 1; i < nums.size(); ++i) {
        if (nums[i] < 0)
            swap(max_product, min_product);
        
        max_product = max(nums[i], max_product * nums[i]);
        min_product = min(nums[i], min_product * nums[i]);
        
        result = max(result, max_product);
    }
    
    return result;
}

int main() {
    vector<int> nums = {2, 3, -2, 4}; // Example input
    cout << "Maximum product subarray: " << maxProductSubarray(nums) << endl;
    return 0;
}
```

Explanation:

- We initialize three variables: `max_product`, `min_product`, and `result` with the first element of the array.
- We iterate through the array starting from the second element.
- At each iteration, we update `max_product` and `min_product` based on the current element. If the current element is negative, we swap `max_product` and `min_product` because multiplying a negative number with a negative number can result in a positive number, and vice versa.
- We update `result` with the maximum value of `result` and `max_product`.
- Finally, we return `result`, which holds the maximum product subarray.

### 1. Algorithms & Data Structures (C++): Maximum Score

To find the maximum score given certain constraints in C++, you can use dynamic programming. Here's an approach to solve such a problem:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int maxScore(vector<int>& nums, vector<int>& multipliers) {
    int n = nums.size();
    int m = multipliers.size();
    
    // Create a 2D DP array to store the maximum score
    vector<vector<int>> dp(m + 1, vector<int>(m + 1, 0));
    
    for (int len = 1; len <= m; ++len) {
        for (int i = 0; i <= len; ++i) {
            int j = len - i;
            if (i == 0) {
                dp[i][j] = dp[i][j - 1] + multipliers[len - 1] * nums[n - j];
            } else if (j == 0) {
                dp[i][j] = dp[i - 1][j] + multipliers[len - 1] * nums[i - 1];
            } else {
                dp[i][j] = max(dp[i - 1][j] + multipliers[len - 1] * nums[i - 1], 
                               dp[i][j - 1] + multipliers[len - 1] * nums[n - j]);
            }
        }
    }
    
    int maxScore = INT_MIN;
    // Find the maximum score from the DP array
    for (int i = 0; i <= m; ++i) {
        maxScore = max(maxScore, dp[i][m - i]);
    }
    
    return maxScore;
}

int main() {
    vector<int> nums = {1, 2, 3};
    vector<int> multipliers = {3, 2, 1};
    
    cout << "Maximum score: " << maxScore(nums, multipliers) << endl;
    
    return 0;
}
```

This code calculates the maximum score given two vectors `nums` and `multipliers`. `nums` contains integers, and `multipliers` contains integers as well. The maximum score is calculated by selecting numbers from `nums` and multipliers from `multipliers` with the constraint that you can pick from either end of `nums`, but the order of selection from both `nums` and `multipliers` must be maintained.

The algorithm fills up a dynamic programming table `dp`, where `dp[i][j]` represents the maximum score obtained by picking `i` numbers from the beginning of `nums` and `j` numbers from the end of `nums`. Finally, it finds the maximum score from the last row of the DP table.

### 1. Algorithms & Data Structures (C++): Maximum Score From Removing Stones

To solve this problem, let's first understand the problem statement. You're given three piles of stones, where each pile contains a certain number of stones. On each turn, you can choose two piles of stones, remove one stone from one pile and two stones from the other, or remove one stone from one pile and one stone from another pile. The goal is to maximize the total score obtained by removing stones.

Here's the approach to solve this problem:

1. Sort the three piles in non-decreasing order.
2. Calculate the total number of moves possible. This will be the sum of the differences between adjacent piles.
3. To maximize the score, we can remove two stones from the largest pile and one stone from the second largest pile repeatedly until either the largest pile becomes smaller than or equal to the second largest pile.
4. Finally, we can remove one stone from the largest pile and one stone from the smallest pile for the remaining moves.

Let's implement this algorithm in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int maximumScore(int a, int b, int c) {
    vector<int> piles = {a, b, c};
    sort(piles.begin(), piles.end());
    
    int moves = piles[1] - piles[0] + piles[2] - piles[1];
    
    if (piles[2] - piles[1] >= moves) {
        return piles[0] + piles[1] + moves;
    } else {
        return piles[0] + piles[1] + (moves - (piles[2] - piles[1])) / 2;
    }
}

int main() {
    int a, b, c;
    cout << "Enter the number of stones in three piles: ";
    cin >> a >> b >> c;
    
    int maxScore = maximumScore(a, b, c);
    cout << "Maximum score: " << maxScore << endl;
    
    return 0;
}
```

This code will prompt the user to enter the number of stones in three piles, calculate the maximum score using the `maximumScore` function, and then output the result.

### 1. Algorithms & Data Structures (C++): Maximum subarray

The maximum subarray problem is a classic algorithmic problem that involves finding the contiguous subarray within a one-dimensional array of numbers (containing both positive and negative numbers) that has the largest sum. This problem can be solved efficiently using various algorithms, with the most well-known one being Kadane's algorithm.

Here's a C++ implementation of Kadane's algorithm to find the maximum subarray sum:

```cpp
#include <iostream>
#include <vector>

int maxSubArray(std::vector<int>& nums) {
    int maxSum = nums[0]; // Initialize maxSum with the first element of the array
    int currentSum = nums[0]; // Initialize currentSum with the first element of the array

    // Traverse the array starting from the second element
    for (int i = 1; i < nums.size(); ++i) {
        // Update currentSum by either adding the current element or starting a new subarray from the current element
        currentSum = std::max(nums[i], currentSum + nums[i]);
        // Update maxSum if the current sum is greater
        maxSum = std::max(maxSum, currentSum);
    }

    return maxSum;
}

int main() {
    // Example usage
    std::vector<int> nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
    std::cout << "Maximum subarray sum: " << maxSubArray(nums) << std::endl;
    return 0;
}
```

This implementation iterates through the array once, maintaining two variables: `maxSum` which keeps track of the maximum subarray sum seen so far, and `currentSum` which keeps track of the current sum of the subarray being considered. At each iteration, `currentSum` is updated either by adding the current element to it or by starting a new subarray from the current element. Then, `maxSum` is updated if the `currentSum` becomes greater than `maxSum`. Finally, the function returns `maxSum`, which represents the maximum subarray sum.

### 1. Algorithms & Data Structures (C++): Maximum Subarray Sum

The maximum subarray sum problem is a classic algorithmic problem. Given an array of integers, you're tasked with finding the contiguous subarray (containing at least one number) which has the largest sum. Here's a simple implementation of the Kadane's algorithm in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int maxSubArraySum(const vector<int>& nums) {
    int maxSum = nums[0];
    int currentSum = nums[0];

    for (int i = 1; i < nums.size(); ++i) {
        currentSum = max(nums[i], currentSum + nums[i]);
        maxSum = max(maxSum, currentSum);
    }

    return maxSum;
}

int main() {
    // Example usage
    vector<int> nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
    cout << "Maximum subarray sum: " << maxSubArraySum(nums) << endl;

    return 0;
}
```

This implementation has a time complexity of O(n), where n is the size of the input array, because it scans the array only once.

Here's a brief overview of the Kadane's algorithm:

- Initialize two variables, `maxSum` and `currentSum`, both set to the first element of the array.
- Traverse the array from the second element onwards.
- At each step, update `currentSum` to be the maximum of the current element and the sum of the current element and the previous `currentSum`.
- Update `maxSum` to be the maximum of `maxSum` and `currentSum`.
- Return `maxSum` as the result.

### 1. Algorithms & Data Structures (C++): Maximum subarray: Complexity analysis

The Maximum Subarray Problem is a classic algorithmic problem where the task is to find the contiguous subarray within a one-dimensional array of numbers that has the largest sum. There are several algorithms to solve this problem, each with its own time complexity.

1. **Brute Force Approach**:
   - In this approach, we consider all possible subarrays and compute their sums.
   - Time Complexity: \(O(n^2)\), where \(n\) is the size of the array. This is because there are \(O(n^2)\) subarrays and calculating the sum of each subarray takes \(O(1)\) time.

2. **Kadane's Algorithm**:
   - This algorithm is more efficient and works by scanning the array from left to right, keeping track of the maximum sum subarray ending at each position.
   - It relies on the observation that the maximum subarray ending at position \(i\) either consists of only the element at position \(i\) or extends the maximum subarray ending at position \(i-1\).
   - Time Complexity: \(O(n)\), where \(n\) is the size of the array. This is because we only need to traverse the array once, updating the maximum sum subarray ending at each position.

3. **Divide and Conquer Approach**:
   - This approach involves dividing the array into two halves, finding the maximum subarray sum in each half recursively, and then combining the results.
   - Time Complexity: \(O(n \log n)\), where \(n\) is the size of the array. This is because the array is divided in half recursively, similar to the merge sort algorithm, and each level of recursion takes linear time to compute the maximum subarray sum.

4. **Dynamic Programming**:
   - This approach involves calculating the maximum subarray sum ending at each position of the array and then finding the maximum of these sums.
   - Time Complexity: \(O(n)\), where \(n\) is the size of the array. Similar to Kadane's Algorithm, we traverse the array once, calculating and updating the maximum subarray sum ending at each position.

Among these approaches, Kadane's Algorithm and the Dynamic Programming approach are the most commonly used due to their \(O(n)\) time complexity, making them efficient for large input arrays.

### 1. Algorithms & Data Structures (C++): Maximum Sum Subarray

To find the maximum sum subarray in an array, you can use Kadane's algorithm. Here's a C++ implementation:

```cpp
#include <iostream>
#include <vector>

using namespace std;

pair<int, int> findMaximumSumSubarray(const vector<int>& nums) {
    int maxEndingHere = nums[0];
    int maxSoFar = nums[0];
    int start = 0;
    int end = 0;
    int tempStart = 0;

    for (int i = 1; i < nums.size(); ++i) {
        if (nums[i] > maxEndingHere + nums[i]) {
            maxEndingHere = nums[i];
            tempStart = i;
        } else {
            maxEndingHere = maxEndingHere + nums[i];
        }

        if (maxSoFar < maxEndingHere) {
            maxSoFar = maxEndingHere;
            start = tempStart;
            end = i;
        }
    }

    return make_pair(start, end);
}

int main() {
    vector<int> nums = { -2, 1, -3, 4, -1, 2, 1, -5, 4 };
    pair<int, int> result = findMaximumSumSubarray(nums);

    cout << "Maximum sum subarray: ";
    for (int i = result.first; i <= result.second; ++i) {
        cout << nums[i] << " ";
    }
    cout << endl;

    cout << "Maximum sum: " << result.second - result.first + 1 << endl;

    return 0;
}
```

This code will find the maximum sum subarray within the given array `nums`. It prints both the maximum sum subarray and its sum. You can replace the sample `nums` vector with your own array to test the algorithm.

### 1. Algorithms & Data Structures (C++): Maximum Sum Subarray - Arrays

To find the maximum sum subarray in an array, you can use the Kadane's Algorithm. This algorithm efficiently solves the problem in O(n) time complexity. Here's how it works:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int maxSubArraySum(vector<int>& nums) {
    int maxSum = nums[0];
    int currentSum = nums[0];

    for (int i = 1; i < nums.size(); ++i) {
        // At each step, decide whether to start a new subarray or extend the current one.
        currentSum = max(nums[i], currentSum + nums[i]);
        // Update the maximum sum encountered so far.
        maxSum = max(maxSum, currentSum);
    }

    return maxSum;
}

int main() {
    vector<int> nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4}; // Example array

    int maxSum = maxSubArraySum(nums);

    cout << "Maximum sum of subarray: " << maxSum << endl;

    return 0;
}
```

In this code:

- We initialize two variables, `maxSum` and `currentSum`, both to the first element of the array.
- We iterate over the array starting from the second element.
- At each step, we decide whether to start a new subarray at the current element or extend the current subarray by adding the current element to it.
- We update `currentSum` to be the maximum of the current element and the sum of the current element and the previous `currentSum`.
- We update `maxSum` to be the maximum of `maxSum` and `currentSum`.
- After the loop, `maxSum` holds the maximum sum of any subarray in the given array.

You can replace the `nums` vector with any array of integers you want to find the maximum sum subarray for.

### 1. Algorithms & Data Structures (C++): Merge intervals

Certainly! The "merge intervals" problem is a classic algorithmic problem that involves merging overlapping intervals. Here's a C++ implementation along with explanations:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// Definition for an interval.
struct Interval {
    int start;
    int end;
    Interval() : start(0), end(0) {}
    Interval(int s, int e) : start(s), end(e) {}
};

vector<Interval> merge(vector<Interval>& intervals) {
    // Sort intervals based on start times
    sort(intervals.begin(), intervals.end(), [](const Interval& a, const Interval& b) {
        return a.start < b.start;
    });

    vector<Interval> mergedIntervals;

    for (const auto& interval : intervals) {
        if (mergedIntervals.empty() || interval.start > mergedIntervals.back().end) {
            // If the current interval doesn't overlap with the previous one, add it to the result
            mergedIntervals.push_back(interval);
        } else {
            // If the current interval overlaps with the previous one, merge them
            mergedIntervals.back().end = max(mergedIntervals.back().end, interval.end);
        }
    }

    return mergedIntervals;
}

// Helper function to print intervals
void printIntervals(const vector<Interval>& intervals) {
    for (const auto& interval : intervals) {
        cout << "[" << interval.start << ", " << interval.end << "] ";
    }
    cout << endl;
}

int main() {
    vector<Interval> intervals = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};
    cout << "Original intervals: ";
    printIntervals(intervals);

    vector<Interval> merged = merge(intervals);
    cout << "Merged intervals: ";
    printIntervals(merged);

    return 0;
}
```

Explanation:

1. We define a struct `Interval` to represent intervals with start and end times.
2. The `merge` function takes a vector of intervals and returns a vector of merged intervals.
3. First, we sort the intervals based on their start times. This is necessary to efficiently merge overlapping intervals.
4. We initialize an empty vector `mergedIntervals` to store the merged intervals.
5. We iterate through each interval in the sorted vector. If `mergedIntervals` is empty or if the current interval doesn't overlap with the last interval in `mergedIntervals`, we add the current interval to `mergedIntervals`. Otherwise, we merge the current interval with the last interval in `mergedIntervals`.
6. Finally, we return `mergedIntervals`.
7. In the `main` function, we demonstrate the usage of the `merge` function with an example set of intervals and print the original and merged intervals.

This code efficiently merges overlapping intervals in O(n log n) time complexity, where n is the number of intervals, due to the sorting step.

### 1. Algorithms & Data Structures (C++): Merge Intervals - Stacks

Sure, I can help with that! In C++, you can use a stack to merge intervals efficiently. The idea is to sort the intervals based on their start times, then iterate through the sorted intervals, merging overlapping intervals as you go. Here's a sample implementation:

```cpp
#include <iostream>
#include <vector>
#include <stack>
#include <algorithm>

using namespace std;

// Interval structure
struct Interval {
    int start;
    int end;
    Interval() : start(0), end(0) {}
    Interval(int s, int e) : start(s), end(e) {}
};

// Function to merge overlapping intervals
vector









<pair<int, int>> mergeIntervals(vector<pair<int, int>>& intervals) {
    // If there are no intervals or just one interval, return as is
    if (intervals.size() <= 1)
        return intervals;

    // Sort intervals based on their start times
    sort(intervals.begin(), intervals.end());

    // Create a stack to store merged intervals
    stack<pair<int, int>> mergedStack;

    // Push the first interval onto the stack
    mergedStack.push(intervals[0]);

    // Iterate through the intervals
    for (int i = 1; i < intervals.size(); ++i) {
        auto currentInterval = intervals[i];
        auto& topInterval = mergedStack.top();

        // If the current interval overlaps with the top interval on the stack, merge them
        if (currentInterval.first <= topInterval.second) {
            topInterval.second = max(topInterval.second, currentInterval.second);
        } else {
            // If there's no overlap, push the current interval onto the stack
            mergedStack.push(currentInterval);
        }
    }

    // Extract the merged intervals from the stack
    vector<pair<int, int>> mergedIntervals;
    while (!mergedStack.empty()) {
        mergedIntervals.push_back(mergedStack.top());
        mergedStack.pop();
    }

    // Reverse the order of intervals to maintain the original order
    reverse(mergedIntervals.begin(), mergedIntervals.end());

    return mergedIntervals;
}

int main() {
    // Example usage
    vector<pair<int, int>> intervals = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};
    vector<pair<int, int>> merged = mergeIntervals(intervals);
    
    // Print the merged intervals
    cout << "Merged Intervals:" << endl;
    for (const auto& interval : merged) {
        cout << "[" << interval.first << ", " << interval.second << "] ";
    }
    cout << endl;

    return 0;
}
```

This code first sorts the intervals based on their start times. Then, it iterates through the sorted intervals, merging overlapping intervals by updating the end time of the top interval on the stack. Finally, it extracts the merged intervals from the stack and reverses the order to maintain the original order of intervals.

### 1. Algorithms & Data Structures (C++): Merge intervals: Complexity analysis

The complexity analysis of the merge intervals algorithm in C++ typically revolves around two main aspects: the sorting step and the merging step.

Here's a brief overview of the complexity analysis:

1. **Sorting Step**:
   The merge intervals algorithm often starts with sorting the intervals based on their start points. Sorting algorithms like quicksort or mergesort are commonly used, with a time complexity of O(n log n), where 'n' is the number of intervals.

2. **Merging Step**:
   After sorting, the algorithm iterates through the sorted intervals, merging overlapping intervals. This step typically has a time complexity of O(n), where 'n' is the number of intervals. This is because each interval is visited once.

So, the overall time complexity of the merge intervals algorithm is dominated by the sorting step, resulting in O(n log n) complexity, where 'n' is the number of intervals.

Additionally, if the intervals are already sorted or if the intervals are represented using a data structure like a balanced binary search tree (BST), the sorting step can be avoided, reducing the time complexity to O(n log n) for sorting and merging in total.

The space complexity of the algorithm usually depends on the sorting algorithm used. It can range from O(log n) to O(n) for the sorting step, and O(1) for the merging step if the intervals are modified in place, or O(n) if a new list of merged intervals is created.

### 1. Algorithms & Data Structures (C++): Merge K sorted List

To merge K sorted lists in C++, you can use a min heap (priority queue) data structure. Here's a step-by-step guide:

1. Define a struct or class to represent nodes of the linked list.
2. Implement a custom comparator for the priority queue to compare nodes.
3. Create a priority queue and push the heads of all K lists into it.
4. Pop the top element from the priority queue and add it to the merged list.
5. If the popped element has a next node, push the next node to the priority queue.
6. Repeat steps 4-5 until the priority queue is empty.
7. Return the merged list.

Here's the C++ code implementing the above steps:

```cpp
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

// Custom comparator for priority queue
struct CompareNodes {
    bool operator()(const ListNode* lhs, const ListNode* rhs) const {
        return lhs->val > rhs->val; // Min heap
    }
};

class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        // Priority queue to maintain the min heap
        priority_queue<ListNode*, vector<ListNode*>, CompareNodes> pq;
        
        // Push the heads of all lists into the priority queue
        for (ListNode* node : lists) {
            if (node) // Check if the list is not empty
                pq.push(node);
        }
        
        // Dummy node to simplify code
        ListNode dummy(0);
        ListNode* tail = &dummy;
        
        // Merge lists until the priority queue is empty
        while (!pq.empty()) {
            // Pop the top element from the priority queue
            ListNode* top = pq.top();
            pq.pop();
            
            // Add the popped node to the merged list
            tail->next = top;
            tail = tail->next;
            
            // Push the next node of the popped node to the priority queue
            if (top->next) {
                pq.push(top->next);
            }
        }
        
        return dummy.next;
    }
};

// Utility function to print the merged list
void printList(ListNode* head) {
    while (head) {
        cout << head->val << " ";
        head = head->next;
    }
    cout << endl;
}

int main() {
    // Example usage
    ListNode* l1 = new ListNode(1);
    l1->next = new ListNode(4);
    l1->next->next = new ListNode(5);

    ListNode* l2 = new ListNode(1);
    l2->next = new ListNode(3);
    l2->next->next = new ListNode(4);

    ListNode* l3 = new ListNode(2);
    l3->next = new ListNode(6);

    vector<ListNode*> lists = {l1, l2, l3};

    Solution sol;
    ListNode* mergedList = sol.mergeKLists(lists);

    cout << "Merged List: ";
    printList(mergedList);

    // Free memory
    while (mergedList) {
        ListNode* temp = mergedList;
        mergedList = mergedList->next;
        delete temp;
    }

    return 0;
}
```

This code defines a `ListNode` struct, a custom comparator `CompareNodes`, and a `Solution` class with the `mergeKLists` method. In the `main` function, it demonstrates how to use the `mergeKLists` method with an example.

### 1. Algorithms & Data Structures (C++): Merge K-Sorted Arrays

To merge k sorted arrays efficiently, you can use a min-heap (priority queue in C++). Here's how you can implement it in C++:

```cpp
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

// Define a structure to store elements of arrays
struct ArrayElement {
    int value;  // Value of element
    int arrayIndex; // Index of the array from which this element belongs
    int elementIndex; // Index of the element in its array

    // Constructor
    ArrayElement(int v, int ai, int ei) : value(v), arrayIndex(ai), elementIndex(ei) {}
};

// Custom comparator for the priority queue
struct Compare {
    bool operator()(const ArrayElement& a, const ArrayElement& b) {
        // Compare based on element value
        return a.value > b.value;
    }
};

vector<int> mergeKSortedArrays(vector<vector<int>>& arrays) {
    vector<int> result;
    priority_queue<ArrayElement, vector<ArrayElement>, Compare> minHeap;

    // Push the first element of each array into the minHeap
    for (int i = 0; i < arrays.size(); ++i) {
        if (!arrays[i].empty()) {
            minHeap.push(ArrayElement(arrays[i][0], i, 0));
        }
    }

    // Merge arrays using minHeap
    while (!minHeap.empty()) {
        // Get the minimum element from minHeap
        ArrayElement minElement = minHeap.top();
        minHeap.pop();

        // Add the minimum element to result
        result.push_back(minElement.value);

        // Check if there is next element in the array from which minElement belongs
        if (minElement.elementIndex + 1 < arrays[minElement.arrayIndex].size()) {
            // Push the next element of the same array to minHeap
            minHeap.push(ArrayElement(arrays[minElement.arrayIndex][minElement.elementIndex + 1],
                                       minElement.arrayIndex,
                                       minElement.elementIndex + 1));
        }
    }

    return result;
}

int main() {
    vector<vector<int>> arrays = {
        {1, 3, 5, 7},
        {2, 4, 6, 8},
        {0, 9, 10, 11}
    };

    vector<int> mergedArray = mergeKSortedArrays(arrays);

    cout << "Merged Array: ";
    for (int num : mergedArray) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}
```

This code defines a `mergeKSortedArrays` function that takes a vector of vectors, each representing a sorted array. It then iteratively picks the smallest element from the arrays using a min-heap, ensuring that the resulting array is also sorted. Finally, it returns the merged array.

### 1. Algorithms & Data Structures (C++): Merging K-Arrays

Merging K sorted arrays is a classic problem in computer science. One of the efficient ways to solve this problem is by using a min-heap (priority queue) data structure. Here's how you can do it in C++:

```cpp
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

// Define a structure to hold the element and its array index
struct Element {
    int value;
    int arrayIndex;
    int elementIndex;

    Element(int v, int ai, int ei) : value(v), arrayIndex(ai), elementIndex(ei) {}

    // Overload the comparison operator for min-heap
    bool operator>(const Element& other) const {
        return value > other.value;
    }
};

// Function to merge K sorted arrays
vector<int> mergeKArrays(vector<vector<int>>& arrays) {
    // Priority queue to hold elements from all arrays
    priority_queue<Element, vector<Element>, greater<Element>> minHeap;

    // Push the first element from each array into the min-heap
    for (int i = 0; i < arrays.size(); ++i) {
        if (!arrays[i].empty()) {
            minHeap.push(Element(arrays[i][0], i, 0));
        }
    }

    // Result vector to store the merged array
    vector<int> mergedArray;

    // Merge the arrays until the min-heap is empty
    while (!minHeap.empty()) {
        // Get the smallest element from the min-heap
        Element smallest = minHeap.top();
        minHeap.pop();

        // Add the smallest element to the merged array
        mergedArray.push_back(smallest.value);

        // Get the next element from the array containing the smallest element
        int nextIndex = smallest.elementIndex + 1;
        if (nextIndex < arrays[smallest.arrayIndex].size()) {
            minHeap.push(Element(arrays[smallest.arrayIndex][nextIndex], smallest.arrayIndex, nextIndex));
        }
    }

    return mergedArray;
}

int main() {
    // Example usage
    vector<vector<int>> arrays = {{1, 3, 5, 7}, {2, 4, 6, 8}, {0, 9, 10, 11}};
    vector<int> merged = mergeKArrays(arrays);

    // Output the merged array
    cout << "Merged Array: ";
    for (int num : merged) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}
```

This code defines a `mergeKArrays` function that takes a vector of vectors representing K sorted arrays. It iterates through each array to push the first element of each array into a min-heap. Then, it continuously pops the smallest element from the min-heap and pushes the next element from the corresponding array into the min-heap until all elements are merged. Finally, it returns the merged array.

### 1. Algorithms & Data Structures (C++): Merging Ropes

Merging ropes is a classic problem that can be efficiently solved using a priority queue (min-heap). The problem statement typically goes like this:

Given N ropes of different lengths, we want to merge them into a single rope. The cost of merging two ropes is equal to the sum of their lengths. Find the minimum cost to merge all ropes into one.

Here's how you can implement this in C++:

```cpp
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

int minCostToMergeRopes(vector<int>& ropes) {
    // Create a min-heap priority queue
    priority_queue<int, vector<int>, greater<int>> minHeap;

    // Push all the rope lengths into the min-heap
    for (int rope : ropes) {
        minHeap.push(rope);
    }

    int totalCost = 0;

    // While there is more than one rope left in the min-heap
    while (minHeap.size() > 1) {
        // Extract the two shortest ropes from the min-heap
        int rope1 = minHeap.top();
        minHeap.pop();
        int rope2 = minHeap.top();
        minHeap.pop();

        // Merge the two ropes and add the cost to the total
        int mergedLength = rope1 + rope2;
        totalCost += mergedLength;

        // Add the merged rope back to the min-heap
        minHeap.push(mergedLength);
    }

    return totalCost;
}

int main() {
    vector<int> ropes = {4, 3, 2, 6};
    cout << "Minimum cost to merge all ropes: " << minCostToMergeRopes(ropes) << endl;
    return 0;
}
```

This code defines a function `minCostToMergeRopes` that takes a vector of rope lengths as input and returns the minimum cost to merge all ropes. It uses a priority queue to efficiently find the shortest ropes to merge at each step. The main function demonstrates how to use this function with a sample input vector.

### 1. Algorithms & Data Structures (C++): Message Route

"Message Route" is a classic problem that can be solved using graph traversal algorithms, particularly Breadth-First Search (BFS). Here's a basic outline of how you might approach solving this problem in C++:

```cpp
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

const int INF = 1e9; // Infinity

void bfs(vector<vector<int>>& adj, vector<int>& dist, int start) {
    queue<int> q;
    q.push(start);
    dist[start] = 0;

    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int v : adj[u]) {
            if (dist[v] == INF) {
                dist[v] = dist[u] + 1;
                q.push(v);
            }
        }
    }
}

int main() {
    int n, m;
    cin >> n >> m; // n: number of nodes, m: number of edges

    vector<vector<int>> adj(n + 1); // adjacency list
    vector<int> dist(n + 1, INF);    // distances from the start node

    for (int i = 0; i < m; ++i) {
        int a, b;
        cin >> a >> b;
        adj[a].push_back(b);
        adj[b].push_back(a); // Since it's an undirected graph
    }

    bfs(adj, dist, 1); // Start BFS from node 1

    if (dist[n] == INF) {
        cout << "IMPOSSIBLE" << endl;
    } else {
        vector<int> path;
        int cur = n;
        while (cur != 1) {
            path.push_back(cur);
            for (int v : adj[cur]) {
                if (dist[v] == dist[cur] - 1) {
                    cur = v;
                    break;
                }
            }
        }
        path.push_back(1);
        reverse(path.begin(), path.end());

        cout << path.size() << endl;
        for (int node : path) {
            cout << node << " ";
        }
        cout << endl;
    }

    return 0;
}
```

This code performs a BFS traversal of the graph starting from node 1 and calculates the shortest distance to each node from the starting node. Finally, it constructs the shortest path from node 1 to node n and prints it. If there is no path from node 1 to node n, it prints "IMPOSSIBLE".

### 1. Algorithms & Data Structures (C++): Microsoft Array Question: Container with most water

The problem you're referring to is a classic algorithmic question often known as the "Container With Most Water" problem. Here's how it typically goes:

#### Problem Statement

Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of the line i is at (i, ai) and (i, 0). Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.

#### Example

Input: [1, 8, 6, 2, 5, 4, 8, 3, 7]  
Output: 49 (the max area of the container formed is between 7 and 8 with a height of 7 and a width of 7)

#### Approach (Two Pointer Technique)

The brute-force approach would be to consider all possible pairs of lines and calculate the area formed by each pair. However, that would take O(n^2) time.

A more optimal approach is to use the two-pointer technique. Here's how it works:

1. Initialize two pointers, one at the beginning of the array and one at the end.
2. Calculate the area formed by these two pointers.
3. Move the pointer with the smaller height inward.
4. Repeat steps 2 and 3 until the pointers meet.

#### C++ Code

```cpp
#include <vector>
#include <algorithm>

int maxArea(std::vector<int>& height) {
    int max_area = 0;
    int left = 0;
    int right = height.size() - 1;
    
    while (left < right) {
        int h = std::min(height[left], height[right]);
        max_area = std::max(max_area, h * (right - left));
        if (height[left] < height[right])
            left++;
        else
            right--;
    }
    
    return max_area;
}

// Example usage:
int main() {
    std::vector<int> heights = {1, 8, 6, 2, 5, 4, 8, 3, 7};
    int max_area = maxArea(heights);
    return 0;
}
```

This code should efficiently solve the problem in O(n) time complexity, where n is the number of elements in the input array.

### 1. Algorithms & Data Structures (C++): Microsoft Backtracking question: Word Search

The "Word Search" problem is a classic backtracking problem often used in technical interviews. In this problem, you're given a 2D board of letters and a word to search for. You need to determine if the word exists in the grid.

Here's a basic outline of the algorithm in C++:

```cpp
#include <iostream>
#include <vector>
#include <string>

using namespace std;

bool search(vector<vector<char>>& board, string word, int i, int j, int k) {
    if (i < 0 || j < 0 || i >= board.size() || j >= board[0].size() || board[i][j] != word[k])
        return false;
    if (k == word.length() - 1)
        return true;
    
    char temp = board[i][j];
    board[i][j] = '*'; // Mark the current cell as visited
    
    // Recur for all the adjacent cells
    if (search(board, word, i + 1, j, k + 1) ||
        search(board, word, i - 1, j, k + 1) ||
        search(board, word, i, j + 1, k + 1) ||
        search(board, word, i, j - 1, k + 1)) {
        return true;
    }
    
    // Mark back the current cell as unvisited
    board[i][j] = temp;
    return false;
}

bool exist(vector<vector<char>>& board, string word) {
    for (int i = 0; i < board.size(); ++i) {
        for (int j = 0; j < board[0].size(); ++j) {
            if (search(board, word, i, j, 0))
                return true;
        }
    }
    return false;
}

int main() {
    vector<vector<char>> board = {
        {'A', 'B', 'C', 'E'},
        {'S', 'F', 'C', 'S'},
        {'A', 'D', 'E', 'E'}
    };
    string word = "ABCCED";
    cout << (exist(board, word) ? "Word found" : "Word not found") << endl;
    return 0;
}
```

In this code:

- `exist()` function iterates through each cell in the board and calls the `search()` function to check if the word exists starting from that cell.
- `search()` function is a recursive function that tries to match each character of the word with the corresponding cell in the board. If a match is found, it recursively explores neighboring cells until the entire word is found or all possibilities are exhausted.

This algorithm employs backtracking to explore all possible paths until either the word is found or all paths are exhausted.

### 1. Algorithms & Data Structures (C++): Microsoft Dynamic Programming Question: Longest Palindromic Substring

The problem of finding the longest palindromic substring can be efficiently solved using dynamic programming. Here's the C++ implementation for finding the longest palindromic substring:

```cpp
#include <iostream>
#include <string>

using namespace std;

string longestPalindrome(string s) {
    int n = s.length();
    if (n == 0) return "";

    bool dp[n][n];
    int maxLen = 1;
    int start = 0;

    // Initialize the dp table
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            dp[i][j] = false;
        }
    }

    // All substrings of length 1 are palindromes
    for (int i = 0; i < n; i++) {
        dp[i][i] = true;
    }

    // Check for substrings of length 2
    for (int i = 0; i < n - 1; i++) {
        if (s[i] == s[i + 1]) {
            dp[i][i + 1] = true;
            start = i;
            maxLen = 2;
        }
    }

    // Check for substrings of length > 2
    for (int len = 3; len <= n; len++) {
        for (int i = 0; i < n - len + 1; i++) {
            int j = i + len - 1; // end index of current substring

            if (s[i] == s[j] && dp[i + 1][j - 1]) {
                dp[i][j] = true;
                if (len > maxLen) {
                    start = i;
                    maxLen = len;
                }
            }
        }
    }

    return s.substr(start, maxLen);
}

int main() {
    string s = "babad";
    cout << "Longest Palindromic Substring: " << longestPalindrome(s) << endl;
    return 0;
}
```

This code uses dynamic programming to solve the problem in O(n^2) time complexity and O(n^2) space complexity, where 'n' is the length of the input string 's'.

### 1. Algorithms & Data Structures (C++): Microsoft Hash Tables / Dictionaries question: LRU Cache

Certainly! An LRU (Least Recently Used) Cache is a data structure used to store a limited number of items, with the constraint that when the cache reaches its limit, it should evict the least recently used item to make space for new items. This is particularly useful in scenarios where you want to cache frequently accessed data to improve performance.

In C++, you can implement an LRU Cache using a combination of a hash table (unordered_map in C++) for fast lookup and a doubly linked list for maintaining the order of access. Here's a basic outline of how you might implement it:

```cpp
#include <iostream>
#include <unordered_map>

using namespace std;

// Definition of a doubly linked list node
struct ListNode {
    int key;
    int value;
    ListNode* prev;
    ListNode* next;
    
    ListNode(int k, int v) : key(k), value(v), prev(nullptr), next(nullptr) {}
};

class LRUCache {
private:
    unordered_map<int, ListNode*> cache; // Hash table for fast lookup
    ListNode* head; // Dummy head node
    ListNode* tail; // Dummy tail node
    int capacity;
    
public:
    LRUCache(int capacity) : capacity(capacity) {
        head = new ListNode(-1, -1);
        tail = new ListNode(-1, -1);
        head->next = tail;
        tail->prev = head;
    }
    
    int get(int key) {
        if (cache.find(key) == cache.end()) {
            return -1; // Key not found
        }
        
        // Move the accessed node to the head
        ListNode* node = cache[key];
        moveToHead(node);
        return node->value;
    }
    
    void put(int key, int value) {
        if (cache.find(key) != cache.end()) {
            // If key exists, update its value and move it to the head
            ListNode* node = cache[key];
            node->value = value;
            moveToHead(node);
        } else {
            // If key doesn't exist, create a new node and add it to the head
            ListNode* newNode = new ListNode(key, value);
            cache[key] = newNode;
            addToHead(newNode);
            
            // If capacity is exceeded, remove the least recently used node
            if (cache.size() > capacity) {
                ListNode* tailPrev = tail->prev;
                removeNode(tailPrev);
                cache.erase(tailPrev->key);
                delete tailPrev;
            }
        }
    }
    
private:
    // Helper function to move a node to the head
    void moveToHead(ListNode* node) {
        removeNode(node);
        addToHead(node);
    }
    
    // Helper function to add a node to the head
    void addToHead(ListNode* node) {
        node->next = head->next;
        head->next->prev = node;
        head->next = node;
        node->prev = head;
    }
    
    // Helper function to remove a node from the list
    void removeNode(ListNode* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }
};
```

In this implementation:

- The `ListNode` struct represents a node in the doubly linked list, containing the key-value pair.
- The `LRUCache` class manages the cache. It uses a hash table `cache` for fast key-value lookup and a doubly linked list to maintain the order of access.
- The `get` method retrieves the value associated with a given key. If the key exists, it moves the corresponding node to the head of the list (indicating it was recently used).
- The `put` method inserts a new key-value pair into the cache. If the key already exists, it updates the value and moves the corresponding node to the head. If the cache capacity is exceeded, it removes the least recently used node from the tail.

This implementation provides O(1) time complexity for both get and put operations, thanks to the hash table. The doubly linked list helps maintain the order of access and enables efficient removal and insertion of nodes.

### 1. Algorithms & Data Structures (C++): Microsoft Linked list question: Reverse linked list

To reverse a linked list in C++, you can follow these steps:

1. Initialize three pointers: `current`, `prev`, and `next`.
2. Start from the head of the linked list.
3. Traverse through the list, updating pointers as follows:
   - Set `next` to the next node of `current`.
   - Point `current`'s `next` to `prev`.
   - Move `prev` to `current` and `current` to `next`.
4. Continue this process until `current` becomes `nullptr`.
5. Update the head of the list to be the last node, which will be pointed to by `prev`.

Here's the C++ code to accomplish this:

```cpp
#include <iostream>

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

ListNode* reverseList(ListNode* head) {
    ListNode *prev = nullptr;
    ListNode *current = head;
    ListNode *next = nullptr;
    
    while (current != nullptr) {
        next = current->next;  // Store next node
        current->next = prev;  // Reverse current node's pointer
        prev = current;        // Move pointers one position ahead
        current = next;
    }
    
    head = prev;  // Update head to point to the last node
    return head;
}

// Utility function to print the linked list
void printList(ListNode *node) {
    while (node != nullptr) {
        std::cout << node->val << " ";
        node = node->next;
    }
    std::cout << std::endl;
}

int main() {
    // Example usage
    ListNode *head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);

    std::cout << "Original list: ";
    printList(head);

    head = reverseList(head);

    std::cout << "Reversed list: ";
    printList(head);

    return 0;
}
```

This code defines a `ListNode` struct for each node in the linked list. The `reverseList` function takes the head of the linked list as input and returns the head of the reversed list. The `printList` function is a utility to print the elements of the linked list.

### 1. Algorithms & Data Structures (C++): Microsoft Math Question: Missing Number

To solve the missing number problem efficiently, you can utilize the XOR operation. XOR has a useful property that if you XOR a number with itself, the result is 0. Also, XOR is commutative and associative, meaning the order of operands does not matter, and you can group them in any way.

Here's how you can solve the missing number problem using XOR:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int findMissingNumber(const vector<int>& nums) {
    int missing = nums.size(); // Initialize missing as the last index
    for (int i = 0; i < nums.size(); ++i) {
        missing ^= i ^ nums[i]; // XOR current index and element
    }
    return missing;
}

int main() {
    vector<int> nums = {0, 1, 3, 4, 5}; // Example array with one missing number
    int missingNumber = findMissingNumber(nums);
    cout << "The missing number is: " << missingNumber << endl;
    return 0;
}
```

In this code:

1. We initialize the `missing` variable as the size of the array because we know the missing number will be between 0 and the size of the array.
2. We iterate over each index and each element of the array.
3. We XOR each index with its corresponding element and update the `missing` variable.
4. Finally, the `missing` variable will hold the missing number.

This algorithm has a time complexity of O(n) and a space complexity of O(1), where n is the number of elements in the array.

### 1. Algorithms & Data Structures (C++): Microsoft Queue Question: Binary Tree Zigzag Level Order Traversal

To solve the Binary Tree Zigzag Level Order Traversal problem, you can use a breadth-first search (BFS) approach with a queue. However, to achieve the zigzag traversal, you'll need to modify the standard BFS a bit.

Here's a general outline of how you can approach this problem in C++:

```cpp
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
    vector<vector<int>> result;
    if (!root) return result;

    queue<TreeNode*> q;
    q.push(root);
    bool leftToRight = true;

    while (!q.empty()) {
        int size = q.size();
        vector<int> level(size);

        for (int i = 0; i < size; ++i) {
            TreeNode* node = q.front();
            q.pop();
            int index = leftToRight ? i : size - 1 - i; // Adjust index based on traversal direction
            level[index] = node->val;

            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }

        result.push_back(level);
        leftToRight = !leftToRight; // Switch the direction for the next level
    }

    return result;
}

int main() {
    // Example usage
    TreeNode* root = new TreeNode(3);
    root->left = new TreeNode(9);
    root->right = new TreeNode(20);
    root->right->left = new TreeNode(15);
    root->right->right = new TreeNode(7);

    vector<vector<int>> result = zigzagLevelOrder(root);

    // Output the result
    for (const auto& level : result) {
        for (int val : level) {
            cout << val << " ";
        }
        cout << endl;
    }

    return 0;
}
```

This code performs a BFS traversal of the binary tree, alternating the direction of traversal between levels. It uses a queue to keep track of nodes at each level and a flag (`leftToRight`) to determine whether to traverse the level from left to right or right to left. The traversal direction alternates after each level.

### 1. Algorithms & Data Structures (C++): Microsoft Trees question: Binary Tree Maximum Path Sum

The "Binary Tree Maximum Path Sum" problem is a classic algorithmic problem that can be solved using tree traversal techniques, such as Depth-First Search (DFS). The problem statement usually goes like this:

Given a binary tree, find the maximum path sum. The path may start and end at any node in the tree, but no two nodes in the path can be connected by the same edge.

Here's a basic outline of how you might approach solving this problem in C++:

1. Define a binary tree node structure:

```cpp
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

1. Define a helper function to perform DFS and calculate the maximum path sum:

```cpp
int maxPathSumHelper(TreeNode* root, int& maxSum) {
    if (!root) return 0;

    int leftSum = max(0, maxPathSumHelper(root->left, maxSum));
    int rightSum = max(0, maxPathSumHelper(root->right, maxSum));

    maxSum = max(maxSum, leftSum + rightSum + root->val);

    return max(leftSum, rightSum) + root->val;
}
```

1. Define the main function to find the maximum path sum:

```cpp
int maxPathSum(TreeNode* root) {
    int maxSum = INT_MIN;
    maxPathSumHelper(root, maxSum);
    return maxSum;
}
```

This solution works by recursively traversing the binary tree, calculating the maximum path sum that includes each node as the "highest" node of the path. At each node, it calculates the maximum sum achievable by including the node itself, and then updates the global maximum if necessary.

You can test this function by creating a binary tree and passing its root node to `maxPathSum` function. For example:

```cpp
int main() {
    TreeNode* root = new TreeNode(10);
    root->left = new TreeNode(2);
    root->right = new TreeNode(10);
    root->left->left = new TreeNode(20);
    root->left->right = new TreeNode(1);
    root->right->right = new TreeNode(-25);
    root->right->right->left = new TreeNode(3);
    root->right->right->right = new TreeNode(4);

    cout << "Maximum path sum is: " << maxPathSum(root) << endl;

    return 0;
}
```

This will output the maximum path sum in the given binary tree.

### 1. Algorithms & Data Structures (C++): Microsoft Trees question: Serialise And Deserialise Binary Tree

Serializing and deserializing a binary tree involves converting a binary tree to a string representation (serialization) and reconstructing the binary tree from its string representation (deserialization). Here's how you can do it in C++:

```cpp
#include <iostream>
#include <sstream>
#include <queue>
#include <string>
using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Serialize the binary tree to a string
string serialize(TreeNode* root) {
    if (root == nullptr)
        return "null";
    
    stringstream ss;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* curr = q.front();
        q.pop();
        
        if (curr != nullptr) {
            ss << curr->val << " ";
            q.push(curr->left);
            q.push(curr->right);
        } else {
            ss << "null ";
        }
    }
    return ss.str();
}

// Deserialize the string and reconstruct the binary tree
TreeNode* deserialize(string data) {
    if (data == "null")
        return nullptr;
    
    stringstream ss(data);
    string val;
    ss >> val;
    TreeNode* root = new TreeNode(stoi(val));
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* curr = q.front();
        q.pop();
        
        if (!(ss >> val)) break;
        if (val != "null") {
            curr->left = new TreeNode(stoi(val));
            q.push(curr->left);
        }
        
        if (!(ss >> val)) break;
        if (val != "null") {
            curr->right = new TreeNode(stoi(val));
            q.push(curr->right);
        }
    }
    return root;
}

// Helper function to print the binary tree (for testing)
void printTree(TreeNode* root) {
    if (root == nullptr) return;
    cout << root->val << " ";
    printTree(root->left);
    printTree(root->right);
}

int main() {
    // Example usage
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->right->left = new TreeNode(4);
    root->right->right = new TreeNode(5);

    cout << "Original Tree: ";
    printTree(root);
    cout << endl;

    string serialized = serialize(root);
    cout << "Serialized Tree: " << serialized << endl;

    TreeNode* deserialized = deserialize(serialized);

    cout << "Tree after deserialization: ";
    printTree(deserialized);
    cout << endl;

    return 0;
}
```

This code serializes the tree into a string by performing a level order traversal (BFS). Each node is appended to the string followed by its children (if any). "null" is used to represent null nodes. During deserialization, the string is split, and the tree is reconstructed level by level.

You can modify the code to handle different data types or adjust the serialization format as needed.

### 1. Algorithms & Data Structures (C++): Microsoft Trees question: Symmetric Trees

To solve the symmetric trees problem, you typically need to check if a binary tree is symmetric around its center. In other words, if you were to fold the tree along the root, the left subtree would match the right subtree.

Here's a typical approach to solving this problem:

1. **Recursive Solution**: Traverse the tree in a symmetric manner. You can do this by comparing the left subtree of the left child with the right subtree of the right child and vice versa.

2. **Base Case**: If both nodes are null, return true. If one node is null and the other is not, return false.

3. **Recursive Step**: Recur for the left and right subtrees of the current nodes. The recursion should check if the left subtree of the left child is symmetric with the right subtree of the right child, and if the right subtree of the left child is symmetric with the left subtree of the right child.

Here's a sample implementation in C++:

```cpp
#include <iostream>

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

bool isSymmetricUtil(TreeNode* leftNode, TreeNode* rightNode) {
    // If both nodes are null, they are symmetric.
    if (leftNode == nullptr && rightNode == nullptr)
        return true;
    
    // If one of the nodes is null but the other isn't, they are not symmetric.
    if (leftNode == nullptr || rightNode == nullptr)
        return false;
    
    // If values at current nodes don't match, they are not symmetric.
    if (leftNode->val != rightNode->val)
        return false;
    
    // Recur for the left subtree of the left child and the right subtree of the right child.
    // Recur for the right subtree of the left child and the left subtree of the right child.
    return isSymmetricUtil(leftNode->left, rightNode->right) && 
           isSymmetricUtil(leftNode->right, rightNode->left);
}

bool isSymmetric(TreeNode* root) {
    if (root == nullptr)
        return true;
    return isSymmetricUtil(root->left, root->right);
}

int main() {
    // Example usage
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(2);
    root->left->left = new TreeNode(3);
    root->left->right = new TreeNode(4);
    root->right->left = new TreeNode(4);
    root->right->right = new TreeNode(3);

    if (isSymmetric(root))
        cout << "Tree is symmetric";
    else
        cout << "Tree is not symmetric";
    
    return 0;
}
```

This implementation checks whether the given binary tree is symmetric around its center or not.

### 1. Algorithms & Data Structures (C++): Min Cost Climbing Stairs

The "Min Cost Climbing Stairs" problem is a classic dynamic programming problem. The problem can be stated as follows:

You are given an array `cost` where `cost[i]` is the cost of reaching step `i` (0-indexed). You can start at either step 0 or step 1. You are allowed to jump from step `i` to step `i+1` or step `i+2`. You need to find the minimum cost to reach the top of the floor, i.e., the topmost step.

Here's a C++ implementation to solve this problem:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int minCostClimbingStairs(std::vector<int>& cost) {
    int n = cost.size();
    if (n <= 1) return 0;

    std::vector<int> dp(n, 0);
    dp[0] = cost[0];
    dp[1] = cost[1];

    for (int i = 2; i < n; ++i) {
        dp[i] = cost[i] + std::min(dp[i-1], dp[i-2]);
    }

    // Minimum cost to reach the top floor can be either from the last or second last step.
    return std::min(dp[n-1], dp[n-2]);
}

int main() {
    std::vector<int> cost = {10, 15, 20};
    std::cout << "Minimum cost to reach the top: " << minCostClimbingStairs(cost) << std::endl;
    return 0;
}
```

This implementation defines a function `minCostClimbingStairs` that takes a vector of costs as input and returns the minimum cost to reach the top floor. It iterates through the steps, computing the minimum cost to reach each step using dynamic programming, and finally returns the minimum of the last two steps' costs.

### 1. Algorithms & Data Structures (C++): Min Cost to Reach Destination

To solve the problem of finding the minimum cost to reach a destination in a graph, you can use algorithms such as Dijkstra's algorithm or Bellman-Ford algorithm. These algorithms can be adapted to handle the problem of finding the minimum cost to reach a destination.

Here's a brief overview of how you can approach this problem using Dijkstra's algorithm in C++:

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <limits>

using namespace std;

#define INF numeric_limits<int>::max()

// Structure to represent a node in the graph
struct Node {
    int destination;
    int cost;
    Node(int dest, int c) : destination(dest), cost(c) {}
};

// Structure to represent a graph
class Graph {
    int V; // Number of vertices
    vector<vector<Node>> adj; // Adjacency list

public:
    Graph(int V) : V(V), adj(V) {}

    // Function to add an edge to the graph
    void addEdge(int u, int v, int w) {
        adj[u].push_back(Node(v, w));
    }

    // Function to find the minimum cost to reach destination using Dijkstra's algorithm
    int minCostToReachDestination(int source, int destination) {
        vector<int> dist(V, INF);
        dist[source] = 0;

        // Priority queue to store nodes to be processed
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        pq.push({0, source});

        while (!pq.empty()) {
            int u = pq.top().second;
            int cost = pq.top().first;
            pq.pop();

            if (u == destination)
                return dist[u];

            for (const auto& neighbor : adj[u]) {
                int v = neighbor.destination;
                int w = neighbor.cost;

                if (dist[u] + w < dist[v]) {
                    dist[v] = dist[u] + w;
                    pq.push({dist[v], v});
                }
            }
        }

        // If destination is not reachable
        return -1;
    }
};

int main() {
    // Example usage
    int V = 4; // Number of vertices
    Graph g(V);

    // Add edges with their respective weights
    g.addEdge(0, 1, 1);
    g.addEdge(0, 2, 4);
    g.addEdge(1, 2, 2);
    g.addEdge(1, 3, 5);
    g.addEdge(2, 3, 1);

    int source = 0;
    int destination = 3;

    int minCost = g.minCostToReachDestination(source, destination);
    if (minCost != -1)
        cout << "Minimum cost to reach destination: " << minCost << endl;
    else
        cout << "Destination is not reachable from the source." << endl;

    return 0;
}
```

This code snippet demonstrates how to use Dijkstra's algorithm to find the minimum cost to reach a destination in a graph. You can create a `Graph` object, add edges to it, and then call the `minCostToReachDestination` function with the source and destination vertices to get the result.

### 1. Algorithms & Data Structures (C++): Min Pairs

Certainly! "Min Pairs" is a problem often encountered in algorithmic challenges and interviews. The problem involves finding pairs of elements in an array (or any collection) such that their absolute difference is minimal. Here's a simple approach in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>

using namespace std;

// Function to find minimum difference pairs
void findMinPairs(vector<int>& arr) {
    // Sort the array first
    sort(arr.begin(), arr.end());
    
    // Initialize minimum difference
    int minDiff = INT_MAX;
    
    // Traverse the array and find minimum difference
    for (int i = 1; i < arr.size(); ++i) {
        int diff = arr[i] - arr[i - 1];
        if (diff < minDiff) {
            minDiff = diff;
        }
    }
    
    // Traverse again to print pairs with minimum difference
    for (int i = 1; i < arr.size(); ++i) {
        int diff = arr[i] - arr[i - 1];
        if (diff == minDiff) {
            cout << "(" << arr[i - 1] << ", " << arr[i] << ") ";
        }
    }
}

int main() {
    vector<int> arr = {4, 2, 1, 3, 5}; // Example array
    cout << "Minimum difference pairs: ";
    findMinPairs(arr);
    cout << endl;
    return 0;
}
```

In this code:

1. We sort the array first to make it easier to find pairs with minimum difference.
2. We then iterate through the sorted array once to find the minimum difference.
3. Finally, we iterate through the sorted array again to print pairs with the minimum difference found earlier.

This code will output the pairs with the minimum difference present in the given array.

### 1. Algorithms & Data Structures (C++): Min Stack - Stacks

In C++, implementing a stack that supports finding the minimum element in constant time (O(1)) is an interesting problem. This is typically done using two stacks: one to store the elements themselves and another to store the minimum elements encountered so far.

Here's a simple implementation of a MinStack class:

```cpp
#include <stack>
#include <limits>

class MinStack {
private:
    std::stack<int> elements; // to store elements
    std::stack<int> minStack; // to store minimum elements

public:
    void push(int x) {
        elements.push(x); // push the element onto the elements stack
        
        // If the minStack is empty or the new element is smaller than or equal to the top element of minStack, push it onto minStack
        if (minStack.empty() || x <= getMin()) {
            minStack.push(x);
        }
    }

    void pop() {
        // If the element being popped is the minimum element, pop it from minStack as well
        if (elements.top() == getMin()) {
            minStack.pop();
        }
        elements.pop(); // Always pop from elements stack
    }

    int top() {
        return elements.top();
    }

    int getMin() {
        // Top of minStack will always have the minimum element
        return minStack.top();
    }
};
```

Here's how you can use it:

```cpp
#include <iostream>

int main() {
    MinStack minStack;
    minStack.push(3);
    minStack.push(5);
    std::cout << minStack.getMin() << std::endl; // Output: 3
    minStack.push(2);
    std::cout << minStack.getMin() << std::endl; // Output: 2
    minStack.pop();
    std::cout << minStack.getMin() << std::endl; // Output: 3
    return 0;
}
```

This implementation ensures that the minimum element is always available in constant time.

### 1. Algorithms & Data Structures (C++): Minimum Add To Make Parantheses Valid - Stacks

Sure, the problem you're referring to is a classic problem in computer science where you need to find the minimum number of parentheses that need to be added to a string of parentheses to make it valid.

Here's a C++ solution using a stack to solve this problem:

```cpp
#include <iostream>
#include <stack>
#include <string>

using namespace std;

int minAddToMakeValid(string S) {
    stack<char> parenthesesStack;
    int additionsNeeded = 0;

    for (char c : S) {
        if (c == '(') {
            parenthesesStack.push(c);
        } else if (c == ')' && !parenthesesStack.empty() && parenthesesStack.top() == '(') {
            parenthesesStack.pop();
        } else {
            // If ')' and stack is empty or top is not '('
            additionsNeeded++;
        }
    }

    // Remaining open parentheses need to be closed
    additionsNeeded += parenthesesStack.size();

    return additionsNeeded;
}

int main() {
    string parentheses = "()))((";
    cout << "Minimum additions needed: " << minAddToMakeValid(parentheses) << endl;
    return 0;
}
```

This code iterates through the given string of parentheses. If it encounters an open parenthesis, it pushes it onto the stack. If it encounters a close parenthesis, it checks if the stack is empty or if the top of the stack contains an open parenthesis. If so, it pops the open parenthesis from the stack, indicating that it's been paired. If not, it means we need to add an additional closing parenthesis. After iterating through the entire string, any remaining open parentheses in the stack need to be paired, so we add their count to the total additions needed.

This algorithm runs in linear time complexity O(n), where n is the length of the input string.

### 1. Algorithms & Data Structures (C++): Minimum Add to Make Parentheses Valid

To solve the problem of finding the minimum number of parentheses to add to make a string valid, you can use a stack data structure. Here's a C++ implementation:

```cpp
#include <iostream>
#include <stack>
#include <string>

int minAddToMakeValid(std::string s) {
    std::stack<char> st;
    int count = 0;
    
    for (char c : s) {
        if (c == '(') {
            st.push(c);
        } else if (c == ')' && !st.empty()) {
            st.pop();
        } else {
            count++;
        }
    }
    
    return count + st.size();
}

int main() {
    std::string parentheses = "((()))())";
    std::cout << "Minimum number of parentheses to add: " << minAddToMakeValid(parentheses) << std::endl;
    return 0;
}
```

In this implementation:

- We iterate through the string character by character.
- If we encounter an opening parenthesis, we push it onto the stack.
- If we encounter a closing parenthesis and the stack is not empty (meaning there is a matching opening parenthesis), we pop from the stack.
- If we encounter any other character (which is not a parenthesis), we count it as an invalid character.
- Finally, the minimum number of parentheses to add is the sum of the count of invalid characters and the size of the stack (which contains unmatched opening parentheses).

### 1. Algorithms & Data Structures (C++): Minimum Bars

The "Minimum Bars" problem can be framed as follows: Given a sequence of integers representing the heights of bars, find the minimum number of bars that need to be added to make it such that each bar is at least as tall as the bar immediately to its right.

Here's a simple algorithm to solve this problem in C++:

```cpp
#include <iostream>
#include <vector>

int minBars(std::vector<int>& heights) {
    int barsToAdd = 0;
    int n = heights.size();
    
    for (int i = 0; i < n - 1; ++i) {
        if (heights[i] < heights[i + 1]) {
            int barsNeeded = heights[i + 1] - heights[i];
            barsToAdd += barsNeeded;
            heights[i] += barsNeeded;
        }
    }
    
    return barsToAdd;
}

int main() {
    // Example usage
    std::vector<int> heights = {1, 3, 2, 5, 4, 2, 3};
    int barsNeeded = minBars(heights);
    std::cout << "Minimum bars needed: " << barsNeeded << std::endl;
    
    return 0;
}
```

Explanation:

- We iterate through the given heights array. If the height of the current bar is less than the height of the next bar, we calculate the difference in height and add that to the number of bars needed. Additionally, we increase the height of the current bar to match the next bar.
- At the end of the loop, `barsToAdd` will hold the total number of bars needed.
- Finally, we return `barsToAdd`.

This algorithm has a time complexity of O(n), where n is the number of bars in the input sequence.

### 1. Algorithms & Data Structures (C++): Minimum cost for tickets (problem)

The "Minimum Cost for Tickets" problem is a classic dynamic programming problem. Here's the problem statement:

Given an array of days representing days of the year, and an array of costs representing the cost of tickets on each of these days, you need to find the minimum cost to travel all the days in the given array.

You can either buy a 1-day pass for each individual day, a 7-day pass that covers seven consecutive days (including the current day), or a 30-day pass that covers 30 consecutive days (including the current day). You may not buy more than one pass on a single day.

For example:

Input:
days = [1, 4, 6, 7, 8, 20]
costs = [2, 7, 15]

Output:
Minimum cost = 11

Explanation:
For day 1, we buy a 1-day pass for $2.
For days 4, 6, 7, 8, we buy a 7-day pass for $7.
For day 20, we buy a 1-day pass for $2.
Total cost = 2 + 7 + 2 = $11.

Here's the C++ implementation for solving this problem using dynamic programming:

```cpp
#include <vector>
#include <algorithm>

using namespace std;

int mincostTickets(vector<int>& days, vector<int>& costs) {
    // dp[i] represents the minimum cost to travel up to the i-th day
    vector<int> dp(366, 0);
    int dIndex = 0; // Index for the days array

    for (int i = 1; i <= 365; ++i) {
        // If i is not a travel day, then the cost is the same as previous day
        if (dIndex >= days.size() || i != days[dIndex]) {
            dp[i] = dp[i - 1];
        } else {
            dp[i] = min({
                dp[max(0, i - 1)] + costs[0],                           // 1-day pass
                dp[max(0, i - 7)] + costs[1],                           // 7-day pass
                dp[max(0, i - 30)] + costs[2]                           // 30-day pass
            });
            ++dIndex;
        }
    }

    return dp[days.back()]; // Return cost to travel all the days
}

int main() {
    vector<int> days = {1, 4, 6, 7, 8, 20};
    vector<int> costs = {2, 7, 15};
    int minCost = mincostTickets(days, costs);
    cout << "Minimum cost: " << minCost << endl;
    return 0;
}
```

This code should solve the problem efficiently using dynamic programming.

### 1. Algorithms & Data Structures (C++): Minimum cost for tickets (solution)

Sure, I can provide you with a C++ solution for the "Minimum Cost For Tickets" problem. This problem is a classic dynamic programming problem where you are given an array representing the days of the month, and you need to find the minimum cost to buy tickets for all the days based on certain rules.

Here's the problem statement:

You have to travel from one city to another. The cities are connected by a one-way road. The road has n stations between the two cities, numbered from 0 to n - 1 from city to city. The distances between adjacent stations are given as an array distances, where distances[i] represents the distance between station i and the next station (i + 1). You are given a subset of the integer array days representing the days of the month you want to travel on.

For each day i in days, you have two options:

- Travel by buying a one-day ticket, which costs costs[0].
- Travel by buying a seven-day ticket for the seven consecutive days starting from day i, which costs costs[1].
- Travel by buying a thirty-day ticket for the thirty consecutive days starting from day i, which costs costs[2].

You are allowed to start traveling on any day, and you can travel in any direction (city to city or city to city). You can buy at most one ticket of each type for each day.

Here's a possible C++ solution for this problem:

```cpp
#include <vector>
#include <unordered_set>
#include <algorithm>

using namespace std;

int mincostTickets(vector<int>& days, vector<int>& costs) {
    vector<int> dp(366, 0);
    unordered_set<int> travel(begin(days), end(days));
    
    for (int i = 1; i <= 365; ++i) {
        if (travel.find(i) == travel.end()) {
            dp[i] = dp[i - 1];
            continue;
        }
        
        int one_day = dp[i - 1] + costs[0];
        int seven_days = (i >= 7) ? dp[i - 7] + costs[1] : costs[1];
        int thirty_days = (i >= 30) ? dp[i - 30] + costs[2] : costs[2];
        
        dp[i] = min(one_day, min(seven_days, thirty_days));
    }
    
    return dp[365];
}
```

You can use this function by passing your `days` vector and `costs` vector as arguments. It will return the minimum cost required to travel on the given days according to the rules.

### 1. Algorithms & Data Structures (C++): Minimum Difference

To find the minimum difference between any two elements in an array, you can follow a simple approach using sorting. Here's how you can implement it in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>

int minDifference(std::vector<int>& nums) {
    // Sort the array
    std::sort(nums.begin(), nums.end());
    
    int minDiff = INT_MAX;
    
    // Iterate through the array and find the minimum difference
    for (int i = 1; i < nums.size(); ++i) {
        int diff = nums[i] - nums[i - 1];
        if (diff < minDiff) {
            minDiff = diff;
        }
    }
    
    return minDiff;
}

int main() {
    std::vector<int> nums = {4, 2, 1, 5, 7, 9, 3};
    
    int minDiff = minDifference(nums);
    
    std::cout << "Minimum difference between any two elements: " << minDiff << std::endl;
    
    return 0;
}
```

This code will output the minimum difference between any two elements in the array. The time complexity of this approach is O(n log n) due to the sorting operation, where n is the number of elements in the array.

### 1. Algorithms & Data Structures (C++): Minimum Distance

Certainly! The problem of finding the minimum distance between two points in a set of points is a classic problem in computational geometry. One common algorithm to solve this problem is the "Closest Pair of Points" algorithm, which has a time complexity of O(n log n) using techniques like divide and conquer.

Here's how you can implement the Closest Pair of Points algorithm in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <limits>

using namespace std;

struct Point {
    double x, y;
};

bool compareX(const Point& a, const Point& b) {
    return a.x < b.x;
}

bool compareY(const Point& a, const Point& b) {
    return a.y < b.y;
}

double distance(const Point& a, const Point& b) {
    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
}

double bruteForce(const vector<Point>& points, int start, int end) {
    double minDist = numeric_limits<double>::max();
    for (int i = start; i <= end; ++i) {
        for (int j = i + 1; j <= end; ++j) {
            minDist = min(minDist, distance(points[i], points[j]));
        }
    }
    return minDist;
}

double stripClosest(const vector<Point>& strip, double d) {
    double minDist = d;

    sort(strip.begin(), strip.end(), compareY);

    for (size_t i = 0; i < strip.size(); ++i) {
        for (size_t j = i + 1; j < strip.size() && (strip[j].y - strip[i].y) < minDist; ++j) {
            minDist = min(minDist, distance(strip[i], strip[j]));
        }
    }

    return minDist;
}

double closestUtil(const vector<Point>& points, int start, int end) {
    if (end - start <= 3) {
        return bruteForce(points, start, end);
    }

    int mid = (start + end) / 2;
    Point midPoint = points[mid];

    double dl = closestUtil(points, start, mid);
    double dr = closestUtil(points, mid + 1, end);
    double d = min(dl, dr);

    vector<Point> strip;
    for (int i = start; i <= end; i++) {
        if (abs(points[i].x - midPoint.x) < d) {
            strip.push_back(points[i]);
        }
    }

    return min(d, stripClosest(strip, d));
}

double closestPair(const vector<Point>& points) {
    vector<Point> sortedPoints = points;
    sort(sortedPoints.begin(), sortedPoints.end(), compareX);
    return closestUtil(sortedPoints, 0, sortedPoints.size() - 1);
}

int main() {
    vector<Point> points = {{2, 3}, {12, 30}, {40, 50}, {5, 1}, {12, 10}, {3, 4}};
    cout << "The smallest distance is " << closestPair(points) << endl;
    return 0;
}
```

This code defines a Point structure to represent the coordinates of a point in 2D space. The `closestPair` function takes a vector of points and returns the minimum distance between any two points. The `closestUtil` function is a recursive function that implements the divide and conquer approach. The `stripClosest` function calculates the minimum distance between points in the strip of a given width.

You can modify the `main` function to use your own set of points for testing.

### 1. Algorithms & Data Structures (C++): Minimum Distance Dynamic Programming

Dynamic programming is a powerful technique used to solve optimization problems by breaking them down into simpler subproblems and storing the solutions to these subproblems to avoid redundant computations. When it comes to minimum distance problems, dynamic programming can be particularly effective.

For instance, let's consider the problem of finding the minimum distance between two strings. We can define a recursive function to solve this problem and then apply dynamic programming to optimize it.

Here's a simple example in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int minDistance(string word1, string word2) {
    int m = word1.length();
    int n = word2.length();

    // Create a 2D DP array
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

    // Base cases: if one of the strings is empty
    for (int i = 0; i <= m; ++i) {
        dp[i][0] = i;
    }
    for (int j = 0; j <= n; ++j) {
        dp[0][j] = j;
    }

    // Fill DP array
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (word1[i - 1] == word2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = 1 + min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]});
            }
        }
    }

    // Return the minimum distance
    return dp[m][n];
}

int main() {
    string word1 = "kitten";
    string word2 = "sitting";

    cout << "Minimum distance between \"" << word1 << "\" and \"" << word2 << "\" is: " << minDistance(word1, word2) << endl;

    return 0;
}
```

In this example, `minDistance` function calculates the minimum distance between two strings `word1` and `word2` using dynamic programming. It fills a 2D DP array where `dp[i][j]` represents the minimum distance between the first `i` characters of `word1` and the first `j` characters of `word2`. It initializes the base cases where one of the strings is empty and then fills the DP array by considering three possible operations: deletion, insertion, or substitution, depending on whether the characters at the current positions are equal or not. Finally, it returns `dp[m][n]`, where `m` and `n` are the lengths of `word1` and `word2`, respectively, representing the minimum distance between the entire strings.

### 1. Algorithms & Data Structures (C++): Minimum Distance Recursive

Sure, I can outline a recursive approach to find the minimum distance between two nodes in a graph represented using adjacency lists in C++.

Here's a simple implementation:

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <climits>

using namespace std;

// Structure to represent an edge in the graph
struct Edge {
    int dest;
    int weight;
};

// Function to find the minimum distance between two nodes in a graph using recursion
int minDistance(vector<vector<Edge>>& graph, int src, int dest, vector<bool>& visited) {
    // If source and destination are same, distance is 0
    if (src == dest)
        return 0;

    // Mark the current node as visited
    visited[src] = true;

    // Initialize minimum distance as infinity
    int minDist = INT_MAX;

    // Recur for all the vertices adjacent to the current vertex
    for (auto& edge : graph[src]) {
        if (!visited[edge.dest]) {
            // Recur to find minimum distance from this adjacent vertex to destination
            int dist = minDistance(graph, edge.dest, dest, visited);

            // If the minimum distance from this adjacent vertex to destination is less than current minimum,
            // update the minimum distance
            if (dist != INT_MAX)
                minDist = min(minDist, dist + edge.weight);
        }
    }

    // Unmark the current node
    visited[src] = false;

    // Return the minimum distance
    return minDist;
}

// Function to add an edge to the graph
void addEdge(vector<vector<Edge>>& graph, int src, int dest, int weight) {
    graph[src].push_back({dest, weight});
}

int main() {
    int V = 5; // Number of vertices

    // Create a graph (adjacency list representation)
    vector<vector<Edge>> graph(V);

    // Add edges to the graph
    addEdge(graph, 0, 1, 4);
    addEdge(graph, 0, 2, 1);
    addEdge(graph, 1, 3, 1);
    addEdge(graph, 2, 1, 2);
    addEdge(graph, 2, 3, 5);
    addEdge(graph, 3, 4, 3);

    // Source and destination vertices
    int src = 0, dest = 4;

    // Create a boolean array to mark visited vertices
    vector<bool> visited(V, false);

    // Find the minimum distance between src and dest
    int minDist = minDistance(graph, src, dest, visited);

    if (minDist != INT_MAX)
        cout << "Minimum distance from " << src << " to " << dest << " is: " << minDist << endl;
    else
        cout << "There is no path from " << src << " to " << dest << endl;

    return 0;
}
```

This code finds the minimum distance between two nodes using a recursive approach. It assumes the graph is represented using adjacency lists. The `minDistance` function recursively explores all paths from the source node to the destination node and returns the minimum distance found.

### 1. Algorithms & Data Structures (C++): Minimum Jumps

To solve the minimum jumps problem in C++, you can use dynamic programming. Here's a basic implementation:

```cpp
#include <iostream>
#include <vector>
#include <climits>

using namespace std;

int minJumps(vector<int>& nums) {
    int n = nums.size();
    if (n <= 1)
        return 0;

    vector<int> jumps(n, INT_MAX);
    jumps[0] = 0;

    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (j + nums[j] >= i) {
                jumps[i] = min(jumps[i], jumps[j] + 1);
            }
        }
    }

    return jumps[n - 1];
}

int main() {
    vector<int> nums = {2, 3, 1, 1, 4}; // Example input
    cout << "Minimum number of jumps required: " << minJumps(nums) << endl;
    return 0;
}
```

This code defines a function `minJumps` that takes a vector of integers representing the maximum number of steps that can be taken from each position. It calculates the minimum number of jumps needed to reach the end of the array.

The main idea is to iterate through the array, maintaining an array `jumps` where `jumps[i]` represents the minimum number of jumps required to reach index `i`. For each index `i`, we iterate through all the previous indices `j` and update `jumps[i]` if we can reach index `i` from index `j` and the number of jumps required is less than the current minimum. Finally, we return `jumps[n - 1]`, where `n` is the size of the input array, which represents the minimum number of jumps required to reach the end of the array.

### 1. Algorithms & Data Structures (C++): Minimum Number of Taps to Open

The problem of finding the minimum number of taps to open is a classic algorithmic problem known as the "Minimum Number of Taps to Open" or sometimes referred to as the "Minimum Interval to Cover All Points". Here's a basic outline of how you might solve it:

1. **Sort the taps by their starting points**: This helps in traversing the taps in a sorted order of their starting points.

2. **Initialize variables**: Set a variable `maxReach` to represent the furthest point you can reach with the current tap. Also, initialize a variable `end` to represent the end point of the current interval.

3. **Iterate through the taps**: Start iterating through the taps sorted by their starting points. For each tap, if its starting point is within the current interval (`start <= end`), update `maxReach` to be the maximum of `maxReach` and the tap's end point. If the current tap's starting point is beyond the current interval, update `end` to `maxReach`, increment the count of taps used, and set `maxReach` to the end point of the current tap.

4. **Check if all points are covered**: After the loop, if `maxReach` is less than the total number of points, return -1, indicating that it's not possible to cover all points.

5. **Return the count of taps used**: If all points are covered, return the count of taps used.

Here's a C++ implementation based on the above approach:

```cpp
#include <vector>
#include <algorithm>

int minTaps(int n, std::vector<int>& ranges) {
    std::vector<std::pair<int, int>> taps; // Store taps as pairs of start and end points

    // Push the start and end points of each tap into the taps vector
    for (int i = 0; i <= n; ++i) {
        if (ranges[i] > 0) {
            taps.push_back({std::max(0, i - ranges[i]), std::min(n, i + ranges[i])});
        }
    }

    // Sort taps based on their start points
    std::sort(taps.begin(), taps.end());

    int count = 0, end = 0, maxReach = 0;

    for (const auto& tap : taps) {
        if (tap.first > end) {
            // If the current tap's start point is beyond the current interval
            if (maxReach <= end) return -1; // If there's a gap in coverage, return -1
            ++count; // Increment the count of taps used
            end = maxReach; // Update the end point of the current interval
        }
        maxReach = std::max(maxReach, tap.second); // Update maxReach if needed
        if (maxReach >= n) return count; // If all points are covered, return the count
    }

    if (maxReach <= end) return -1; // If there's a gap in coverage at the end, return -1

    return count;
}
```

This implementation should give you the minimum number of taps needed to cover all points, or -1 if it's not possible to cover all points.

### 1. Algorithms & Data Structures (C++): Minimum Size Subarray Sum

To solve the "Minimum Size Subarray Sum" problem, you can use a two-pointer technique. Here's the approach:

1. Initialize two pointers, `left` and `right`, both starting at index 0.
2. Keep moving the `right` pointer forward and updating the sum until the sum becomes greater than or equal to the target value or until the `right` pointer reaches the end of the array.
3. Once the sum is greater than or equal to the target value, move the `left` pointer forward and update the sum until the sum becomes less than the target value.
4. Keep track of the minimum length of subarrays that satisfy the condition.
5. Repeat steps 2-4 until the `right` pointer reaches the end of the array.

Here's a sample implementation in C++:

```cpp
#include <vector>
#include <limits>
#include <iostream>

int minSubArrayLen(int target, std::vector<int>& nums) {
    int n = nums.size();
    int minLen = std::numeric_limits<int>::max();
    int sum = 0;
    int left = 0;

    for (int right = 0; right < n; ++right) {
        sum += nums[right];

        while (sum >= target) {
            minLen = std::min(minLen, right - left + 1);
            sum -= nums[left++];
        }
    }

    return minLen == std::numeric_limits<int>::max() ? 0 : minLen;
}

int main() {
    std::vector<int> nums = {2, 3, 1, 2, 4, 3};
    int target = 7;
    std::cout << "Minimum length of subarray with sum at least " << target << ": "
              << minSubArrayLen(target, nums) << std::endl;
    return 0;
}
```

This code initializes the `left` pointer at the beginning of the array and iterates through the array with the `right` pointer. It maintains a sum of elements between the two pointers. When the sum becomes greater than or equal to the target, it updates the minimum length of subarrays that satisfy the condition and moves the `left` pointer forward until the sum is less than the target. Finally, it returns the minimum length found.

### 1. Algorithms & Data Structures (C++): N - Queens Problem

The N-Queens Problem is a classic problem in computer science and combinatorial optimization. The goal is to place N chess queens on an N×N chessboard in such a way that no two queens threaten each other. In other words, no two queens can share the same row, column, or diagonal.

Here's a C++ implementation of the N-Queens Problem using backtracking:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Function to check if a queen can be placed in board[row][col]
bool isSafe(vector<vector<int>>& board, int row, int col, int N) {
    // Check this row on the left side
    for (int i = 0; i < col; i++)
        if (board[row][i])
            return false;

    // Check upper diagonal on left side
    for (int i = row, j = col; i >= 0 && j >= 0; i--, j--)
        if (board[i][j])
            return false;

    // Check lower diagonal on left side
    for (int i = row, j = col; j >= 0 && i < N; i++, j--)
        if (board[i][j])
            return false;

    return true;
}

// Recursive function to solve N-Queens problem
bool solveNQueensUtil(vector<vector<int>>& board, int col, int N) {
    // If all queens are placed, return true
    if (col >= N)
        return true;

    // Consider this column and try placing this queen in all rows one by one
    for (int i = 0; i < N; i++) {
        // Check if the queen can be placed on board[i][col]
        if (isSafe(board, i, col, N)) {
            // Place this queen in board[i][col]
            board[i][col] = 1;

            // Recur to place rest of the queens
            if (solveNQueensUtil(board, col + 1, N))
                return true;

            // If placing queen in board[i][col] doesn't lead to a solution, then remove it
            board[i][col] = 0; // BACKTRACK
        }
    }

    // If the queen cannot be placed in any row in this column col, then return false
    return false;
}

// Function to solve N-Queens problem
bool solveNQueens(int N) {
    vector<vector<int>> board(N, vector<int>(N, 0));

    if (!solveNQueensUtil(board, 0, N)) {
        cout << "Solution does not exist.";
        return false;
    }

    // Print the solution
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++)
            cout << board[i][j] << " ";
        cout << endl;
    }
    return true;
}

int main() {
    int N;
    cout << "Enter the size of the chessboard (N x N): ";
    cin >> N;
    solveNQueens(N);
    return 0;
}
```

This code prompts the user to enter the size of the chessboard (N x N) and then prints one possible configuration of placing N queens on the board without threatening each other. If no solution exists, it prints "Solution does not exist."

### 1. Algorithms & Data Structures (C++): N and P positions

In algorithms and data structures, "N and P positions" typically refers to a game theory concept. Let's delve into it:

### N and P Positions

- **N Position (Next Player Wins):** In a game, if it's a player's turn and they are in an N position, it means that no matter what move they make, their opponent can respond with a move that leads them to a P position (Player position) where the current player will eventually win.

- **P Position (Previous Player Wins):** In contrast, if it's a player's turn and they are in a P position, it means that no matter what move they make, their opponent can respond with a move that leads them to an N position where the current player will eventually lose.

In simple terms, an N position is favorable for the player whose turn it is, while a P position is favorable for the opponent. The goal of the game is usually to avoid being in a P position, if possible, and force the opponent into one.

### Usage in Game Theory

N and P positions are often used in analyzing combinatorial games, where two players take turns making moves in a game with perfect information and no chance elements, such as chess, Go, or Nim. By determining the N and P positions within a game, players can develop strategies to maximize their chances of winning.

### Example

Consider the game of Nim, where players take turns removing objects from distinct heaps. The game ends when there are no objects left. The player who removes the last object wins.

- If the current number of objects in each heap is such that the bitwise XOR of all heap sizes is zero, then the current position is a P position.
- Otherwise, it's an N position.

In Nim, the optimal strategy is to leave your opponent in a P position whenever possible, ensuring that you eventually win the game.

### Implementation

In terms of implementation, determining N and P positions often involves analyzing the game rules and recursively determining the outcomes of possible moves. This can be done using techniques like dynamic programming, memoization, or game trees.

Do you need further clarification or examples?

### 1. Algorithms & Data Structures (C++): N-K Ladders (3 Approaches)

Sure, let's delve into three different approaches for solving the N-K Ladders problem using C++.

### Problem Statement

Given a ladder of length `N`, you need to find the number of ways to climb it, with the condition that you can take at most `K` steps at a time.

### Approach 1: Recursive Approach

```cpp
#include <iostream>
using namespace std;

int countWays(int n, int k) {
    if (n == 0)
        return 1;
    if (n < 0)
        return 0;
    
    int ways = 0;
    for (int i = 1; i <= k; ++i) {
        ways += countWays(n - i, k);
    }
    return ways;
}

int main() {
    int n = 5;
    int k = 2;
    cout << "Number of ways to climb the ladder: " << countWays(n, k) << endl;
    return 0;
}
```

### Approach 2: Dynamic Programming (Memoization)

```cpp
#include <iostream>
#include <vector>
using namespace std;

int countWays(int n, int k, vector<int>& memo) {
    if (n == 0)
        return 1;
    if (n < 0)
        return 0;
    
    if (memo[n] != -1)
        return memo[n];
    
    int ways = 0;
    for (int i = 1; i <= k; ++i) {
        ways += countWays(n - i, k, memo);
    }
    memo[n] = ways;
    return ways;
}

int main() {
    int n = 5;
    int k = 2;
    vector<int> memo(n + 1, -1);
    cout << "Number of ways to climb the ladder: " << countWays(n, k, memo) << endl;
    return 0;
}
```

### Approach 3: Dynamic Programming (Tabulation)

```cpp
#include <iostream>
#include <vector>
using namespace std;

int countWays(int n, int k) {
    vector<int> dp(n + 1, 0);
    dp[0] = 1;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= k && i - j >= 0; ++j) {
            dp[i] += dp[i - j];
        }
    }
    return dp[n];
}

int main() {
    int n = 5;
    int k = 2;
    cout << "Number of ways to climb the ladder: " << countWays(n, k) << endl;
    return 0;
}
```

These are three common approaches for solving the N-K Ladders problem. The recursive approach has exponential time complexity, while both dynamic programming approaches have linear time complexity. The tabulation approach is generally more efficient than memoization in terms of space complexity.

### 1. Algorithms & Data Structures (C++): N-K Ladders (Bottom Up)

Sure, I can help you with that. The N-K Ladders problem is a classic dynamic programming problem where you need to find the number of ways to climb N steps if you can take at most K steps at a time. Here's a C++ implementation of the bottom-up approach:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int countWays(int n, int k) {
    vector<int> dp(n + 1, 0);
    dp[0] = 1;

    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= k; ++j) {
            if (i - j >= 0) {
                dp[i] += dp[i - j];
            }
        }
    }

    return dp[n];
}

int main() {
    int n, k;
    cout << "Enter the number of steps (N): ";
    cin >> n;
    cout << "Enter the maximum steps you can take at a time (K): ";
    cin >> k;

    int ways = countWays(n, k);
    cout << "Number of ways to climb " << n << " steps with at most " << k << " steps at a time: " << ways << endl;

    return 0;
}
```

This code defines a function `countWays` that calculates the number of ways to climb `n` steps with at most `k` steps at a time using bottom-up dynamic programming. Then, in the `main` function, it takes input for `n` and `k`, calls the `countWays` function, and prints the result.

### 1. Algorithms & Data Structures (C++): N-K Ladders (Top Down)

Sure, I can provide you with a C++ implementation of the N-K Ladders problem using a top-down approach with dynamic programming. The N-K Ladders problem involves counting the number of ways to climb to the top of a ladder with N steps, where a person can take at most K steps at a time.

Here's the implementation:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int countWays(int n, int k, vector<int>& dp) {
    if (n <= 1)
        return 1;

    if (dp[n] != -1)
        return dp[n];

    int ways = 0;
    for (int i = 1; i <= k && i <= n; ++i) {
        ways += countWays(n - i, k, dp);
    }

    return dp[n] = ways;
}

int main() {
    int n, k;
    cout << "Enter the number of steps (N): ";
    cin >> n;
    cout << "Enter the maximum steps allowed (K): ";
    cin >> k;

    vector<int> dp(n + 1, -1); // Memoization array

    int ways = countWays(n, k, dp);
    cout << "Number of ways to climb the ladder: " << ways << endl;

    return 0;
}
```

This code defines a function `countWays` which recursively calculates the number of ways to climb a ladder with `n` steps where a person can take at most `k` steps at a time. It uses memoization to avoid recalculating the same subproblems. Finally, the `main` function takes user input for `n` and `k`, initializes the memoization array, calls `countWays`, and prints the result.

You can compile and run this code to calculate the number of ways to climb the ladder with given parameters.

### 1. Algorithms & Data Structures (C++): N-K Ladders Bottom Up

Sure, I can provide you with a bottom-up approach for generating N-K ladders in C++. The N-K ladders problem is a variation of the classic ladder problem where you can climb either K steps or 1 step at a time. Here's a C++ implementation:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int countWays(int n, int k) {
    vector<int> dp(n + 1, 0);

    // Base case: There is only one way to reach 0th and 1st steps
    dp[0] = dp[1] = 1;

    // Calculate number of ways for remaining steps bottom-up
    for (int i = 2; i <= n; ++i) {
        for (int j = 1; j <= k && i - j >= 0; ++j) {
            dp[i] += dp[i - j];
        }
    }

    return dp[n];
}

int main() {
    int n, k;
    cout << "Enter the number of steps (N): ";
    cin >> n;
    cout << "Enter the maximum steps you can take at a time (K): ";
    cin >> k;

    cout << "Number of ways to reach the top: " << countWays(n, k) << endl;

    return 0;
}
```

In this implementation:

- We define a vector `dp` of size `(n + 1)` to store the number of ways to reach each step.
- We initialize the base cases `dp[0]` and `dp[1]` to 1 because there is only one way to reach the 0th and 1st steps.
- We then iterate from step 2 to step `n` and calculate the number of ways to reach each step by summing up the ways to reach the previous `k` steps.
- Finally, we return the value stored in `dp[n]`, which represents the number of ways to reach the top of the ladder.

You can run this code, input the number of steps `N` and the maximum number of steps you can take at a time `K`, and it will output the number of ways to reach the top of the ladder.

### 1. Algorithms & Data Structures (C++): N-K Ladders Top Down

Sure, I can help you with that. The N-K Ladders problem is a classic dynamic programming problem where you need to find the number of ways to climb N steps, with the constraint that at each step you can climb either 1 to K steps. Here's the C++ implementation for solving this problem using top-down dynamic programming:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Function to calculate the number of ways to climb N steps with K steps at most
int countWays(int n, int k, vector<int>& dp) {
    if (n == 0)
        return 1;

    if (dp[n] != -1)
        return dp[n];

    int ways = 0;
    for (int i = 1; i <= k && n - i >= 0; i++) {
        ways += countWays(n - i, k, dp);
    }

    dp[n] = ways;
    return ways;
}

// Wrapper function to initialize the dynamic programming array and call the actual function
int countWays(int n, int k) {
    vector<int> dp(n + 1, -1);
    return countWays(n, k, dp);
}

int main() {
    int n, k;
    cout << "Enter the number of steps (N): ";
    cin >> n;
    cout << "Enter the maximum steps you can climb at a time (K): ";
    cin >> k;
    
    int ways = countWays(n, k);
    cout << "Number of ways to climb the ladder: " << ways << endl;

    return 0;
}
```

This code defines a function `countWays` which calculates the number of ways to climb `n` steps using at most `k` steps at a time, using top-down dynamic programming with memoization. The `main` function takes input for the number of steps `n` and the maximum steps `k`, calls `countWays`, and outputs the result.

### 1. Algorithms & Data Structures (C++): N-Queen

The N-Queens problem is a classic problem in computer science where the objective is to place N queens on an N×N chessboard in such a way that no two queens threaten each other; i.e., no two queens are in the same row, column, or diagonal.

Here's a C++ implementation using backtracking to solve the N-Queens problem:

```cpp
#include <iostream>
#include <vector>

using namespace std;

bool isSafe(vector<vector<int>>& board, int row, int col, int n) {
    // Check the column
    for (int i = 0; i < row; ++i)
        if (board[i][col])
            return false;

    // Check upper left diagonal
    for (int i = row, j = col; i >= 0 && j >= 0; --i, --j)
        if (board[i][j])
            return false;

    // Check upper right diagonal
    for (int i = row, j = col; i >= 0 && j < n; --i, ++j)
        if (board[i][j])
            return false;

    return true;
}

bool solveNQueensUtil(vector<vector<int>>& board, int row, int n) {
    if (row == n)
        return true;

    for (int col = 0; col < n; ++col) {
        if (isSafe(board, row, col, n)) {
            board[row][col] = 1;
            if (solveNQueensUtil(board, row + 1, n))
                return true;
            board[row][col] = 0;
        }
    }
    return false;
}

void solveNQueens(int n) {
    vector<vector<int>> board(n, vector<int>(n, 0));

    if (solveNQueensUtil(board, 0, n)) {
        cout << "Solution found:" << endl;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j)
                cout << board[i][j] << " ";
            cout << endl;
        }
    } else {
        cout << "No solution exists." << endl;
    }
}

int main() {
    int n;
    cout << "Enter the size of the chessboard (N): ";
    cin >> n;
    solveNQueens(n);
    return 0;
}
```

This code defines functions to check if a queen can be placed in a given position (isSafe), a recursive function to solve the N-Queens problem (solveNQueensUtil), and a function to initiate the solving process (solveNQueens). Finally, it provides a main function to take input from the user regarding the size of the chessboard and calls the solveNQueens function to find a solution.

### 1. Algorithms & Data Structures (C++): N-Queen Problem

The N-Queen problem is a classic problem in computer science and involves placing N chess queens on an N×N chessboard so that no two queens attack each other. This means that no two queens share the same row, column, or diagonal. Here's a C++ implementation using backtracking:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Function to print the chessboard
void printBoard(const vector<int>& board) {
    int n = board.size();
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            if (board[i] == j) {
                cout << "Q ";
            } else {
                cout << ". ";
            }
        }
        cout << endl;
    }
    cout << endl;
}

// Function to check if a queen can be placed at the given position
bool isSafe(const vector<int>& board, int row, int col) {
    // Check for the same column
    for (int i = 0; i < row; ++i) {
        if (board[i] == col || abs(i - row) == abs(board[i] - col)) {
            return false;
        }
    }
    return true;
}

// Recursive function to solve the N-Queen problem
void solveNQueens(vector<int>& board, int row, vector<vector<int>>& solutions) {
    int n = board.size();
    if (row == n) {
        // Found a solution
        solutions.push_back(board);
        return;
    }

    for (int col = 0; col < n; ++col) {
        if (isSafe(board, row, col)) {
            board[row] = col; // Place the queen

            // Move to the next row
            solveNQueens(board, row + 1, solutions);

            // Backtrack
            board[row] = -1;
        }
    }
}

// Function to solve the N-Queen problem
vector<vector<int>> solveNQueens(int n) {
    vector<int> board(n, -1);
    vector<vector<int>> solutions;
    solveNQueens(board, 0, solutions);
    return solutions;
}

int main() {
    int n;
    cout << "Enter the size of the chessboard (N): ";
    cin >> n;

    vector<vector<int>> solutions = solveNQueens(n);

    int count = 1;
    for (const auto& solution : solutions) {
        cout << "Solution " << count++ << ":\n";
        printBoard(solution);
    }

    return 0;
}
```

This code prompts the user to input the size of the chessboard (N) and then finds and prints all possible solutions to the N-Queen problem for that size of the board. Each solution is represented as a vector, where the value at index i represents the column where the queen is placed in row i.

### 1. Algorithms & Data Structures (C++): N-Queen Ways

Solving the N-Queens problem involves placing N queens on an N×N chessboard in such a way that no two queens threaten each other. One of the most common solutions is to use backtracking. Here's a basic approach to solve the N-Queens problem using C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Function to check if a queen can be placed at position (row, col)
bool isSafe(vector<string>& board, int row, int col, int n) {
    // Check the column
    for (int i = 0; i < row; i++) {
        if (board[i][col] == 'Q')
            return false;
    }
    // Check upper left diagonal
    for (int i = row, j = col; i >= 0 && j >= 0; i--, j--) {
        if (board[i][j] == 'Q')
            return false;
    }
    // Check upper right diagonal
    for (int i = row, j = col; i >= 0 && j < n; i--, j++) {
        if (board[i][j] == 'Q')
            return false;
    }
    return true;
}

// Recursive function to solve N-Queens problem
void solveNQueens(vector<vector<string>>& res, vector<string>& board, int row, int n) {
    if (row == n) {
        res.push_back(board);
        return;
    }
    for (int col = 0; col < n; col++) {
        if (isSafe(board, row, col, n)) {
            board[row][col] = 'Q'; // Place the queen
            solveNQueens(res, board, row + 1, n); // Recur for the next row
            board[row][col] = '.'; // Backtrack
        }
    }
}

vector<vector<string>> solveNQueens(int n) {
    vector<vector<string>> res;
    vector<string> board(n, string(n, '.')); // Initialize empty board
    solveNQueens(res, board, 0, n);
    return res;
}

int main() {
    int n;
    cout << "Enter the size of the chessboard (N): ";
    cin >> n;
    vector<vector<string>> solutions = solveNQueens(n);
    cout << "Number of solutions: " << solutions.size() << endl;
    // Printing all solutions
    for (const auto& solution : solutions) {
        for (const auto& row : solution) {
            cout << row << endl;
        }
        cout << endl;
    }
    return 0;
}
```

This code defines a function `solveNQueens` which takes an integer `n` as input (the size of the chessboard) and returns a vector of vectors of strings representing all possible solutions. The `isSafe` function checks if it's safe to place a queen at a given position, and the `solveNQueens` function recursively tries to place queens on the board and backtrack if a solution is not possible. Finally, in the `main` function, it prompts the user for the size of the chessboard and prints out all possible solutions along with their count.

### 1. Algorithms & Data Structures (C++): N-queens

The N-queens problem is a classic problem in computer science and combinatorial optimization. The task is to place N queens on an N×N chessboard in such a way that no two queens threaten each other. This means that no two queens can share the same row, column, or diagonal.

Here's a basic implementation of the N-queens problem in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Function to check if a queen can be placed at position (row, col)
bool isSafe(vector<vector<int>>& board, int row, int col, int N) {
    // Check the row on the left side
    for (int i = 0; i < col; i++)
        if (board[row][i])
            return false;

    // Check upper diagonal on the left side
    for (int i = row, j = col; i >= 0 && j >= 0; i--, j--)
        if (board[i][j])
            return false;

    // Check lower diagonal on the left side
    for (int i = row, j = col; j >= 0 && i < N; i++, j--)
        if (board[i][j])
            return false;

    return true;
}

// Recursive function to solve N-queens problem
bool solveNQueens(vector<vector<int>>& board, int col, int N) {
    // If all queens are placed, return true
    if (col >= N)
        return true;

    // Consider this column and try placing this queen in all rows one by one
    for (int i = 0; i < N; i++) {
        // Check if the queen can be placed at board[i][col]
        if (isSafe(board, i, col, N)) {
            // Place the queen
            board[i][col] = 1;

            // Recur to place rest of the queens
            if (solveNQueens(board, col + 1, N))
                return true;

            // If placing queen in board[i][col] doesn't lead to a solution then backtrack
            board[i][col] = 0; // Backtrack
        }
    }

    // If the queen can't be placed in any row in this column, return false
    return false;
}

void printSolution(vector<vector<int>>& board, int N) {
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            cout << board[i][j] << " ";
        }
        cout << endl;
    }
}

int main() {
    int N;
    cout << "Enter the number of queens: ";
    cin >> N;

    // Create a 2D vector to represent the chessboard
    vector<vector<int>> board(N, vector<int>(N, 0));

    if (solveNQueens(board, 0, N)) {
        cout << "Solution exists. The placement of queens on the board is: \n";
        printSolution(board, N);
    } else {
        cout << "Solution does not exist.";
    }

    return 0;
}
```

This code prompts the user to enter the number of queens (`N`), then it solves the N-queens problem and prints the solution if it exists. The `solveNQueens` function uses backtracking to find the solution.

### 1. Algorithms & Data Structures (C++): n-Queens Algorithm

The n-Queens problem is a classic problem in computer science and combinatorial optimization. The objective is to place n chess queens on an n×n chessboard in such a way that no two queens threaten each other. Here's a basic implementation of the n-Queens algorithm in C++ using backtracking:

```cpp
#include <iostream>
#include <vector>

using namespace std;

bool isSafe(vector<vector<int>>& board, int row, int col, int n) {
    // Check left side of the row
    for (int i = 0; i < col; i++)
        if (board[row][i])
            return false;

    // Check upper diagonal on left side
    for (int i = row, j = col; i >= 0 && j >= 0; i--, j--)
        if (board[i][j])
            return false;

    // Check lower diagonal on left side
    for (int i = row, j = col; j >= 0 && i < n; i++, j--)
        if (board[i][j])
            return false;

    return true;
}

bool solveNQueensUtil(vector<vector<int>>& board, int col, int n) {
    if (col == n) {
        // If all queens are placed, return true
        return true;
    }

    // Try placing a queen in each row of this column
    for (int i = 0; i < n; i++) {
        if (isSafe(board, i, col, n)) {
            // Place the queen
            board[i][col] = 1;

            // Recur to place rest of the queens
            if (solveNQueensUtil(board, col + 1, n))
                return true;

            // If placing queen in board[i][col] doesn't lead to a solution
            // then remove queen from board[i][col]
            board[i][col] = 0; // Backtrack
        }
    }

    // If the queen cannot be placed in any row in this column, return false
    return false;
}

bool solveNQueens(int n) {
    vector<vector<int>> board(n, vector<int>(n, 0));

    if (!solveNQueensUtil(board, 0, n)) {
        cout << "Solution does not exist";
        return false;
    }

    // Print the solution
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cout << board[i][j] << " ";
        }
        cout << endl;
    }
    return true;
}

int main() {
    int n;
    cout << "Enter the number of queens (n): ";
    cin >> n;
    solveNQueens(n);
    return 0;
}
```

This code solves the n-Queens problem using a backtracking approach. It tries to place a queen in each column and backtracks if it cannot place a queen in a particular column. If a solution is found, it prints the board configuration with queens placed such that no two queens threaten each other.

### 1. Algorithms & Data Structures (C++): N-queens: Complexity analysis

Analyzing the complexity of the N-Queens problem involves considering both the time and space complexities of the algorithm.

1. **Time Complexity**: The time complexity of the N-Queens problem is typically measured in terms of the number of recursive calls made to place queens on the board. A common algorithm to solve this problem is the backtracking algorithm.

    - In the backtracking algorithm, you place queens on the board row by row, trying all possible positions for each row.
    - For each row, you iterate through each column and check if placing a queen at that position conflicts with previously placed queens. If it doesn't, you recursively move to the next row.
    - If you reach the end of the board (i.e., placed N queens), you've found a solution. Otherwise, you backtrack and try the next position for the previous row.
    - The time complexity of the backtracking algorithm can be expressed as O(N!), where N is the number of queens (or the size of the board). This is because there are N choices for placing the queen in the first row, N-2 choices for placing the queen in the second row (after removing the conflicting positions), N-4 choices for placing the queen in the third row, and so on.
    - Although the worst-case time complexity is O(N!), in practice, backtracking algorithms often perform much better due to pruning of branches that lead to invalid solutions.

2. **Space Complexity**: The space complexity primarily concerns the amount of memory used during the execution of the algorithm.

    - The primary space usage comes from the recursion stack. At any given point, the recursion stack depth is equal to the current row being processed.
    - Since the N-Queens problem is solved recursively, the space complexity depends on the maximum recursion depth.
    - The space complexity of the backtracking algorithm for N-Queens is O(N), as there can be at most N recursive calls on the stack at any point during the execution.

In summary, the time complexity of the N-Queens problem is O(N!), and the space complexity is O(N). However, in practice, the actual performance can vary significantly based on factors such as the efficiency of the pruning strategy and the specific implementation details.

### 1. Algorithms & Data Structures (C++): Nested List Weight Sum

Nested List Weight Sum is a common problem in algorithmic interviews and competitive programming. It involves computing the sum of nested lists, where each element can either be an integer or a nested list. The weight of each integer is its depth multiplied by its value. Here's how you can implement it in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Nested Integer class definition (assuming provided)
class NestedInteger {
public:
    NestedInteger(int value) : value(value), isInteger(true) {}
    NestedInteger(vector<NestedInteger> nestedList) : nestedList(nestedList), isInteger(false) {}
    bool isInteger() const { return isInteger; }
    int getInteger() const { return value; }
    const vector<NestedInteger>& getList() const { return nestedList; }
private:
    int value;
    vector<NestedInteger> nestedList;
    bool isInteger;
};

int depthSum(const vector<NestedInteger>& nestedList, int depth) {
    int sum = 0;
    for (const auto& ni : nestedList) {
        if (ni.isInteger()) {
            sum += ni.getInteger() * depth;
        } else {
            sum += depthSum(ni.getList(), depth + 1);
        }
    }
    return sum;
}

int depthSum(const vector<NestedInteger>& nestedList) {
    return depthSum(nestedList, 1);
}

int main() {
    // Example usage
    vector<NestedInteger> nestedList = {
        NestedInteger(1),
        NestedInteger({NestedInteger(4), NestedInteger({NestedInteger(6)})}),
        NestedInteger(2)
    };
    cout << "Nested list weight sum: " << depthSum(nestedList) << endl;
    return 0;
}
```

In this implementation:

- `NestedInteger` is a class that represents either an integer or a nested list of integers.
- `depthSum` is a recursive function that calculates the sum of nested lists. It traverses each element of the input list and recursively calls itself if the element is another nested list.
- The `depth` parameter is used to keep track of the depth of the current nested list.

You can modify the `NestedInteger` class according to your requirements or use a similar existing class provided by your platform or library.

### 1. Algorithms & Data Structures (C++): Nested Recursion

Nested recursion in algorithms and data structures refers to a scenario where a recursive function calls itself with a recursive call as one of its parameters. This creates a recursive tree where each node may have multiple recursive calls. It's a less common form of recursion compared to direct or tail recursion, but it's still important to understand.

In C++, nested recursion can be implemented just like regular recursion. Here's a simple example to illustrate nested recursion:

```cpp
#include <iostream>

int nestedRecursion(int n) {
    if (n > 100)
        return n - 10;
    else
        return nestedRecursion(nestedRecursion(n + 11));
}

int main() {
    int result = nestedRecursion(95);
    std::cout << "Result: " << result << std::endl;
    return 0;
}
```

In this example, the function `nestedRecursion` calls itself with the result of another call to `nestedRecursion`, thus creating nested levels of recursion.

However, nested recursion can lead to very deep recursion stacks and can be less efficient than other forms of recursion in certain scenarios. It's important to analyze the problem and the input size to determine if nested recursion is appropriate. Additionally, it's crucial to ensure there's a proper base case to avoid infinite recursion.

### 1. Algorithms & Data Structures (C++): Next Greater Element

The "Next Greater Element" problem is a classic algorithmic problem where, given an array, you have to find the next greater element for every element. In other words, for each element, find the first element to its right which is greater than the current element. This problem has various applications in computer science, particularly in optimization and searching.

Here's a C++ implementation of the Next Greater Element problem using a stack:

```cpp
#include <iostream>
#include <vector>
#include <stack>
#include <unordered_map>

using namespace std;

vector<int> nextGreaterElement(const vector<int>& nums) {
    vector<int> result(nums.size(), -1); // Initialize result with -1, indicating no greater element found
    stack<int> st;
    unordered_map<int, int> numToIndex; // Mapping from number to its index in the array

    for (int i = 0; i < nums.size(); ++i)
        numToIndex[nums[i]] = i; // Store index of each number

    for (int i = 0; i < nums.size(); ++i) {
        while (!st.empty() && nums[i] > nums[st.top()]) {
            result[st.top()] = nums[i]; // If the current element is greater, update result for elements in stack
            st.pop();
        }
        st.push(i); // Push the index of the current element onto the stack
    }

    // For elements without next greater element, result will remain -1
    return result;
}

int main() {
    vector<int> nums = {4, 5, 2, 25, 10};
    vector<int> result = nextGreaterElement(nums);

    cout << "Next Greater Element for each element:" << endl;
    for (int i = 0; i < nums.size(); ++i)
        cout << nums[i] << " --> " << (result[i] == -1 ? -1 : result[i]) << endl;

    return 0;
}
```

In this implementation, we iterate through the array and use a stack to store indices of elements for which we haven't found the next greater element yet. We maintain a mapping from each number to its index to quickly find the index of any number. We then iterate through the array again, popping elements from the stack and updating the result array until we find the next greater element or the stack becomes empty. Finally, we print the result.

### 1. Algorithms & Data Structures (C++): Next Greater Node In Linked List

To find the next greater node in a linked list, you can use a stack-based approach. Here's how you can implement this algorithm in C++:

```cpp
#include <stack>
#include <vector>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

vector<int> nextLargerNodes(ListNode* head) {
    vector<int> result;
    stack<pair<int, int>> stk; // Pair of (node value, index)

    // Traverse the linked list
    int index = 0;
    while (head) {
        // Process until the stack is not empty and the current node's value is greater than the top of the stack
        while (!stk.empty() && head->val > stk.top().first) {
            result[stk.top().second] = head->val; // Update the result for the index at the top of the stack
            stk.pop(); // Pop the index as it is no longer needed
        }
        stk.push({head->val, index}); // Push the current node's value and its index to the stack
        result.push_back(0); // Initialize the result for the current node
        head = head->next;
        index++;
    }

    return result;
}

// Helper function to create a linked list
ListNode* createLinkedList(vector<int>& values) {
    ListNode* head = nullptr;
    ListNode* tail = nullptr;

    for (int val : values) {
        ListNode* newNode = new ListNode(val);
        if (!head) {
            head = newNode;
            tail = newNode;
        } else {
            tail->next = newNode;
            tail = newNode;
        }
    }

    return head;
}

// Helper function to print a vector
void printVector(const vector<int>& vec) {
    for (int val : vec) {
        cout << val << " ";
    }
    cout << endl;
}

int main() {
    vector<int> values = {2, 1, 5};
    ListNode* head = createLinkedList(values);

    vector<int> result = nextLargerNodes(head);

    cout << "Next greater node for each node: ";
    printVector(result);

    return 0;
}
```

This code defines a `ListNode` structure for the linked list and implements the `nextLargerNodes` function, which takes the head of the linked list as input and returns a vector containing the next greater node for each node in the linked list.

The algorithm uses a stack to keep track of the indices of the nodes whose next greater node is yet to be found. It traverses the linked list and updates the result vector accordingly. Finally, it returns the result vector.

The `main` function demonstrates how to use this algorithm by creating a linked list, calling the `nextLargerNodes` function, and printing the result.

### 1. Algorithms & Data Structures (C++): Nim Game

In the game of Nim, players take turns removing objects from heaps or piles. The players can choose to remove any number of objects, but they must remove at least one object per turn. The player who removes the last object wins.

Here's a simple C++ implementation of the Nim game:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Function to calculate the nim-sum of an array
int calculateNimSum(const vector<int>& piles) {
    int nimSum = 0;
    for (int pile : piles) {
        nimSum ^= pile;
    }
    return nimSum;
}

// Function to determine if the current player wins
bool canWinNim(const vector<int>& piles) {
    int nimSum = calculateNimSum(piles);
    return nimSum != 0; // If nimSum is not zero, current player wins
}

int main() {
    vector<int> piles = {3, 4, 5}; // Example piles
    if (canWinNim(piles)) {
        cout << "You win!" << endl;
    } else {
        cout << "You lose!" << endl;
    }
    return 0;
}
```

In this code:

- `calculateNimSum` calculates the nim-sum of all the piles using the XOR operation.
- `canWinNim` determines if the current player can win the game based on the nim-sum. If the nim-sum is not zero, the current player can win.

You can modify the `piles` vector to represent different numbers of objects in each pile and test the game with different scenarios.

### 1. Algorithms & Data Structures (C++): Nim Sum

In the game of Nim, players take turns removing objects from heaps. In Nim Sum, the key idea is to represent the state of the game using binary numbers. Each heap's size is represented by the number of objects in binary form. When you perform the bitwise XOR operation (^) on these binary numbers, you get the Nim Sum. The Nim Sum essentially tells you whether the current state of the game is losing or winning.

Here's how you can implement Nim Sum calculation in C++:

```cpp
#include <iostream>
#include <vector>

// Function to calculate Nim Sum
int calculateNimSum(const std::vector<int>& heaps) {
    int nimSum = 0;
    for (int heap : heaps) {
        nimSum ^= heap; // Bitwise XOR operation
    }
    return nimSum;
}

int main() {
    // Example: Let's say we have 3 heaps with 3, 4, and 5 objects
    std::vector<int> heaps = {3, 4, 5};

    // Calculate Nim Sum
    int nimSum = calculateNimSum(heaps);

    // Print Nim Sum
    std::cout << "Nim Sum: " << nimSum << std::endl;

    return 0;
}
```

In this code:

- `calculateNimSum` function takes a vector of integers representing the sizes of the heaps and calculates the Nim Sum by performing bitwise XOR on all the heap sizes.
- In the `main` function, you can define the heaps and call `calculateNimSum` to get the Nim Sum.

Remember, if the Nim Sum is zero, then the current position is a losing position. Otherwise, it's a winning position. This property can be used to determine optimal moves in the game of Nim.

### 1. Algorithms & Data Structures (C++): Number of Provinces

To find the number of provinces in a given graph using C++, you can employ graph traversal algorithms like Depth First Search (DFS) or Breadth First Search (BFS). The problem sounds like it might involve finding connected components in an undirected graph. Here's a basic outline of how you can approach this problem:

1. Represent the graph: You can represent the graph using an adjacency list or an adjacency matrix.

2. Perform graph traversal: Start traversing the graph from any node. As you traverse, mark visited nodes to avoid revisiting them.

3. Count connected components: Each time you start a new traversal from an unvisited node, you've encountered a new connected component. Keep track of these components.

4. The number of provinces will be equal to the number of connected components.

Here's a C++ implementation using Depth First Search (DFS) to find the number of provinces:

```cpp
#include <iostream>
#include <vector>

using namespace std;

void dfs(vector<vector<int>>& graph, vector<bool>& visited, int node) {
    visited[node] = true;
    for (int neighbor : graph[node]) {
        if (!visited[neighbor]) {
            dfs(graph, visited, neighbor);
        }
    }
}

int countProvinces(vector<vector<int>>& isConnected) {
    int n = isConnected.size();
    vector<bool> visited(n, false);
    int provinces = 0;

    for (int i = 0; i < n; ++i) {
        if (!visited[i]) {
            dfs(isConnected, visited, i);
            provinces++;
        }
    }
    return provinces;
}

int main() {
    // Example usage
    vector<vector<int>> isConnected = {{1, 0, 0, 1},
                                        {0, 1, 1, 0},
                                        {0, 1, 1, 1},
                                        {1, 0, 1, 1}};
    cout << "Number of provinces: " << countProvinces(isConnected) << endl;
    return 0;
}
```

This code defines a function `countProvinces` that takes an adjacency matrix `isConnected` representing the graph and returns the number of provinces. The `dfs` function is a standard Depth First Search algorithm that marks visited nodes.

You can customize the `isConnected` matrix to represent your specific graph and then call `countProvinces` to find the number of provinces.

### 1. Algorithms & Data Structures (C++): Number of Ways to reach the Last Cell with given Cost

To solve this problem, we can use dynamic programming. Let's assume `dp[i]` represents the number of ways to reach cell `i` from the start. We can initialize `dp[0] = 1` since there is only one way to reach the start cell. Then, for each cell `i` from `1` to `n-1`, we can update `dp[i]` based on the previous cells.

Here's a C++ implementation:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int countWaysToReachLastCell(vector<int>& cost) {
    int n = cost.size();
    vector<int> dp(n, 0);
    dp[0] = 1; // There is only one way to reach the start cell

    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (j + cost[j] >= i) {
                dp[i] += dp[j]; // Update dp[i] based on previous reachable cells
            }
        }
    }

    return dp[n - 1];
}

int main() {
    vector<int> cost = {1, 2, 3, 1, 0, 1}; // Example cost array
    cout << "Number of ways to reach the last cell: " << countWaysToReachLastCell(cost) << endl;
    return 0;
}
```

This code will output the number of ways to reach the last cell based on the given cost. In the example given, `countWaysToReachLastCell(cost)` will output the number of ways to reach the last cell considering the given costs in the `cost` vector.

### 1. Algorithms & Data Structures (C++): Number of Ways to Wear Different Hats to Each Other

To solve the problem of finding the number of ways for people to wear different hats, you can use dynamic programming and bit manipulation techniques. Here's a general outline of how you can approach this problem:

1. **Dynamic Programming with Bitmasking**:
   - Each person can wear a hat or not wear it. We can represent the state of wearing hats using a bitmask. Let's say there are n people and m different types of hats. We'll have 2^n states representing the combinations of wearing hats.
   - Initialize a 2D dp array of size [m][2^n], where dp[i][mask] represents the number of ways to assign hats to the first i hats with the state of wearing hats represented by the bitmask mask.

2. **Base Case**:
   - dp[0][0] = 1, as there's only one way to assign no hats to no people.

3. **Transitions**:
   - For each hat type i from 1 to m, iterate through all possible mask values from 0 to (1 << n) - 1.
   - For each mask value, iterate through all people j from 0 to n - 1.
   - If person j can wear hat i and it's not already worn by anyone (bit j is not set in the mask), then add dp[i - 1][mask] to dp[i][mask | (1 << j)].

4. **Final Answer**:
   - The final answer will be stored in dp[m][(1 << n) - 1], representing the number of ways to assign hats to all people with all hats worn.

Here's a C++ code snippet demonstrating the approach:

```cpp
#include <iostream>
#include <vector>
using namespace std;

const int MOD = 1000000007;

int numberWays(vector<vector<int>>& hats) {
    int n = hats.size();
    vector<vector<int>> dp(41, vector<int>(1 << n, 0)); // Assuming there are at most 40 different types of hats

    dp[0][0] = 1; // Base case

    for (int i = 1; i <= 40; ++i) { // For each hat type
        for (int mask = 0; mask < (1 << n); ++mask) { // For each possible mask
            for (int j = 0; j < n; ++j) { // For each person
                if ((mask & (1 << j)) == 0) { // If person j doesn't already have a hat
                    dp[i][mask | (1 << j)] = (dp[i][mask | (1 << j)] + dp[i - 1][mask]) % MOD;
                }
            }
        }
    }

    return dp[40][(1 << n) - 1];
}

int main() {
    // Example usage
    vector<vector<int>> hats = {{3,4},{4,5},{5}};
    cout << numberWays(hats) << endl; // Output should be 1
    return 0;
}
```

This code calculates the number of ways people can wear hats given the constraints. You can adjust the size of the dp array according to your constraints.

### 1. Algorithms & Data Structures (C++): Number Spell

Creating a program in C++ to spell out a number involves breaking down the number into its individual digits and then converting each digit into its corresponding word. Here's a simple implementation:

```cpp
#include <iostream>
#include <string>
#include <vector>

using namespace std;

// Function to convert digit to word
string digitToWord(int digit) {
    switch (digit) {
        case 0:
            return "zero";
        case 1:
            return "one";
        case 2:
            return "two";
        case 3:
            return "three";
        case 4:
            return "four";
        case 5:
            return "five";
        case 6:
            return "six";
        case 7:
            return "seven";
        case 8:
            return "eight";
        case 9:
            return "nine";
        default:
            return ""; // Invalid digit
    }
}

// Function to spell out a number
string spellNumber(int number) {
    if (number == 0)
        return digitToWord(0);

    vector<string> result;
    while (number != 0) {
        int digit = number % 10;
        string word = digitToWord(digit);
        result.push_back(word);
        number /= 10;
    }

    string spelledNumber = "";
    for (int i = result.size() - 1; i >= 0; --i) {
        spelledNumber += result[i];
        if (i != 0)
            spelledNumber += " ";
    }

    return spelledNumber;
}

int main() {
    int number;
    cout << "Enter a number: ";
    cin >> number;

    cout << "Spelled out number: " << spellNumber(number) << endl;

    return 0;
}
```

This program takes an integer input from the user and spells out the number in words. For example, if the user inputs 123, the output will be "one two three".

### 1. Algorithms & Data Structures (C++): One Away

The "One Away" problem is a classic algorithmic problem that involves comparing two strings and determining if they are at most one edit away from being equal. The possible edits are: insert a character, remove a character, or replace a character.

Here's a C++ implementation to solve the "One Away" problem:

```cpp
#include <iostream>
#include <string>
#include <cmath>

using namespace std;

bool isOneAway(string str1, string str2) {
    int len1 = str1.length();
    int len2 = str2.length();

    // If the length difference is more than 1, they can't be one edit away
    if (abs(len1 - len2) > 1)
        return false;

    int edits = 0;
    int i = 0, j = 0;

    while (i < len1 && j < len2) {
        // If characters are same, move to next characters
        if (str1[i] == str2[j]) {
            i++;
            j++;
        } else {
            // If characters are different, check which edit operation is needed
            edits++;
            if (len1 > len2)
                i++;
            else if (len2 > len1)
                j++;
            else {
                // If lengths are equal, move to next characters in both strings
                i++;
                j++;
            }
        }
    }

    // If there are extra characters left in any string, they can be deleted or inserted
    if (i < len1 || j < len2)
        edits++;

    // If number of edits made is at most 1, strings are one edit away
    return edits <= 1;
}

int main() {
    string str1, str2;
    cout << "Enter the first string: ";
    cin >> str1;
    cout << "Enter the second string: ";
    cin >> str2;

    if (isOneAway(str1, str2))
        cout << "Strings are one edit away.\n";
    else
        cout << "Strings are not one edit away.\n";

    return 0;
}
```

This program defines a function `isOneAway` which takes two strings as input and returns true if they are one edit away from each other, and false otherwise. The main function takes two strings as input from the user and then calls the `isOneAway` function to check if they are one edit away.

### 1. Algorithms & Data Structures (C++): Parsing Roman Numerals

Parsing Roman numerals can be a fascinating exercise in algorithms and data structures. Here's a basic approach in C++:

```cpp
#include <iostream>
#include <unordered_map>
#include <string>

using namespace std;

int romanToInt(string s) {
    unordered_map<char, int> romanMap = {
        {'I', 1},
        {'V', 5},
        {'X', 10},
        {'L', 50},
        {'C', 100},
        {'D', 500},
        {'M', 1000}
    };
    
    int result = 0;
    int prev = 0; // To keep track of previous value
    for (int i = s.size() - 1; i >= 0; i--) {
        int curr = romanMap[s[i]];
        if (curr < prev) {
            result -= curr; // For cases like IV, IX, etc.
        } else {
            result += curr;
        }
        prev = curr;
    }
    return result;
}

int main() {
    string roman = "MCMXCIV"; // Example: 1994
    cout << "Roman numeral: " << roman << endl;
    cout << "Integer value: " << romanToInt(roman) << endl;
    return 0;
}
```

This code defines a function `romanToInt` that takes a string representing a Roman numeral and returns its integer equivalent. It iterates through the string from right to left, adding the values of each Roman numeral character. If the current value is less than the previous one, it subtracts the current value instead of adding to account for cases like IV (4), IX (9), etc. Finally, it returns the calculated integer value.

This is a simple approach to parsing Roman numerals. Depending on your needs, you may want to expand it to handle more complex cases or edge cases.

### 1. Algorithms & Data Structures (C++): Partition

In computer science, partitioning is a fundamental operation used in various algorithms and data structures. It involves dividing a set of elements into two or more disjoint subsets based on a certain criterion. In the context of algorithms and data structures, partitioning is commonly used in sorting algorithms like Quicksort and in data structures like binary search trees.

Let's discuss a common example of partitioning in the context of the Quicksort algorithm, implemented in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Function to partition the array
int partition(vector<int>& arr, int low, int high) {
    int pivot = arr[high]; // Choosing the last element as the pivot
    int i = low - 1; // Index of the smaller element

    for (int j = low; j < high; j++) {
        // If current element is smaller than or equal to pivot
        if (arr[j] <= pivot) {
            i++; // Increment index of smaller element
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i + 1], arr[high]);
    return i + 1;
}

// Quicksort algorithm
void quickSort(vector<int>& arr, int low, int high) {
    if (low < high) {
        // Partitioning index
        int pi = partition(arr, low, high);

        // Recursively sort elements before partition and after partition
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

// Utility function to print an array
void printArray(const vector<int>& arr) {
    for (int num : arr) {
        cout << num << " ";
    }
    cout << endl;
}

int main() {
    vector<int> arr = {10, 7, 8, 9, 1, 5};
    int n = arr.size();
    cout << "Original array: ";
    printArray(arr);

    quickSort(arr, 0, n - 1);

    cout << "Sorted array: ";
    printArray(arr);

    return 0;
}
```

In this code:

- The `partition` function takes the last element of the array as the pivot, then rearranges the array in such a way that all elements smaller than the pivot are moved to its left, and all elements greater than the pivot are moved to its right. It returns the index of the pivot after partitioning.
- The `quickSort` function recursively applies the partitioning process to sort the entire array.

This implementation demonstrates how partitioning is used as a crucial step in the Quicksort algorithm to efficiently sort arrays.

### 1. Algorithms & Data Structures (C++): Partition (problem)

The Partition problem is a classic problem in computer science and is often used to demonstrate dynamic programming techniques.

In the Partition problem, you are given a set of numbers and the task is to determine if it is possible to partition the set into two subsets such that the sum of elements in both subsets is equal. In other words, given an array of integers, can you divide the array into two subsets such that the sum of elements in both subsets is the same?

Here's a brief overview of a dynamic programming approach to solve the Partition problem:

1. **Dynamic Programming**: We can use dynamic programming to solve the Partition problem efficiently. The basic idea is to create a boolean 2D array `dp`, where `dp[i][j]` represents whether it is possible to obtain a sum `j` using elements up to index `i` in the given array.

2. **Initialization**: Initialize the first row of the `dp` array as `true` because it is always possible to obtain a sum of 0 with any subset of elements.

3. **Transition**: For each element in the array and for each possible sum, we have two choices:
   - Include the current element in the subset: `dp[i][j] = dp[i-1][j - arr[i]]`
   - Exclude the current element from the subset: `dp[i][j] = dp[i-1][j]`

4. **Final Result**: The answer to the problem is `true` if there exists a subset whose sum is equal to half of the total sum of the array.

Here's a simple example in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

bool canPartition(vector<int>& nums) {
    int n = nums.size();
    int totalSum = 0;
    for (int num : nums) {
        totalSum += num;
    }
    
    if (totalSum % 2 != 0) {
        return false;
    }
    
    int targetSum = totalSum / 2;
    vector<vector<bool>> dp(n + 1, vector<bool>(targetSum + 1, false));
    dp[0][0] = true;
    
    for (int i = 1; i <= n; ++i) {
        int num = nums[i - 1];
        for (int j = 0; j <= targetSum; ++j) {
            dp[i][j] = dp[i - 1][j];
            if (j >= num) {
                dp[i][j] = dp[i][j] || dp[i - 1][j - num];
            }
        }
    }
    
    return dp[n][targetSum];
}

int main() {
    vector<int> nums = {1, 5, 11, 5};
    if (canPartition(nums)) {
        cout << "Can partition into two subsets with equal sum." << endl;
    } else {
        cout << "Cannot partition into two subsets with equal sum." << endl;
    }
    return 0;
}
```

This code will output "Can partition into two subsets with equal sum." because the array can be partitioned into {1, 5, 5} and {11}, both having a sum of 11.

### 1. Algorithms & Data Structures (C++): Partition (solution)

Certainly! In computer science, the partition algorithm is commonly used in various sorting algorithms like Quicksort and quick selection. It rearranges the elements of an array in such a way that all elements less than a certain value (usually called a pivot) come before it, and all elements greater than or equal to the pivot come after it. Here's a simple implementation of the partition algorithm in C++:

```cpp
#include <iostream>
#include <vector>

// Function to partition the array around a pivot
int partition(std::vector<int>& arr, int low, int high) {
    int pivot = arr[high]; // Choosing the last element as the pivot
    int i = low - 1; // Index of the smaller element

    for (int j = low; j < high; j++) {
        // If current element is smaller than or equal to the pivot
        if (arr[j] <= pivot) {
            i++; // Increment index of smaller element
            std::swap(arr[i], arr[j]);
        }
    }
    std::swap(arr[i + 1], arr[high]);
    return i + 1;
}

int main() {
    std::vector<int> arr = {10, 7, 8, 9, 1, 5};
    int n = arr.size();

    std::cout << "Original array: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    int pivotIndex = partition(arr, 0, n - 1);

    std::cout << "Array after partitioning: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    std::cout << "Pivot element: " << arr[pivotIndex] << " at index " << pivotIndex << std::endl;

    return 0;
}
```

This code defines a `partition` function that takes a vector `arr`, along with the low and high indices of the range to be partitioned. It chooses the last element of the range as the pivot and rearranges the elements such that all elements less than or equal to the pivot are on the left side, and all elements greater than the pivot are on the right side. Finally, it returns the index of the pivot element after partitioning.

In the `main` function, an example array is initialized, and then the `partition` function is called. The resulting array after partitioning and the index of the pivot element are printed to the console.

This implementation uses the Lomuto partition scheme, which is simpler to implement but not as efficient as the Hoare partition scheme used in the original Quicksort algorithm.

### 1. Algorithms & Data Structures (C++): Peak finding

Peak finding is a classic problem in computer science where you're tasked with finding any peak in an array, where a peak is defined as an element that is greater than or equal to its neighbors. There can be multiple peaks, and any one of them can be returned.

Here's a simple implementation of peak finding in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Function to find a peak in an array
int findPeak(vector<int>& arr) {
    int n = arr.size();
    int left = 0, right = n - 1;

    while (left < right) {
        int mid = left + (right - left) / 2;

        // Check if mid is a peak
        if (arr[mid] > arr[mid + 1])
            right = mid;
        else
            left = mid + 1;
    }

    // Left or right can be returned as peak, as per problem requirement
    return left; // or return right;
}

int main() {
    vector<int> arr = {1, 3, 20, 4, 1, 0};
    int peakIndex = findPeak(arr);
    cout << "A peak is found at index " << peakIndex << ", value = " << arr[peakIndex] << endl;
    return 0;
}
```

In this implementation, we're using a binary search approach. We start with the middle element, and compare it with its neighbors. If it's greater than its right neighbor, then a peak must exist on its left side. If it's smaller than its right neighbor, then a peak must exist on its right side. We keep moving towards the direction where the peak is guaranteed to be present until we find one.

The time complexity of this algorithm is O(log n), where n is the number of elements in the array. This is because we're halving the search space in each iteration.

### 1. Algorithms & Data Structures (C++): Peak finding: Complexity analysis

Peak finding is a classic problem in computer science where the goal is to find any peak element in an array. A peak element is defined as an element that is greater than or equal to its adjacent elements. There can be multiple peak elements in an array, and the task is to find any one of them.

Here's a simple approach to find a peak element in an array:

1. **Linear Scan**: Iterate through the array and check if each element is a peak by comparing it with its adjacent elements.

```cpp
int findPeak(int arr[], int n) {
    for (int i = 1; i < n - 1; i++) {
        if (arr[i] >= arr[i - 1] && arr[i] >= arr[i + 1]) {
            return arr[i];
        }
    }
    // Check edge cases
    if (arr[0] >= arr[1]) return arr[0];
    if (arr[n - 1] >= arr[n - 2]) return arr[n - 1];
    return -1; // No peak found
}
```

### Complexity Analysis

- **Time Complexity**:
  - The linear scan approach has a time complexity of O(n), where n is the number of elements in the array. This is because we iterate through the entire array once.
  
- **Space Complexity**:
  - The space complexity is O(1) because we only use a constant amount of extra space for storing loop variables.

### Optimizations

- **Binary Search**: If the array is sorted or can be sorted in a specific order, you can use binary search for a more efficient solution. The time complexity of this approach is O(log n).

```cpp
int findPeakUtil(int arr[], int low, int high, int n) {
    int mid = low + (high - low) / 2;
    if ((mid == 0 || arr[mid] >= arr[mid - 1]) && (mid == n - 1 || arr[mid] >= arr[mid + 1])) {
        return arr[mid];
    } else if (mid > 0 && arr[mid - 1] > arr[mid]) {
        return findPeakUtil(arr, low, mid - 1, n);
    } else {
        return findPeakUtil(arr, mid + 1, high, n);
    }
}

int findPeak(int arr[], int n) {
    return findPeakUtil(arr, 0, n - 1, n);
}
```

### Complexity Analysis (Binary Search Approach)

- **Time Complexity**:
  - O(log n) - This is because in each step, we reduce the search space by half.
  
- **Space Complexity**:
  - O(1) - Same as before, constant space usage.

In practice, the binary search approach is more efficient for larger arrays as it reduces the time complexity significantly compared to the linear scan approach.

### 1. Algorithms & Data Structures (C++): Peak finding

Peak finding is a classic problem in computer science where you're tasked with finding any peak in an array, where a peak is defined as an element that is greater than or equal to its neighbors. There can be multiple peaks, and any one of them can be returned.

Here's a simple implementation of peak finding in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Function to find a peak in an array
int findPeak(vector<int>& arr) {
    int n = arr.size();
    int left = 0, right = n - 1;

    while (left < right) {
        int mid = left + (right - left) / 2;

        // Check if mid is a peak
        if (arr[mid] > arr[mid + 1])
            right = mid;
        else
            left = mid + 1;
    }

    // Left or right can be returned as peak, as per problem requirement
    return left; // or return right;
}

int main() {
    vector<int> arr = {1, 3, 20, 4, 1, 0};
    int peakIndex = findPeak(arr);
    cout << "A peak is found at index " << peakIndex << ", value = " << arr[peakIndex] << endl;
    return 0;
}
```

In this implementation, we're using a binary search approach. We start with the middle element, and compare it with its neighbors. If it's greater than its right neighbor, then a peak must exist on its left side. If it's smaller than its right neighbor, then a peak must exist on its right side. We keep moving towards the direction where the peak is guaranteed to be present until we find one.

The time complexity of this algorithm is O(log n), where n is the number of elements in the array. This is because we're halving the search space in each iteration.

### 1. Algorithms & Data Structures (C++): Peak finding: Complexity analysis

Peak finding is a classic problem in computer science where the goal is to find any peak element in an array. A peak element is defined as an element that is greater than or equal to its adjacent elements. There can be multiple peak elements in an array, and the task is to find any one of them.

Here's a simple approach to find a peak element in an array:

1. **Linear Scan**: Iterate through the array and check if each element is a peak by comparing it with its adjacent elements.

```cpp
int findPeak(int arr[], int n) {
    for (int i = 1; i < n - 1; i++) {
        if (arr[i] >= arr[i - 1] && arr[i] >= arr[i + 1]) {
            return arr[i];
        }
    }
    // Check edge cases
    if (arr[0] >= arr[1]) return arr[0];
    if (arr[n - 1] >= arr[n - 2]) return arr[n - 1];
    return -1; // No peak found
}
```

### Complexity Analysis

- **Time Complexity**:
  - The linear scan approach has a time complexity of O(n), where n is the number of elements in the array. This is because we iterate through the entire array once.
  
- **Space Complexity**:
  - The space complexity is O(1) because we only use a constant amount of extra space for storing loop variables.

### Optimizations

- **Binary Search**: If the array is sorted or can be sorted in a specific order, you can use binary search for a more efficient solution. The time complexity of this approach is O(log n).

```cpp
int findPeakUtil(int arr[], int low, int high, int n) {
    int mid = low + (high - low) / 2;
    if ((mid == 0 || arr[mid] >= arr[mid - 1]) && (mid == n - 1 || arr[mid] >= arr[mid + 1])) {
        return arr[mid];
    } else if (mid > 0 && arr[mid - 1] > arr[mid]) {
        return findPeakUtil(arr, low, mid - 1, n);
    } else {
        return findPeakUtil(arr, mid + 1, high, n);
    }
}

int findPeak(int arr[], int n) {
    return findPeakUtil(arr, 0, n - 1, n);
}
```

### Complexity Analysis (Binary Search Approach)

- **Time Complexity**:
  - O(log n) - This is because in each step, we reduce the search space by half.
  
- **Space Complexity**:
  - O(1) - Same as before, constant space usage.

In practice, the binary search approach is more efficient for larger arrays as it reduces the time complexity significantly compared to the linear scan approach.

### 1. Algorithms & Data Structures (C++): Peak Index in a Mountain Array

To find the peak index in a mountain array using C++, you can employ a binary search algorithm. Here's a basic implementation:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int peakIndexInMountainArray(vector<int>& arr) {
    int low = 0;
    int high = arr.size() - 1;

    while (low < high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] < arr[mid + 1]) {
            low = mid + 1;
        } else {
            high = mid;
        }
    }

    // At the end of the loop, 'low' and 'high' will converge to the peak
    return low; // or high, they are the same at this point
}

int main() {
    vector<int> arr = {0, 1, 2, 3, 4, 5, 4, 3, 2, 1}; // Example array

    int peakIndex = peakIndexInMountainArray(arr);
    cout << "Peak index: " << peakIndex << endl;

    return 0;
}
```

In this code:

- `peakIndexInMountainArray` is a function that takes a vector representing the mountain array and returns the index of the peak.
- The function uses a binary search approach to find the peak index efficiently. It compares the middle element of the array with its adjacent elements to determine whether the peak lies to the left or right of the middle element.
- The binary search continues narrowing down the search space until it converges to the peak index.
- The `main` function demonstrates how to use this function with an example array.

### 1. Algorithms & Data Structures (C++): Perfect Squares

To implement a solution for finding perfect squares in C++, you can use a simple algorithm that iterates through numbers and checks if each number is a perfect square. Here's a basic implementation:

```cpp
#include <iostream>
#include <cmath>

bool isPerfectSquare(int num) {
    int root = sqrt(num);
    return root * root == num;
}

void findPerfectSquares(int n) {
    std::cout << "Perfect squares up to " << n << " are:\n";
    for (int i = 1; i <= n; ++i) {
        if (isPerfectSquare(i)) {
            std::cout << i << " ";
        }
    }
    std::cout << std::endl;
}

int main() {
    int limit;
    std::cout << "Enter the limit: ";
    std::cin >> limit;
    findPerfectSquares(limit);
    return 0;
}
```

In this code:

- `isPerfectSquare()` checks whether a given number is a perfect square by calculating its square root and checking if the square of the root equals the number.
- `findPerfectSquares()` iterates from 1 to the given limit, calling `isPerfectSquare()` for each number and printing it if it's a perfect square.
- In `main()`, the user is prompted to enter the limit, and `findPerfectSquares()` is called with the input limit.

This code will print all perfect squares up to the given limit. You can test it by compiling and running it, providing a suitable limit.

### 1. Algorithms & Data Structures (C++): Permuations

Certainly! In C++, you can generate permutations of a given sequence using the `next_permutation` function from the `<algorithm>` library. Here's a simple example:

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

int main() {
    std::vector<int> nums = {1, 2, 3}; // Input sequence

    // Sort the sequence in ascending order
    std::sort(nums.begin(), nums.end());

    // Output the original sequence
    std::cout << "Original sequence: ";
    for (int num : nums) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    // Generate and output permutations
    std::cout << "Permutations: " << std::endl;
    do {
        for (int num : nums) {
            std::cout << num << " ";
        }
        std::cout << std::endl;
    } while (std::next_permutation(nums.begin(), nums.end()));

    return 0;
}
```

In this code:

- We start with a vector `nums` containing the sequence for which we want to generate permutations.
- We sort the sequence first because `next_permutation` generates permutations in lexicographically sorted order. Sorting ensures that we get permutations in ascending order.
- We output the original sequence.
- Then, we repeatedly call `next_permutation` in a loop to generate and output permutations until all permutations have been generated.

This code will output all possible permutations of the input sequence `{1, 2, 3}`. You can replace `{1, 2, 3}` with any sequence you want to find permutations for.

### 1. Algorithms & Data Structures (C++): Permutation

In C++, you can generate permutations of a sequence using the standard library function `std::next_permutation`. Here's a simple example demonstrating how to use it:

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

int main() {
    std::vector<int> nums = {1, 2, 3}; // Example sequence

    // Sort the sequence in ascending order
    std::sort(nums.begin(), nums.end());

    // Generate and print permutations
    do {
        for (int num : nums) {
            std::cout << num << " ";
        }
        std::cout << std::endl;
    } while (std::next_permutation(nums.begin(), nums.end()));

    return 0;
}
```

In this example, `std::next_permutation` generates permutations of the elements in the `nums` vector. It modifies the vector in-place, rearranging the elements into the next lexicographically greater permutation. The function returns `true` as long as there exists a next permutation; otherwise, it returns `false`.

Before using `std::next_permutation`, it's important to sort the elements in ascending order to start with the first permutation in lexicographical order.

Remember to include the necessary headers (`

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
```

### 1. Algorithms & Data Structures (C++): Permutation (Brute Force)

Sure, I can help you with that! In C++, you can implement a brute-force algorithm to generate permutations using recursion. Here's a simple implementation:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Function to swap two elements in a vector
void swap(vector<int>& nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}

// Recursive function to generate permutations
void generatePermutations(vector<int>& nums, int start, vector<vector<int>>& result) {
    if (start == nums.size() - 1) {
        result.push_back(nums);
        return;
    }

    for (int i = start; i < nums.size(); ++i) {
        swap(nums, start, i);
        generatePermutations(nums, start + 1, result);
        swap(nums, start, i); // Backtrack
    }
}

// Function to generate all permutations of a given vector
vector<vector<int>> permute(vector<int>& nums) {
    vector<vector<int>> result;
    generatePermutations(nums, 0, result);
    return result;
}

// Function to display permutations
void displayPermutations(const vector<vector<int>>& result) {
    for (const auto& perm : result) {
        for (int num : perm) {
            cout << num << " ";
        }
        cout << endl;
    }
}

int main() {
    vector<int> nums = {1, 2, 3}; // Example input
    vector<vector<int>> result = permute(nums);
    displayPermutations(result);
    return 0;
}
```

In this code:

- `swap` is a utility function to swap two elements in a vector.
- `generatePermutations` is a recursive function that generates permutations by swapping elements.
- `permute` is a wrapper function that initializes the result vector and calls `generatePermutations`.
- `displayPermutations` is a utility function to display the generated permutations.
- In the `main` function, we initialize a vector `nums`, call `permute` to generate permutations, and then display them.

This code generates all permutations of the elements in the input vector `nums`. You can modify it as needed for different types of input or output requirements.

### 1. Algorithms & Data Structures (C++): Permutation of String

Certainly! Here's a C++ implementation to generate all permutations of a given string:

```cpp
#include <iostream>
#include <string>
#include <algorithm>

void generatePermutations(std::string str, int start, int end) {
    if (start == end) {
        std::cout << str << std::endl;
    } else {
        for (int i = start; i <= end; i++) {
            std::swap(str[start], str[i]);
            generatePermutations(str, start + 1, end);
            std::swap(str[start], str[i]);
        }
    }
}

void permuteString(std::string str) {
    int n = str.length();
    generatePermutations(str, 0, n - 1);
}

int main() {
    std::string str;
    std::cout << "Enter a string: ";
    std::cin >> str;
    std::cout << "Permutations of the string are:" << std::endl;
    permuteString(str);
    return 0;
}
```

This code defines a function `generatePermutations` that generates all permutations of the string by recursively swapping characters. The `permuteString` function initializes the process by calling `generatePermutations` with the appropriate parameters. Finally, in the `main` function, the user is prompted to enter a string, and the permutations of that string are printed out.

### 1. Algorithms & Data Structures (C++): Permutations

Sure, I can provide you with a basic implementation of generating permutations of a given sequence in C++. One common approach is to use recursion. Here's a simple example:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// Function to generate permutations recursively
void generatePermutations(vector<int>& nums, int start, vector<vector<int>>& result) {
    if (start == nums.size() - 1) {
        result.push_back(nums);
        return;
    }
    
    for (int i = start; i < nums.size(); ++i) {
        swap(nums[start], nums[i]);
        generatePermutations(nums, start + 1, result);
        swap(nums[start], nums[i]);
    }
}

// Function to generate all permutations of a given sequence
vector<vector<int>> permute(vector<int>& nums) {
    vector<vector<int>> result;
    generatePermutations(nums, 0, result);
    return result;
}

// Function to print permutations
void printPermutations(const vector<vector<int>>& permutations) {
    for (const auto& perm : permutations) {
        for (int num : perm) {
            cout << num << " ";
        }
        cout << endl;
    }
}

int main() {
    vector<int> nums = {1, 2, 3};
    vector<vector<int>> permutations = permute(nums);
    
    cout << "Permutations:" << endl;
    printPermutations(permutations);
    
    return 0;
}
```

This code defines a function `permute` which takes a vector of integers and returns a vector of vectors representing all permutations of the input sequence. It uses a helper function `generatePermutations` which recursively generates permutations.

In the `main` function, you can replace `nums` with any sequence you want to find permutations for. The `printPermutations` function is used to print the permutations.

### 1. Algorithms & Data Structures (C++): Phone Number Mnemonics

Creating phone number mnemonics involves mapping digits to letters, typically following the layout of a telephone keypad. Here's a C++ implementation to generate all possible mnemonics for a given phone number:

```cpp
#include <iostream>
#include <vector>
#include <string>

using namespace std;

const vector<string> keypad = {
    " ",    // 0
    "",     // 1
    "abc",  // 2
    "def",  // 3
    "ghi",  // 4
    "jkl",  // 5
    "mno",  // 6
    "pqrs", // 7
    "tuv",  // 8
    "wxyz"  // 9
};

void generateMnemonicsHelper(const string& digits, string current, int index, vector<string>& result) {
    if (index == digits.length()) {
        result.push_back(current);
        return;
    }

    int digit = digits[index] - '0';
    string letters = keypad[digit];

    for (char letter : letters) {
        generateMnemonicsHelper(digits, current + letter, index + 1, result);
    }
}

vector<string> generateMnemonics(const string& digits) {
    vector<string> result;
    if (digits.empty()) return result;

    generateMnemonicsHelper(digits, "", 0, result);
    return result;
}

int main() {
    string phoneNumber = "23"; // Example phone number

    vector<string> mnemonics = generateMnemonics(phoneNumber);

    // Output the generated mnemonics
    for (const string& mnemonic : mnemonics) {
        cout << mnemonic << endl;
    }

    return 0;
}
```

This code defines a `generateMnemonics` function that generates all possible mnemonics for a given phone number. The `generateMnemonicsHelper` function is a recursive helper function that builds up the mnemonics one character at a time, and the `main` function demonstrates its usage by generating mnemonics for the phone number "23".

### 1. Algorithms & Data Structures (C++): Phone Numbers Search

To create a phone number search algorithm in C++, you can use data structures like a trie or a hash table for efficient searching. Here's a simple example using a hash table:

```cpp
#include <iostream>
#include <unordered_map>
#include <string>

using namespace std;

// Structure for storing contact information
struct Contact {
    string name;
    string phoneNumber;
};

// Phone book class
class PhoneBook {
private:
    unordered_map<string, Contact> contacts;

public:
    // Function to add a contact to the phone book
    void addContact(const string& name, const string& phoneNumber) {
        contacts[name] = {name, phoneNumber};
    }

    // Function to search for a contact by name
    Contact* searchByName(const string& name) {
        auto it = contacts.find(name);
        if (it != contacts.end()) {
            return &(it->second);
        } else {
            return nullptr;
        }
    }
};

int main() {
    // Create a phone book
    PhoneBook phoneBook;

    // Add some contacts
    phoneBook.addContact("Alice", "1234567890");
    phoneBook.addContact("Bob", "9876543210");
    phoneBook.addContact("Charlie", "4567890123");

    // Search for a contact
    string searchName = "Bob";
    Contact* result = phoneBook.searchByName(searchName);
    if (result) {
        cout << "Contact found: " << result->name << ", Phone Number: " << result->phoneNumber << endl;
    } else {
        cout << "Contact not found." << endl;
    }

    return 0;
}
```

In this example, we have a `Contact` structure to store the name and phone number. The `PhoneBook` class maintains a hash table (implemented using `unordered_map`) where the key is the contact name and the value is the `Contact` structure.

The `addContact` function adds a new contact to the phone book, and the `searchByName` function searches for a contact by name and returns a pointer to the contact if found, or `nullptr` otherwise.

In the `main` function, we create a `PhoneBook` object, add some contacts to it, and then search for a contact by name.

### 1. Algorithms & Data Structures (C++): Polish notation and Reverse Polish Notation

Polish notation (also known as prefix notation) and Reverse Polish Notation (RPN) are notations used to represent mathematical expressions in a way that doesn't require parentheses to specify the order of operations. Both notations are commonly used in computer science, especially in the implementation of calculators and parsers.

1. **Polish Notation (Prefix Notation)**:
   In Polish notation, the operator precedes its operands. For example, instead of writing "3 + 4", you would write "+ 3 4". This eliminates the need for parentheses because the operator is always placed before its operands.

   Here's another example:

   ```bash
   Infix Notation:    (5 + 3) * 4
   Polish Notation:   * + 5 3 4
   ```

2. **Reverse Polish Notation (RPN or Postfix Notation)**:
   In Reverse Polish Notation, the operator follows its operands. For example, instead of writing "3 + 4", you would write "3 4 +". Similarly, instead of "(5 + 3) *4", you would write "5 3 + 4*".

   RPN is particularly useful in evaluating expressions because it can be evaluated easily using a stack-based algorithm.

   Here's how you would evaluate "5 3 + 4 *":
   - Start with an empty stack.
   - Push each operand onto the stack in order: 5, 3.
   - Encountering an operator (+), pop the top two operands from the stack (3 and 5), perform the operation (3 + 5 = 8), and push the result (8) onto the stack.
   - Continue until all operators have been applied.
   - The final result is the only remaining value on the stack, which is 8 in this case.

Both notations have their advantages and are used in different contexts. Polish notation is easier for parsing and converting expressions, while RPN is easier for evaluating expressions using a stack-based algorithm. In practice, RPN is often used in calculators and stack-based virtual machines.

### 1. Algorithms & Data Structures (C++): Polish Notations

Polish notation, also known as prefix notation, is a mathematical notation in which every operator precedes its operands. This notation eliminates the need for parentheses to indicate the order of operations. There are three main types of Polish notation:

1. **Prefix Notation**: Operators are placed before their operands. For example, the infix expression "3 + 4" becomes "+ 3 4" in prefix notation.

2. **Infix Notation**: This is the standard mathematical notation we are most familiar with, where operators are placed between their operands. For example, "3 + 4".

3. **Postfix Notation**: Operators are placed after their operands. For example, the infix expression "3 + 4" becomes "3 4 +".

Implementing algorithms for converting between infix, prefix, and postfix notations typically involves using stacks. Here's a brief overview of the algorithms for converting infix expressions to prefix and postfix notations:

### Infix to Prefix Conversion Algorithm

1. Reverse the infix expression.
2. Replace '(' with ')' and vice versa.
3. Convert the resulting expression to postfix notation.
4. Reverse the postfix expression to get the prefix notation.

### Infix to Postfix Conversion Algorithm

1. Initialize an empty stack and an empty string for the output.
2. Scan the infix expression from left to right.
3. If the current token is an operand, append it to the output string.
4. If the current token is an operator:
   - While the stack is not empty and the precedence of the current token is less than or equal to the precedence of the operator at the top of the stack, pop operators from the stack and append them to the output string.
   - Push the current token onto the stack.
5. If the current token is '(' push it onto the stack.
6. If the current token is ')' pop operators from the stack and append them to the output string until a '(' is encountered.
7. After scanning the entire expression, pop any remaining operators from the stack and append them to the output string.
8. The resulting string is the postfix notation of the infix expression.

Do you need more detailed explanations or examples of code?

### 1. Algorithms & Data Structures (C++): Primality Test

Sure, I can outline a basic algorithm for testing primality in C++. One of the simplest and commonly used primality tests is the **trial division** method.

Here's a C++ implementation:

```cpp
#include <iostream>
#include <cmath>

bool isPrime(int n) {
    // Base cases
    if (n <= 1)
        return false;
    if (n <= 3)
        return true;

    // Check if n is divisible by 2 or 3
    if (n % 2 == 0 || n % 3 == 0)
        return false;

    // Check for divisibility by numbers of the form 6k ± 1
    for (int i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0)
            return false;
    }

    return true;
}

int main() {
    int num;
    std::cout << "Enter a number: ";
    std::cin >> num;
    
    if (isPrime(num))
        std::cout << num << " is prime.\n";
    else
        std::cout << num << " is not prime.\n";

    return 0;
}
```

This implementation works as follows:

1. It first checks for base cases: if the number is less than or equal to 1, it returns false; if it's 2 or 3, it returns true.
2. Then, it checks if the number is divisible by 2 or 3. If so, it returns false because no prime number other than 2 or 3 can be divisible by these.
3. After that, it checks divisibility by numbers of the form 6k ± 1 (where k is an integer). This optimization reduces the number of divisions needed to check primality.

This algorithm has a time complexity of approximately O(√n), which makes it efficient for checking primality of moderately sized numbers. However, for very large numbers, more advanced primality testing algorithms like Miller-Rabin or AKS may be more suitable.

### 1. Algorithms & Data Structures (C++): Prime Factorisation

Prime factorization is a fundamental concept in number theory and is often used in various algorithms and applications. Here's a basic implementation of prime factorization in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Function to find prime factors of n
void primeFactors(int n) {
    // Vector to store the prime factors
    vector<int> factors;

    // Check for 2 as a factor and divide n by 2 until it is odd
    while (n % 2 == 0) {
        factors.push_back(2);
        n = n / 2;
    }

    // Now n must be odd, start from 3 and increment by 2
    // We only need to check odd numbers because all even factors (except 2) have been already considered
    for (int i = 3; i * i <= n; i = i + 2) {
        // While i is a factor of n, push i and divide n by i
        while (n % i == 0) {
            factors.push_back(i);
            n = n / i;
        }
    }

    // If n is a prime number greater than 2, then it itself is a factor
    if (n > 2)
        factors.push_back(n);

    // Output the prime factors
    cout << "Prime Factors: ";
    for (int i = 0; i < factors.size(); i++) {
        cout << factors[i];
        if (i != factors.size() - 1)
            cout << " * ";
    }
    cout << endl;
}

int main() {
    int n;
    cout << "Enter a number to find its prime factors: ";
    cin >> n;
    primeFactors(n);
    return 0;
}
```

This code takes an integer input from the user and then finds and prints its prime factors. The primeFactors function iterates through all possible factors starting from 2 and progressively divides the number by its factors, storing each prime factor in a vector. Finally, it prints out the prime factors.

### 1. Algorithms & Data Structures (C++): Prime Factorisation Code O(N)

Sure, here's a simple C++ code to perform prime factorization in O(N) complexity:

```cpp
#include <iostream>
#include <vector>

using namespace std;

vector<int> primeFactorization(int n) {
    vector<int> factors;
    
    // Divide by 2
    while (n % 2 == 0) {
        factors.push_back(2);
        n /= 2;
    }
    
    // Now n must be odd, so we can skip even numbers
    for (int i = 3; i * i <= n; i += 2) {
        while (n % i == 0) {
            factors.push_back(i);
            n /= i;
        }
    }
    
    // If n is still greater than 2, it's a prime number
    if (n > 2)
        factors.push_back(n);
    
    return factors;
}

int main() {
    int n;
    cout << "Enter a number to find its prime factors: ";
    cin >> n;

    vector<int> factors = primeFactorization(n);

    cout << "Prime factors of " << n << " are: ";
    for (int factor : factors) {
        cout << factor << " ";
    }
    cout << endl;

    return 0;
}
```

This code first divides the number by 2 until it's not divisible anymore (taking care of even factors), then it iterates through odd numbers starting from 3 up to the square root of the number, checking for divisibility. Finally, if there's any remainder greater than 2, it means it's a prime factor.

### 1. Algorithms & Data Structures (C++): Prime Factorisation Code O(Sqrt(N))

Certainly! Here's a simple C++ code to find the prime factors of a given number using the trial division method, which has a time complexity of O(sqrt(N)):

```cpp
#include <iostream>
#include <vector>

using namespace std;

vector<int> primeFactorization(int n) {
    vector<int> factors;
    // Check for 2 as a factor
    while (n % 2 == 0) {
        factors.push_back(2);
        n /= 2;
    }
    // Check for other odd factors
    for (int i = 3; i * i <= n; i += 2) {
        while (n % i == 0) {
            factors.push_back(i);
            n /= i;
        }
    }
    // If n is a prime greater than 2
    if (n > 2)
        factors.push_back(n);
    return factors;
}

int main() {
    int n;
    cout << "Enter a number: ";
    cin >> n;
    vector<int> factors = primeFactorization(n);
    cout << "Prime factors of " << n << " are: ";
    for (int factor : factors) {
        cout << factor << " ";
    }
    cout << endl;
    return 0;
}
```

This code first checks if 2 is a factor, then iterates through odd numbers up to the square root of the input number to find other prime factors. This approach ensures that we only check prime factors up to the square root of the number, hence achieving a time complexity of O(sqrt(N)).

### 1. Algorithms & Data Structures (C++): Prime Factorisation using Sieve O(LogN)

To perform prime factorization using the Sieve of Eratosthenes in logarithmic time complexity (`O(log N)`), you typically wouldn't use the Sieve directly. Instead, you can precalculate prime numbers using the Sieve and then use that information to perform prime factorization efficiently.

Here's a basic outline of how you might implement prime factorization in C++ using the Sieve of Eratosthenes:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Function to generate primes up to a given limit using Sieve of Eratosthenes
vector<int> generatePrimes(int limit) {
    vector<bool> isPrime(limit + 1, true);
    vector<int> primes;

    for (int p = 2; p * p <= limit; ++p) {
        if (isPrime[p]) {
            for (int i = p * p; i <= limit; i += p)
                isPrime[i] = false;
        }
    }

    for (int p = 2; p <= limit; ++p) {
        if (isPrime[p])
            primes.push_back(p);
    }

    return primes;
}

// Function to perform prime factorization
vector<int> primeFactorization(int n, const vector<int>& primes) {
    vector<int> factors;
    
    for (int i = 0; i < primes.size() && primes[i] * primes[i] <= n; ++i) {
        while (n % primes[i] == 0) {
            factors.push_back(primes[i]);
            n /= primes[i];
        }
    }
    
    if (n > 1)
        factors.push_back(n);
    
    return factors;
}

int main() {
    int n;
    cout << "Enter a number to find its prime factors: ";
    cin >> n;

    vector<int> primes = generatePrimes(n);
    vector<int> factors = primeFactorization(n, primes);

    cout << "Prime factors of " << n << " are: ";
    for (int factor : factors)
        cout << factor << " ";
    cout << endl;

    return 0;
}
```

In this code:

- The `generatePrimes` function generates all the prime numbers up to the given limit using the Sieve of Eratosthenes.
- The `primeFactorization` function factors the given number `n` using the generated primes. It iterates through the prime numbers and checks if they divide `n` evenly. If they do, it adds them to the list of factors and divides `n` by that prime number.
- Finally, in the `main` function, it takes input from the user, generates primes using `generatePrimes`, and performs prime factorization using `primeFactorization`.

### 1. Algorithms & Data Structures (C++): Prime Factorization: Factor

Sure! Here's a simple C++ implementation for prime factorization using trial division:

```cpp
#include <iostream>
#include <vector>

using namespace std;

vector<int> primeFactorization(int n) {
    vector<int> factors;
    
    // Divide by 2 as many times as possible
    while (n % 2 == 0) {
        factors.push_back(2);
        n = n / 2;
    }
    
    // Now n must be odd. Check for odd factors
    for (int i = 3; i * i <= n; i = i + 2) {
        while (n % i == 0) {
            factors.push_back(i);
            n = n / i;
        }
    }
    
    // If n is a prime greater than 2
    if (n > 2) {
        factors.push_back(n);
    }
    
    return factors;
}

int main() {
    int n;
    cout << "Enter a number to factorize: ";
    cin >> n;
    
    vector<int> factors = primeFactorization(n);
    
    cout << "Prime factors of " << n << " are: ";
    for (int i = 0; i < factors.size(); ++i) {
        cout << factors[i];
        if (i != factors.size() - 1) {
            cout << " * ";
        }
    }
    cout << endl;
    
    return 0;
}
```

This code takes an integer as input and returns its prime factors. It first divides the number by 2 as many times as possible to eliminate all even factors. Then, it checks for odd factors starting from 3 up to the square root of the number. If a factor is found, it's added to the list of prime factors. Finally, if the remaining number is greater than 2, it's also added to the list as it's a prime factor itself.

### 1. Algorithms & Data Structures (C++): Prime Factorization: Factoring Algorithm

Prime factorization is a fundamental algorithm in number theory that decomposes a composite number into its prime factors. Here's a basic C++ implementation of the prime factorization algorithm:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Function to perform prime factorization
vector<int> primeFactorization(int n) {
    vector<int> factors;
    
    // Divide by 2 until n is odd
    while (n % 2 == 0) {
        factors.push_back(2);
        n /= 2;
    }
    
    // Now n must be odd, so we can start from 3 and increment by 2
    for (int i = 3; i * i <= n; i += 2) {
        while (n % i == 0) {
            factors.push_back(i);
            n /= i;
        }
    }
    
    // If n is still greater than 2, then it must be a prime number
    if (n > 2)
        factors.push_back(n);
    
    return factors;
}

int main() {
    int n;
    cout << "Enter a number to factorize: ";
    cin >> n;

    vector<int> factors = primeFactorization(n);

    cout << "Prime factors of " << n << " are: ";
    for (int factor : factors) {
        cout << factor << " ";
    }
    cout << endl;

    return 0;
}
```

In this implementation:

- We start by dividing the number by 2 until it becomes odd. This step takes care of the 2's in the prime factorization.
- Then, we iterate from 3 up to the square root of the number, checking each odd number as potential factors. If a number divides `n`, we add it to the list of factors and divide `n` by that factor.
- After the loop, if `n` is still greater than 2, it means `n` itself is a prime number, so we add it to the factors list.
- Finally, we print out the prime factors obtained.

### 1. Algorithms & Data Structures (C++): Prime Numbers & Factorisation

Sure, let's delve into implementing algorithms for generating prime numbers and factorizing integers in C++.

**1. Prime Numbers:**

A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.

Here's a simple implementation of a function to check if a number is prime:

```cpp
#include <iostream>

bool isPrime(int n) {
    if (n <= 1) return false;
    if (n <= 3) return true;
    if (n % 2 == 0 || n % 3 == 0) return false;

    for (int i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0)
            return false;
    }
    return true;
}

int main() {
    int num;
    std::cout << "Enter a number: ";
    std::cin >> num;
    if (isPrime(num))
        std::cout << num << " is prime.\n";
    else
        std::cout << num << " is not prime.\n";
    return 0;
}
```

**2. Prime Factorization:**

Prime factorization is the process of finding the prime factors of a number.

Here's how you can implement prime factorization:

```cpp
#include <iostream>
#include <vector>

std::vector<int> primeFactors(int n) {
    std::vector<int> factors;
    while (n % 2 == 0) {
        factors.push_back(2);
        n /= 2;
    }
    for (int i = 3; i * i <= n; i += 2) {
        while (n % i == 0) {
            factors.push_back(i);
            n /= i;
        }
    }
    if (n > 2)
        factors.push_back(n);
    return factors;
}

int main() {
    int num;
    std::cout << "Enter a number: ";
    std::cin >> num;
    std::vector<int> factors = primeFactors(num);
    std::cout << "Prime factors of " << num << " are: ";
    for (int factor : factors)
        std::cout << factor << " ";
    std::cout << std::endl;
    return 0;
}
```

These are basic implementations. Depending on your requirements, you may want to optimize these algorithms further for larger numbers or specific use cases.

### 1. Algorithms & Data Structures (C++): Prime Sieve

A Prime Sieve is a classic algorithm used to generate all prime numbers up to a given limit efficiently. The basic idea is to eliminate multiples of each prime number found, leaving only the primes themselves. Here's a simple implementation of the Prime Sieve algorithm in C++:

```cpp
#include <iostream>
#include <vector>

void sieveOfEratosthenes(int n) {
    // Create a boolean vector "prime[0..n]" and initialize
    // all entries as true. A value in prime[i] will finally be
    // false if i is Not a prime, else true.
    std::vector<bool> prime(n + 1, true);

    for (int p = 2; p * p <= n; ++p) {
        // If prime[p] is not changed, then it is a prime
        if (prime[p]) {
            // Update all multiples of p
            for (int i = p * p; i <= n; i += p)
                prime[i] = false;
        }
    }

    // Print all prime numbers
    for (int p = 2; p <= n; ++p) {
        if (prime[p])
            std::cout << p << " ";
    }
}

int main() {
    int n = 100; // Limit to generate prime numbers up to 100
    std::cout << "Prime numbers up to " << n << " are: ";
    sieveOfEratosthenes(n);
    std::cout << std::endl;
    return 0;
}
```

In this implementation:

- We create a boolean vector `prime` of size `n + 1`, where `prime[i]` will indicate whether `i` is a prime number or not.
- We iterate over numbers from 2 to the square root of `n`. For each prime `p`, we mark all its multiples as non-prime.
- Finally, we print all the numbers that are marked as prime.

This algorithm has a time complexity of O(n*log(log(n))) and space complexity of O(n). It's quite efficient for generating prime numbers up to moderately large values of `n`.

### 1. Algorithms & Data Structures (C++): Prime Sum

To find pairs of prime numbers that sum up to a given target in C++, you can use a simple algorithm. First, you'll need a function to check if a number is prime. Then, you can iterate through numbers up to the target, checking if each number is prime. If a number is prime, you can check if the target minus that number is also prime. If both are prime, you've found a pair that sums up to the target.

Here's a C++ implementation of this algorithm:

```cpp
#include <iostream>
#include <vector>

// Function to check if a number is prime
bool isPrime(int n) {
    if (n <= 1) return false;
    if (n <= 3) return true;
    if (n % 2 == 0 || n % 3 == 0) return false;
    for (int i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0)
            return false;
    }
    return true;
}

// Function to find pairs of primes that sum up to a given target
std::vector<std::pair<int, int>> primeSum(int target) {
    std::vector<std::pair<int, int>> result;

    for (int i = 2; i <= target / 2; ++i) {
        if (isPrime(i) && isPrime(target - i)) {
            result.push_back({i, target - i});
        }
    }

    return result;
}

// Helper function to print pairs
void printPairs(const std::vector<std::pair<int, int>>& pairs) {
    for (const auto& pair : pairs) {
        std::cout << pair.first << " + " << pair.second << " = " << pair.first + pair.second << std::endl;
    }
}

int main() {
    int target = 50;
    std::vector<std::pair<int, int>> pairs = primeSum(target);

    std::cout << "Pairs of prime numbers that sum up to " << target << ":" << std::endl;
    printPairs(pairs);

    return 0;
}
```

In this code:

- The `isPrime()` function checks if a number is prime or not.
- The `primeSum()` function finds pairs of prime numbers that sum up to the given target.
- The `printPairs()` function is a helper function to print out the pairs found.

You can adjust the `target` variable in the `main()` function to find pairs for different target sums.

### 1. Algorithms & Data Structures (C++): Print Pairs

Certainly! Printing pairs from an array in C++ involves iterating through the array and considering all possible combinations of elements. Here's a simple example of how you can achieve this:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Function to print all pairs in an array
void printPairs(const vector<int>& arr) {
    int n = arr.size();
    
    // Iterate through each element in the array
    for (int i = 0; i < n; ++i) {
        for (int j = i + 1; j < n; ++j) {
            // Print the pair (arr[i], arr[j])
            cout << "(" << arr[i] << ", " << arr[j] << ")" << endl;
        }
    }
}

int main() {
    // Example array
    vector<int> arr = {1, 2, 3, 4, 5};
    
    // Print all pairs
    printPairs(arr);
    
    return 0;
}
```

In this code:

- The `printPairs` function takes a vector of integers `arr` as input.
- It iterates through each element of the array using two nested loops.
- For each pair of elements `(arr[i], arr[j])` where `i` and `j` are indices and `i < j`, it prints the pair.

You can modify this code according to your specific requirements, such as changing the data type of the array or adding conditions for selecting pairs.

### 1. Algorithms & Data Structures (C++): Problem: Combination Sum

Sure, I'd be happy to help with that! The Combination Sum problem is a classic problem in computer science and is often used to practice recursion and backtracking algorithms. The problem statement typically goes like this:

Given a set of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.

Each number in candidates may only be used once in the combination.

Here's an example:

```bash
Input: candidates = [2,3,6,7], target = 7,
A solution set is:
[
  [7],
  [2,2,3]
]
```

This problem can be solved using a backtracking approach. We can start with an empty combination, and at each step, we can either include the current number or skip it. We continue this process recursively until we reach the target sum or exhaust all the numbers.

Here's a C++ implementation of the solution:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

void backtrack(vector<vector<int>>& res, vector<int>& candidates, vector<int>& temp, int target, int start) {
    if (target == 0) {
        res.push_back(temp);
        return;
    }
    for (int i = start; i < candidates.size(); ++i) {
        if (candidates[i] > target) break; // optimization
        if (i > start && candidates[i] == candidates[i - 1]) continue; // skip duplicates
        temp.push_back(candidates[i]);
        backtrack(res, candidates, temp, target - candidates[i], i + 1);
        temp.pop_back();
    }
}

vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
    vector<vector<int>> res;
    vector<int> temp;
    sort(candidates.begin(), candidates.end());
    backtrack(res, candidates, temp, target, 0);
    return res;
}

int main() {
    vector<int> candidates = {2, 3, 6, 7};
    int target = 7;
    vector<vector<int>> result = combinationSum(candidates, target);
    cout << "Solution set:" << endl;
    for (const auto& combination : result) {
        cout << "[";
        for (int num : combination) {
            cout << num << ", ";
        }
        cout << "]" << endl;
    }
    return 0;
}
```

This code defines a `backtrack` function that explores all possible combinations and recursively searches for valid combinations that sum up to the target. The `combinationSum` function initializes the result vector, sorts the candidates, and then calls the `backtrack` function to find the combinations. Finally, it prints out the solution set.

### 1. Algorithms & Data Structures (C++): Problem: Subsets

The "Subsets" problem involves generating all possible subsets of a given set. Here's a C++ implementation using backtracking:

```cpp
#include <iostream>
#include <vector>

using namespace std;

void generateSubsets(vector<int>& nums, vector<int>& subset, int index, vector<vector<int>>& subsets) {
    subsets.push_back(subset); // Add the current subset to the list of subsets
    for (int i = index; i < nums.size(); ++i) {
        // Include the current element in the subset
        subset.push_back(nums[i]);
        // Recursively generate subsets starting from the next index
        generateSubsets(nums, subset, i + 1, subsets);
        // Backtrack: Remove the current element from the subset
        subset.pop_back();
    }
}

vector<vector<int>> subsets(vector<int>& nums) {
    vector<vector<int>> result;
    vector<int> subset;
    generateSubsets(nums, subset, 0, result);
    return result;
}

int main() {
    vector<int> nums = {1, 2, 3};
    vector<vector<int>> result = subsets(nums);
    // Print all subsets
    for (const auto& subset : result) {
        cout << "[";
        for (int i = 0; i < subset.size(); ++i) {
            cout << subset[i];
            if (i != subset.size() - 1) cout << ", ";
        }
        cout << "]" << endl;
    }
    return 0;
}
```

This code will generate all possible subsets of the given set `{1, 2, 3}` and print them. The algorithm uses backtracking to generate subsets by including or excluding each element at each step.

### 1. Algorithms & Data Structures (C++): Project : Design LRU Cache

Designing an LRU (Least Recently Used) cache involves using both data structures and algorithms efficiently. In C++, you can implement it using a combination of a doubly linked list and a hash map for fast access to elements. Here's a basic outline of how you can design an LRU cache:

1. **Define Node Structure**: This structure represents each node in the doubly linked list. It will contain pointers to the previous and next nodes, as well as key-value pairs for the cache.

```cpp
struct Node {
    int key;
    int value;
    Node* prev;
    Node* next;
    Node(int k, int v) : key(k), value(v), prev(nullptr), next(nullptr) {}
};
```

1. **LRUCache Class**: This class will implement the functionality of the LRU cache. It will have a hash map to quickly access nodes based on keys, and a doubly linked list to maintain the order of recently used elements.

```cpp
#include <unordered_map>

class LRUCache {
private:
    int capacity;
    std::unordered_map<int, Node*> cache;
    Node* head;
    Node* tail;

    // Private helper functions
    void addNode(Node* node);
    void removeNode(Node* node);
    void moveToHead(Node* node);

public:
    LRUCache(int capacity);
    ~LRUCache();

    int get(int key);
    void put(int key, int value);
};
```

1. **Constructor and Destructor**: Implement the constructor to initialize the cache with a given capacity. The destructor should free the memory allocated for the nodes.

```cpp
LRUCache::LRUCache(int capacity) : capacity(capacity), head(nullptr), tail(nullptr) {}

LRUCache::~LRUCache() {
    for (auto it = cache.begin(); it != cache.end(); ++it) {
        delete it->second;
    }
}
```

1. **Helper Functions**: Implement helper functions to maintain the doubly linked list and the hash map.

```cpp
void LRUCache::addNode(Node* node) {
    node->prev = nullptr;
    node->next = head;

    if (head != nullptr)
        head->prev = node;
    else
        tail = node;

    head = node;
}

void LRUCache::removeNode(Node* node) {
    if (node->prev != nullptr)
        node->prev->next = node->next;
    else
        head = node->next;

    if (node->next != nullptr)
        node->next->prev = node->prev;
    else
        tail = node->prev;
}

void LRUCache::moveToHead(Node* node) {
    removeNode(node);
    addNode(node);
}
```

1. **Main Operations**: Implement the `get` and `put` operations for the LRU cache.

```cpp
int LRUCache::get(int key) {
    if (cache.find(key) == cache.end())
        return -1;

    Node* node = cache[key];
    moveToHead(node);
    return node->value;
}

void LRUCache::put(int key, int value) {
    if (cache.find(key) != cache.end()) {
        Node* node = cache[key];
        node->value = value;
        moveToHead(node);
    } else {
        if (cache.size() == capacity) {
            cache.erase(tail->key);
            removeNode(tail);
        }

        Node* newNode = new Node(key, value);
        cache[key] = newNode;
        addNode(newNode);
    }
}
```

This implementation ensures that the `get` and `put` operations work in constant time, O(1), by utilizing both the hash map and the doubly linked list. The hash map provides fast access to cache nodes based on keys, while the doubly linked list maintains the order of recently used elements.

### 1. Algorithms & Data Structures (C++): Rains

It sounds like you're referring to the "Trapping Rain Water" problem, which is a classic algorithmic problem often encountered in interviews and competitive programming. The problem involves calculating the amount of rainwater that can be trapped between towers in a cityscape. Here's a brief explanation of the problem and a possible C++ solution using dynamic programming:

**Problem Description:**
Given an array representing heights of towers, where the width of each tower is 1, calculate how much rainwater can be trapped between the towers.

**Example:**

```bash
Input: [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
```

Explanation: In this example, the amount of rainwater trapped is 6 units.

**C++ Solution:**

```cpp
#include <iostream>
#include <vector>

using namespace std;

int trap(vector<int>& height) {
    int n = height.size();
    if (n <= 2) return 0;

    vector<int> left_max(n), right_max(n);

    // Calculate the maximum height to the left of each tower
    left_max[0] = height[0];
    for (int i = 1; i < n; ++i) {
        left_max[i] = max(left_max[i - 1], height[i]);
    }

    // Calculate the maximum height to the right of each tower
    right_max[n - 1] = height[n - 1];
    for (int i = n - 2; i >= 0; --i) {
        right_max[i] = max(right_max[i + 1], height[i]);
    }

    int trapped_water = 0;
    for (int i = 0; i < n; ++i) {
        trapped_water += min(left_max[i], right_max[i]) - height[i];
    }

    return trapped_water;
}

int main() {
    vector<int> heights = {0,1,0,2,1,0,1,3,2,1,2,1};
    cout << "Trapped water: " << trap(heights) << " units" << endl;
    return 0;
}
```

This C++ solution utilizes dynamic programming to efficiently calculate the trapped water. We maintain two arrays, `left_max` and `right_max`, to store the maximum height to the left and right of each tower, respectively. Then, we iterate through the array once to calculate the trapped water by finding the minimum of `left_max` and `right_max` for each tower and subtracting the tower's height. Finally, we sum up the trapped water for all towers and return the result.

### 1. Algorithms & Data Structures (C++): Range Minimum Queries

Range Minimum Queries (RMQ) is a fundamental problem in computer science, particularly in the realm of algorithms and data structures. Given an array of elements, RMQ involves finding the minimum element within a specified range of indices. This problem has numerous applications, including computational biology, linguistics, and many others.

One popular data structure used to efficiently solve RMQ is the Segment Tree. Here's a basic overview of how you can implement it in C++:

```cpp
#include <iostream>
#include <vector>
#include <climits>

using namespace std;

// Segment Tree Node
struct SegmentTreeNode {
    int start, end, minimum;
    SegmentTreeNode *left, *right;

    SegmentTreeNode(int start, int end) : start(start), end(end), left(nullptr), right(nullptr), minimum(INT_MAX) {}
};

// Build Segment Tree
SegmentTreeNode* buildSegmentTree(vector<int>& nums, int start, int end) {
    if (start > end) return nullptr;

    SegmentTreeNode* root = new SegmentTreeNode(start, end);

    if (start == end) {
        root->minimum = nums[start];
    } else {
        int mid = start + (end - start) / 2;
        root->left = buildSegmentTree(nums, start, mid);
        root->right = buildSegmentTree(nums, mid + 1, end);
        root->minimum = min(root->left->minimum, root->right->minimum);
    }

    return root;
}

// Query the Segment Tree
int querySegmentTree(SegmentTreeNode* root, int start, int end) {
    if (!root || root->start > end || root->end < start) return INT_MAX;
    if (root->start >= start && root->end <= end) return root->minimum;

    return min(querySegmentTree(root->left, start, end), querySegmentTree(root->right, start, end));
}

int main() {
    vector<int> nums = {1, 3, 2, 7, 9, 11};
    SegmentTreeNode* root = buildSegmentTree(nums, 0, nums.size() - 1);

    // Example queries
    cout << "Minimum in range [1, 3]: " << querySegmentTree(root, 1, 3) << endl;
    cout << "Minimum in range [2, 5]: " << querySegmentTree(root, 2, 5) << endl;

    return 0;
}
```

In this implementation, we use a divide-and-conquer approach to build the Segment Tree. Each node of the Segment Tree represents a range of the original array. The `minimum` field of each node stores the minimum element within that range. When querying the Segment Tree for a range, we traverse down the tree and return the minimum value found within the specified range.

This is a basic implementation, and there are optimizations and variations depending on specific requirements, such as using lazy propagation to handle updates efficiently or using different data structures like Sparse Table for RMQ.

### 1. Algorithms & Data Structures (C++): Range Queries

Range queries are a fundamental concept in algorithms and data structures, particularly in scenarios where you need to retrieve or manipulate data within a specified range efficiently. In C++, you can implement various data structures and algorithms to handle range queries effectively. Here's an overview of some common approaches:

1. **Segment Tree**:
   - A segment tree is a versatile data structure that allows efficient querying and updating of intervals or ranges in an array.
   - Each node in the tree represents a range of the array, and each leaf node represents a single element of the array.
   - Segment trees are commonly used for range minimum/maximum queries, range sum queries, and similar operations.
   - Here's a basic implementation of a segment tree for range minimum queries:

   ```cpp
   #include <vector>
   #include <climits>

   using namespace std;

   class SegmentTree {
   private:
       vector<int> tree;
       int n;

       void build(const vector<int>& arr, int node, int start, int end) {
           if (start == end) {
               tree[node] = arr[start];
           } else {
               int mid = (start + end) / 2;
               build(arr, 2 * node, start, mid);
               build(arr, 2 * node + 1, mid + 1, end);
               tree[node] = min(tree[2 * node], tree[2 * node + 1]);
           }
       }

       int query(int node, int start, int end, int l, int r) {
           if (r < start || l > end) return INT_MAX;
           if (l <= start && r >= end) return tree[node];
           int mid = (start + end) / 2;
           return min(query(2 * node, start, mid, l, r),
                      query(2 * node + 1, mid + 1, end, l, r));
       }

   public:
       SegmentTree(const vector<int>& arr) {
           n = arr.size();
           tree.resize(4 * n);
           build(arr, 1, 0, n - 1);
       }

       int rangeMinimumQuery(int l, int r) {
           return query(1, 0, n - 1, l, r);
       }
   };
   ```

2. **Binary Indexed Tree (Fenwick Tree)**:
   - Binary Indexed Tree is another data structure used for range queries and point updates on arrays efficiently.
   - It is particularly useful when you need to perform cumulative operations (like prefix sums) on elements of the array.
   - Here's a basic implementation of a binary indexed tree for range sum queries:

   ```cpp
   #include <vector>

   using namespace std;

   class FenwickTree {
   private:
       vector<int> tree;

       int sum(int idx) {
           int result = 0;
           while (idx > 0) {
               result += tree[idx];
               idx -= idx & (-idx);
           }
           return result;
       }

   public:
       FenwickTree(int n) {
           tree.assign(n + 1, 0);
       }

       void update(int idx, int delta) {
           while (idx < tree.size()) {
               tree[idx] += delta;
               idx += idx & (-idx);
           }
       }

       int rangeSumQuery(int l, int r) {
           return sum(r) - sum(l - 1);
       }
   };
   ```

These are just two examples of how you can handle range queries in C++. Depending on the specific problem requirements and constraints, you may need to choose the appropriate data structure or algorithm for efficient range query processing.

### 1. Algorithms & Data Structures (C++): Range Set Query

A Range Set Query is a common problem in algorithms and data structures where you're given a set of elements and queries to perform operations on specific ranges within that set. One common variation is the Range Minimum Query (RMQ), where you're asked to find the minimum element within a given range.

In C++, you can implement a Range Set Query using various data structures, such as segment trees, binary indexed trees (also known as Fenwick trees), or square root decomposition. Here, I'll give you an example implementation using a segment tree for RMQ.

```cpp
#include <iostream>
#include <vector>
#include <limits>

using namespace std;

class SegmentTree {
private:
    vector<int> tree;
    int n;

    void build(const vector<int>& arr, int node, int start, int end) {
        if (start == end) {
            tree[node] = arr[start];
            return;
        }
        int mid = (start + end) / 2;
        build(arr, 2 * node + 1, start, mid);
        build(arr, 2 * node + 2, mid + 1, end);
        tree[node] = min(tree[2 * node + 1], tree[2 * node + 2]);
    }

    int query(int node, int start, int end, int l, int r) {
        if (r < start || end < l) return numeric_limits<int>::max();
        if (l <= start && end <= r) return tree[node];
        int mid = (start + end) / 2;
        return min(query(2 * node + 1, start, mid, l, r),
                   query(2 * node + 2, mid + 1, end, l, r));
    }

public:
    SegmentTree(const vector<int>& arr) {
        n = arr.size();
        tree.resize(4 * n); // Adjust size for a sufficient number of nodes
        build(arr, 0, 0, n - 1);
    }

    int rangeMinimumQuery(int l, int r) {
        return query(0, 0, n - 1, l, r);
    }
};

int main() {
    vector<int> arr = {1, 3, 2, 7, 9, 11};
    SegmentTree segTree(arr);

    // Example range minimum queries
    cout << "Minimum element in range [0, 3]: " << segTree.rangeMinimumQuery(0, 3) << endl;
    cout << "Minimum element in range [2, 5]: " << segTree.rangeMinimumQuery(2, 5) << endl;

    return 0;
}
```

In this example, the `SegmentTree` class represents the segment tree data structure. The `build` function constructs the segment tree from an input array, and the `query` function finds the minimum element within a given range. The `main` function demonstrates how to use this class by constructing a segment tree from an example array and performing range minimum queries.

### 1. Algorithms & Data Structures (C++): Range Update Queries

Range update queries are a common problem in algorithmic interviews and competitive programming contests. The task involves updating a range of elements in an array efficiently. Here's how you can implement range update queries in C++ using segment trees:

```cpp
#include <iostream>
#include <vector>

using namespace std;

class SegmentTree {
private:
    vector<long long> tree;
    vector<long long> lazy;
    int size;

    void propagate(int node, int left, int right) {
        if (lazy[node] != 0) {
            tree[node] += lazy[node] * (right - left + 1);
            if (left != right) {
                lazy[2 * node + 1] += lazy[node];
                lazy[2 * node + 2] += lazy[node];
            }
            lazy[node] = 0;
        }
    }

    void updateRangeUtil(int node, int start, int end, int rangeStart, int rangeEnd, long long diff) {
        propagate(node, start, end);

        if (start > end || start > rangeEnd || end < rangeStart)
            return;

        if (start >= rangeStart && end <= rangeEnd) {
            tree[node] += diff * (end - start + 1);
            if (start != end) {
                lazy[2 * node + 1] += diff;
                lazy[2 * node + 2] += diff;
            }
            return;
        }

        int mid = (start + end) / 2;
        updateRangeUtil(2 * node + 1, start, mid, rangeStart, rangeEnd, diff);
        updateRangeUtil(2 * node + 2, mid + 1, end, rangeStart, rangeEnd, diff);
        tree[node] = tree[2 * node + 1] + tree[2 * node + 2];
    }

    long long queryRangeUtil(int node, int start, int end, int rangeStart, int rangeEnd) {
        propagate(node, start, end);

        if (start > end || start > rangeEnd || end < rangeStart)
            return 0;

        if (start >= rangeStart && end <= rangeEnd)
            return tree[node];

        int mid = (start + end) / 2;
        long long left = queryRangeUtil(2 * node + 1, start, mid, rangeStart, rangeEnd);
        long long right = queryRangeUtil(2 * node + 2, mid + 1, end, rangeStart, rangeEnd);
        return left + right;
    }

public:
    SegmentTree(int n) {
        size = n;
        tree.assign(4 * n, 0);
        lazy.assign(4 * n, 0);
    }

    void updateRange(int rangeStart, int rangeEnd, long long diff) {
        updateRangeUtil(0, 0, size - 1, rangeStart, rangeEnd, diff);
    }

    long long queryRange(int rangeStart, int rangeEnd) {
        return queryRangeUtil(0, 0, size - 1, rangeStart, rangeEnd);
    }
};

int main() {
    // Example usage
    int n = 5;
    SegmentTree st(n);

    // Update range [1, 3] by adding 2
    st.updateRange(1, 3, 2);

    // Update range [2, 4] by adding 3
    st.updateRange(2, 4, 3);

    // Query range [1, 4]
    cout << "Sum of elements in range [1, 4]: " << st.queryRange(1, 4) << endl;

    return 0;
}
```

This code implements a segment tree with lazy propagation, which efficiently handles range update queries. It can perform range updates and range queries in O(log N) time complexity, where N is the number of elements in the array.

### 1. Algorithms & Data Structures (C++): Range Xor Queries

Range XOR queries are a common problem in competitive programming and can be solved efficiently using a data structure called a segment tree. Here's how you can implement it in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Node structure for segment tree
struct Node {
    int value;
    Node *left, *right;
    Node(int val) : value(val), left(nullptr), right(nullptr) {}
};

// Function to build segment tree
Node* buildTree(vector<int>& arr, int start, int end) {
    if (start == end) {
        return new Node(arr[start]);
    }

    int mid = start + (end - start) / 2;
    Node* leftChild = buildTree(arr, start, mid);
    Node* rightChild = buildTree(arr, mid + 1, end);

    Node* node = new Node(leftChild->value ^ rightChild->value);
    node->left = leftChild;
    node->right = rightChild;

    return node;
}

// Function to perform XOR range queries
int xorQuery(Node* node, int start, int end, int qStart, int qEnd) {
    if (start > qEnd || end < qStart) {
        return 0; // Out of range
    }

    if (start >= qStart && end <= qEnd) {
        return node->value; // Current segment is fully within query range
    }

    int mid = start + (end - start) / 2;
    int leftXor = xorQuery(node->left, start, mid, qStart, qEnd);
    int rightXor = xorQuery(node->right, mid + 1, end, qStart, qEnd);

    return leftXor ^ rightXor;
}

int main() {
    vector<int> arr = {1, 3, 5, 7, 9, 11};
    int n = arr.size();

    // Build segment tree
    Node* root = buildTree(arr, 0, n - 1);

    // Example queries
    int q1_start = 1, q1_end = 4;
    int q2_start = 0, q2_end = 3;

    // Query 1: XOR of elements from index 1 to 4
    cout << "XOR of elements from index " << q1_start << " to " << q1_end << ": ";
    cout << xorQuery(root, 0, n - 1, q1_start, q1_end) << endl;

    // Query 2: XOR of elements from index 0 to 3
    cout << "XOR of elements from index " << q2_start << " to " << q2_end << ": ";
    cout << xorQuery(root, 0, n - 1, q2_start, q2_end) << endl;

    return 0;
}
```

This code builds a segment tree for the given array `arr`, where each node stores the XOR of its children. The `xorQuery` function performs XOR range queries efficiently on the segment tree. You can modify the `main` function to suit your specific input and query requirements.

### 1. Algorithms & Data Structures (C++): Rat and Mice

Sure, let's discuss a classic problem in algorithms and data structures: "Rat and Mice" problem.

**Problem Statement**:

Suppose there is a maze represented as a rectangular grid. In this maze, there are rats and mice, each occupying a cell. Some cells in the maze contain food. The task is to find paths for the rats and mice to reach the food, ensuring that each rat reaches its respective food source, and each mouse reaches its respective food source. The goal is to minimize the time taken for all rats and mice to reach their food sources.

**Approach**:

1. **Modeling the Problem**: Represent the maze and its elements (rats, mice, food) using appropriate data structures like arrays or matrices.

2. **Graph Representation**: Model the maze as a graph, where each cell is a node, and there are edges between adjacent cells (up, down, left, right).

3. **Breadth-First Search (BFS)**: Use BFS to find the shortest paths from each rat and mouse to its respective food source.

4. **Path Reconstruction**: After running BFS, reconstruct the paths from each rat and mouse to its food source.

5. **Optimization**: You may need to optimize the algorithm if the maze is large or the number of rats/mice is significant. Techniques like memoization or dynamic programming can be applied.

**Implementation (C++)**:

Here's a basic implementation outline in C++:

```cpp
#include <iostream>
#include <queue>
#include <vector>
#include <utility>

using namespace std;

#define N 5 // Size of the maze, adjust as needed

// Define cell structure
struct Cell {
    int x, y;
};

// Function to check if a cell is valid
bool isValid(int x, int y) {
    return (x >= 0 && x < N && y >= 0 && y < N);
}

// Function to find shortest path using BFS
void findShortestPath(int maze[][N], Cell src, Cell dest) {
    vector<vector<bool>> visited(N, vector<bool>(N, false));
    vector<vector<Cell>> parent(N, vector<Cell>(N, {-1, -1}));
    queue<Cell> q;
    q.push(src);
    visited[src.x][src.y] = true;

    int dx[] = {-1, 0, 1, 0};
    int dy[] = {0, 1, 0, -1};
    
    while (!q.empty()) {
        Cell curr = q.front();
        q.pop();

        if (curr.x == dest.x && curr.y == dest.y) {
            // Destination reached, reconstruct path
            while (!(curr.x == src.x && curr.y == src.y)) {
                cout << "(" << curr.x << "," << curr.y << ") <- ";
                curr = parent[curr.x][curr.y];
            }
            cout << "(" << src.x << "," << src.y << ")\n";
            return;
        }

        for (int i = 0; i < 4; i++) {
            int nx = curr.x + dx[i];
            int ny = curr.y + dy[i];
            if (isValid(nx, ny) && maze[nx][ny] && !visited[nx][ny]) {
                visited[nx][ny] = true;
                parent[nx][ny] = curr;
                q.push({nx, ny});
            }
        }
    }
    cout << "No path found!\n";
}

int main() {
    // Example maze
    int maze[N][N] = {
        {1, 0, 1, 1, 1},
        {1, 1, 1, 0, 1},
        {0, 0, 1, 0, 1},
        {1, 1, 1, 1, 1},
        {1, 1, 1, 1, 0}
    };

    Cell ratSrc = {0, 0}; // Rat source cell
    Cell ratDest = {3, 4}; // Rat destination cell
    Cell mouseSrc = {2, 2}; // Mouse source cell
    Cell mouseDest = {4, 4}; // Mouse destination cell

    cout << "Path for rat:\n";
    findShortestPath(maze, ratSrc, ratDest);
    cout << "Path for mouse:\n";
    findShortestPath(maze, mouseSrc, mouseDest);

    return 0;
}
```

This code provides a basic framework for solving the problem. You can extend it further to handle multiple rats, mice, and food sources, as well as optimize it for larger mazes.

### 1. Algorithms & Data Structures (C++): Rat in a Maze

Implementing the Rat in a Maze problem is a classic example of using backtracking algorithms. In this problem, you're given a maze represented by a 2D grid, where 0s represent walls and 1s represent paths. The task is to find a path from the starting position (0, 0) to the destination (N-1, N-1), if one exists.

Here's a simple C++ implementation of the Rat in a Maze problem using backtracking:

```cpp
#include <iostream>
#include <vector>

using namespace std;

const int N = 5; // Size of the maze

// Function to check if cell (x, y) is valid to move
bool isValidMove(int maze[N][N], int x, int y) {
    // Check if (x, y) is within the maze and is a valid path
    return (x >= 0 && x < N && y >= 0 && y < N && maze[x][y] == 1);
}

// Function to solve the maze using backtracking
bool solveMazeUtil(int maze[N][N], int x, int y, vector<vector<int>>& sol) {
    // Base case: if (x, y) is the destination
    if (x == N - 1 && y == N - 1) {
        sol[x][y] = 1;
        return true;
    }

    // Check if (x, y) is a valid move
    if (isValidMove(maze, x, y)) {
        // Mark current cell as part of the solution path
        sol[x][y] = 1;

        // Move right
        if (solveMazeUtil(maze, x, y + 1, sol))
            return true;

        // Move down
        if (solveMazeUtil(maze, x + 1, y, sol))
            return true;

        // If moving right or down doesn't lead to the destination,
        // backtrack by marking current cell as not part of solution path
        sol[x][y] = 0;
        return false;
    }

    return false; // If (x, y) is not a valid move
}

// Function to solve the maze and print the solution path
void solveMaze(int maze[N][N]) {
    vector<vector<int>> sol(N, vector<int>(N, 0)); // Initialize solution matrix

    if (solveMazeUtil(maze, 0, 0, sol)) {
        // If a solution exists, print the solution path
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++)
                cout << sol[i][j] << " ";
            cout << endl;
        }
    } else {
        cout << "No solution exists!" << endl;
    }
}

int main() {
    int maze[N][N] = {
        {1, 0, 0, 0, 0},
        {1, 1, 0, 1, 0},
        {0, 1, 1, 1, 1},
        {0, 0, 0, 0, 1},
        {0, 0, 0, 0, 1}
    };

    solveMaze(maze);

    return 0;
}
```

This code will output the solution path if it exists, otherwise, it will print "No solution exists!". You can adjust the maze size (`N`) and the maze itself by modifying the `maze` array in the `main` function.

### 1. Algorithms & Data Structures (C++): Rat in Maze

Creating a program to solve the Rat in a Maze problem involves both algorithms and data structures. Here's a basic approach using C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

const int N = 5; // Size of the maze

// Function to print the solution matrix
void printSolution(vector<vector<int>>& sol) {
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++)
            cout << sol[i][j] << " ";
        cout << endl;
    }
}

// Function to check if x, y is valid index for N*N maze
bool isSafe(int maze[N][N], int x, int y) {
    // if (x, y outside maze) return false
    return (x >= 0 && x < N && y >= 0 && y < N && maze[x][y] == 1);
}

// Recursive function to solve Rat in Maze problem
bool solveMazeUtil(int maze[N][N], int x, int y, vector<vector<int>>& sol) {
    // if (x, y is goal) return true
    if (x == N - 1 && y == N - 1) {
        sol[x][y] = 1;
        return true;
    }

    // Check if maze[x][y] is valid
    if (isSafe(maze, x, y)) {
        // Mark x, y as part of solution path
        sol[x][y] = 1;

        // Move forward in x direction
        if (solveMazeUtil(maze, x + 1, y, sol)) return true;

        // If moving in x direction doesn't give solution then move down in y direction
        if (solveMazeUtil(maze, x, y + 1, sol)) return true;

        // If none of the above movements work then backtrack: unmark x, y as part of solution path
        sol[x][y] = 0;
        return false;
    }

    return false;
}

// Function to solve the Rat in a Maze problem
bool solveMaze(int maze[N][N]) {
    vector<vector<int>> sol(N, vector<int>(N, 0));

    if (!solveMazeUtil(maze, 0, 0, sol)) {
        cout << "Solution doesn't exist";
        return false;
    }

    printSolution(sol);
    return true;
}

int main() {
    int maze[N][N] = {
        {1, 0, 0, 0, 0},
        {1, 1, 0, 1, 0},
        {0, 1, 1, 1, 0},
        {0, 0, 0, 1, 0},
        {0, 0, 0, 1, 1}
    };

    solveMaze(maze);
    return 0;
}
```

This program finds a path through a maze from the starting point (0, 0) to the ending point (N-1, N-1). The algorithm uses backtracking to explore all possible paths until it finds the correct one. The `isSafe` function checks if the current position is valid to move, and `solveMazeUtil` is a recursive function that tries all possible movements. If a path is found, it prints the solution.

### 1. Algorithms & Data Structures (C++): Reconstruct itinerary

Reconstructing an itinerary from a list of flight tickets is a classic problem in computer science. The problem involves finding a sequence of flights that forms a valid itinerary, given a list of tickets with departure and arrival airports.

Here's a high-level approach to solving this problem using C++:

```cpp
#include <iostream>
#include <unordered_map>
#include <vector>
#include <string>
#include <algorithm>

using namespace std;

// Function to reconstruct the itinerary
vector<string> reconstructItinerary(unordered_map<string, vector<string>>& tickets, string start) {
    vector<string> itinerary;
    
    while (!tickets.empty()) {
        itinerary.push_back(start);
        auto& destinations = tickets[start];
        if (destinations.empty()) break; // No more flights from this airport
        string next_dest = destinations.front(); // Next destination
        destinations.erase(destinations.begin()); // Remove this flight from the list
        if (destinations.empty()) tickets.erase(start); // Remove the airport if no more flights from it
        start = next_dest; // Update the current airport
    }
    
    itinerary.push_back(start); // Add the last airport
    return itinerary;
}

int main() {
    unordered_map<string, vector<string>> tickets;
    // Populate the tickets map with flight information
    
    // Example flight tickets:
    tickets["JFK"] = {"SFO", "ATL"};
    tickets["SFO"] = {"ATL"};
    tickets["ATL"] = {"JFK", "SFO"};
    tickets["ORD"] = {"LAX"};

    string start = "JFK"; // Starting airport

    // Reconstruct the itinerary
    vector<string> itinerary = reconstructItinerary(tickets, start);

    // Print the reconstructed itinerary
    for (const auto& airport : itinerary) {
        cout << airport << " ";
    }
    cout << endl;

    return 0;
}
```

This code snippet demonstrates a simple implementation of the algorithm to reconstruct the itinerary. The `reconstructItinerary` function takes an unordered map `tickets` where keys are departure airports and values are vectors of arrival airports. It starts from the given `start` airport and iterates through each ticket, constructing the itinerary until no more flights are available.

You can extend this example by reading flight information from a file or a database, handling cases such as multiple valid itineraries, and so on, depending on your requirements.

### 1. Algorithms & Data Structures (C++): Remainders Game

The Remainders Game is a fascinating problem that involves concepts from number theory, specifically modular arithmetic. In this game, players take turns subtracting a divisor from a dividend, and the winner is the one who makes the dividend zero. The twist is that only the remainder of the division operation is subtracted.

Let's break down how you could approach implementing this game using C++:

1. **Define the game rules**:
    - Players take turns subtracting the remainder from a dividend until it becomes zero.
    - The remainder is calculated as `dividend % divisor`.

2. **Implement the game loop**:
    - Iterate while the dividend is greater than zero.
    - Prompt each player for their move (the remainder to subtract).
    - Update the dividend accordingly.
    - Alternate between players.

3. **Check for the winner**:
    - The player who reduces the dividend to zero wins the game.

Here's a simplified version of how you might implement this game in C++:

```cpp
#include <iostream>

int main() {
    int dividend, divisor;
    std::cout << "Enter dividend: ";
    std::cin >> dividend;
    std::cout << "Enter divisor: ";
    std::cin >> divisor;

    int player = 1; // Player 1 starts
    while (dividend > 0) {
        // Display current dividend
        std::cout << "Current dividend: " << dividend << std::endl;

        // Prompt player for remainder to subtract
        int remainder;
        std::cout << "Player " << player << ", enter remainder to subtract: ";
        std::cin >> remainder;

        // Update dividend
        dividend -= remainder;

        // Toggle player
        player = (player == 1) ? 2 : 1;
    }

    // The player who made the dividend zero wins
    std::cout << "Player " << ((player == 1) ? 2 : 1) << " wins!" << std::endl;

    return 0;
}
```

This is a basic implementation to get you started. Depending on your requirements, you might want to add error checking for invalid inputs, handle special cases, or even create a more sophisticated AI opponent.

### 1. Algorithms & Data Structures (C++): Remove Duplicates from Sorted Linked List

To remove duplicates from a sorted linked list in C++, you can use a simple algorithm that iterates through the list and removes any duplicate nodes. Here's a basic implementation:

```cpp
#include <iostream>

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

void deleteDuplicates(ListNode* head) {
    if (head == nullptr) return;

    ListNode* current = head;
    while (current->next != nullptr) {
        if (current->val == current->next->val) {
            ListNode* duplicate = current->next;
            current->next = duplicate->next;
            delete duplicate;
        } else {
            current = current->next;
        }
    }
}

void printList(ListNode* head) {
    while (head != nullptr) {
        std::cout << head->val << " ";
        head = head->next;
    }
    std::cout << std::endl;
}

int main() {
    // Example usage
    ListNode* head = new ListNode(1);
    head->next = new ListNode(1);
    head->next->next = new ListNode(2);
    head->next->next->next = new ListNode(3);
    head->next->next->next->next = new ListNode(3);

    std::cout << "Original List: ";
    printList(head);

    deleteDuplicates(head);

    std::cout << "List after removing duplicates: ";
    printList(head);

    // Clean up memory
    while (head != nullptr) {
        ListNode* temp = head;
        head = head->next;
        delete temp;
    }

    return 0;
}
```

This code defines a `ListNode` struct to represent each element in the linked list. The `deleteDuplicates` function removes duplicates from the sorted linked list by iterating through the list and removing any duplicate nodes. Finally, the `printList` function prints the elements of the linked list, and the `main` function demonstrates the usage of `deleteDuplicates` and `printList`.

### 1. Algorithms & Data Structures (C++): Remove duplicates: Complexity analysis

Removing duplicates from a data structure, such as an array or a linked list, is a common problem in computer science. Let's analyze the complexity of removing duplicates from an array in C++ using various approaches:

### Approach 1: Brute Force

One straightforward approach is to use nested loops to compare each element with every other element and remove duplicates when found. The complexity of this approach is O(n^2) where 'n' is the number of elements in the array. This is because for each element in the array, you may potentially have to compare it with every other element in the worst case.

```cpp
void removeDuplicates(int arr[], int& n) {
    for (int i = 0; i < n; ++i) {
        for (int j = i + 1; j < n; ) {
            if (arr[i] == arr[j]) {
                for (int k = j; k < n - 1; ++k) {
                    arr[k] = arr[k + 1];
                }
                --n;
            } else {
                ++j;
            }
        }
    }
}
```

### Approach 2: Sorting

Another approach involves sorting the array first and then removing adjacent duplicates. The time complexity of this approach is dominated by the sorting algorithm used. If we use an efficient sorting algorithm like QuickSort (average case O(n log n)), the overall time complexity would be O(n log n) for sorting and then O(n) for removing duplicates, resulting in O(n log n) overall time complexity.

```cpp
void removeDuplicates(int arr[], int& n) {
    std::sort(arr, arr + n);
    int j = 0;
    for (int i = 0; i < n; ++i) {
        if (arr[i] != arr[j]) {
            arr[++j] = arr[i];
        }
    }
    n = j + 1;
}
```

### Approach 3: Using Hashing

Using hashing, we can keep track of unique elements encountered so far. The time complexity of this approach is O(n) since insertion and lookup operations in a hash set (unordered_set in C++) are O(1) on average.

```cpp
#include <unordered_set>

void removeDuplicates(int arr[], int& n) {
    std::unordered_set<int> seen;
    int j = 0;
    for (int i = 0; i < n; ++i) {
        if (seen.find(arr[i]) == seen.end()) {
            seen.insert(arr[i]);
            arr[j++] = arr[i];
        }
    }
    n = j;
}
```

### Summary

- Brute Force: O(n^2)
- Sorting: O(n log n)
- Hashing: O(n)

Hashing provides the most efficient solution among these approaches when dealing with large datasets or when the order of elements does not matter.

### 1. Algorithms & Data Structures (C++): Removing Duplicates

Sure! Removing duplicates from a collection, such as an array or a linked list, is a common problem in programming. Here's how you can do it efficiently in C++ using various data structures and algorithms:

#### Using STL (Standard Template Library)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

void removeDuplicates(std::vector<int>& nums) {
    std::sort(nums.begin(), nums.end()); // Sort the vector
    nums.erase(std::unique(nums.begin(), nums.end()), nums.end()); // Remove duplicates
}

int main() {
    std::vector<int> nums = {1, 2, 3, 4, 2, 3, 5};
    removeDuplicates(nums);

    // Print the vector after removing duplicates
    for (int num : nums) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

#### Using Hash Set

```cpp
#include <iostream>
#include <unordered_set>
#include <vector>

void removeDuplicates(std::vector<int>& nums) {
    std::unordered_set<int> seen;
    std::vector<int> result;

    for (int num : nums) {
        if (seen.insert(num).second) {
            result.push_back(num);
        }
    }

    nums = result;
}

int main() {
    std::vector<int> nums = {1, 2, 3, 4, 2, 3, 5};
    removeDuplicates(nums);

    // Print the vector after removing duplicates
    for (int num : nums) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

Both approaches achieve the same result, removing duplicates from the input vector `nums`. The first method sorts the vector and then removes adjacent duplicates, while the second method uses a hash set to keep track of seen elements and removes duplicates as they are encountered. Choose the one that best suits your requirements based on the characteristics of your data and performance considerations.

### 1. Algorithms & Data Structures (C++): Removing Recursion With Stacks

Sure, removing recursion from algorithms and data structures is a common optimization technique, especially in cases where recursion might lead to stack overflow errors for large inputs. One way to remove recursion is by using an explicit stack data structure to mimic the call stack behavior of recursive algorithms. Here's how you can do it in C++:

Let's take an example of a recursive function to calculate the factorial of a number, and then convert it to an iterative version using a stack:

```cpp
#include <iostream>
#include <stack>

using namespace std;

// Recursive factorial function
int factorialRecursive(int n) {
    if (n == 0 || n == 1)
        return 1;
    else
        return n * factorialRecursive(n - 1);
}

// Iterative factorial function using stack
int factorialIterative(int n) {
    stack<int> s;
    s.push(n);
    int result = 1;
    while (!s.empty()) {
        int current = s.top();
        s.pop();
        if (current > 1) {
            result *= current;
            s.push(current - 1);
        }
    }
    return result;
}

int main() {
    int n = 5;
    cout << "Factorial of " << n << " (Recursive): " << factorialRecursive(n) << endl;
    cout << "Factorial of " << n << " (Iterative): " << factorialIterative(n) << endl;
    return 0;
}
```

In the `factorialIterative` function:

- We use a stack `s` to simulate the call stack.
- We push the input `n` onto the stack to start the iteration.
- Inside the loop, we pop the top element from the stack, calculate the factorial, and push the decremented value onto the stack if it's greater than 1.
- We repeat this process until the stack becomes empty.

This way, we achieve the same result as the recursive version but without using recursion. This technique is particularly useful when dealing with large inputs where recursion might cause stack overflow.

### 1. Algorithms & Data Structures (C++): Removing Tail Recursion

Removing tail recursion in algorithms and data structures, particularly in C++, often involves converting the recursive function into an iterative one. Tail recursion occurs when the recursive call is the last operation executed by the function. Here's a general approach to removing tail recursion:

1. **Identify Tail Recursion**: First, identify the recursive calls in the function. If the recursive call is the last operation before the function returns, it's tail recursion.

2. **Convert to Iterative**: To remove tail recursion, rewrite the recursive function as an iterative one. This usually involves using a loop construct, such as a while or for loop, to simulate the recursive behavior.

3. **Use Stack**: If necessary, you might need to use an explicit stack data structure to keep track of the state that would otherwise be maintained by the function call stack during recursion.

Here's an example of how you might convert a tail-recursive function to an iterative one:

```cpp
// Tail-recursive factorial function
int factorial(int n, int result = 1) {
    if (n == 0)
        return result;
    else
        return factorial(n - 1, n * result);
}

// Iterative version of factorial function
int factorial_iterative(int n) {
    int result = 1;
    for (int i = 1; i <= n; ++i) {
        result *= i;
    }
    return result;
}
```

In the above example, `factorial` is a tail-recursive function to calculate the factorial of a number `n`. We can remove tail recursion by rewriting it iteratively in `factorial_iterative`.

In some cases, you might need to use an explicit stack to handle recursion manually. For instance, in tree traversal algorithms, you might convert recursive depth-first search (DFS) to an iterative approach using a stack to keep track of nodes to visit.

Remember, while removing tail recursion can sometimes improve performance and avoid stack overflow errors, it may make the code less readable or maintainable. So, consider the trade-offs carefully, especially in terms of code clarity and complexity.

### 1. Algorithms & Data Structures (C++): Repeat and Missing

The problem of finding a missing and repeating number in an array is a classic interview question and can be solved using various approaches. Here's a solution using C++:

```cpp
#include <iostream>
#include <vector>
#include <cmath>

using namespace std;

void findRepeatAndMissing(const vector<int>& nums) {
    int n = nums.size();
    int sum = 0, squareSum = 0;
    for (int i = 0; i < n; ++i) {
        sum += nums[i];
        squareSum += nums[i] * nums[i];
    }
    int actualSum = (n * (n + 1)) / 2;
    int actualSquareSum = (n * (n + 1) * (2 * n + 1)) / 6;
    
    int diffSum = actualSum - sum;
    int diffSquareSum = actualSquareSum - squareSum;
    
    int repeat = (diffSquareSum - diffSum * diffSum) / (2 * diffSum);
    int missing = repeat + diffSum;
    
    cout << "Repeated number: " << repeat << endl;
    cout << "Missing number: " << missing << endl;
}

int main() {
    vector<int> nums = {4, 3, 6, 2, 1, 1}; // Example array
    findRepeatAndMissing(nums);
    return 0;
}
```

Explanation:

- We calculate the sum of the elements and the sum of squares of the elements of the array.
- Then, we find the actual sum and the actual sum of squares of the numbers from 1 to n.
- The difference between the actual sum and the sum of the array gives us the missing number, and the difference between the actual sum of squares and the sum of squares of the array gives us the square of the repeating number.
- With the sum and the square of the repeating number, we can solve for both the repeating and the missing numbers.

This solution has a time complexity of O(n) and requires only constant space.

### 1. Algorithms & Data Structures (C++): Reversing a given Number

Sure! Reversing a number involves taking a number and flipping its digits. Here's how you can do it in C++:

```cpp
#include <iostream>

int reverseNumber(int num) {
    int reversed = 0;
    while (num != 0) {
        int digit = num % 10;
        reversed = reversed * 10 + digit;
        num /= 10;
    }
    return reversed;
}

int main() {
    int num;
    std::cout << "Enter a number: ";
    std::cin >> num;

    int reversedNum = reverseNumber(num);
    std::cout << "Reversed number: " << reversedNum << std::endl;

    return 0;
}
```

Here, `reverseNumber` function takes an integer `num` as input and returns its reverse. Inside the function, we initialize `reversed` to 0. Then, in the while loop, we extract the last digit of `num` using `% 10`, add it to `reversed` after shifting `reversed` one place to the left (by multiplying by 10), and remove the last digit from `num` by integer division `/= 10`. We repeat this process until `num` becomes 0. Finally, we return the reversed number.

In the `main` function, we take the input number from the user, call `reverseNumber` to get the reversed number, and then print it out.

### 1. Algorithms & Data Structures (C++): Rotate Image

Rotating an image in C++ is a classic problem that can be efficiently solved using a few key algorithms and data structures. One common approach is to first transpose the matrix representing the image, followed by reversing each row to achieve the desired rotation.

Here's the implementation:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Function to transpose the matrix
void transpose(vector<vector<int>>& matrix) {
    int n = matrix.size();
    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            swap(matrix[i][j], matrix[j][i]);
        }
    }
}

// Function to reverse each row of the matrix
void reverseRows(vector<vector<int>>& matrix) {
    int n = matrix.size();
    for (int i = 0; i < n; i++) {
        int left = 0, right = n - 1;
        while (left < right) {
            swap(matrix[i][left], matrix[i][right]);
            left++;
            right--;
        }
    }
}

// Function to rotate the image by 90 degrees clockwise
void rotateImage(vector<vector<int>>& matrix) {
    // Transpose the matrix
    transpose(matrix);
    // Reverse each row
    reverseRows(matrix);
}

// Function to print the matrix
void printMatrix(const vector<vector<int>>& matrix) {
    for (const auto& row : matrix) {
        for (int element : row) {
            cout << element << " ";
        }
        cout << endl;
    }
}

int main() {
    vector<vector<int>> image = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    cout << "Original Image:" << endl;
    printMatrix(image);

    rotateImage(image);

    cout << "\nRotated Image:" << endl;
    printMatrix(image);

    return 0;
}
```

This code demonstrates how to rotate a 3x3 matrix (representing an image) by 90 degrees clockwise. You can modify the size of the matrix and its contents according to your requirements. The `transpose` function swaps elements across the main diagonal, effectively transposing the matrix. The `reverseRows` function reverses each row of the matrix. Finally, the `rotateImage` function combines these operations to achieve the desired rotation.

### 1. Algorithms & Data Structures (C++): Rotten Oranges

The Rotten Oranges problem is a classic problem in computer science and falls under the realm of algorithms and data structures, particularly graph traversal. Here's a brief overview of the problem and how you might solve it in C++:

### Problem Statement

Given a grid representing a box of oranges, where each cell in the grid can have one of three values:

- 0 representing an empty cell.
- 1 representing a fresh orange.
- 2 representing a rotten orange.

Every minute, any fresh orange that is adjacent (up, down, left, or right) to a rotten orange becomes rotten.

Determine the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.

### Approach

You can solve this problem using Breadth First Search (BFS) or Depth First Search (DFS). Here, BFS is more appropriate as it helps in finding the shortest path.

1. First, you'd scan the grid and identify all the rotten oranges and put their coordinates into a queue along with a marker (to denote the passage of time, you can use a pair of `(x, y, time)`).
2. Then, you'd perform a BFS traversal starting from each rotten orange, marking fresh oranges as rotten and adding them to the queue for the next iteration.
3. You keep track of the time taken for each orange to rot and return the maximum time among them.

### C++ Code Sketch

```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

int orangesRotting(vector<vector<int>>& grid) {
    int rows = grid.size();
    int cols = grid[0].size();
    int freshOranges = 0;
    queue<pair<int, int>> rottenOranges;

    // Count fresh oranges and add rotten oranges to the queue
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            if (grid[i][j] == 1)
                ++freshOranges;
            else if (grid[i][j] == 2)
                rottenOranges.push({i, j});
        }
    }

    int time = 0;
    vector<pair<int, int>> directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

    while (!rottenOranges.empty() && freshOranges > 0) {
        int size = rottenOranges.size();
        for (int i = 0; i < size; ++i) {
            auto [x, y] = rottenOranges.front();
            rottenOranges.pop();
            for (auto& dir : directions) {
                int nx = x + dir.first;
                int ny = y + dir.second;
                if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && grid[nx][ny] == 1) {
                    grid[nx][ny] = 2;
                    rottenOranges.push({nx, ny});
                    --freshOranges;
                }
            }
        }
        ++time;
    }

    return freshOranges == 0 ? time : -1;
}

int main() {
    // Example usage
    vector<vector<int>> grid = {{2,1,1},{1,1,0},{0,1,1}};
    cout << "Time taken: " << orangesRotting(grid) << endl;
    return 0;
}
```

This code outlines the basic structure and approach to solve the problem. You can adjust it according to the constraints and input specifications of the problem you're solving.

### 1. Algorithms & Data Structures (C++): Row Gcd

"Row GCD" sounds like a problem where you need to find the greatest common divisor (GCD) of elements in each row of a matrix. The task likely involves iterating through each row, computing the GCD of its elements, and then storing or utilizing the result in some way. Here's a basic outline of how you might approach implementing this in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// Function to calculate GCD of two numbers using Euclid's algorithm
int gcd(int a, int b) {
    if (b == 0)
        return a;
    return gcd(b, a % b);
}

// Function to find GCD of elements in a row
int rowGCD(const vector<int>& row) {
    int result = row[0];
    for (size_t i = 1; i < row.size(); ++i) {
        result = gcd(result, row[i]);
    }
    return result;
}

// Function to calculate row-wise GCDs of a matrix
vector<int> calculateRowGCDs(const vector<vector<int>>& matrix) {
    vector<int> rowGCDs;
    for (const auto& row : matrix) {
        rowGCDs.push_back(rowGCD(row));
    }
    return rowGCDs;
}

int main() {
    // Example usage
    vector<vector<int>> matrix = {{12, 18, 24}, {4, 8, 12}, {5, 10, 15}};

    vector<int> rowGCDs = calculateRowGCDs(matrix);

    cout << "Row-wise GCDs: ";
    for (int gcd : rowGCDs) {
        cout << gcd << " ";
    }
    cout << endl;

    return 0;
}
```

This code defines a function `rowGCD` to compute the GCD of elements in a single row, and another function `calculateRowGCDs` to find GCDs for each row in the matrix. Finally, the main function demonstrates how to use these functions with an example matrix and outputs the computed row-wise GCDs.

### 1. Algorithms & Data Structures (C++): Second Player

When it comes to algorithms and data structures in C++, the second player usually refers to the opponent in a game or competition scenario. In algorithms like minimax or alpha-beta pruning, the second player's moves are analyzed to make optimal decisions for the first player. Here's a brief overview of how these concepts tie into C++:

1. **Minimax Algorithm**: This is a decision rule used in game theory for minimizing the possible loss for a worst-case scenario. In a two-player game, the algorithm considers all possible moves that the opponent (second player) can make and selects the one that minimizes the maximum possible loss for the player (first player). In C++, you would typically implement this algorithm recursively, evaluating all possible moves and selecting the one that leads to the best outcome.

2. **Alpha-Beta Pruning**: This is an optimization technique for the minimax algorithm that reduces the number of nodes evaluated in the search tree. It maintains two values, alpha and beta, representing the minimum score the maximizing player (first player) is assured of and the maximum score the minimizing player (second player) is assured of respectively. The algorithm prunes branches that cannot possibly influence the final decision, thus reducing the number of nodes that need to be evaluated. In C++, you would implement this alongside the minimax algorithm to optimize the search process.

3. **Game Implementation**: To apply these algorithms in C++, you would typically start by representing the game state and defining the rules of the game. Then, you would implement functions to generate possible moves, evaluate the current state of the game, and apply the minimax algorithm with alpha-beta pruning to make optimal moves.

Here's a very basic example of how you might implement the minimax algorithm with alpha-beta pruning in C++:

```cpp
// Pseudocode for minimax with alpha-beta pruning

int minimax(State state, int depth, bool isMaximizingPlayer, int alpha, int beta) {
    if (depth == 0 || state.isGameOver()) {
        return evaluate(state);
    }

    if (isMaximizingPlayer) {
        int bestScore = INT_MIN;
        for (auto move : state.getValidMoves()) {
            State nextState = state.makeMove(move);
            int score = minimax(nextState, depth - 1, false, alpha, beta);
            bestScore = max(bestScore, score);
            alpha = max(alpha, bestScore);
            if (beta <= alpha)
                break; // Beta cutoff
        }
        return bestScore;
    } else {
        int bestScore = INT_MAX;
        for (auto move : state.getValidMoves()) {
            State nextState = state.makeMove(move);
            int score = minimax(nextState, depth - 1, true, alpha, beta);
            bestScore = min(bestScore, score);
            beta = min(beta, bestScore);
            if (beta <= alpha)
                break; // Alpha cutoff
        }
        return bestScore;
    }
}

// Entry point
int main() {
    State initialState; // Initialize the game state
    int bestMove = -1;
    int bestScore = INT_MIN;
    for (auto move : initialState.getValidMoves()) {
        State nextState = initialState.makeMove(move);
        int score = minimax(nextState, depth, false, INT_MIN, INT_MAX);
        if (score > bestScore) {
            bestScore = score;
            bestMove = move;
        }
    }
    // Perform bestMove
    return 0;
}
```

In this example, `State` represents the game state, and `makeMove` generates a new state after applying a move. `evaluate` function assigns a score to the current state. The minimax function recursively explores possible moves, while alpha-beta pruning helps to cut off unnecessary branches in the search tree. Finally, the main function calls minimax to find the best move to make.

### 1. Algorithms & Data Structures (C++): Segment Intersections

Segment intersection is a classic problem in computational geometry and algorithms. In C++, you can implement a solution using techniques like the sweep line algorithm or line intersection algorithms. Here's a basic approach using the sweep line algorithm:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// Structure to represent a point
struct Point {
    int x, y;
};

// Structure to represent a line segment
struct Segment {
    Point start, end;
};

// Function to check if two segments intersect
bool doIntersect(Segment s1, Segment s2) {
    // Find the orientation of triplet (p, q, r)
    auto orientation = [](Point p, Point q, Point r) {
        int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
        if (val == 0) return 0; // collinear
        return (val > 0) ? 1 : 2; // clock or counterclock wise
    };

    int o1 = orientation(s1.start, s1.end, s2.start);
    int o2 = orientation(s1.start, s1.end, s2.end);
    int o3 = orientation(s2.start, s2.end, s1.start);
    int o4 = orientation(s2.start, s2.end, s1.end);

    // General case
    if (o1 != o2 && o3 != o4)
        return true;

    // Special cases (collinear segments)
    if (o1 == 0 && isOnSegment(s1.start, s2.start, s1.end)) return true;
    if (o2 == 0 && isOnSegment(s1.start, s2.end, s1.end)) return true;
    if (o3 == 0 && isOnSegment(s2.start, s1.start, s2.end)) return true;
    if (o4 == 0 && isOnSegment(s2.start, s1.end, s2.end)) return true;

    return false;
}

// Function to check if a point lies on a segment
bool isOnSegment(Point p, Point q, Point r) {
    if (q.x <= max(p.x, r.x) && q.x >= min(p.x, r.x) &&
        q.y <= max(p.y, r.y) && q.y >= min(p.y, r.y))
        return true;
    return false;
}

int main() {
    // Example segments
    Segment s1 = {{1, 1}, {10, 1}};
    Segment s2 = {{1, 2}, {10, 2}};
    Segment s3 = {{10, 0}, {0, 10}};
    Segment s4 = {{0, 0}, {10, 10}};

    if (doIntersect(s1, s2))
        cout << "Segments s1 and s2 intersect\n";
    else
        cout << "Segments s1 and s2 don't intersect\n";

    if (doIntersect(s3, s4))
        cout << "Segments s3 and s4 intersect\n";
    else
        cout << "Segments s3 and s4 don't intersect\n";

    return 0;
}
```

This code defines structures for Points and Segments and provides functions to check if two segments intersect or if a point lies on a segment. You can test it with different sets of segments by creating instances of Segment and passing them to the `doIntersect` function.

### 1. Algorithms & Data Structures (C++): Shortest common supersequence (problem)

The Shortest Common Supersequence (SCS) problem is a classic problem in computer science, especially in the realm of algorithms and data structures. The problem can be defined as follows:

Given two strings, find the shortest string that has both strings as subsequences.

In other words, given two strings \( X \) and \( Y \), we want to find the shortest string \( Z \) such that both \( X \) and \( Y \) are subsequences of \( Z \). Here's a more formal definition:

Let \( X[1..m] \) and \( Y[1..n] \) be two strings. A supersequence of \( X \) and \( Y \) is a string \( Z[1..l] \) such that both \( X \) and \( Y \) are subsequences of \( Z \). The shortest common supersequence (SCS) of \( X \) and \( Y \) is the supersequence of minimum length.

For example:

- If \( X = \text{"ABCBDAB"} \) and \( Y = \text{"BDCAB"} \), then an SCS could be \( \text{"ABDCABDAB"} \).
- If \( X = \text{"ABC"} \) and \( Y = \text{"ACB"} \), then an SCS could be \( \text{"ACB"} \).

One common approach to solve this problem is using dynamic programming. We can define a table \( dp \) where \( dp[i][j] \) represents the length of the shortest common supersequence of the substrings \( X[0..i-1] \) and \( Y[0..j-1] \). We can fill this table iteratively and then backtrack to reconstruct the actual supersequence.

Here's a sample C++ code implementing this approach:

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

string shortestCommonSupersequence(string X, string Y) {
    int m = X.size();
    int n = Y.size();
    
    // Initialize the DP table
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

    // Fill the DP table
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (X[i - 1] == Y[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    // Backtrack to construct the supersequence
    int i = m, j = n;
    string result;
    while (i > 0 && j > 0) {
        if (X[i - 1] == Y[j - 1]) {
            result = X[i - 1] + result;
            i--;
            j--;
        } else if (dp[i - 1][j] > dp[i][j - 1]) {
            result = X[i - 1] + result;
            i--;
        } else {
            result = Y[j - 1] + result;
            j--;
        }
    }

    while (i > 0) {
        result = X[i - 1] + result;
        i--;
    }

    while (j > 0) {
        result = Y[j - 1] + result;
        j--;
    }

    return result;
}

int main() {
    string X = "ABCBDAB";
    string Y = "BDCAB";
    cout << "Shortest Common Supersequence: " << shortestCommonSupersequence(X, Y) << endl;
    return 0;
}
```

This code demonstrates how to find the shortest common supersequence of two strings using dynamic programming in C++.

### 1. Algorithms & Data Structures (C++): Shortest common supersequence (solution)

To find the shortest common supersequence (SCS) of two strings using dynamic programming in C++, you can follow this approach:

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

string shortestCommonSupersequence(const string& str1, const string& str2) {
    int m = str1.length();
    int n = str2.length();

    // Create a 2D vector to store the lengths of SCS for substrings of str1 and str2
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

    // Fill the dp table
    for (int i = 0; i <= m; ++i) {
        for (int j = 0; j <= n; ++j) {
            if (i == 0 || j == 0)
                dp[i][j] = i + j;
            else if (str1[i - 1] == str2[j - 1])
                dp[i][j] = dp[i - 1][j - 1] + 1;
            else
                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1]);
        }
    }

    // Construct the shortest common supersequence
    int i = m, j = n;
    string result = "";
    while (i > 0 && j > 0) {
        if (str1[i - 1] == str2[j - 1]) {
            result = str1[i - 1] + result;
            --i;
            --j;
        } else if (dp[i - 1][j] < dp[i][j - 1]) {
            result = str1[i - 1] + result;
            --i;
        } else {
            result = str2[j - 1] + result;
            --j;
        }
    }

    while (i > 0) {
        result = str1[i - 1] + result;
        --i;
    }

    while (j > 0) {
        result = str2[j - 1] + result;
        --j;
    }

    return result;
}

int main() {
    string str1 = "AGGTAB";
    string str2 = "GXTXAYB";
    cout << "Shortest Common Supersequence: " << shortestCommonSupersequence(str1, str2) << endl;
    return 0;
}
```

This code defines a function `shortestCommonSupersequence` that takes two input strings `str1` and `str2` and returns their shortest common supersequence. The function utilizes dynamic programming to calculate the lengths of SCS for substrings of `str1` and `str2`, and then constructs the SCS string based on the calculated lengths. Finally, in the `main` function, an example is provided to demonstrate the usage of this function.

### 1. Algorithms & Data Structures (C++): Simplify Path

The Simplify Path problem typically involves simplifying a Unix-style file path. Given a string representing an absolute file path, you need to simplify it to the canonical path. Here's a step-by-step approach in C++:

1. Tokenize the input string using the delimiter '/'.
2. Traverse through the tokens, maintaining a stack.
3. For each token:
   - If it is '..', pop the top element from the stack if the stack is not empty.
   - If it is '.' or an empty string, ignore it.
   - Otherwise, push the token onto the stack.
4. After traversing all tokens, construct the simplified path using elements in the stack.

Here's the C++ implementation:

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <sstream>

std::string simplifyPath(const std::string& path) {
    std::stringstream ss(path);
    std::vector<std::string> tokens;
    std::string token;
    
    // Tokenize the input path
    while (std::getline(ss, token, '/')) {
        if (token == "" || token == ".")
            continue;
        if (token == "..") {
            if (!tokens.empty())
                tokens.pop_back();
        } else {
            tokens.push_back(token);
        }
    }
    
    // Construct the simplified path
    std::string simplified_path;
    for (const auto& t : tokens)
        simplified_path += "/" + t;
    
    return simplified_path.empty() ? "/" : simplified_path;
}

int main() {
    std::string path1 = "/home/";
    std::string path2 = "/../";
    std::string path3 = "/home//foo/";
    std::string path4 = "/a/./b/../../c/";
    
    std::cout << simplifyPath(path1) << std::endl; // Output: "/home"
    std::cout << simplifyPath(path2) << std::endl; // Output: "/"
    std::cout << simplifyPath(path3) << std::endl; // Output: "/home/foo"
    std::cout << simplifyPath(path4) << std::endl; // Output: "/c"
    
    return 0;
}
```

This code demonstrates the simplification of different paths and prints the simplified paths to the console.

### 1. Algorithms & Data Structures (C++): Single Number

The problem of finding a single number in an array where every element appears twice except for one element (which appears only once) is a classic problem that can be efficiently solved using bitwise XOR (^) operation. Here's how you can implement it in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int singleNumber(vector<int>& nums) {
    int result = 0;
    for (int num : nums) {
        result ^= num; // XOR operation
    }
    return result;
}

int main() {
    // Example usage:
    vector<int> nums = {4, 1, 2, 1, 2};
    cout << "The single number is: " << singleNumber(nums) << endl;
    return 0;
}
```

Explanation:

- XOR of a number with itself is 0. So, when you XOR all the elements in the array, the elements that appear twice will cancel each other out, leaving only the single number.
- The time complexity of this solution is O(n), where n is the number of elements in the array.

Feel free to ask if you have any questions or need further clarification!

### 1. Algorithms & Data Structures (C++): Single Number - Sorting

Certainly! The "Single Number" problem is a classic problem in computer science. The problem statement typically goes like this: Given an array of integers, where every element appears twice except for one, find that single one.

One of the simple and effective approaches to solve this problem involves sorting the array and then iterating through it to find the single number. Here's how you can implement it in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int singleNumber(std::vector<int>& nums) {
    // Sort the array
    std::sort(nums.begin(), nums.end());
    
    // Iterate through the sorted array
    for (int i = 0; i < nums.size(); i += 2) {
        // If the current element doesn't have a pair
        if (i + 1 >= nums.size() || nums[i] != nums[i + 1]) {
            // This is the single number
            return nums[i];
        }
    }
    
    // Return -1 if no single number is found (this won't happen if the input is valid)
    return -1;
}

int main() {
    // Example usage
    std::vector<int> nums = {4, 1, 2, 1, 2}; // Expected output: 4
    std::cout << "Single number is: " << singleNumber(nums) << std::endl;
    return 0;
}
```

This solution works by sorting the array, which brings all the duplicate elements together. Then, it iterates through the sorted array and checks for elements that don't have a pair (i.e., elements at even indices), returning the first one found.

However, note that this solution has a time complexity of O(n log n) due to the sorting step, where n is the number of elements in the array. If you need a linear time solution, there are other approaches such as using hash tables or bitwise operations, but sorting provides a simple and understandable solution.

### 1. Algorithms & Data Structures (C++): Skyline

The skyline problem is a classic algorithmic problem in computer science that deals with representing the silhouette formed by buildings in a city skyline. Given a set of buildings each defined by their starting point, ending point, and height, the task is to find the outline of the buildings when viewed from a distance, considering the visible portions and their heights.

Here's a high-level approach to solving the skyline problem using the divide and conquer technique:

1. **Divide**: Divide the given set of buildings into two approximately equal halves.

2. **Conquer**: Recursively solve the skyline problem for each half.

3. **Merge**: Merge the results obtained from the two halves to determine the final skyline.

To implement this in C++, you can use the following approach:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct Building {
    int left;
    int right;
    int height;
};

vector<pair<int, int>> mergeSkylines(vector<pair<int, int>>& skyline1, vector<pair<int, int>>& skyline2) {
    vector<pair<int, int>> mergedSkyline;
    int h1 = 0, h2 = 0;
    int i = 0, j = 0;

    while (i < skyline1.size() && j < skyline2.size()) {
        if (skyline1[i].first < skyline2[j].first) {
            h1 = skyline1[i].second;
            int x = skyline1[i].first;
            int h = max(h1, h2);
            mergedSkyline.push_back({x, h});
            i++;
        } else {
            h2 = skyline2[j].second;
            int x = skyline2[j].first;
            int h = max(h1, h2);
            mergedSkyline.push_back({x, h});
            j++;
        }
    }

    while (i < skyline1.size()) {
        mergedSkyline.push_back(skyline1[i++]);
    }

    while (j < skyline2.size()) {
        mergedSkyline.push_back(skyline2[j++]);
    }

    return mergedSkyline;
}

vector<pair<int, int>> findSkyline(vector

<pair<int, int>>& buildings, int left, int right) {
    if (left == right) {
        vector<pair<int, int>> skyline;
        skyline.push_back({buildings[left].left, buildings[left].height});
        skyline.push_back({buildings[left].right, 0});
        return skyline;
    }

    int mid = left + (right - left) / 2;
    vector<pair<int, int>> skyline1 = findSkyline(buildings, left, mid);
    vector<pair<int, int>> skyline2 = findSkyline(buildings, mid + 1, right);
    return mergeSkylines(skyline1, skyline2);
}

vector<pair<int, int>> getSkyline(vector

<pair<int, int>>& buildings) {
    if (buildings.empty()) {
        return {};
    }
    return findSkyline(buildings, 0, buildings.size() - 1);
}

int main() {
    // Example usage
    vector



```cpp
    <Building> buildings = {
        {1, 3, 3},
        {2, 4, 4},
        {5, 6, 1},
        {7, 8, 5}
    };

    vector<pair<int, int>> skyline = getSkyline(buildings);

    cout << "Skyline: " << endl;
    for (const auto& point : skyline) {
        cout << "(" << point.first << ", " << point.second << ") ";
    }
    cout << endl;

    return 0;
}
```

This code defines a set of buildings with their left coordinate, right coordinate, and height. It then calculates the skyline for these buildings using the divide and conquer approach and prints the resulting skyline.

### 1. Algorithms & Data Structures (C++): Smallest number after removing k digits

To find the smallest number after removing k digits from a given number, you can use a stack-based approach. Here's how you can implement it in C++:

```cpp
#include <iostream>
#include <stack>
#include <string>

std::string removeKDigits(std::string num, int k) {
    std::stack<char> st;
    // Iterate through each digit of the number
    for (char digit : num) {
        // Remove digits from the stack as long as the current digit is smaller
        // and there are still remaining digits to remove (k > 0)
        while (!st.empty() && k > 0 && st.top() > digit) {
            st.pop();
            k--;
        }
        // Push the current digit onto the stack
        st.push(digit);
    }
    // Pop the remaining digits if k is not yet zero
    while (k > 0 && !st.empty()) {
        st.pop();
        k--;
    }
    // Construct the result from the stack
    std::string result;
    while (!st.empty()) {
        result = st.top() + result;
        st.pop();
    }
    // Remove leading zeros
    size_t nonZeroIndex = result.find_first_not_of('0');
    if (nonZeroIndex != std::string::npos) {
        return result.substr(nonZeroIndex);
    }
    return "0"; // Return "0" if all digits were removed
}

int main() {
    std::string num = "1432219";
    int k = 3;
    std::cout << "Original number: " << num << std::endl;
    std::cout << "Number after removing " << k << " digits: " << removeKDigits(num, k) << std::endl;
    return 0;
}
```

In this code:

- We use a stack to keep track of digits while iterating through the number.
- We remove digits from the stack as long as the current digit is smaller and there are still remaining digits to remove.
- After processing all digits, if there are remaining digits to remove (k > 0), we pop them from the stack.
- Finally, we construct the result string from the stack while removing leading zeros.
- The `removeKDigits` function takes the original number and the number of digits to remove (k) as input and returns the smallest number after removing k digits.

### 1. Algorithms & Data Structures (C++): Smallest number after removing k digits: Complexity analysis

To analyze the complexity of finding the smallest number after removing k digits from a given number, let's outline the approach:

1. **Convert the number to a string**: Since we need to manipulate individual digits, converting the number to a string makes it easier to remove digits.

2. **Iteratively remove digits**: We'll iterate through the string and remove digits to create different combinations. We can use techniques like a stack to efficiently remove digits while maintaining the order.

3. **Find the smallest number**: After removing k digits, we'll need to find the smallest number among all the combinations generated.

Here's a rough algorithm:

```cpp
string removeKDigits(string num, int k) {
    stack<char> stk;
    for (char &c : num) {
        while (!stk.empty() && k > 0 && stk.top() > c) {
            stk.pop();
            k--;
        }
        stk.push(c);
    }
    
    // Remove remaining k digits from the end
    while (k > 0 && !stk.empty()) {
        stk.pop();
        k--;
    }
    
    // Build the result string
    string result = "";
    while (!stk.empty()) {
        result = stk.top() + result;
        stk.pop();
    }
    
    // Remove leading zeros
    int pos = 0;
    while (pos < result.size() && result[pos] == '0') {
        pos++;
    }
    result = result.substr(pos);
    
    // If the result is empty, return "0"
    return result.empty() ? "0" : result;
}
```

Now, let's analyze the complexity:

- **Converting the number to a string**: This operation takes O(n) time, where n is the number of digits in the input number.

- **Iteratively removing digits using a stack**: This step also takes O(n) time. Although it appears to be nested loops, it actually runs in linear time because each digit is pushed and popped from the stack at most once.

- **Building the result string**: Constructing the result string takes O(n) time since we iterate through the stack, which contains at most n elements.

- **Removing leading zeros**: This step takes O(n) time since it involves iterating through the result string, which has at most n characters.

Overall, the time complexity of the algorithm is O(n), where n is the number of digits in the input number. This is because all the steps involved in the algorithm are linear in the number of digits. Therefore, the algorithm's complexity is efficient and suitable for practical use cases.

### 1. Algorithms & Data Structures (C++): Smallest Range Covering Elements from K Lists

The problem of finding the smallest range covering elements from K lists is commonly known as the "Smallest Range Covering Elements from K Lists" problem. This problem can be efficiently solved using a data structure called a min-heap. Here's how you can approach it in C++:

```cpp
#include <vector>
#include <queue>
#include <limits>
#include <iostream>

using namespace std;

// Custom comparator for min-heap
struct Compare {
    bool operator()(const pair<int, pair<int, int>>& a, const pair<int, pair<int, int>>& b) const {
        return a.first > b.first;
    }
};

vector<int> smallestRange(vector<vector<int>>& nums) {
    int k = nums.size();
    priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, Compare> minHeap;

    int maxNum = numeric_limits<int>::min();
    // Initialize the heap with the first element of each list and keep track of the maximum number
    for (int i = 0; i < k; ++i) {
        minHeap.push({nums[i][0], {i, 0}});
        maxNum = max(maxNum, nums[i][0]);
    }

    int rangeStart = -1, rangeEnd = -1, minRange = numeric_limits<int>::max();

    // Loop until one of the lists is exhausted
    while (minHeap.size() == k) {
        auto current = minHeap.top();
        minHeap.pop();
        int num = current.first;
        int listIndex = current.second.first;
        int index = current.second.second;

        // Update the range if it's smaller
        if (maxNum - num < minRange) {
            minRange = maxNum - num;
            rangeStart = num;
            rangeEnd = maxNum;
        }

        // Move to the next element in the list
        if (index + 1 < nums[listIndex].size()) {
            int nextNum = nums[listIndex][index + 1];
            maxNum = max(maxNum, nextNum);
            minHeap.push({nextNum, {listIndex, index + 1}});
        }
    }

    return {rangeStart, rangeEnd};
}

int main() {
    vector<vector<int>> nums = {
        {4, 10, 15, 24, 26},
        {0, 9, 12, 20},
        {5, 18, 22, 30}
    };

    vector<int> result = smallestRange(nums);
    cout << "Smallest range covering elements from K lists: [" << result[0] << ", " << result[1] << "]" << endl;

    return 0;
}
```

This code defines a custom comparator for a min-heap, creates a min-heap of pairs `(number, (listIndex, index))` where `number` is the current element, `listIndex` is the index of the list, and `index` is the index of the element within that list. It then iterates through the heap, updating the range if a smaller range is found, and pushes the next element from the list into the heap. Finally, it returns the smallest range found.

### 1. Algorithms & Data Structures (C++): Smart Keypad

A smart keypad is a concept that involves designing a system to efficiently generate all possible words or combinations of words that can be formed by pressing keys on a phone keypad. Each digit on a phone keypad corresponds to a set of letters, similar to the letters associated with the numbers on a traditional telephone keypad.

For example, consider the standard phone keypad layout:

```
1:     2: ABC  3: DEF
4: GHI  5: JKL  6: MNO
7: PQRS 8: TUV  9: WXYZ
```

Given a sequence of digits, the task is to generate all possible words that can be formed by pressing those digits. This problem is often solved using recursive backtracking or dynamic programming.

Here's a high-level outline of how you might approach implementing this in C++:

1. **Define the mapping**: Create a mapping of digits to the corresponding set of letters.

```cpp
std::vector<std::string> keypad = {
    "",     // 0
    "",     // 1
    "ABC",  // 2
    "DEF",  // 3
    "GHI",  // 4
    "JKL",  // 5
    "MNO",  // 6
    "PQRS", // 7
    "TUV",  // 8
    "WXYZ"  // 9
};
```

1. **Generate words recursively**: Write a recursive function to generate all possible combinations of letters for a given sequence of digits.

```cpp
void generateWordsUtil(const std::vector<std::string>& keypad, const std::string& digits, int current_digit, std::string& result, std::vector<std::string>& output) {
    if (current_digit == digits.length()) {
        output.push_back(result);
        return;
    }

    int digit = digits[current_digit] - '0';
    for (char letter : keypad[digit]) {
        result.push_back(letter);
        generateWordsUtil(keypad, digits, current_digit + 1, result, output);
        result.pop_back();
    }
}
```

1. **Wrap the recursive function**: Create a wrapper function to handle the input and call the recursive function.

```cpp
std::vector<std::string> generateWords(const std::vector<std::string>& keypad, const std::string& digits) {
    std::vector<std::string> output;
    if (digits.empty()) return output;

    std::string result;
    generateWordsUtil(keypad, digits, 0, result, output);
    return output;
}
```

1. **Test the implementation**: Write test cases to verify that the implementation works correctly.

```cpp
int main() {
    std::vector<std::string> result = generateWords(keypad, "23");
    for (const auto& word : result) {
        std::cout << word << std::endl;
    }
    return 0;
}
```

This is a basic implementation to get you started. Depending on your requirements, you might need to add additional features such as handling invalid input, optimizing performance, or supporting additional functionalities.

### 1. Algorithms & Data Structures (C++): Snakes & Ladders

Implementing the Snakes and Ladders game in C++ involves a combination of data structures and algorithms. Here's a basic outline of how you can approach it:

1. **Design the Board**: You'll need to design the board layout, either as a 1D array, 2D array, or a custom data structure. Each cell on the board represents a position where a player can be.

2. **Define the Snakes and Ladders**: You need to decide where the snakes and ladders are on the board. This could be done through another data structure like a map or an array that stores the start and end positions of each snake and ladder.

3. **Player Movement**: Implement the logic for player movement. This involves rolling a dice (random number generation) and moving the player accordingly. Ensure that you handle cases where the player lands on a ladder or a snake.

4. **Game Loop**: You'll need a game loop that continues until one of the players reaches the end position.

5. **Winning Condition**: Check if a player has reached the end position and declare the winner.

Here's a simple implementation to get you started:

```cpp
#include <iostream>
#include <vector>
#include <cstdlib> // for rand() and srand()
#include <ctime>   // for time()

using namespace std;

// Define the board size
const int BOARD_SIZE = 100;

// Define the positions of snakes and ladders
vector<pair<int, int>> snakes = {{16, 6}, {47, 26}, {49, 11}, {56, 53}, {62, 19}, {64, 60}, {87, 24}, {93, 73}, {95, 75}, {98, 78}};
vector<pair<int, int>> ladders = {{1, 38}, {4, 14}, {9, 31}, {21, 42}, {28, 84}, {36, 44}, {51, 67}, {71, 91}, {80, 100}};

// Function to roll the dice
int rollDice() {
    return rand() % 6 + 1;
}

// Function to check if a player has won
bool hasWon(int position) {
    return position >= BOARD_SIZE;
}

// Function to move the player
int movePlayer(int currentPosition, int diceRoll) {
    int newPosition = currentPosition + diceRoll;
    
    // Check if newPosition lands on a snake
    for (auto snake : snakes) {
        if (snake.first == newPosition) {
            newPosition = snake.second;
            break;
        }
    }
    
    // Check if newPosition lands on a ladder
    for (auto ladder : ladders) {
        if (ladder.first == newPosition) {
            newPosition = ladder.second;
            break;
        }
    }
    
    return newPosition;
}

int main() {
    // Initialize random seed
    srand(time(0));
    
    // Initialize player positions
    int player1Position = 0, player2Position = 0;
    
    // Game loop
    while (true) {
        // Player 1's turn
        int diceRoll = rollDice();
        player1Position = movePlayer(player1Position, diceRoll);
        cout << "Player 1 rolled a " << diceRoll << " and is now at position " << player1Position << endl;
        if (hasWon(player1Position)) {
            cout << "Player 1 wins!" << endl;
            break;
        }
        
        // Player 2's turn
        diceRoll = rollDice();
        player2Position = movePlayer(player2Position, diceRoll);
        cout << "Player 2 rolled a " << diceRoll << " and is now at position " << player2Position << endl;
        if (hasWon(player2Position)) {
            cout << "Player 2 wins!" << endl;
            break;
        }
    }
    
    return 0;
}
```

This is a basic implementation. You can expand it by adding features like multiple players, customizable board sizes, a GUI interface, etc., depending on your requirements.

### 1. Algorithms & Data Structures (C++): Snakes & Ladders Game

Creating a Snakes and Ladders game involves a mix of algorithms and data structures, primarily focused on representing the game board, managing player movements, and handling the logic for snakes and ladders. Here's a basic implementation in C++ using object-oriented programming:

```cpp
#include <iostream>
#include <map>
#include <vector>
#include <cstdlib>
#include <ctime>

using namespace std;

class SnakesAndLadders {
private:
    map<int, int> snakes;
    map<int, int> ladders;
    int boardSize;
    int currentPlayerPosition;
public:
    SnakesAndLadders(int size) : boardSize(size), currentPlayerPosition(1) {}

    void addSnake(int head, int tail) {
        snakes[head] = tail;
    }

    void addLadder(int start, int end) {
        ladders[start] = end;
    }

    void rollDice() {
        int diceRoll = rand() % 6 + 1;
        cout << "You rolled a " << diceRoll << ". ";

        currentPlayerPosition += diceRoll;

        if (currentPlayerPosition > boardSize) {
            cout << "You need " << (currentPlayerPosition - boardSize) << " to win." << endl;
            return;
        }

        cout << "You are now at position " << currentPlayerPosition << ". ";

        if (snakes.count(currentPlayerPosition)) {
            cout << "Oops! You landed on a snake. Go down to position " << snakes[currentPlayerPosition] << "." << endl;
            currentPlayerPosition = snakes[currentPlayerPosition];
        }
        else if (ladders.count(currentPlayerPosition)) {
            cout << "Hooray! You landed on a ladder. Climb up to position " << ladders[currentPlayerPosition] << "." << endl;
            currentPlayerPosition = ladders[currentPlayerPosition];
        }
        else {
            cout << "Nothing special happened." << endl;
        }

        if (currentPlayerPosition == boardSize) {
            cout << "Congratulations! You won!" << endl;
            return;
        }
    }
};

int main() {
    srand(time(NULL)); // Seed for random number generation

    SnakesAndLadders game(100); // Board size 100

    // Add some snakes
    game.addSnake(16, 6);
    game.addSnake(47, 26);
    game.addSnake(49, 11);
    game.addSnake(56, 53);
    game.addSnake(62, 19);
    game.addSnake(64, 60);
    game.addSnake(87, 24);
    game.addSnake(93, 73);
    game.addSnake(95, 75);
    game.addSnake(98, 78);

    // Add some ladders
    game.addLadder(1, 38);
    game.addLadder(4, 14);
    game.addLadder(9, 31);
    game.addLadder(21, 42);
    game.addLadder(28, 84);
    game.addLadder(36, 44);
    game.addLadder(51, 67);
    game.addLadder(71, 91);
    game.addLadder(80, 100);

    cout << "Welcome to Snakes and Ladders!" << endl;

    while (true) {
        cout << "Press Enter to roll the dice...";
        cin.get(); // Wait for user to press Enter
        game.rollDice();
    }

    return 0;
}
```

In this code:

- The `SnakesAndLadders` class represents the game itself. It has methods to add snakes and ladders, roll the dice, and handle player movements.
- Snakes and ladders are represented using `map<int, int>`, where the key is the head/start position, and the value is the tail/end position.
- The `rollDice` method simulates rolling a dice, moves the player accordingly, and handles snake and ladder interactions.
- In the `main` function, we create an instance of the `SnakesAndLadders` class, add some snakes and ladders, and then enter a loop where the player can roll the dice until they win.

You can customize the board size, the number and positions of snakes and ladders, and add more features as needed.

### 1. Algorithms & Data Structures (C++): Solvability of 15 Puzzles

The 15 puzzle problem is a classic problem in the field of algorithms and data structures, often used to demonstrate search algorithms and techniques like A* search. The puzzle consists of a 4x4 grid with 15 tiles numbered from 1 to 15, and one blank space. The objective is to move the tiles around to arrange them in numerical order, starting from some initial configuration.

Determining whether a given configuration of the 15 puzzle is solvable can be done using concepts from permutation theory. One common approach is to count the number of inversions in the initial state. An inversion occurs when a tile precedes another tile with a lower number but comes after it in the solved configuration.

Here's how you can determine the solvability of a given configuration:

1. Count the number of inversions in the initial state.
2. If the grid width (number of columns) is odd, a solvable configuration is one where the number of inversions is even.
3. If the grid width is even, a solvable configuration is one where:
   - The sum of the number of inversions and the row number of the blank space (starting from the bottom, counting rows from 1) is odd.

Here's a sample C++ code to determine the solvability of a 15 puzzle configuration:

```cpp
#include <iostream>
#include <vector>

int countInversions(const std::vector<int>& puzzle) {
    int inversions = 0;
    int size = puzzle.size();
    for (int i = 0; i < size - 1; ++i) {
        for (int j = i + 1; j < size; ++j) {
            if (puzzle[i] > puzzle[j] && puzzle[j] != 0) {
                ++inversions;
            }
        }
    }
    return inversions;
}

bool isSolvable(const std::vector<int>& puzzle) {
    int inversions = countInversions(puzzle);
    int blankIndex = 0;
    int size = puzzle.size();
    // Find the row number of the blank space
    for (int i = 0; i < size; ++i) {
        if (puzzle[i] == 0) {
            blankIndex = size - i;
            break;
        }
    }
    if (size % 2 == 1) {
        return inversions % 2 == 0;
    } else {
        return (inversions + blankIndex) % 2 == 1;
    }
}

int main() {
    std::vector<int> puzzle = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0};
    if (isSolvable(puzzle)) {
        std::cout << "Puzzle is solvable.\n";
    } else {
        std::cout << "Puzzle is not solvable.\n";
    }
    return 0;
}
```

This code first counts the number of inversions in the puzzle, then determines solvability based on the rules mentioned above.

### 1. Algorithms & Data Structures (C++): Sorted Permutations

Sorted permutations can be generated efficiently using algorithms such as the next_permutation function in C++. Here's a basic approach to generating sorted permutations:

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

void sortedPermutations(vector<int>& nums) {
    sort(nums.begin(), nums.end()); // Sort the vector initially
    do {
        // Print the current permutation
        for (int num : nums) {
            cout << num << " ";
        }
        cout << endl;
    } while (next_permutation(nums.begin(), nums.end())); // Generate next permutation until no more exists
}

int main() {
    vector<int> nums = {1, 2, 3};
    sortedPermutations(nums);
    return 0;
}
```

In this code:

- We first sort the vector of numbers to ensure that the permutations are generated in sorted order.
- Then, we use a do-while loop along with the `next_permutation` function to generate and print permutations until no more permutations are possible.

The `next_permutation` function returns true if there exists a next permutation, and false otherwise. It rearranges the elements in the range `[first, last)` into the next lexicographically greater permutation.

This approach guarantees sorted permutations and is efficient, as it avoids generating all permutations upfront and then sorting them. Instead, it generates permutations on-the-fly in sorted order.

### 1. Algorithms & Data Structures (C++): Square matrix of ones (problem)

Sure, here's a problem statement for creating a square matrix of ones using C++:

### Problem Statement

Given a positive integer `n`, write a C++ function to generate an `n x n` square matrix filled with ones.

### Function Signature

```cpp
std::vector<std::vector<int>> generateOnesMatrix(int n);
```

### Input

- An integer `n` where `1 <= n <= 100`.

### Output

- A 2D vector representing the `n x n` square matrix filled with ones.

### Example

#### Input

```cpp
int n = 3;
```

#### Output

```cpp
{{1, 1, 1},
 {1, 1, 1},
 {1, 1, 1}}
```

### Note

- The input `n` represents the number of rows and columns in the square matrix.
- Each cell of the matrix should contain the value `1`.

Now, you can implement the `generateOnesMatrix` function in C++ to solve this problem.

### 1. Algorithms & Data Structures (C++): Square matrix of ones (solution)

To create a square matrix filled with ones in C++, you can use a nested loop to iterate over each row and column and assign a value of 1 to each element. Here's a simple example:

```cpp
#include <iostream>
#include <vector>

// Function to create a square matrix of ones
std::vector<std::vector<int>> createSquareMatrix(int n) {
    std::vector<std::vector<int>> matrix(n, std::vector<int>(n, 1));
    return matrix;
}

// Function to print the matrix
void printMatrix(const std::vector<std::vector<int>>& matrix) {
    for (const auto& row : matrix) {
        for (int element : row) {
            std::cout << element << " ";
        }
        std::cout << std::endl;
    }
}

int main() {
    int n;
    std::cout << "Enter the size of the square matrix: ";
    std::cin >> n;

    // Create the square matrix
    std::vector<std::vector<int>> squareMatrix = createSquareMatrix(n);

    // Print the square matrix
    std::cout << "Square Matrix of Ones:" << std::endl;
    printMatrix(squareMatrix);

    return 0;
}
```

This code defines a function `createSquareMatrix` that takes an integer `n` as input, creates a 2D vector of size `n x n`, and initializes all elements to 1. The `printMatrix` function is used to print the matrix. In the `main` function, the user is prompted to enter the size of the square matrix, and then the matrix is created and printed.

### 1. Algorithms & Data Structures (C++): Stair Game

The Stair Game is a simple yet interesting algorithmic problem that involves two players taking turns to climb stairs. The stairs have a certain number of steps, and on each turn, a player can choose to climb either one or two steps. The player who reaches the top of the stairs first wins the game.

Here's a simple implementation of the Stair Game in C++:

```cpp
#include <iostream>

using namespace std;

// Function to determine the winner of the Stair Game
string stairGameWinner(int n) {
    // If the number of steps is divisible by 3, second player wins
    if (n % 3 == 0) {
        return "Second Player";
    } else {
        return "First Player";
    }
}

int main() {
    int steps;
    cout << "Enter the number of steps in the stairs: ";
    cin >> steps;

    string winner = stairGameWinner(steps);
    cout << "The winner of the Stair Game is: " << winner << endl;

    return 0;
}
```

In this implementation, we determine the winner based on whether the total number of steps is divisible by 3 or not. If it's divisible by 3, the second player wins; otherwise, the first player wins.

This is a simple version of the problem. More complex versions may involve dynamic programming to optimize the solution, especially when the number of steps is large.

### 1. Algorithms & Data Structures (C++): Staircase Problem

The staircase problem is a classic algorithmic problem often used to teach recursion and dynamic programming. The problem statement typically goes like this: Given a staircase with `n` steps, you can climb either 1 or 2 steps at a time. Count the number of ways to reach the top.

Here's a C++ implementation using dynamic programming:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int countWays(int n) {
    // Base cases
    if (n == 0 || n == 1)
        return 1;

    // Create a table to store results of subproblems
    vector<int> dp(n + 1, 0);

    // Initialize base cases
    dp[0] = 1;
    dp[1] = 1;

    // Fill dp[] in bottom-up manner
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }

    return dp[n];
}

int main() {
    int n;
    cout << "Enter the number of steps in the staircase: ";
    cin >> n;
    cout << "Number of ways to reach the top: " << countWays(n) << endl;
    return 0;
}
```

This implementation uses dynamic programming to avoid redundant computations and efficiently calculates the number of ways to reach the top of the staircase.

### 1. Algorithms & Data Structures (C++): Stock Span Problem

The stock span problem is a classic problem in computer science and is often used to demonstrate the application of stack data structures. In this problem, you're given an array of stock prices for consecutive days, and you need to find the span of each stock's price, where the span is defined as the maximum number of consecutive days (including the current day) for which the price of the stock on the current day is less than or equal to its price on all those consecutive days.

Here's a C++ implementation of the stock span problem using a stack:

```cpp
#include <iostream>
#include <stack>
#include <vector>

using namespace std;

vector<int> calculateSpan(const vector<int>& prices) {
    vector<int> spans(prices.size(), 1); // Initialize spans with 1 as the minimum span for any stock

    stack<int> st; // Stack to store indices of prices

    for (int i = 0; i < prices.size(); ++i) {
        // Pop elements from the stack while the current price is greater than or equal to prices[top]
        while (!st.empty() && prices[i] >= prices[st.top()]) {
            st.pop();
        }

        // If the stack is empty, span is i+1, else it's i - stack top index
        spans[i] = st.empty() ? (i + 1) : (i - st.top());

        // Push the current index onto the stack
        st.push(i);
    }

    return spans;
}

int main() {
    vector<int> prices = {100, 80, 60, 70, 60, 75, 85};
    vector<int> spans = calculateSpan(prices);

    cout << "Stock Prices: ";
    for (int price : prices) {
        cout << price << " ";
    }
    cout << endl;

    cout << "Spans: ";
    for (int span : spans) {
        cout << span << " ";
    }
    cout << endl;

    return 0;
}
```

In this implementation, we iterate through the prices array and use a stack to keep track of the indices of the previous stock prices. We keep popping from the stack while the current price is greater than or equal to the price corresponding to the index at the top of the stack. Once we find a price smaller than the current price, we calculate the span for the current day and push its index onto the stack.

This implementation has a time complexity of O(n), where n is the number of stock prices. This is because each element is pushed and popped from the stack at most once.

### 1. Algorithms & Data Structures (C++): Stones

Sure, let's talk about an interesting problem involving algorithms and data structures related to stones. One classic problem is often referred to as the "Stone Game" or "Nim Game." The problem goes like this:

#### Nim Game

Suppose there are \( n \) piles of stones, each containing a certain number of stones. Two players take turns, and in each turn, a player chooses one pile and removes any number of stones (at least one) from that pile. The player who removes the last stone wins.

For example, if we have three piles with 3, 4, and 5 stones, respectively, a valid move could be to remove 2 stones from the second pile. The game continues until one player takes the last stone, making them the winner.

The key to solving Nim games efficiently is understanding the game's winning strategy. Nim games are well-studied in game theory, and there's a simple algorithm to determine whether a given position is winning or losing. This algorithm relies on the concept of "Nim sum."

#### Nim Sum

The Nim sum of a position is calculated by XOR-ing the number of stones in each pile. For example, in the position with piles of size 3, 4, and 5, the Nim sum is \( 3 \oplus 4 \oplus 5 = 2 \).

#### Winning Strategy

If the Nim sum of a position is zero, then the position is losing because no matter what move the player makes, the opponent can always make a move to ensure that the Nim sum remains zero, eventually leading to the opponent's victory.

Conversely, if the Nim sum is non-zero, then the position is winning because the current player can make a move that alters the Nim sum to become zero, ensuring their victory.

#### Implementation in C++

Here's a simple implementation of the Nim game in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int calculateNimSum(const vector<int>& piles) {
    int nimSum = 0;
    for (int pile : piles) {
        nimSum ^= pile;
    }
    return nimSum;
}

bool canWin(const vector<int>& piles) {
    int nimSum = calculateNimSum(piles);
    return nimSum != 0;
}

int main() {
    vector<int> piles = {3, 4, 5};
    if (canWin(piles)) {
        cout << "You can win the Nim game!" << endl;
    } else {
        cout << "You cannot win the Nim game." << endl;
    }
    return 0;
}
```

This program determines if you can win the Nim game with a given set of piles. You can modify the `piles` vector to represent different initial positions.

### 1. Algorithms & Data Structures (C++): Strange Function

Sure, let's discuss the "Strange Function" problem. The problem typically goes like this:

#### Problem Statement

You are given a positive integer \( n \). You need to compute the following function:

\[ f(n) = \sum_{i=1}^{n} \left\lfloor \frac{n}{i} \right\rfloor \]

where \( \lfloor x \rfloor \) represents the greatest integer less than or equal to \( x \).

You need to find the value of \( f(n) \) modulo \( 10^9 + 7 \).

#### Explanation

This problem can be solved efficiently using mathematical properties. The key observation here is that the function \( f(n) \) essentially counts the occurrence of each number from 1 to \( n \) as a divisor in all numbers from 1 to \( n \).

For example, let's take \( n = 6 \):

- For \( i = 1 \), \( \left\lfloor \frac{6}{1} \right\rfloor = 6 \), so 6 occurs once in the sum.
- For \( i = 2 \), \( \left\lfloor \frac{6}{2} \right\rfloor = 3 \), so 3 occurs twice in the sum.
- For \( i = 3 \), \( \left\lfloor \frac{6}{3} \right\rfloor = 2 \), so 2 occurs twice in the sum.
- For \( i = 4, 5, 6 \), \( \left\lfloor \frac{6}{4} \right\rfloor = 1 \), \( \left\lfloor \frac{6}{5} \right\rfloor = 1 \), \( \left\lfloor \frac{6}{6} \right\rfloor = 1 \), so each of 1, 5, and 6 occurs once in the sum.

So, \( f(6) = 1 \times 6 + 2 \times 3 + 3 \times 2 + 1 \times 1 + 1 \times 1 + 1 \times 1 = 24 \).

#### Algorithm

1. For each divisor \( i \) from 1 to \( n \), calculate how many multiples of \( i \) are there in the range 1 to \( n \). This can be done by computing \( \left\lfloor \frac{n}{i} \right\rfloor \).
2. Sum up all these occurrences.

#### Complexity

The time complexity of this approach is \( O(n \log n) \) because you iterate through all numbers from 1 to \( n \), and for each number, you compute the sum of its multiples up to \( n \).

Would you like to see a code implementation of this algorithm in C++?

### 1. Algorithms & Data Structures (C++): Subsums

"Subsums" is a classic problem in computer science that deals with finding the number of subarrays of an array that sum up to a given value. This problem can be efficiently solved using dynamic programming or other techniques.

Here's a basic outline of how you could solve the "Subsums" problem in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// Function to count the number of subarrays with sum equal to target
int countSubarrays(vector<int>& arr, int target) {
    int n = arr.size();
    int count = 0;

    // Initialize a vector to store the prefix sums
    vector<int> prefixSums(n + 1, 0);

    // Compute the prefix sums
    for (int i = 1; i <= n; ++i) {
        prefixSums[i] = prefixSums[i - 1] + arr[i - 1];
    }

    // Loop through each subarray and check if its sum equals the target
    for (int i = 0; i < n; ++i) {
        for (int j = i + 1; j <= n; ++j) {
            if (prefixSums[j] - prefixSums[i] == target) {
                ++count;
            }
        }
    }

    return count;
}

int main() {
    int n, target;
    cin >> n >> target;

    vector<int> arr(n);
    for (int i = 0; i < n; ++i) {
        cin >> arr[i];
    }

    cout << countSubarrays(arr, target) << endl;

    return 0;
}
```

In this code:

1. We define a function `countSubarrays` that takes a vector `arr` and an integer `target` as input and returns the count of subarrays with sum equal to `target`.
2. Within `countSubarrays`, we first compute the prefix sums of the array elements and store them in the `prefixSums` vector.
3. Then, we iterate over all possible subarrays using two nested loops and check if the sum of the subarray equals the target. If it does, we increment the `count`.
4. Finally, we return the `count` as the result.

You can use this code by providing the array size `n`, the target sum, and the elements of the array as input.

### 1. Algorithms & Data Structures (C++): Sudoku

Implementing Sudoku in C++ involves using various algorithms and data structures. Here's a high-level overview of how you can approach it:

1. **Data Structure for Sudoku Board**:
   Represent the Sudoku grid using a 2D array or a vector of vectors. Each cell in the grid will hold either the value of the cell (if filled) or a placeholder for empty cells.

2. **Algorithm for Solving Sudoku**:
   There are several algorithms for solving Sudoku puzzles. One of the most common is the backtracking algorithm. Here's how it works:
   - Start with an empty Sudoku grid.
   - Try placing a number (from 1 to 9) in an empty cell.
   - Check if the number violates any Sudoku rules (no repetition of numbers in rows, columns, or subgrids).
   - If the number doesn't violate the rules, move to the next empty cell and repeat the process.
   - If you reach a dead-end (no valid number can be placed in the current cell), backtrack to the previous cell and try a different number.
   - Repeat this process until the entire grid is filled.

3. **Algorithm for Generating Sudoku Puzzles**:
   Generating Sudoku puzzles involves creating a filled Sudoku grid and then selectively removing numbers to create the puzzle. You can use various techniques, such as:
   - Starting with a solved Sudoku grid and removing numbers randomly while ensuring that the puzzle remains solvable.
   - Generating a completely filled Sudoku grid using backtracking and then randomly removing numbers.

4. **Additional Techniques**:
   - You may need to implement functions to check whether a particular number can be placed in a specific cell without violating Sudoku rules.
   - Implement functions for checking the validity of a partially filled Sudoku grid.
   - Include functions for printing the Sudoku grid to the console or any other output.

Here's a simplified example of what the code might look like:

```cpp
#include <iostream>
#include <vector>

using namespace std;

const int N = 9; // Size of the Sudoku grid

// Function to print the Sudoku grid
void printGrid(const vector<vector<int>>& grid) {
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N; ++j) {
            cout << grid[i][j] << " ";
        }
        cout << endl;
    }
}

// Function to solve Sudoku using backtracking
bool solveSudoku(vector<vector<int>>& grid) {
    // Find an empty cell
    int row = -1, col = -1;
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N; ++j) {
            if (grid[i][j] == 0) {
                row = i;
                col = j;
                break;
            }
        }
        if (row != -1) break;
    }
    // If no empty cell found, Sudoku is solved
    if (row == -1) return true;
    
    // Try placing numbers 1 to 9 in the empty cell
    for (int num = 1; num <= 9; ++num) {
        // Check if placing num in the current cell is valid
        // (i.e., it doesn't violate Sudoku rules)
        bool valid = true;
        // Check row
        for (int i = 0; i < N; ++i) {
            if (grid[row][i] == num) {
                valid = false;
                break;
            }
        }
        // Check column
        for (int i = 0; i < N; ++i) {
            if (grid[i][col] == num) {
                valid = false;
                break;
            }
        }
        // Check subgrid
        int startRow = row - row % 3;
        int startCol = col - col % 3;
        for (int i = startRow; i < startRow + 3; ++i) {
            for (int j = startCol; j < startCol + 3; ++j) {
                if (grid[i][j] == num) {
                    valid = false;
                    break;
                }
            }
            if (!valid) break;
        }
        // If placing num is valid, place it and try to solve the rest
        if (valid) {
            grid[row][col] = num;
            if (solveSudoku(grid)) return true;
            // If unable to solve with this num, backtrack
            grid[row][col] = 0;
        }
    }
    // If no number can be placed, backtrack
    return false;
}

int main() {
    // Example Sudoku grid (0 represents empty cells)
    vector<vector<int>> sudokuGrid = {
        {5, 3, 0, 0, 7, 0, 0, 0, 0},
        {6, 0, 0, 1, 9, 5, 0, 0, 0},
        {0, 9, 8, 0, 0, 0, 0, 6, 0},
        {8, 0, 0, 0, 6, 0, 0, 0, 3},
        {4, 0, 0, 8, 0, 3, 0, 0, 1},
        {7, 0, 0, 0, 2, 0, 0, 0, 6},
        {0, 6, 0, 0, 0, 0, 2, 8, 0},
        {0, 0, 0, 4, 1, 9, 0, 0, 5},
        {0, 0, 0, 0, 8, 0, 0, 7, 9}
    };

    cout << "Sudoku grid before solving:" << endl;
    printGrid(sudokuGrid);

    if (solveSudoku(sudokuGrid)) {
        cout << "\nSudoku grid after solving:" << endl;
        printGrid(sudokuGrid);
    } else {
        cout << "\nNo solution exists." << endl;
    }

    return 0;
}
```

This code provides a basic implementation of solving Sudoku using backtracking. You can further extend it to include functionality for generating Sudoku puzzles and additional optimizations for solving Sudoku efficiently.

### 1. Algorithms & Data Structures (C++): Sudoku Solver

Sure, I can provide you with a basic outline of how you might approach solving Sudoku using C++ and some common algorithms and data structures. Here's a simplified version:

#### 1. Representation of Sudoku Board

You can represent the Sudoku board as a 2D array. Each cell of the array will hold a number from 1 to 9, or 0 if the cell is empty.

```cpp
const int N = 9;
int board[N][N];
```

#### 2. Backtracking Algorithm

Backtracking is a common technique for solving constraint satisfaction problems like Sudoku.

Here's a basic outline of the backtracking algorithm:

- Find an empty cell.
- Try placing a number (1 to 9) in that cell.
- Check if the number violates any Sudoku rules (no duplicate numbers in row, column, or 3x3 box).
- If it doesn't violate the rules, recursively solve the remaining empty cells.
- If no number works, backtrack and try a different number.

#### 3. Helper Functions

You'll need some helper functions to check if a number is valid in a particular cell, to find an empty cell, and to print the board.

```cpp
bool isValid(int row, int col, int num);
bool findEmptyCell(int &row, int &col);
void printBoard();
```

#### 4. Implementation of Solver

```cpp
bool solveSudoku() {
    int row, col;
    
    // If there are no empty cells, Sudoku is solved
    if (!findEmptyCell(row, col))
        return true; // Sudoku solved
    
    // Try placing numbers from 1 to 9
    for (int num = 1; num <= 9; num++) {
        if (isValid(row, col, num)) {
            board[row][col] = num; // Place number
            if (solveSudoku()) // Recursively solve the remaining Sudoku
                return true;
            board[row][col] = 0; // If solution is not possible, backtrack
        }
    }
    return false; // Backtrack
}
```

#### 5. Helper Functions Implementation

```cpp
bool isValid(int row, int col, int num) {
    // Check if num is already in the same row or column
    for (int i = 0; i < N; i++) {
        if (board[row][i] == num || board[i][col] == num)
            return false;
    }
    // Check if num is already in the 3x3 box
    int startRow = row - row % 3;
    int startCol = col - col % 3;
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            if (board[i + startRow][j + startCol] == num)
                return false;
        }
    }
    return true;
}

bool findEmptyCell(int &row, int &col) {
    for (row = 0; row < N; row++) {
        for (col = 0; col < N; col++) {
            if (board[row][col] == 0)
                return true; // Found an empty cell
        }
    }
    return false; // No empty cells left
}

void printBoard() {
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            cout << board[i][j] << " ";
        }
        cout << endl;
    }
}
```

#### 6. Main Function

In the `main` function, you can input the initial Sudoku board, call the `solveSudoku` function, and then print the solved Sudoku board.

This is just a basic outline of how you could implement a Sudoku solver in C++. There are optimizations and improvements that can be made, such as using bit manipulation for faster checking of validity, optimizing the backtracking algorithm, and implementing techniques like constraint propagation and guessing.

### 1. Algorithms & Data Structures (C++): Sum lists

Sure! The "Sum Lists" problem is a classic algorithmic problem often encountered in technical interviews. The problem statement usually goes like this:

Given two numbers represented by two linked lists, where each node contains a single digit and the digits are stored in reverse order (i.e., the ones digit is at the head), write a function that adds the two numbers and returns the sum as a linked list.

For example:

```bash
Input: (7 -> 1 -> 6) + (5 -> 9 -> 2) => 617 + 295
Output: 2 -> 1 -> 9 => 912
```

Here's a sample implementation of this problem in C++:

```cpp
#include <iostream>

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    ListNode dummy(0); // Dummy head node to simplify logic
    ListNode *current = &dummy;
    int carry = 0;
    
    while (l1 != nullptr || l2 != nullptr || carry != 0) {
        int sum = carry;
        if (l1 != nullptr) {
            sum += l1->val;
            l1 = l1->next;
        }
        if (l2 != nullptr) {
            sum += l2->val;
            l2 = l2->next;
        }
        carry = sum / 10;
        current->next = new ListNode(sum % 10);
        current = current->next;
    }
    
    return dummy.next;
}

// Utility function to print a linked list
void printList(ListNode* head) {
    while (head != nullptr) {
        std::cout << head->val << " ";
        head = head->next;
    }
    std::cout << std::endl;
}

int main() {
    // Example usage
    ListNode* l1 = new ListNode(7);
    l1->next = new ListNode(1);
    l1->next->next = new ListNode(6);
    
    ListNode* l2 = new ListNode(5);
    l2->next = new ListNode(9);
    l2->next->next = new ListNode(2);
    
    std::cout << "Input: ";
    printList(l1);
    std::cout << "+ ";
    printList(l2);
    
    ListNode* sum = addTwoNumbers(l1, l2);
    
    std::cout << "Output: ";
    printList(sum);
    
    // Freeing memory
    while (l1 != nullptr) {
        ListNode* temp = l1;
        l1 = l1->next;
        delete temp;
    }
    while (l2 != nullptr) {
        ListNode* temp = l2;
        l2 = l2->next;
        delete temp;
    }
    while (sum != nullptr) {
        ListNode* temp = sum;
        sum = sum->next;
        delete temp;
    }
    
    return 0;
}
```

This code defines a `ListNode` struct representing a node in the linked list and a function `addTwoNumbers` to perform the addition. The `printList` function is just a utility to print the linked list. Finally, in the `main` function, you can see an example usage of how to create linked lists and call the `addTwoNumbers` function.

### 1. Algorithms & Data Structures (C++): Sum Of Digits

Sure, let's implement a C++ function to calculate the sum of digits of a given integer. Here's a simple implementation:

```cpp
#include <iostream>

int sumOfDigits(int num) {
    int sum = 0;
    
    // Iterate through each digit of the number
    while (num != 0) {
        // Extract the last digit
        int digit = num % 10;
        
        // Add the digit to the sum
        sum += digit;
        
        // Remove the last digit from the number
        num /= 10;
    }
    
    return sum;
}

int main() {
    int number;
    std::cout << "Enter an integer: ";
    std::cin >> number;
    
    // Calculate the sum of digits
    int sum = sumOfDigits(number);
    
    std::cout << "Sum of digits: " << sum << std::endl;
    
    return 0;
}
```

This program defines a function `sumOfDigits` that takes an integer `num` as input and returns the sum of its digits. Then in the `main` function, it takes an integer as input from the user, calculates the sum of its digits using `sumOfDigits`, and prints the result.

### 1. Algorithms & Data Structures (C++): Sushi

Creating a sushi-themed algorithm or data structure sounds like a fun challenge! How about we design a "Sushi Queue" using C++? It could be a variation of a standard queue, with each element representing a type of sushi. Here's a simple implementation:

```cpp
#include <iostream>
#include <queue>
#include <string>

using namespace std;

// Define a struct for Sushi
struct Sushi {
    string name;
    float price;
};

// Define a SushiQueue class
class SushiQueue {
private:
    queue<Sushi> sushiQueue;

public:
    // Method to add sushi to the queue
    void enqueue(const Sushi& sushi) {
        sushiQueue.push(sushi);
    }

    // Method to remove sushi from the queue
    Sushi dequeue() {
        if (sushiQueue.empty()) {
            cerr << "Queue is empty!" << endl;
            // Returning a default sushi in case of empty queue
            return {"Empty", 0.0};
        }
        Sushi frontSushi = sushiQueue.front();
        sushiQueue.pop();
        return frontSushi;
    }

    // Method to check if the queue is empty
    bool isEmpty() {
        return sushiQueue.empty();
    }

    // Method to get the size of the queue
    int size() {
        return sushiQueue.size();
    }
};

int main() {
    // Create a SushiQueue
    SushiQueue sushiQueue;

    // Adding some sushi to the queue
    sushiQueue.enqueue({"Salmon Roll", 8.99});
    sushiQueue.enqueue({"Tuna Nigiri", 5.49});
    sushiQueue.enqueue({"California Roll", 7.99});

    // Dequeue and print sushi until the queue is empty
    while (!sushiQueue.isEmpty()) {
        Sushi currentSushi = sushiQueue.dequeue();
        cout << "Serving: " << currentSushi.name << " ($" << currentSushi.price << ")" << endl;
    }

    return 0;
}
```

In this implementation, `Sushi` is a simple struct representing a type of sushi with a name and price. The `SushiQueue` class utilizes a `std::queue` internally to manage the sushi items. You can enqueue new sushi items, dequeue them, check if the queue is empty, and get its size. In the `main()` function, we demonstrate how to use the `SushiQueue` by adding some sushi items, then serving them in FIFO (First In, First Out) order.

### 1. Algorithms & Data Structures (C++): Take Away Games

Take Away Games, also known as Subtraction Games, are mathematical games where players take turns subtracting a certain number of items from a pile. The goal is typically to force your opponent to take the last item. This concept can be applied in various forms, such as Nim, Wythoff's game, and others.

In C++, you can implement a simple Take Away Game using basic data structures and algorithms. Here's a basic example of a two-player Take Away Game:

```cpp
#include <iostream>

// Function to play the game
void playGame(int initialItems) {
    int currentItem = initialItems;
    bool player1Turn = true;

    while (currentItem > 0) {
        std::cout << "Current items: " << currentItem << std::endl;
        
        // Alternate players
        if (player1Turn)
            std::cout << "Player 1's turn. ";
        else
            std::cout << "Player 2's turn. ";

        int toRemove;
        std::cout << "Enter the number of items to remove (1 or 2): ";
        std::cin >> toRemove;

        // Validate input
        if (toRemove != 1 && toRemove != 2) {
            std::cout << "Invalid input. Please enter 1 or 2." << std::endl;
            continue;
        }

        // Remove items
        currentItem -= toRemove;

        // Check if the game is over
        if (currentItem <= 0) {
            if (player1Turn)
                std::cout << "Player 2 wins!" << std::endl;
            else
                std::cout << "Player 1 wins!" << std::endl;
        }

        // Switch player
        player1Turn = !player1Turn;
    }
}

int main() {
    int initialItems;
    std::cout << "Enter the initial number of items in the pile: ";
    std::cin >> initialItems;

    playGame(initialItems);

    return 0;
}
```

This code sets up a simple two-player Take Away Game where players take turns removing 1 or 2 items from the pile until there are no items left. You can extend and modify this code to implement more complex variations of Take Away Games or add additional features like AI opponents.

### 1. Algorithms & Data Structures (C++): Target Sum

The "Target Sum" problem involves finding all pairs of numbers in an array that sum up to a given target value. Here's how you can solve it efficiently using C++:

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>

using namespace std;

vector<pair<int, int>> findPairsWithTargetSum(vector<int>& nums, int target) {
    vector<pair<int, int>> result;
    unordered_map<int, int> numToIndex;

    for (int i = 0; i < nums.size(); ++i) {
        int complement = target - nums[i];
        if (numToIndex.find(complement) != numToIndex.end()) {
            result.push_back({numToIndex[complement], i});
        }
        numToIndex[nums[i]] = i;
    }

    return result;
}

int main() {
    vector<int> nums = {2, 7, 11, 15};
    int target = 9;

    vector<pair<int, int>> pairs = findPairsWithTargetSum(nums, target);

    if (pairs.empty()) {
        cout << "No pairs found." << endl;
    } else {
        cout << "Pairs found:" << endl;
        for (auto& pair : pairs) {
            cout << nums[pair.first] << " + " << nums[pair.second] << " = " << target << endl;
        }
    }

    return 0;
}
```

Explanation:

- We use an unordered map `numToIndex` to store the mapping of each number to its index in the array.
- We iterate through the array. For each number `nums[i]`, we calculate its complement `target - nums[i]`.
- If the complement exists in the map, it means we've found a pair that sums up to the target. We add this pair to the result.
- Otherwise, we store the current number and its index in the map.
- Finally, we return the result containing all pairs.

This solution has a time complexity of O(n) since it only requires a single pass through the array, and a space complexity of O(n) due to the unordered map.

### 1. Algorithms & Data Structures (C++): Target Sum - Dynamic Programming

To solve the Target Sum problem using dynamic programming in C++, you can use a similar approach to the subset sum problem. The idea is to build a 2D array `dp`, where `dp[i][j]` represents the number of ways to achieve a sum of `j` using the first `i` elements of the array. Here's a sample implementation:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int findTargetSumWays(vector<int>& nums, int S) {
    int sum = 0;
    for (int num : nums) sum += num;

    // If the total sum of the array is smaller than the target S
    // or if the combined sum of the array and S is odd, it's impossible to find a subset with sum S
    if (sum < S || (sum + S) % 2 != 0) return 0;

    int target = (sum + S) / 2;
    int n = nums.size();

    vector<vector<int>> dp(n + 1, vector<int>(target + 1, 0));
    
    // Base case: one way to achieve a sum of 0, i.e., not selecting any element
    dp[0][0] = 1;

    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j <= target; ++j) {
            // If the current number can be included
            if (nums[i - 1] <= j) {
                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]];
            } else { // If the current number cannot be included
                dp[i][j] = dp[i - 1][j];
            }
        }
    }

    return dp[n][target];
}

int main() {
    vector<int> nums = {1, 1, 2, 3};
    int S = 1;
    cout << "Number of ways to achieve the target sum: " << findTargetSumWays(nums, S) << endl;
    return 0;
}
```

In this implementation, we iterate through each number in the array and for each number, we update the `dp` array. Finally, `dp[n][target]` will give us the number of ways to achieve the target sum `S`.

### 1. Algorithms & Data Structures (C++): Task: Common Keys

Sure! The task "Common Keys" typically involves finding common elements between two data structures, such as arrays, sets, or maps, in the context of C++. Here's a general approach using different data structures:

#### Approach 1: Using Hash Set

You can iterate through one of the collections and store its elements in a hash set. Then, iterate through the second collection and check if each element exists in the hash set. This approach has an average time complexity of O(n), where n is the size of the larger collection.

```cpp
#include <iostream>
#include <unordered_set>
#include <vector>

std::vector<int> findCommon(const std::vector<int>& arr1, const std::vector<int>& arr2) {
    std::unordered_set<int> hashSet;
    std::vector<int> result;

    // Insert elements of arr1 into hash set
    for (int num : arr1) {
        hashSet.insert(num);
    }

    // Check elements of arr2 in hash set
    for (int num : arr2) {
        if (hashSet.find(num) != hashSet.end()) {
            result.push_back(num);
        }
    }

    return result;
}

int main() {
    std::vector<int> arr1 = {1, 2, 3, 4, 5};
    std::vector<int> arr2 = {3, 4, 5, 6, 7};

    std::vector<int> common = findCommon(arr1, arr2);

    std::cout << "Common elements: ";
    for (int num : common) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

#### Approach 2: Sorting and Two Pointers

If the input collections are sorted, you can use a two-pointer approach to iterate through both collections simultaneously and identify common elements. This approach has a time complexity of O(n log n) due to sorting and O(n) for finding common elements.

#### Approach 3: Using Maps

If you're dealing with key-value pairs or want to find common keys in maps, you can use maps themselves. Iterate through one map, check if the key exists in the second map. This approach has an average time complexity of O(n), where n is the size of the larger map.

Choose the approach based on the characteristics of your input data and performance requirements.

### 1. Algorithms & Data Structures (C++): Task: Conditional Filter

Sure, let's delve into implementing a conditional filter in C++. A conditional filter is a function that takes in a collection of elements and a predicate (a function that returns true or false) and returns a new collection containing only those elements that satisfy the given predicate.

Here's a simple implementation using templates and the standard library:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>

template<typename T>
std::vector<T> conditionalFilter(const std::vector<T>& collection, std::function<bool(const T&)> predicate) {
    std::vector<T> filteredCollection;
    for (const auto& element : collection) {
        if (predicate(element)) {
            filteredCollection.push_back(element);
        }
    }
    return filteredCollection;
}

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    // Filter even numbers
    auto evenNumbers = conditionalFilter(numbers, [](int x) { return x % 2 == 0; });

    // Filter numbers greater than 5
    auto greaterThanFive = conditionalFilter(numbers, [](int x) { return x > 5; });

    std::cout << "Even Numbers: ";
    for (auto num : evenNumbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    std::cout << "Numbers Greater Than 5: ";
    for (auto num : greaterThanFive) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

In this code:

- `conditionalFilter` is a function template that takes a vector of elements `collection` and a predicate function `predicate`.
- Inside `conditionalFilter`, it iterates through each element in the collection and applies the predicate function to determine if the element should be included in the filtered collection.
- If the predicate returns true for an element, it's added to the `filteredCollection`.
- The filtered collection is then returned.

In the `main()` function, I demonstrated two different uses of `conditionalFilter` by filtering even numbers and numbers greater than 5 from the `numbers` vector. You can modify the predicate function passed to `conditionalFilter` to suit different filtering conditions.

### 1. Algorithms & Data Structures (C++): Task: Count Word Frequency

To count word frequency in C++, you can use a map data structure to store each word as a key and its corresponding frequency as the value. Here's a simple example:

```cpp
#include <iostream>
#include <map>
#include <string>
#include <sstream>
#include <cctype> // for std::tolower

// Function to clean up a word (remove punctuation and convert to lowercase)
std::string cleanWord(const std::string& word) {
    std::string cleanedWord;
    for (char c : word) {
        if (std::isalpha(c)) { // Check if the character is alphabetic
            cleanedWord += std::tolower(c); // Convert to lowercase
        }
    }
    return cleanedWord;
}

int main() {
    std::string text;
    std::cout << "Enter text: ";
    std::getline(std::cin, text);

    std::map<std::string, int> wordFreq;

    // Tokenize the input text
    std::stringstream ss(text);
    std::string word;
    while (ss >> word) {
        word = cleanWord(word);
        if (!word.empty()) {
            wordFreq[word]++;
        }
    }

    // Print the word frequencies
    std::cout << "Word frequencies:\n";
    for (const auto& pair : wordFreq) {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }

    return 0;
}
```

Here's how the program works:

1. It prompts the user to enter text.
2. It reads the input text and tokenizes it into words.
3. For each word, it cleans it up (removing punctuation and converting to lowercase) using the `cleanWord` function.
4. It updates the frequency of each word in the `wordFreq` map.
5. Finally, it prints out the word frequencies.

This program assumes that words are separated by whitespace. You may need to modify the `cleanWord` function if your requirements are different.

### 1. Algorithms & Data Structures (C++): Task: Key with the Highest Value

To find the key with the highest value in a C++ map, you can iterate through the map and keep track of the key with the maximum value encountered so far. Here's a sample implementation:

```cpp
#include <iostream>
#include <map>

// Function to find the key with the highest value in a map
template <typename Key, typename Value>
Key getKeyWithMaxValue(const std::map<Key, Value>& m) {
    Key maxKey;
    Value maxValue = std::numeric_limits<Value>::min(); // Initialize with minimum possible value

    for (const auto& pair : m) {
        if (pair.second > maxValue) {
            maxValue = pair.second;
            maxKey = pair.first;
        }
    }

    return maxKey;
}

int main() {
    std::map<int, int> myMap;
    
    // Insert some sample data
    myMap[1] = 10;
    myMap[2] = 30;
    myMap[3] = 20;
    myMap[4] = 50;
    myMap[5] = 40;
    
    // Find the key with the highest value
    int keyWithMaxValue = getKeyWithMaxValue(myMap);
    
    std::cout << "Key with the highest value: " << keyWithMaxValue << std::endl;

    return 0;
}
```

In this code:

- `getKeyWithMaxValue` is a function template that takes a `std::map` and returns the key with the highest associated value.
- The function iterates through each key-value pair in the map, updating `maxKey` and `maxValue` whenever a higher value is encountered.
- Finally, the main function inserts some sample data into a map and calls `getKeyWithMaxValue` to find the key with the highest value.

### 1. Algorithms & Data Structures (C++): Task: Reverse Key-Value Pairs

To reverse key-value pairs in a C++ map, you can iterate through the map and swap each key with its corresponding value. Here's a simple implementation:

```cpp
#include <iostream>
#include <map>

template<typename K, typename V>
std::map<V, K> reverseKeyValuePairs(const std::map<K, V>& originalMap) {
    std::map<V, K> reversedMap;
    for (const auto& pair : originalMap) {
        reversedMap[pair.second] = pair.first;
    }
    return reversedMap;
}

int main() {
    // Original map
    std::map<int, std::string> originalMap = {
        {1, "one"},
        {2, "two"},
        {3, "three"}
    };

    // Reverse key-value pairs
    auto reversedMap = reverseKeyValuePairs(originalMap);

    // Print reversed map
    for (const auto& pair : reversedMap) {
        std::cout << pair.first << " : " << pair.second << std::endl;
    }

    return 0;
}
```

In this code:

- The `reverseKeyValuePairs` function takes a `std::map` as input and returns a new map with key-value pairs reversed.
- Inside the function, it iterates over each pair in the original map, swapping the key and value when adding to the reversed map.
- In the `main` function, an original map is defined with integer keys and string values.
- The `reverseKeyValuePairs` function is called to reverse the key-value pairs.
- Finally, the reversed map is printed.

This code should output:

```bash
one : 1
two : 2
three : 3
```

### 1. Algorithms & Data Structures (C++): Task: Same Frequency

For the task "Same Frequency," you'll want to write a C++ function that determines whether two integers have the same frequency of digits. Here's a basic outline of how you might approach it:

1. **Convert integers to strings**: To analyze the digits, convert both integers to strings. This allows easy access to individual digits.

2. **Count the frequency of digits**: Create a map (or an array if the range of digits is known) to store the frequency of each digit in both numbers.

3. **Compare the frequencies**: Once you have the frequencies of digits for both numbers, compare them. If they match for all digits (0 to 9), return true; otherwise, return false.

Here's a sample implementation:

```cpp
#include <iostream>
#include <string>
#include <unordered_map>

bool sameFrequency(int num1, int num2) {
    // Convert integers to strings
    std::string str1 = std::to_string(num1);
    std::string str2 = std::to_string(num2);
    
    // Check if the lengths are the same
    if (str1.length() != str2.length()) {
        return false;
    }
    
    // Count frequency of digits
    std::unordered_map<char, int> freq1, freq2;
    for (char digit : str1) {
        freq1[digit]++;
    }
    for (char digit : str2) {
        freq2[digit]++;
    }
    
    // Compare the frequencies
    for (char digit = '0'; digit <= '9'; digit++) {
        if (freq1[digit] != freq2[digit]) {
            return false;
        }
    }
    
    return true;
}

int main() {
    int num1, num2;
    std::cout << "Enter two integers: ";
    std::cin >> num1 >> num2;

    if (sameFrequency(num1, num2)) {
        std::cout << "They have the same frequency of digits.\n";
    } else {
        std::cout << "They do not have the same frequency of digits.\n";
    }

    return 0;
}
```

This code prompts the user to input two integers and then checks whether they have the same frequency of digits. You can customize it as per your needs.

### 1. Algorithms & Data Structures (C++): The 15 Puzzle Problem

The 15 Puzzle Problem is a classic sliding puzzle that consists of a frame of numbered square tiles in random order with one tile missing. The puzzle also goes by other names like the "n-Puzzle" or "Gem Puzzle." The challenge is to rearrange the tiles to a target configuration by sliding tiles into the empty space.

Here's a high-level overview of how you might approach solving the 15 Puzzle Problem using algorithms and data structures in C++:

1. **Representation of the Puzzle**: You need a data structure to represent the state of the puzzle. This could be a 4x4 grid or a linear array of size 16 (representing each tile).

2. **State Space Search**: You can model the problem as a state space search where each state represents a different configuration of the puzzle. You need to define the initial state and the goal state.

3. **Search Algorithms**: You can use search algorithms like Breadth-First Search (BFS), Depth-First Search (DFS), A* search, or Iterative Deepening Search to explore the state space and find a sequence of moves from the initial state to the goal state.

4. **Operators**: Define the possible moves or operators that can be applied to transition from one state to another. In the case of the 15 Puzzle, the operators are moving a tile into the empty space (up, down, left, or right).

5. **Heuristic Function (for Informed Search)**: If you're using informed search algorithms like A*, you'll need a heuristic function to estimate the cost of reaching the goal from a given state. Common heuristics for the 15 Puzzle include the Manhattan distance or the number of misplaced tiles.

6. **Implementation in C++**: Implement the puzzle representation, search algorithms, operators, and heuristic functions in C++ using classes, structs, and functions.

Here's a simple example of how you might represent the puzzle state in C++ using a linear array and define the initial and goal states:

```cpp
#include <iostream>
#include <vector>

using namespace std;

const int N = 4; // Size of the puzzle (4x4)

struct Puzzle {
    int tiles[N * N]; // Linear array to represent the puzzle state

    // Function to print the current state of the puzzle
    void print() const {
        for (int i = 0; i < N * N; ++i) {
            if (i % N == 0 && i != 0)
                cout << endl;
            cout << tiles[i] << "\t";
        }
        cout << endl;
    }
};

int main() {
    Puzzle initial = {
        1, 2, 3, 4,
        5, 6, 7, 8,
        9, 10, 11, 12,
        13, 14, 0, 15 // 0 represents the empty space
    };

    Puzzle goal = {
        1, 2, 3, 4,
        5, 6, 7, 8,
        9, 10, 11, 12,
        13, 14, 15, 0 // Goal state
    };

    cout << "Initial State:" << endl;
    initial.print();

    cout << "\nGoal State:" << endl;
    goal.print();

    return 0;
}
```

This code provides a starting point for implementing the 15 Puzzle Problem in C++. You can extend it by adding search algorithms, operators, and heuristic functions to solve the puzzle efficiently.

### 1. Algorithms & Data Structures (C++): The Circuit Satisfiability Problem

The Circuit Satisfiability Problem (CSP) is a classic problem in computer science, particularly in the realm of algorithms and data structures. It's a fundamental problem in the field of Boolean satisfiability and computational complexity theory. The problem is to determine whether there exists an assignment of truth values to the variables of a Boolean formula such that the formula evaluates to true.

Here's a high-level overview of how you might approach solving the Circuit Satisfiability Problem using C++:

1. **Input Parsing**: First, you'll need to parse the Boolean circuit from its representation into a data structure that your algorithm can work with. This might involve reading in the circuit description from a file or receiving it as input in some other format.

2. **Graph Representation**: Represent the circuit as a graph data structure, where each node represents a gate or a variable, and each edge represents a connection between gates.

3. **Backtracking/Exhaustive Search**: One common approach to solving CSPs is backtracking or exhaustive search. In this approach, you recursively explore all possible assignments of truth values to the variables and check if any assignment satisfies the circuit. If you encounter a contradiction (e.g., a gate evaluates to both true and false), you backtrack and try a different assignment.

4. **Optimizations**: Backtracking can be quite inefficient for large circuits, so you'll likely want to implement various optimizations to improve performance. Some common optimizations include:
   - Early termination: Stop exploring branches of the search tree once you determine they cannot lead to a satisfying assignment.
   - Variable ordering: Choose the order in which you assign truth values to variables strategically, such as using heuristics like most constrained variable or most constraining variable.
   - Clause learning: Keep track of learned clauses to avoid redundant exploration of the search space.

5. **Implementing the Algorithm**: Write C++ code to implement the algorithm you've designed based on the above steps. This will involve writing functions for parsing input, representing the circuit, performing the search, and applying any optimizations.

6. **Testing and Debugging**: Test your implementation on various input instances, including both small and large circuits, to ensure correctness and measure performance. Debug any issues that arise during testing.

7. **Analysis**: Finally, analyze the complexity of your algorithm to understand its time and space requirements. Consider factors such as the size of the circuit, the branching factor of the search tree, and the effectiveness of your optimizations.

By following these steps, you should be able to implement a C++ solution for the Circuit Satisfiability Problem. Remember that this problem is NP-complete, so finding an efficient solution for large circuits is challenging, and you may need to trade off between solution quality and runtime performance.

### 1. Algorithms & Data Structures (C++): The Eight Queens Problem

The Eight Queens Problem is a classic puzzle in computer science and mathematics that challenges you to place eight chess queens on an 8×8 chessboard so that no two queens threaten each other. This means that no two queens share the same row, column, or diagonal.

Here's a simple C++ implementation of the Eight Queens Problem using backtracking:

```cpp
#include <iostream>
#include <vector>

using namespace std;

const int N = 8; // Size of the chessboard

// Function to check if it's safe to place a queen at board[row][col]
bool isSafe(vector<vector<int>>& board, int row, int col) {
    // Check this row on the left side
    for (int i = 0; i < col; i++)
        if (board[row][i])
            return false;

    // Check upper diagonal on left side
    for (int i = row, j = col; i >= 0 && j >= 0; i--, j--)
        if (board[i][j])
            return false;

    // Check lower diagonal on left side
    for (int i = row, j = col; j >= 0 && i < N; i++, j--)
        if (board[i][j])
            return false;

    return true;
}

// Function to solve the Eight Queens Problem recursively
bool solveNQueensUtil(vector<vector<int>>& board, int col) {
    // Base case: If all queens are placed, return true
    if (col >= N)
        return true;

    // Try placing this queen in all rows one by one
    for (int i = 0; i < N; i++) {
        if (isSafe(board, i, col)) {
            // Place this queen in board[i][col]
            board[i][col] = 1;

            // Recur to place rest of the queens
            if (solveNQueensUtil(board, col + 1))
                return true;

            // If placing queen in board[i][col] doesn't lead to a solution,
            // then remove queen from board[i][col]
            board[i][col] = 0;
        }
    }

    // If the queen can't be placed in any row in this column, return false
    return false;
}

// Function to solve the Eight Queens Problem
void solveNQueens() {
    vector<vector<int>> board(N, vector<int>(N, 0));

    if (solveNQueensUtil(board, 0)) {
        // If a solution exists, print the board
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                cout << board[i][j] << " ";
            }
            cout << endl;
        }
    } else {
        cout << "Solution does not exist" << endl;
    }
}

int main() {
    solveNQueens();
    return 0;
}
```

This code defines a recursive function `solveNQueensUtil()` to solve the problem. It tries to place queens one by one in different columns. If a queen can be placed in a particular column, it recursively solves the problem for the next column. If all queens are placed successfully, it returns true, indicating a solution exists. Otherwise, it backtracks and tries a different row for the last queen placed.

### 1. Algorithms & Data Structures (C++): The Eight Queens Problem: Algorithm Modfication

The Eight Queens Problem is a classic problem in computer science where the task is to place eight queens on an 8×8 chessboard in such a way that no two queens threaten each other. In other words, no two queens should share the same row, column, or diagonal.

The typical solution to this problem involves using backtracking algorithms such as recursive depth-first search. However, you mentioned modifying the algorithm, so here are a few possible modifications you could consider:

1. **Optimizing the Data Structure**: Instead of using a simple 2D array to represent the chessboard, you could use a bitboard representation. A bitboard is a data structure that uses a single integer to represent the occupancy of squares on a chessboard. This can lead to more efficient algorithms due to bitwise operations.

2. **Parallelization**: You could explore parallel algorithms to solve the problem. For instance, you could divide the chessboard into smaller sub-boards and have multiple threads or processes searching for solutions concurrently.

3. **Heuristic Optimization**: Introduce heuristic methods to guide the search. Instead of blindly exploring all possible configurations, you could prioritize certain moves that are more likely to lead to a solution. This could involve techniques like least-constraining-value or most-constrained-variable heuristics.

4. **Symmetry Reduction**: Exploit symmetries in the problem to reduce the search space. For example, you could reduce the problem to only considering solutions for one quadrant of the chessboard and then reflecting or rotating those solutions to cover the entire board.

5. **Constraint Propagation**: Implement constraint propagation techniques to prune the search space. This involves using rules and constraints to eliminate certain configurations without having to explicitly explore them.

6. **Monte Carlo Tree Search (MCTS)**: Although MCTS is more commonly used in game playing, it could be adapted to solve the Eight Queens Problem. It involves building a search tree where each node represents a game state, and using statistical sampling to guide the search towards promising regions of the solution space.

7. **Genetic Algorithms**: You could use genetic algorithms to evolve solutions to the Eight Queens Problem. This involves maintaining a population of candidate solutions and iteratively applying genetic operators such as mutation and crossover to evolve better solutions over successive generations.

These are just a few ideas for modifying algorithms to solve the Eight Queens Problem. Depending on your specific requirements and constraints, some of these modifications may be more suitable than others.

### 1. Algorithms & Data Structures (C++): The Eight Queens Problem: Eight Queens Algorithm Modification

The Eight Queens Problem is a classic puzzle that involves placing eight queens on a standard 8×8 chessboard in such a way that no two queens threaten each other. This means that no two queens can share the same row, column, or diagonal.

To modify the algorithm for the Eight Queens Problem, you could consider various enhancements or optimizations. Here are a few modifications you might consider:

1. **Backtracking with Heuristics**: Implement backtracking, but incorporate heuristics to improve performance. For instance, you can prioritize placing queens in rows or columns that are likely to have fewer conflicts.

2. **Bitwise Representation**: Represent the state of the chessboard and queen placements using bitwise operations, which can significantly speed up computations.

3. **Parallelization**: Utilize parallel processing techniques to explore different branches of the search tree simultaneously, potentially speeding up the search for a solution.

4. **Symmetry Reduction**: Exploit symmetries in the problem to reduce the search space. For example, you can consider only the solutions that lie within a specific quadrant and then mirror or rotate them to find all possible solutions.

5. **Precomputation**: Precompute solutions for smaller board sizes (e.g., 4x4 or 5x5) and use them to speed up the search for larger board sizes.

6. **Genetic Algorithm**: Apply a genetic algorithm approach to evolve solutions over multiple generations, selecting for individuals that have fewer conflicts.

7. **Constraint Propagation**: Use techniques like constraint satisfaction or propagation to reduce the search space by eliminating certain configurations that are guaranteed to lead to conflicts.

8. **Monte Carlo Tree Search (MCTS)**: Implement MCTS, a heuristic search algorithm often used in decision-making and optimization problems, to efficiently explore the solution space.

Remember to benchmark your modifications to assess their effectiveness in terms of performance and solution quality. Each modification comes with its own trade-offs, so it's essential to consider the specific requirements of your application or problem instance.

### 1. Algorithms & Data Structures (C++): The Knights Tour

The Knight's Tour is a classic problem in the realm of algorithms and data structures. It involves finding a sequence of moves for a knight on a chessboard such that the knight visits every square exactly once. This problem can be solved using backtracking.

Here's a basic approach to solving the Knight's Tour problem in C++:

```cpp
#include <iostream>
#include <array>

constexpr int BOARD_SIZE = 8;

// Possible moves for the knight
const std::array<std::pair<int, int>, 8> moves = {{
    {2, 1}, {1, 2}, {-1, 2}, {-2, 1},
    {-2, -1}, {-1, -2}, {1, -2}, {2, -1}
}};

// Check if the given position is valid on the board
bool isValidMove(int x, int y, const std::array<std::array<int, BOARD_SIZE>, BOARD_SIZE>& board) {
    return (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE && board[x][y] == -1);
}

// Recursive function to solve the Knight's Tour
bool solveKnightTour(int x, int y, int moveNumber, std::array<std::array<int, BOARD_SIZE>, BOARD_SIZE>& board) {
    if (moveNumber == BOARD_SIZE * BOARD_SIZE)
        return true;

    for (const auto& move : moves) {
        int nextX = x + move.first;
        int nextY = y + move.second;
        if (isValidMove(nextX, nextY, board)) {
            board[nextX][nextY] = moveNumber;
            if (solveKnightTour(nextX, nextY, moveNumber + 1, board))
                return true;
            // Backtrack
            board[nextX][nextY] = -1;
        }
    }

    return false;
}

// Function to print the Knight's Tour path
void printKnightTour(const std::array<std::array<int, BOARD_SIZE>, BOARD_SIZE>& board) {
    for (int i = 0; i < BOARD_SIZE; ++i) {
        for (int j = 0; j < BOARD_SIZE; ++j) {
            std::cout << board[i][j] << "\t";
        }
        std::cout << std::endl;
    }
}

// Main function
int main() {
    std::array<std::array<int, BOARD_SIZE>, BOARD_SIZE> board;
    // Initialize the board with -1 (indicating no move has been made yet)
    for (auto& row : board) {
        row.fill(-1);
    }

    // Start from position (0, 0) and make the first move
    int startX = 0, startY = 0;
    board[startX][startY] = 0; // Start from move 0
    if (solveKnightTour(startX, startY, 1, board)) {
        std::cout << "Solution exists. Knight's Tour path:" << std::endl;
        printKnightTour(board);
    } else {
        std::cout << "No solution exists." << std::endl;
    }

    return 0;
}
```

This code initializes a chessboard represented as a 2D array and then recursively tries different moves for the knight, backtracking whenever it reaches a dead-end. Finally, it prints out the Knight's Tour path if a solution exists.

### 1. Algorithms & Data Structures (C++): Three Sum

The Three Sum problem is a classic algorithmic problem that asks to find all unique triplets in an array that sum up to a given target value. Here's a C++ implementation of the Three Sum problem using a two-pointer approach:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

vector<vector<int>> threeSum(vector<int>& nums, int target) {
    vector<vector<int>> result;

    // Sorting the array to use two-pointer approach
    sort(nums.begin(), nums.end());

    int n = nums.size();

    for (int i = 0; i < n - 2; ++i) {
        // Avoiding duplicate triplets with the same first element
        if (i == 0 || (i > 0 && nums[i] != nums[i - 1])) {
            int left = i + 1;
            int right = n - 1;
            int targetSum = target - nums[i];

            while (left < right) {
                int currentSum = nums[left] + nums[right];

                if (currentSum == targetSum) {
                    // Found a triplet, add it to the result
                    result.push_back({nums[i], nums[left], nums[right]});

                    // Skip duplicate elements
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    while (left < right && nums[right] == nums[right - 1]) right--;

                    left++;
                    right--;
                } else if (currentSum < targetSum) {
                    left++;
                } else {
                    right--;
                }
            }
        }
    }

    return result;
}

int main() {
    vector<int> nums = {-1, 0, 1, 2, -1, -4};
    int target = 0;
    vector<vector<int>> triplets = threeSum(nums, target);

    for (const auto& triplet : triplets) {
        cout << "[";
        for (int num : triplet) {
            cout << num << " ";
        }
        cout << "]" << endl;
    }

    return 0;
}
```

This implementation has a time complexity of O(n^2), where n is the number of elements in the input array. Sorting the array initially takes O(n log n) time, and then finding the triplets using the two-pointer approach takes O(n^2) time.

### 1. Algorithms & Data Structures (C++): Three Sum - Hash Table

To solve the Three Sum problem using a hash table in C++, you can follow these steps:

1. Create a hash table to store the elements of the array.
2. Iterate through the array, fixing one element at a time as the potential first number in the triplet.
3. For each fixed element, use a nested loop to find the other two numbers such that their sum equals the negation of the fixed element.
4. Check if the other two numbers exist in the hash table.
5. If found, add the triplet to the result set.

Here's a C++ implementation:

```cpp
#include <vector>
#include <unordered_map>
#include <algorithm>

using namespace std;

vector<vector<int>> threeSum(vector<int>& nums) {
    vector<vector<int>> result;
    int n = nums.size();
    
    // Sort the array to handle duplicates and easily find the complement
    sort(nums.begin(), nums.end());
    
    // Iterate through the array
    for (int i = 0; i < n - 2; ++i) {
        // Check for duplicates
        if (i > 0 && nums[i] == nums[i - 1])
            continue;
        
        // Fix the first number and find the other two
        int target = -nums[i];
        unordered_map<int, int> hash_table; // Stores the complement and its index
        
        // Iterate through the rest of the array
        for (int j = i + 1; j < n; ++j) {
            int complement = target - nums[j];
            
            // Check if complement exists in the hash table
            if (hash_table.find(complement) != hash_table.end()) {
                // Triplet found, add it to the result set
                result.push_back({nums[i], complement, nums[j]});
                
                // Skip duplicates
                while (j + 1 < n && nums[j] == nums[j + 1])
                    ++j;
            }
            
            // Add current number to the hash table
            hash_table[nums[j]] = j;
        }
    }
    
    return result;
}

// Example usage
int main() {
    vector<int> nums = {-1, 0, 1, 2, -1, -4};
    vector<vector<int>> result = threeSum(nums);
    
    // Output the result
    for (const auto& triplet : result) {
        for (int num : triplet) {
            cout << num << " ";
        }
        cout << endl;
    }
    
    return 0;
}
```

This code will find all unique triplets in the array that sum up to zero. The time complexity of this solution is O(n^2) due to the nested loops, and the space complexity is O(n) for the hash table.

### 1. Algorithms & Data Structures (C++): Tiling a Defective Chessboard

Tiling a defective chessboard is a classic problem in computer science, often used to illustrate the power of certain algorithmic techniques. The problem statement goes like this:

Given a chessboard with some squares missing, can you tile the remaining squares with L-shaped tiles (formed by connecting three squares in the shape of an L)? If so, what is the minimum number of L-shaped tiles required?

Here's a high-level approach to solve this problem using recursive backtracking:

1. **Divide and Conquer**: Break the chessboard into smaller subproblems. You can divide the board in half recursively until you reach a base case.

2. **Base Case**: The base case occurs when the size of the board is small enough that you can directly solve it.

3. **Recursive Step**: For each recursive step, try placing an L-shaped tile in every possible valid position on the current sub-board. Recur for each possibility until you find a solution or exhaust all possibilities.

4. **Backtracking**: If placing an L-shaped tile leads to a dead end (i.e., it violates the constraints or cannot be completed to a solution), backtrack and try another possibility.

5. **Optimization**: You can optimize the algorithm by using techniques like memoization or dynamic programming to avoid redundant calculations.

Here's a simple pseudocode outline of this approach:

```plaintext
function tileChessboard(board):
    if all squares are tiled:
        return true // base case
    for each empty square s in board:
        if it's possible to place an L-shaped tile at s:
            place the tile at s
            if tileChessboard(board) returns true:
                return true
            remove the tile from s
    return false

function canPlaceTile(board, position):
    // Check if it's possible to place an L-shaped tile at the given position
    // (i.e., the position is within bounds and doesn't overlap with existing tiles)

main:
    initialize an empty chessboard
    if tileChessboard(chessboard) returns true:
        print "The chessboard can be tiled with L-shaped tiles."
    else:
        print "The chessboard cannot be tiled with L-shaped tiles."
```

You can implement the `tileChessboard` function in C++ using recursion and backtracking, along with a helper function `canPlaceTile` to check if it's possible to place a tile at a given position. This problem is a great exercise for practicing recursion, backtracking, and problem-solving skills in general.

### 1. Algorithms & Data Structures (C++): Tiling Problem

The tiling problem is a classic problem in computer science and mathematics that involves covering a given area using a set of tiles. In this problem, we usually deal with a rectangular grid or a similar structure, and the goal is to find the number of ways to tile the grid using given types of tiles. There are various variations of this problem, each with its own constraints and requirements.

Here's a basic implementation of the tiling problem in C++ using dynamic programming:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Function to count the number of ways to tile a given width using 1xN tiles
int countWays(int width, int N) {
    vector<int> dp(width + 1, 0);

    // Base case
    dp[0] = 1;

    // Fill the dp array using bottom-up approach
    for (int i = 1; i <= width; ++i) {
        if (i < N) {
            dp[i] = dp[i - 1];
        } else {
            dp[i] = dp[i - 1] + dp[i - N];
        }
    }

    return dp[width];
}

int main() {
    int width = 5; // Width of the grid
    int N = 2;     // Width of the tile

    cout << "Number of ways to tile the grid: " << countWays(width, N) << endl;

    return 0;
}
```

This code snippet demonstrates how to count the number of ways to tile a given width using 1xN tiles, where `width` is the width of the grid, and `N` is the width of the tile. The `countWays` function uses dynamic programming to efficiently compute the result.

You can extend or modify this code according to your specific requirements, such as different types of tiles or additional constraints.

### 1. Algorithms & Data Structures (C++): Travelling Salesman Problem

The Travelling Salesman Problem (TSP) is a classic problem in computer science and optimization. It involves finding the shortest possible route that visits each city exactly once and returns to the original city. There are several algorithms to solve the TSP, ranging from exact algorithms to heuristic and approximation algorithms. I can provide you with a basic implementation of the brute-force approach in C++, which is not efficient for large numbers of cities but can serve as a starting point:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>

using namespace std;

const int INF = INT_MAX;

// Function to calculate the total distance of a path
int calculateDistance(const vector<vector<int>>& graph, const vector<int>& path) {
    int distance = 0;
    int n = graph.size();
    for (int i = 0; i < n - 1; ++i) {
        if (graph[path[i]][path[i + 1]] == INF)
            return INF; // Path is invalid
        distance += graph[path[i]][path[i + 1]];
    }
    if (graph[path[n - 1]][path[0]] == INF)
        return INF; // Path is invalid
    distance += graph[path[n - 1]][path[0]]; // Return to the starting city
    return distance;
}

// Function to solve TSP using brute-force approach
int tspBruteForce(const vector<vector<int>>& graph) {
    int n = graph.size();
    vector<int> path(n);
    for (int i = 0; i < n; ++i)
        path[i] = i;
    
    int minDistance = INF;
    do {
        int distance = calculateDistance(graph, path);
        minDistance = min(minDistance, distance);
    } while (next_permutation(path.begin() + 1, path.end())); // Generate all permutations
    
    return minDistance;
}

int main() {
    vector<vector<int>> graph = {
        {0, 10, 15, 20},
        {10, 0, 35, 25},
        {15, 35, 0, 30},
        {20, 25, 30, 0}
    };
    
    int minDistance = tspBruteForce(graph);
    
    if (minDistance == INF)
        cout << "No valid tour exists.\n";
    else
        cout << "Minimum distance: " << minDistance << endl;
    
    return 0;
}
```

This code represents a brute-force solution to the TSP problem for a small number of cities. For larger instances, you would need more efficient algorithms like dynamic programming (e.g., Held-Karp algorithm) or heuristic methods (e.g., Genetic Algorithms, Ant Colony Optimization).

### 1. Algorithms & Data Structures (C++): Unique Email Addresses

Sure, let's discuss how to implement a solution for finding unique email addresses in C++.

To solve this problem, we can use a set to store unique email addresses. For each email address, we'll normalize it according to the rules (e.g., removing periods and ignoring everything after a '+' sign in the local name), and then add it to the set. Finally, the size of the set will give us the count of unique email addresses.

Here's a sample implementation:

```cpp
#include <iostream>
#include <string>
#include <unordered_set>

using namespace std;

// Function to normalize an email address
string normalizeEmail(const string& email) {
    string normalized;
    bool ignore = false;
    
    for(char c : email) {
        if(c == '@') {
            normalized += email.substr(email.find('@'));
            break;
        }
        if(c == '.') continue;
        if(c == '+') {
            ignore = true;
            continue;
        }
        if(!ignore) normalized += c;
    }
    
    return normalized;
}

// Function to count unique email addresses
int countUniqueEmails(const vector<string>& emails) {
    unordered_set<string> uniqueEmails;
    
    for(const string& email : emails) {
        uniqueEmails.insert(normalizeEmail(email));
    }
    
    return uniqueEmails.size();
}

int main() {
    // Sample email addresses
    vector<string> emails = {
        "test.email@gmail.com",
        "test.e.mail+bob.cathy@gmail.com",
        "testemail+david@lee.tcode.com"
    };
    
    cout << "Number of unique email addresses: " << countUniqueEmails(emails) << endl;
    
    return 0;
}
```

In this code:

- The `normalizeEmail` function takes an email address and returns its normalized version according to the rules.
- The `countUniqueEmails` function takes a vector of email addresses, normalizes each one, and adds it to an unordered set to ensure uniqueness.
- In the `main` function, a sample vector of email addresses is created, and then `countUniqueEmails` is called to get the count of unique email addresses.

This implementation will correctly count the number of unique email addresses according to the specified rules.

### 1. Algorithms & Data Structures (C++): Unique Morse Code Words

To solve this problem, you'll need to map each letter of the alphabet to its corresponding Morse code representation. Then, for each word in the given list, convert it to Morse code and count how many unique representations you have. Here's a C++ implementation:

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <unordered_set>

using namespace std;

string morseCode[] = {
    ".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..", ".---", "-.-", ".-..", "--", "-.",
    "---", ".--.", "--.-", ".-.", "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.."
};

string wordToMorse(string word) {
    string morse = "";
    for (char c : word) {
        morse += morseCode[c - 'a'];
    }
    return morse;
}

int uniqueMorseRepresentations(vector<string>& words) {
    unordered_set<string> uniqueMorse;
    for (string word : words) {
        uniqueMorse.insert(wordToMorse(word));
    }
    return uniqueMorse.size();
}

int main() {
    vector<string> words = {"gin", "zen", "gig", "msg"};
    cout << "Number of unique Morse code representations: " << uniqueMorseRepresentations(words) << endl;
    return 0;
}
```

This code defines a function `uniqueMorseRepresentations` that takes a vector of words as input and returns the number of unique Morse code representations. The `wordToMorse` function converts a single word to its Morse code representation. Finally, the `main` function demonstrates its usage with a sample vector of words.

### 1. Algorithms & Data Structures (C++): Vacation

Sure, let's talk about implementing an algorithm or data structure related to vacations in C++! Vacations could involve various aspects such as planning, scheduling, budgeting, and more. Here's a simple example of how you could implement a vacation planner using C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

// Define a struct to represent a vacation destination
struct Destination {
    std::string name;
    double cost;
    int rating;

    Destination(std::string n, double c, int r) : name(n), cost(c), rating(r) {}
};

// Function to compare destinations based on cost
bool compareByCost(const Destination &a, const Destination &b) {
    return a.cost < b.cost;
}

// Function to compare destinations based on rating
bool compareByRating(const Destination &a, const Destination &b) {
    return a.rating > b.rating;
}

int main() {
    // Create a vector to store destinations
    std::vector<Destination> destinations;

    // Add some sample destinations
    destinations.push_back(Destination("Paris", 2000, 9));
    destinations.push_back(Destination("Tokyo", 2500, 8));
    destinations.push_back(Destination("New York", 1800, 7));
    destinations.push_back(Destination("Sydney", 3000, 9));

    // Sort destinations by cost
    std::sort(destinations.begin(), destinations.end(), compareByCost);

    // Print destinations sorted by cost
    std::cout << "Destinations sorted by cost:\n";
    for (const auto &dest : destinations) {
        std::cout << dest.name << " - Cost: $" << dest.cost << std::endl;
    }

    // Sort destinations by rating
    std::sort(destinations.begin(), destinations.end(), compareByRating);

    // Print destinations sorted by rating
    std::cout << "\nDestinations sorted by rating:\n";
    for (const auto &dest : destinations) {
        std::cout << dest.name << " - Rating: " << dest.rating << std::endl;
    }

    return 0;
}
```

In this example, we have a struct `Destination` to represent vacation destinations, with attributes such as name, cost, and rating. We then define two comparison functions (`compareByCost` and `compareByRating`) to sort the destinations based on cost and rating, respectively. Finally, we use `std::sort` to sort the destinations and print them out.

This is a basic example, but you can extend it to include more functionality like user input for adding destinations, filtering destinations based on budget or rating, and so on. Let me know if you have any specific aspects of vacations or algorithms/data structures you'd like to delve into!

### 1. Algorithms & Data Structures (C++): Valid Perfect Square

Sure! Here's a C++ function to check whether a given number is a valid perfect square using binary search:

```cpp
#include <iostream>

bool isPerfectSquare(int num) {
    if (num < 0) return false;
    if (num == 0) return true;

    long left = 1, right = num;

    while (left <= right) {
        long mid = left + (right - left) / 2;
        long square = mid * mid;

        if (square == num)
            return true;
        else if (square < num)
            left = mid + 1;
        else
            right = mid - 1;
    }

    return false;
}

int main() {
    int num;
    std::cout << "Enter a number: ";
    std::cin >> num;

    if (isPerfectSquare(num))
        std::cout << num << " is a valid perfect square." << std::endl;
    else
        std::cout << num << " is not a valid perfect square." << std::endl;

    return 0;
}
```

This code defines a function `isPerfectSquare` that takes an integer `num` as input and returns `true` if `num` is a valid perfect square and `false` otherwise. It uses a binary search approach to efficiently find the square root of `num`. In the `main` function, it prompts the user to input a number and then calls `isPerfectSquare` to determine if the input number is a perfect square or not.

### 1. Algorithms & Data Structures (C++): Word break (problem)

The word break problem is a classic algorithmic problem in computer science, often encountered in interviews and competitive programming. The problem statement goes like this:

Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.

For example, given the string "leetcode" and the dictionary ["leet", "code"], return true because "leetcode" can be segmented as "leet code".

This problem can be efficiently solved using dynamic programming. Here's a high-level approach to solving it:

1. Create a boolean array `dp[]` of size n, where n is the length of the input string s. `dp[i]` is true if and only if there's a valid segmentation from index 0 to i.
2. Initialize `dp[0]` as true since an empty string is always present in the dictionary.
3. Iterate through each index `i` from 1 to n.
4. For each `i`, iterate through each index `j` from 0 to `i-1`.
5. Check if the substring from index `j` to `i` is in the dictionary and if `dp[j]` is true. If both conditions are met, set `dp[i]` to true.
6. After completing the iterations, `dp[n-1]` will contain the answer.

Here's a simple C++ implementation of the above approach:

```cpp
#include <iostream>
#include <string>
#include <unordered_set>
#include <vector>

using namespace std;

bool wordBreak(string s, unordered_set<string>& wordDict) {
    int n = s.size();
    vector<bool> dp(n + 1, false);
    dp[0] = true;

    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (dp[j] && wordDict.find(s.substr(j, i - j)) != wordDict.end()) {
                dp[i] = true;
                break;
            }
        }
    }

    return dp[n];
}

int main() {
    string s = "leetcode";
    unordered_set<string> wordDict = {"leet", "code"};

    if (wordBreak(s, wordDict)) {
        cout << "String can be segmented." << endl;
    } else {
        cout << "String cannot be segmented." << endl;
    }

    return 0;
}
```

This implementation efficiently solves the word break problem using dynamic programming.

### 1. Algorithms & Data Structures (C++): Word break (solution)

Sure! The word break problem is a classic dynamic programming problem. Given a string and a dictionary of words, you need to determine if the string can be segmented into a space-separated sequence of one or more dictionary words.

Here's a C++ solution using dynamic programming:

```cpp
#include <iostream>
#include <string>
#include <unordered_set>
#include <vector>

using namespace std;

bool wordBreak(string s, unordered_set<string>& wordDict) {
    int n = s.length();
    vector<bool> dp(n + 1, false);
    dp[0] = true; // Empty string is always breakable

    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (dp[j] && wordDict.count(s.substr(j, i - j))) {
                dp[i] = true;
                break;
            }
        }
    }

    return dp[n];
}

int main() {
    string s = "leetcode";
    unordered_set<string> wordDict = {"leet", "code"};

    if (wordBreak(s, wordDict))
        cout << "String can be segmented into words." << endl;
    else
        cout << "String cannot be segmented into words." << endl;

    return 0;
}
```

This solution iterates through each prefix of the input string `s` and checks if it can be broken into words found in the dictionary. The `dp` array is used to store whether the prefix up to the current index can be broken into words. If any valid break is found, the corresponding entry in the `dp` array is set to true.

At the end of the iteration, `dp[n]` will be true if the entire string can be segmented into words found in the dictionary, and false otherwise.

### 1. Algorithms & Data Structures (C++): Word Break Problem

The Word Break Problem is a classic algorithmic problem where the task is to determine whether a given string can be segmented into a space-separated sequence of one or more dictionary words. For example, given the string "applepenapple" and the dictionary ["apple", "pen"], you should return true because the string can be segmented as "apple pen apple".

Here's a C++ implementation using dynamic programming:

```cpp
#include <iostream>
#include <string>
#include <unordered_set>
#include <vector>

using namespace std;

bool wordBreak(string s, unordered_set<string>& wordDict) {
    int n = s.length();
    vector<bool> dp(n + 1, false);
    dp[0] = true; // Empty string is always valid

    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (dp[j] && wordDict.find(s.substr(j, i - j)) != wordDict.end()) {
                dp[i] = true;
                break;
            }
        }
    }

    return dp[n];
}

int main() {
    string s = "applepenapple";
    unordered_set<string> wordDict = {"apple", "pen"};

    if (wordBreak(s, wordDict))
        cout << "String can be segmented." << endl;
    else
        cout << "String cannot be segmented." << endl;

    return 0;
}
```

Explanation:

- We use dynamic programming to solve this problem. The `dp` array of boolean values of size `n + 1` is used, where `dp[i]` indicates whether the substring ending at index `i` (inclusive) can be segmented into words from the dictionary.
- We initialize `dp[0]` to be true because an empty string can always be segmented.
- Then, for each index `i` from 1 to `n`, we iterate over all substrings ending at index `i` (inclusive). For each such substring, we check if there exists a word in the dictionary that ends at index `i`, and if the substring before that word can be segmented. If both conditions are true, we set `dp[i]` to true.
- Finally, we return `dp[n]`, which indicates whether the entire string can be segmented.

This algorithm has a time complexity of O(n^2) and a space complexity of O(n), where n is the length of the input string.

### 1. Algorithms & Data Structures (C++): Cracking Trees and Graphs Top Interview Questions (Apple, Amazon, Facebook)

Sure, let's go through some common interview questions related to trees and graphs that are frequently asked by companies like Apple, Amazon, and Facebook:

1. **Binary Tree Traversal**: Implement the three main types of binary tree traversal: preorder, inorder, and postorder. Explain the differences between them and their respective use cases.

2. **Binary Search Tree (BST) Validation**: Write a function to determine whether a given binary tree is a valid binary search tree.

3. **Lowest Common Ancestor (LCA)**: Given a binary tree and two nodes, find the lowest common ancestor of the two nodes.

4. **Serialize and Deserialize a Binary Tree**: Write functions to serialize a binary tree into a string and deserialize the string back into a tree.

5. **Graph Traversal (BFS and DFS)**: Implement breadth-first search (BFS) and depth-first search (DFS) algorithms for traversing a graph. Discuss their applications and differences.

6. **Topological Sorting**: Given a directed graph, perform a topological sort on it if possible.

7. **Graph Connectivity**: Determine whether a given undirected graph is connected or not.

8. **Shortest Path Algorithms**: Implement Dijkstra's algorithm and discuss its time complexity. Also, discuss the difference between Dijkstra's algorithm and the Bellman-Ford algorithm.

9. **Detecting Cycles in a Graph**: Write a function to detect cycles in a directed or undirected graph.

10. **Minimum Spanning Tree (MST)**: Implement Prim's algorithm or Kruskal's algorithm to find the minimum spanning tree of a weighted graph.

These are just a few examples of the types of questions you might encounter in interviews focusing on trees and graphs. Each of these topics requires a solid understanding of algorithms and data structures in order to tackle them effectively.

### 1. Algorithms & Data Structures (C++): Compressor

Creating a compressor involves implementing algorithms to reduce the size of data. In the realm of algorithms and data structures, there are several techniques for compression. Here's a basic outline of how you might approach creating a compressor in C++:

1. **Choose a Compression Algorithm**: There are various compression algorithms like Huffman coding, Lempel-Ziv-Welch (LZW), Run-Length Encoding (RLE), Burrows-Wheeler Transform (BWT), etc. Choose one based on your requirements for compression ratio, speed, and complexity.

2. **Implement the Chosen Algorithm**: Implement the chosen compression algorithm. For instance, if you choose Huffman coding, you'll need to create functions/classes to build the Huffman tree, encode data, and decode data.

3. **Read Data**: Create functions to read data from the input file. You might read data in chunks to process large files efficiently.

4. **Compress Data**: Use the implemented compression algorithm to compress the data read from the file.

5. **Write Compressed Data**: Write the compressed data to an output file. Ensure that you also write any metadata required for decompression (e.g., Huffman tree for Huffman coding).

6. **Implement Decompression**: Implement the decompression counterpart of your chosen compression algorithm. This involves reading the compressed data and reconstructing the original data.

7. **Test Your Compressor**: Test your compressor with various types of data to ensure it performs well across different scenarios. Measure compression ratio, speed, and accuracy.

Here's a simple example using Huffman coding for compression and decompression:

```cpp
// Include necessary libraries

// Define structures and classes for Huffman coding

// Functions for compression
void compress(const std::string& inputFilename, const std::string& outputFilename) {
    // Read data from input file
    // Compress data using Huffman coding
    // Write compressed data to output file
}

// Functions for decompression
void decompress(const std::string& inputFilename, const std::string& outputFilename) {
    // Read compressed data from input file
    // Decompress data using Huffman coding
    // Write decompressed data to output file
}

int main() {
    // Example usage
    compress("input.txt", "compressed.bin");
    decompress("compressed.bin", "output.txt");
    return 0;
}
```

Remember to handle edge cases and errors gracefully, such as file not found, insufficient memory, etc. Also, optimize your code for performance if dealing with large files.

### 1. Algorithms & Data Structures (C++): Subsequence Based Problems

Subsequence-based problems in algorithms and data structures often involve finding or analyzing subsequences within a given sequence. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Here are some common subsequence-based problems in C++:

1. **Longest Increasing Subsequence (LIS)**:
   - Problem: Given an array of integers, find the length of the longest increasing subsequence.
   - Solution: This problem can be solved using dynamic programming. You can define a DP array where `dp[i]` represents the length of the longest increasing subsequence ending at index `i`.
   - Code Example:

    ```cpp
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n, 1);
        int maxLen = 1;
        
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                    maxLen = max(maxLen, dp[i]);
                }
            }
        }
        
        return maxLen;
    }
    ```

2. **Longest Common Subsequence (LCS)**:
   - Problem: Given two sequences, find the length of the longest subsequence present in both of them.
   - Solution: This can also be solved using dynamic programming. You can define a 2D DP array where `dp[i][j]` represents the length of LCS for `text1[0...i]` and `text2[0...j]`.
   - Code Example:

    ```cpp
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.size(), n = text2.size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1[i - 1] == text2[j - 1])
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                else
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        
        return dp[m][n];
    }
    ```

3. **Maximum Sum Increasing Subsequence**:
   - Problem: Given an array of integers, find the sum of the maximum sum subsequence such that the integers in the subsequence are sorted in increasing order.
   - Solution: This can also be solved using dynamic programming. You can define a DP array where `dp[i]` represents the maximum sum of increasing subsequence ending at index `i`.
   - Code Example:

    ```cpp
    int maxSumIncreasingSubsequence(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n);
        int maxSum = INT_MIN;
        
        for (int i = 0; i < n; i++) {
            dp[i] = nums[i];
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = max(dp[i], dp[j] + nums[i]);
                }
            }
            maxSum = max(maxSum, dp[i]);
        }
        
        return maxSum;
    }
    ```

These are just a few examples of subsequence-based problems in C++. There are many more variations and complexities of these problems, and they often involve dynamic programming techniques for efficient solutions.

### 1. Algorithms & Data Structures (C++): Sum Closest

To find the sum of two numbers in an array that are closest to a given target value, you can follow these steps:

1. Sort the array.
2. Initialize two pointers, one at the beginning (left) and the other at the end (right) of the sorted array.
3. While the left pointer is less than the right pointer:
   a. Calculate the sum of the current elements pointed by the left and right pointers.
   b. Update the closest sum found so far if the absolute difference between the current sum and the target is less than the absolute difference between the closest sum and the target.
   c. If the current sum is less than the target, move the left pointer to the right (increasing the sum).
   d. If the current sum is greater than the target, move the right pointer to the left (decreasing the sum).
4. Repeat until the pointers meet.

Here's a C++ implementation of the algorithm:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>

using namespace std;

pair<int, int> sumClosest(vector<int>& nums, int target) {
    sort(nums.begin(), nums.end()); // Sort the array
    int closestSum = INT_MAX;
    pair<int, int> result;

    int left = 0;
    int right = nums.size() - 1;

    while (left < right) {
        int sum = nums[left] + nums[right];
        int diff = abs(sum - target);

        if (diff < abs(closestSum - target)) {
            closestSum = sum;
            result = {nums[left], nums[right]};
        }

        if (sum < target) {
            left++;
        } else if (sum > target) {
            right--;
        } else { // If sum equals target, this is the closest possible sum
            return {nums[left], nums[right]};
        }
    }

    return result;
}

int main() {
    vector<int> nums = {1, 2, 4, 7, 11, 15};
    int target = 18;
    pair<int, int> closestPair = sumClosest(nums, target);

    cout << "Closest pair summing to " << target << ": " << closestPair.first << " and " << closestPair.second << endl;

    return 0;
}
```

This code demonstrates how to find the pair of numbers whose sum is closest to the target value in a given array. You can adjust the `nums` array and `target` value as per your requirement.

### 1. Algorithms & Data Structures (C++): Trapping Rain Water - Arrays

Trapping Rain Water problem is a classic algorithmic problem that can be solved efficiently using arrays. The problem statement goes like this: given an elevation map represented by an array where the width of each bar is 1, calculate how much water it can trap after raining.

Here's a simple approach to solve this problem efficiently:

1. **Scan from left to right to find the maximum height of bars on the left of each bar.**
2. **Scan from right to left to find the maximum height of bars on the right of each bar.**
3. **Iterate over each bar and calculate the trapped water at that position as min(max_left, max_right) - height of the current bar.**

Here's a sample implementation in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int trap(vector<int>& height) {
    int n = height.size();
    if (n == 0) return 0;

    vector<int> max_left(n);
    vector<int> max_right(n);

    // Fill max_left array
    max_left[0] = height[0];
    for (int i = 1; i < n; ++i) {
        max_left[i] = max(max_left[i - 1], height[i]);
    }

    // Fill max_right array
    max_right[n - 1] = height[n - 1];
    for (int i = n - 2; i >= 0; --i) {
        max_right[i] = max(max_right[i + 1], height[i]);
    }

    int water = 0;
    // Calculate trapped water at each position
    for (int i = 0; i < n; ++i) {
        water += min(max_left[i], max_right[i]) - height[i];
    }

    return water;
}

int main() {
    vector<int> height = {0,1,0,2,1,0,1,3,2,1,2,1};
    cout << "Trapped water: " << trap(height) << endl;
    return 0;
}
```

This code snippet first calculates the maximum height of bars to the left and right of each bar in two separate passes. Then, it calculates the trapped water at each position by taking the minimum of the maximum heights on both sides and subtracting the height of the current bar. Finally, it sums up all the trapped water to get the total amount of trapped rainwater.

### 1. Algorithms & Data Structures (C++): Flood Fill - Arrays

Certainly! Flood fill is a classic algorithm used to traverse and manipulate connected regions in a grid or an array. It's commonly used in image processing, maze-solving, and other graphical applications. The basic idea is to start from a given point in the grid and explore its neighbors, recursively applying some operation until a certain condition is met. Here's a C++ implementation of the flood fill algorithm:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Define the directions (up, down, left, right)
const int dx[] = {-1, 1, 0, 0};
const int dy[] = {0, 0, -1, 1};

// Function to perform flood fill
void floodFill(vector<vector<int>>& grid, int x, int y, int newColor, int oldColor) {
    // Boundary check
    if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] != oldColor)
        return;

    // Change the color of the current cell
    grid[x][y] = newColor;

    // Recursively flood fill adjacent cells
    for (int i = 0; i < 4; ++i) {
        int nx = x + dx[i];
        int ny = y + dy[i];
        floodFill(grid, nx, ny, newColor, oldColor);
    }
}

// Function to print the grid
void printGrid(const vector<vector<int>>& grid) {
    for (const auto& row : grid) {
        for (int cell : row) {
            cout << cell << " ";
        }
        cout << endl;
    }
}

int main() {
    vector<vector<int>> grid = {
        {1, 1, 1, 1, 1},
        {1, 1, 0, 0, 1},
        {1, 0, 1, 0, 1},
        {1, 1, 1, 1, 1}
    };

    cout << "Original Grid:" << endl;
    printGrid(grid);

    int x = 1, y = 2; // Starting point
    int newColor = 2; // New color to flood fill with
    int oldColor = grid[x][y]; // Old color of the starting point

    floodFill(grid, x, y, newColor, oldColor);

    cout << "\nGrid after flood fill:" << endl;
    printGrid(grid);

    return 0;
}
```

In this implementation:

- We define a 2D vector `grid` representing the array.
- `floodFill` function performs the flood fill algorithm recursively. It takes the grid, coordinates of the starting point `(x, y)`, the new color to fill, and the old color of the starting point as parameters.
- `printGrid` function simply prints the grid.
- In the `main` function, we define a sample grid, choose a starting point `(x, y)`, specify the new color, and call `floodFill` function with these parameters.
- Finally, we print the grid before and after the flood fill operation.

You can adjust the grid, starting point, and new color as needed to experiment with different scenarios.

### 1. Algorithms & Data Structures (C++): DQUERY SPOJ using Mo's Algorithm

Solving the DQUERY problem on SPOJ using Mo's Algorithm can be an interesting challenge. Mo's Algorithm is an offline algorithm used to process range queries offline, meaning that it's suitable when you have all the queries in advance and can process them in any order.

Here's a general outline of how you can implement Mo's Algorithm to solve the DQUERY problem:

1. **Input**: Read the input, which consists of an array of N integers and M queries. Each query is represented by two integers L and R, denoting the range for which you need to find distinct elements.

2. **Preprocessing**: Sort the queries based on the block to which they belong. Each query's block is determined by the value L / block_size, where block_size is some appropriate value. Additionally, sort the array elements if they are not already sorted.

3. **Initialize**: Initialize data structures and variables needed for processing queries.

4. **Mo's Algorithm Processing**: Iterate through each query. For each query, move the left and right pointers to accommodate the current query. As you move from one query to the next, update your data structures to reflect the changes in the range.

5. **Output**: For each query, output the number of distinct elements in the range.

Here's a sample implementation in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <unordered_map>

using namespace std;

#define MAXN 30005
#define MAXQ 200005
#define BLOCK_SIZE 175 // Experiment with block size

struct Query {
    int id, l, r;
};

int freq[MAXN]; // frequency array to count occurrences of elements
int ans[MAXQ]; // to store the answer of each query
int arr[MAXN]; // input array
Query queries[MAXQ];

bool compare(Query a, Query b) {
    // Comparator function to sort queries based on the block
    if (a.l / BLOCK_SIZE != b.l / BLOCK_SIZE)
        return a.l / BLOCK_SIZE < b.l / BLOCK_SIZE;
    return a.r < b.r;
}

void add(int idx, int& cnt) {
    // Update data structures when including a new element at idx
    if (freq[arr[idx]] == 0)
        cnt++;
    freq[arr[idx]]++;
}

void remove(int idx, int& cnt) {
    // Update data structures when excluding an element at idx
    freq[arr[idx]]--;
    if (freq[arr[idx]] == 0)
        cnt--;
}

void processQueries(int n, int m) {
    sort(queries, queries + m, compare);
    
    int currL = 0, currR = -1;
    int distinctCount = 0;

    for (int i = 0; i < m; i++) {
        int L = queries[i].l;
        int R = queries[i].r;

        while (currL > L) {
            currL--;
            add(currL, distinctCount);
        }
        while (currR < R) {
            currR++;
            add(currR, distinctCount);
        }
        while (currL < L) {
            remove(currL, distinctCount);
            currL++;
        }
        while (currR > R) {
            remove(currR, distinctCount);
            currR--;
        }

        ans[queries[i].id] = distinctCount;
    }
}

int main() {
    int n, m;
    cin >> n;

    for (int i = 0; i < n; i++)
        cin >> arr[i];

    cin >> m;

    for (int i = 0; i < m; i++) {
        cin >> queries[i].l >> queries[i].r;
        queries[i].id = i;
    }

    processQueries(n, m);

    for (int i = 0; i < m; i++)
        cout << ans[i] << endl;

    return 0;
}
```

This code assumes that the maximum array size is 30005 and the maximum number of queries is 200005. Adjust these constants according to the constraints given in the problem statement. Additionally, you may need to modify the BLOCK_SIZE constant based on experimentation for optimal performance.

Remember to thoroughly test your implementation with various test cases to ensure correctness and efficiency.

### 1. Algorithms & Data Structures (C++): DQUERY using Fenwick Tree

Sure, let's discuss how to solve the "DQUERY" problem using Fenwick Tree (also known as Binary Indexed Tree or BIT) in C++.

The "DQUERY" problem is a classic problem on online judges like SPOJ. Here's a brief overview of the problem:

You are given an array of \( N \) integers. You have to answer \( Q \) queries. Each query is defined by two integers \( l \) and \( r \), and you need to find the number of distinct elements in the subarray \( A[l, r] \).

Here's how you can solve this problem efficiently using a Fenwick Tree:

1. Create a Fenwick Tree of size \( N \) to store the frequencies of elements in the array.
2. Initialize another array to keep track of the last occurrence of each element.
3. Process each query:
   - For each query \( l, r \), iterate from \( l \) to \( r \) and update the Fenwick Tree and the last occurrence array.
   - Count the distinct elements by subtracting the cumulative frequency at the last occurrence of each element before \( l \) from the cumulative frequency at \( r \).

Here's a sample implementation in C++:

```cpp
#include <iostream>
#include <vector>
#include <map>
using namespace std;

// Fenwick Tree class
class FenwickTree {
private:
    vector<int> tree;
public:
    FenwickTree(int size) : tree(size + 1, 0) {}

    void update(int index, int val) {
        for (; index < tree.size(); index += index & -index)
            tree[index] += val;
    }

    int query(int index) {
        int sum = 0;
        for (; index > 0; index -= index & -index)
            sum += tree[index];
        return sum;
    }
};

int main() {
    int n;
    cin >> n;

    vector<int> a(n + 1); // 1-indexed array
    map<int, int> last_occurrence;

    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        last_occurrence[a[i]] = 0; // Initialize last occurrence for each element
    }

    int q;
    cin >> q;

    vector<pair<int, pair<int, int>>> queries(q); // (index, (l, r))
    vector<int> result(q);

    for (int i = 0; i < q; ++i) {
        cin >> queries[i].second.first >> queries[i].second.second;
        queries[i].first = i;
    }

    sort(queries.begin(), queries.end());

    FenwickTree fenwick(n);
    int curr_index = 1;

    for (int i = 0; i < q; ++i) {
        auto [index, lr] = queries[i];
        int l = lr.first, r = lr.second;

        while (curr_index <= r) {
            if (last_occurrence[a[curr_index]] != 0) {
                fenwick.update(last_occurrence[a[curr_index]], -1);
            }
            last_occurrence[a[curr_index]] = curr_index;
            fenwick.update(curr_index, 1);
            curr_index++;
        }

        result[index] = fenwick.query(r) - fenwick.query(l - 1);
    }

    for (int i = 0; i < q; ++i) {
        cout << result[i] << endl;
    }

    return 0;
}
```

This code first reads the input array, then processes the queries one by one using Fenwick Tree to efficiently compute the number of distinct elements in each subarray. Finally, it prints the results of all queries.

### 1. Algorithms & Data Structures (C++): WebCrawler (core of search engines)

Building a web crawler, which is indeed at the core of many search engines, involves several key algorithms and data structures. Here's a basic outline of how you might implement a web crawler in C++, focusing on the core components:

#### Data Structures

1. **Graph Representation**: Websites and their links can be represented as a graph. You can use an adjacency list or adjacency matrix to represent this graph.

2. **Queue or Stack**: You'll need a data structure to store URLs that need to be crawled. A queue or a stack (depending on whether you want breadth-first or depth-first crawling) can be used for this purpose.

3. **Set or Hash Table**: To keep track of visited URLs and avoid revisiting them, you'll need a data structure to store visited URLs efficiently. A set or hash table is suitable for this.

#### Algorithms

1. **Breadth-First Search (BFS) or Depth-First Search (DFS)**: These are the core graph traversal algorithms that you'll use to visit web pages starting from a given seed URL. BFS is usually preferred for web crawling to ensure a more systematic exploration of the web.

2. **HTML Parsing**: You'll need an HTML parser to extract links from web pages. Libraries like libxml2 or Boost's Spirit parser can be helpful here.

3. **URL Normalization and Canonicalization**: URLs can have various formats and representations. Normalizing and canonicalizing URLs help in ensuring that duplicate URLs are detected accurately.

#### Steps

1. **Seed URL**: Start with a seed URL that you want to crawl.

2. **Fetch Web Page**: Fetch the HTML content of the seed URL.

3. **Parse HTML**: Extract links from the fetched HTML content.

4. **Normalize and Canonicalize URLs**: Normalize and canonicalize the extracted URLs to avoid duplicates.

5. **Add to Queue**: Add the extracted URLs to the queue (or stack) for further crawling.

6. **Repeat**: Repeat steps 2-5 until you reach the desired depth or until there are no more URLs to crawl.

7. **Store Data**: Store the crawled data (e.g., web page content, metadata) in a suitable data structure or database.

8. **Respect Robots.txt**: Follow the guidelines specified in the `robots.txt` file of websites to avoid crawling disallowed pages.

9. **Politeness**: Implement politeness policies to avoid overloading servers with requests. This may include adding delays between requests or limiting the number of requests per second.

10. **Error Handling**: Implement error handling mechanisms to deal with cases such as unreachable URLs, server errors, etc.

Here's a simplified example code snippet in C++ for a basic web crawler:

```cpp
#include <iostream>
#include <queue>
#include <set>
#include <string>

// Function to fetch HTML content of a URL
std::string fetchHTML(const std::string& url) {
    // Code to fetch HTML content from URL
}

// Function to extract links from HTML content
std::set<std::string> extractLinks(const std::string& html) {
    // Code to parse HTML and extract links
}

// Function to normalize and canonicalize URLs
std::string normalizeURL(const std::string& url) {
    // Code to normalize URL
}

void crawl(const std::string& seedURL, int maxDepth) {
    std::queue<std::string> urlQueue;
    std::set<std::string> visited;

    urlQueue.push(seedURL);
    visited.insert(seedURL);

    while (!urlQueue.empty() && maxDepth > 0) {
        std::string currentURL = urlQueue.front();
        urlQueue.pop();
        
        std::string html = fetchHTML(currentURL);
        std::set<std::string> links = extractLinks(html);

        for (const std::string& link : links) {
            std::string normalizedURL = normalizeURL(link);
            if (visited.find(normalizedURL) == visited.end()) {
                urlQueue.push(normalizedURL);
                visited.insert(normalizedURL);
            }
        }

        maxDepth--;
    }
}

int main() {
    std::string seedURL = "https://example.com";
    int maxDepth = 3;
    crawl(seedURL, maxDepth);
    return 0;
}
```

This is a very basic implementation. Real-world web crawlers would need to handle various edge cases, such as handling redirects, dealing with different types of links (relative, absolute, etc.), handling different content types, and respecting web standards and conventions. Additionally, concurrency and distributed crawling are also essential considerations for efficient web crawling at scale.

### 1. Algorithms & Data Structures (C++): MMI

MMI (Maximal Matching Interface) typically refers to a concept in graph theory and combinatorial optimization, particularly in the context of matching algorithms. In algorithms and data structures, it often relates to finding the largest possible matching in a graph.

Here's a basic approach to implement MMI in C++ using the maximum cardinality matching algorithm (e.g., using Ford-Fulkerson algorithm):

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <cstring>

using namespace std;

const int MAXN = 1005; // Maximum number of vertices

vector<int> adj[MAXN]; // Adjacency list representation

bool visited[MAXN];
int match[MAXN];

bool dfs(int u) {
    if (visited[u]) return false;
    visited[u] = true;
    for (int v : adj[u]) {
        if (match[v] == -1 || dfs(match[v])) {
            match[v] = u;
            return true;
        }
    }
    return false;
}

int maximumMatching(int n) {
    memset(match, -1, sizeof(match));
    int matching = 0;
    for (int i = 0; i < n; ++i) {
        memset(visited, false, sizeof(visited));
        if (dfs(i)) ++matching;
    }
    return matching;
}

int main() {
    int n, m; // Number of vertices and edges respectively
    cin >> n >> m;

    // Input edges
    for (int i = 0; i < m; ++i) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u); // Assuming undirected graph
    }

    // Compute maximal matching
    int matching = maximumMatching(n);

    cout << "Size of Maximal Matching: " << matching << endl;

    return 0;
}
```

In this implementation, `adj` is the adjacency list representation of the graph, and the `maximumMatching` function computes the size of the maximal matching using a DFS-based algorithm. The `main` function takes input for the graph and outputs the size of the maximal matching. You can further extend or optimize this code depending on your specific requirements and constraints.

### 1. Algorithms & Data Structures (C++): Surrounded Regions

The Surrounded Regions problem is a classic problem in algorithms and data structures. The problem usually involves a 2D grid of characters where some cells are filled with 'X' (representing walls) and some cells are filled with 'O' (representing regions). The task is to capture all regions surrounded by 'X' with 'O'.

Here's a typical approach to solve this problem using depth-first search (DFS) or breadth-first search (BFS) algorithms:

1. First, iterate through the border of the grid. For each 'O' cell found on the border, perform a DFS or BFS to mark all connected 'O' cells as safe (not surrounded by 'X').
2. Next, iterate through the entire grid. For each 'O' cell encountered:
   - If it's marked as safe, leave it as 'O' (not surrounded).
   - If it's not marked as safe, change it to 'X' (surrounded by 'X').

Here's a high-level implementation in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

void dfs(vector<vector<char>>& board, int i, int j) {
    int m = board.size();
    int n = board[0].size();

    if (i < 0 || j < 0 || i >= m || j >= n || board[i][j] != 'O')
        return;

    board[i][j] = 'Y'; // Mark as safe temporarily

    // Explore neighboring cells
    dfs(board, i + 1, j);
    dfs(board, i - 1, j);
    dfs(board, i, j + 1);
    dfs(board, i, j - 1);
}

void solve(vector<vector<char>>& board) {
    int m = board.size();
    if (m == 0) return;
    int n = board[0].size();

    // Mark safe cells connected to the border
    for (int i = 0; i < m; ++i) {
        dfs(board, i, 0);          // Left border
        dfs(board, i, n - 1);      // Right border
    }
    for (int j = 0; j < n; ++j) {
        dfs(board, 0, j);          // Top border
        dfs(board, m - 1, j);      // Bottom border
    }

    // Change remaining 'O's to 'X's and revert 'Y's back to 'O's
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            if (board[i][j] == 'O') board[i][j] = 'X';
            else if (board[i][j] == 'Y') board[i][j] = 'O';
        }
    }
}

// Helper function to print the board
void printBoard(const vector<vector<char>>& board) {
    for (const auto& row : board) {
        for (char cell : row) {
            cout << cell << " ";
        }
        cout << endl;
    }
}

int main() {
    vector<vector<char>> board = {
        {'X', 'X', 'X', 'X'},
        {'X', 'O', 'O', 'X'},
        {'X', 'X', 'O', 'X'},
        {'X', 'O', 'X', 'X'}
    };

    cout << "Original Board:" << endl;
    printBoard(board);

    solve(board);

    cout << "\nSurrounded Regions Board:" << endl;
    printBoard(board);

    return 0;
}
```

This code first marks all the safe 'O' regions connected to the border, then changes the remaining 'O's to 'X's as they are surrounded by 'X's, and finally reverts the temporarily marked 'Y's back to 'O's.

### 1. Algorithms & Data Structures (C++): Surrounded Regions - Graphs

The "Surrounded Regions" problem is a classic algorithmic problem where you're given a 2D board containing 'X's and 'O's. Your task is to capture all regions surrounded by 'X's. A region is captured by flipping all 'O's into 'X's if it's surrounded by 'X's.

To solve this problem efficiently, you can use graph traversal techniques like Depth-First Search (DFS) or Breadth-First Search (BFS). Here's a basic outline of how you can approach this problem using DFS:

1. **Traverse the boundary**: Start traversing the boundary of the board. Whenever you encounter an 'O', perform a DFS from that position to mark all connected 'O's as safe (not surrounded by 'X's). Mark them temporarily as something like 'Y'.

2. **Flip**: After traversing the boundary, iterate through the entire board. For every 'O' encountered, it means it's not connected to the boundary, so flip it to 'X'. And every 'Y' encountered, change it back to 'O' (as it's not surrounded by 'X's).

Here's a sample implementation in C++:

```cpp
#include <vector>

using namespace std;

// Helper function to perform DFS
void dfs(vector<vector<char>>& board, int i, int j) {
    if (i < 0 || i >= board.size() || j < 0 || j >= board[0].size() || board[i][j] != 'O') {
        return;
    }
    board[i][j] = 'Y'; // Mark the 'O' as safe temporarily
    // Explore its neighbors
    dfs(board, i + 1, j);
    dfs(board, i - 1, j);
    dfs(board, i, j + 1);
    dfs(board, i, j - 1);
}

void solve(vector<vector<char>>& board) {
    if (board.empty()) return;
    int rows = board.size();
    int cols = board[0].size();

    // Traverse the boundary and mark connected 'O's as safe
    for (int i = 0; i < rows; ++i) {
        dfs(board, i, 0);            // left side
        dfs(board, i, cols - 1);     // right side
    }
    for (int j = 0; j < cols; ++j) {
        dfs(board, 0, j);            // top side
        dfs(board, rows - 1, j);     // bottom side
    }

    // Flip the 'O's to 'X's and 'Y's back to 'O's
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            if (board[i][j] == 'O') {
                board[i][j] = 'X';
            } else if (board[i][j] == 'Y') {
                board[i][j] = 'O';
            }
        }
    }
}
```

This code performs a DFS traversal starting from the boundary cells, marking all 'O's connected to the boundary as 'Y'. Then, it iterates over the entire board, flipping 'O's to 'X's and 'Y's back to 'O's. This ensures that only 'O's that are not surrounded by 'X's are flipped.

### 1. Algorithms & Data Structures (C++): Connected Cities

Certainly! Let's discuss how to approach a problem involving connected cities using algorithms and data structures in C++.

#### Problem Statement

You have a list of cities and a list of connections between those cities. Each connection has a distance associated with it. You need to determine the shortest path between two given cities or whether it's even possible to travel between them.

#### Key Concepts

1. **Graph Representation:** Cities and their connections can be represented as a graph where cities are nodes and connections are edges.
2. **Shortest Path Algorithm:** Dijkstra’s algorithm or the A* algorithm are typically used to find the shortest path in weighted graphs.
3. **Graph Traversal:** Breadth-First Search (BFS) or Depth-First Search (DFS) can be used to determine if a path exists between two cities.

##### Graph Representation

We'll represent the graph using an adjacency list, which is efficient in terms of space and allows quick access to the neighbors of any node.

##### Implementation Plan

1. **Graph Class:** Create a class to represent the graph with methods to add edges and find the shortest path.
2. **Dijkstra’s Algorithm:** Implement Dijkstra's algorithm to find the shortest path between two cities.
3. **BFS/DFS:** Implement BFS or DFS to check if a path exists between two cities.

##### Example Code

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
#include <set>
#include <limits>
#include <utility>

class Graph {
public:
    // Add a connection (edge) between two cities (nodes)
    void addEdge(const std::string& city1, const std::string& city2, int distance) {
        adjList[city1].push_back({city2, distance});
        adjList[city2].push_back({city1, distance}); // Since the graph is undirected
    }

    // Dijkstra's algorithm to find the shortest path
    int shortestPath(const std::string& start, const std::string& end) {
        std::unordered_map<std::string, int> distances;
        for (const auto& pair : adjList) {
            distances[pair.first] = std::numeric_limits<int>::max();
        }
        distances[start] = 0;

        std::priority_queue<std::pair<int, std::string>, std::vector<std::pair<int, std::string>>, std::greater<>> pq;
        pq.push({0, start});

        while (!pq.empty()) {
            auto [currentDist, currentCity] = pq.top();
            pq.pop();

            if (currentCity == end) {
                return currentDist;
            }

            for (const auto& [neighbor, weight] : adjList[currentCity]) {
                int distance = currentDist + weight;
                if (distance < distances[neighbor]) {
                    distances[neighbor] = distance;
                    pq.push({distance, neighbor});
                }
            }
        }
        return -1; // Return -1 if there is no path from start to end
    }

    // BFS to check if a path exists between two cities
    bool pathExists(const std::string& start, const std::string& end) {
        std::set<std::string> visited;
        std::queue<std::string> q;
        q.push(start);

        while (!q.empty()) {
            std::string currentCity = q.front();
            q.pop();

            if (currentCity == end) {
                return true;
            }

            visited.insert(currentCity);

            for (const auto& [neighbor, _] : adjList[currentCity]) {
                if (visited.find(neighbor) == visited.end()) {
                    q.push(neighbor);
                }
            }
        }
        return false;
    }

private:
    std::unordered_map<std::string, std::vector<std::pair<std::string, int>>> adjList;
};

int main() {
    Graph g;
    g.addEdge("CityA", "CityB", 5);
    g.addEdge("CityB", "CityC", 3);
    g.addEdge("CityC", "CityD", 1);
    g.addEdge("CityA", "CityD", 10);

    std::string start = "CityA";
    std::string end = "CityD";

    int distance = g.shortestPath(start, end);
    if (distance != -1) {
        std::cout << "Shortest path from " << start << " to " << end << " is " << distance << std::endl;
    } else {
        std::cout << "No path exists between " << start << " and " << end << std::endl;
    }

    bool exists = g.pathExists(start, end);
    if (exists) {
        std::cout << "A path exists between " << start << " and " << end << std::endl;
    } else {
        std::cout << "No path exists between " << start << " and " << end << std::endl;
    }

    return 0;
}
```

##### Explanation

1. **Graph Class:**
   - `addEdge` method adds a bidirectional edge between two cities.
   - `shortestPath` method implements Dijkstra’s algorithm using a priority queue to find the shortest path between two cities.
   - `pathExists` method implements BFS to check if a path exists between two cities.

2. **Main Function:**
   - The main function demonstrates adding cities and connections, and then finding the shortest path and checking for path existence.

This example covers the basic functionalities needed for handling connected cities using C++ with a focus on graph algorithms.

### 1. Algorithms & Data Structures (C++): Exercise: Guess The Graph

#### Problem Statement

Given a hidden graph, you are tasked with guessing the structure of this graph. You can ask the system questions about the graph, such as the degree of a specific node, whether there is an edge between two nodes, and so on. Your goal is to reconstruct the graph with the fewest possible questions.

#### Steps to Implement the Exercise

1. **Define the Graph Class**: Create a class to represent the graph. This class will include methods to add edges, check for the existence of edges, get the degree of a node, etc.

2. **Question Interface**: Implement an interface for asking questions about the graph. This can be a set of functions that simulate the process of querying the hidden graph.

3. **Reconstruction Logic**: Write the logic to reconstruct the graph by asking a series of questions. This involves using the interface functions effectively to deduce the graph structure.

4. **Main Function**: Combine all the parts together in a main function where you simulate the guessing process.

Here’s a simplified example in C++:

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <queue>
using namespace std;

class Graph {
private:
    int V; // Number of vertices
    unordered_map<int, unordered_set<int>> adjList;

public:
    Graph(int V) : V(V) {}

    void addEdge(int u, int v) {
        adjList[u].insert(v);
        adjList[v].insert(u);
    }

    bool isEdge(int u, int v) {
        return adjList[u].find(v) != adjList[u].end();
    }

    int degree(int u) {
        return adjList[u].size();
    }

    vector<int> getNeighbors(int u) {
        vector<int> neighbors;
        for (int v : adjList[u]) {
            neighbors.push_back(v);
        }
        return neighbors;
    }

    int getVertices() const {
        return V;
    }
};

class GuessTheGraph {
private:
    Graph hiddenGraph;
    Graph guessedGraph;

public:
    GuessTheGraph(Graph &hiddenGraph) : hiddenGraph(hiddenGraph), guessedGraph(hiddenGraph.getVertices()) {}

    void reconstructGraph() {
        int V = hiddenGraph.getVertices();

        // Simple BFS to reconstruct the graph
        vector<bool> visited(V, false);
        queue<int> q;
        q.push(0); // Start from node 0
        visited[0] = true;

        while (!q.empty()) {
            int u = q.front();
            q.pop();

            int degree = hiddenGraph.degree(u);
            vector<int> neighbors = hiddenGraph.getNeighbors(u);

            for (int v : neighbors) {
                if (!visited[v]) {
                    guessedGraph.addEdge(u, v);
                    visited[v] = true;
                    q.push(v);
                }
            }
        }
    }

    void printGuessedGraph() {
        int V = guessedGraph.getVertices();
        for (int i = 0; i < V; ++i) {
            vector<int> neighbors = guessedGraph.getNeighbors(i);
            cout << "Node " << i << ": ";
            for (int neighbor : neighbors) {
                cout << neighbor << " ";
            }
            cout << endl;
        }
    }
};

int main() {
    int V = 5;
    Graph hiddenGraph(V);
    hiddenGraph.addEdge(0, 1);
    hiddenGraph.addEdge(0, 2);
    hiddenGraph.addEdge(1, 2);
    hiddenGraph.addEdge(1, 3);
    hiddenGraph.addEdge(3, 4);

    GuessTheGraph game(hiddenGraph);
    game.reconstructGraph();
    game.printGuessedGraph();

    return 0;
}
```

#### Explanation

1. **Graph Class**:
   - `addEdge`: Adds an edge between two vertices.
   - `isEdge`: Checks if there's an edge between two vertices.
   - `degree`: Returns the degree of a vertex.
   - `getNeighbors`: Returns a list of neighbors for a vertex.
   - `getVertices`: Returns the number of vertices.

2. **GuessTheGraph Class**:
   - **Constructor**: Initializes the hidden graph and a graph to store the guessed structure.
   - **reconstructGraph**: Uses BFS to reconstruct the graph. This is a simplified version; more sophisticated algorithms can be used to minimize the number of questions.
   - **printGuessedGraph**: Prints the structure of the guessed graph.

3. **Main Function**:
   - Creates a hidden graph.
   - Initializes the guessing game.
   - Reconstructs and prints the guessed graph.

#### Notes

- This implementation assumes that the graph is undirected.
- The `reconstructGraph` method uses BFS, which may not be optimal. Depending on the specific problem constraints, more efficient algorithms can be applied.
- This code provides a framework. Depending on your exact requirements, you might need to adjust the question interface and reconstruction logic.

### 1. Algorithms & Data Structures (C++): Graph: Find Star in the graph

To find a star in a graph using C++, you need to understand the properties of a star graph. A star graph is a type of graph where one central node is connected to all other nodes, and those other nodes have no connections between them. In other words, the central node has a degree of \( n-1 \) (where \( n \) is the total number of nodes in the graph), and all other nodes have a degree of 1.

Here's a step-by-step approach to find the star in the graph:

1. **Read the graph input**: This can be an adjacency list or an edge list.
2. **Calculate the degree of each node**: This involves counting the number of edges incident to each node.
3. **Identify the central node**: The central node will be the one with a degree of \( n-1 \).
4. **Verify the structure**: Ensure all other nodes have a degree of 1.

Let's write the C++ code for this process. We'll assume the graph is given as an edge list.

#### C++ Code

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>

using namespace std;

// Function to find the star node
int findStar(const vector<pair<int, int>>& edges, int n) {
    // Initialize a map to store the degree of each node
    unordered_map<int, int> degree;

    // Iterate over the edges to count degrees
    for (const auto& edge : edges) {
        degree[edge.first]++;
        degree[edge.second]++;
    }

    // Identify the central node (which has degree n-1)
    for (const auto& node : degree) {
        if (node.second == n - 1) {
            return node.first;
        }
    }

    // If no star node found, return -1 (invalid star graph)
    return -1;
}

int main() {
    // Number of nodes (example)
    int n = 5;

    // Edge list (example)
    vector<pair<int, int>> edges = {
        {1, 2}, {1, 3}, {1, 4}, {1, 5}
    };

    // Find the star node
    int starNode = findStar(edges, n);

    // Output the result
    if (starNode != -1) {
        cout << "The star node is: " << starNode << endl;
    } else {
        cout << "No star graph found." << endl;
    }

    return 0;
}
```

#### Explanation

1. **Data Structures**:
    - `vector<pair<int, int>> edges`: Stores the edges of the graph.
    - `unordered_map<int, int> degree`: Maps each node to its degree.

2. **Degree Calculation**:
    - Iterate through each edge and increment the degree for both nodes in the edge.

3. **Identify Central Node**:
    - Iterate through the degree map and find the node with degree \( n-1 \).

4. **Output**:
    - If a node with degree \( n-1 \) is found, it is the central node of the star graph.
    - If no such node is found, print that no star graph exists.

This algorithm works in \( O(E) \) time, where \( E \) is the number of edges, which is efficient for this problem. The space complexity is \( O(V) \), where \( V \) is the number of vertices, due to the degree map.

### 1. Algorithms & Data Structures (C++): Graph: Keys and Rooms

The "Keys and Rooms" problem is a common problem in graph theory and can be solved using various graph traversal techniques such as Depth-First Search (DFS) or Breadth-First Search (BFS). Here's the problem statement and how to solve it using DFS in C++.

#### Problem Statement

You are in a building with `n` rooms. Each room is numbered from `0` to `n-1` and each room may have some keys to access other rooms. Initially, you have access to room `0` only. Each room `i` has a list of keys `rooms[i]`, where each key `rooms[i][j]` is an integer representing the index of the room that you can access with that key. The goal is to determine if you can visit all the rooms.

#### Solution

We can represent the problem as a graph where rooms are nodes and keys are edges that connect these nodes. The problem then reduces to checking if all nodes (rooms) are reachable from the starting node (room 0).

Here is a C++ solution using Depth-First Search (DFS):

```cpp
#include <iostream>
#include <vector>
#include <stack>

using namespace std;

class Solution {
public:
    bool canVisitAllRooms(vector<vector<int>>& rooms) {
        int n = rooms.size();
        vector<bool> visited(n, false);
        stack<int> s;
        s.push(0);
        visited[0] = true;

        while (!s.empty()) {
            int current = s.top();
            s.pop();
            for (int key : rooms[current]) {
                if (!visited[key]) {
                    visited[key] = true;
                    s.push(key);
                }
            }
        }

        for (bool v : visited) {
            if (!v) return false;
        }
        return true;
    }
};

int main() {
    vector<vector<int>> rooms = {{1}, {2}, {3}, {}};
    Solution sol;
    bool result = sol.canVisitAllRooms(rooms);
    if (result) {
        cout << "All rooms can be visited." << endl;
    } else {
        cout << "Not all rooms can be visited." << endl;
    }
    return 0;
}
```

#### Explanation

1. **Graph Representation**: We use a vector of vectors to represent the graph, where `rooms[i]` contains the list of keys available in room `i`.

2. **DFS Initialization**: We use a stack for DFS. Initially, we push room `0` onto the stack and mark it as visited.

3. **DFS Traversal**: While the stack is not empty, we pop the top element to visit the current room. For each key in the current room, if the corresponding room has not been visited, we mark it as visited and push it onto the stack.

4. **Check All Rooms**: After the traversal, we check if all rooms have been visited by inspecting the `visited` vector.

#### Conclusion

This DFS approach ensures that we explore all reachable rooms starting from room `0`. If all rooms are marked as visited by the end of the traversal, we return `true`, indicating that all rooms can be visited. Otherwise, we return `false`.

You can also solve this problem using BFS in a similar manner, where you would use a queue instead of a stack.

### 1. Algorithms & Data Structures (C++): Flood Fill - Graphs

Flood fill is a common algorithm used in image processing and computer graphics to determine a region connected to a given node in a multi-dimensional array. It's typically used to determine the area connected to a certain point with the same color in a two-dimensional image or matrix.

Here's a basic implementation of flood fill in C++ using recursion:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Define directions: up, down, left, right
int dr[] = {-1, 1, 0, 0};
int dc[] = {0, 0, -1, 1};

// Function to perform flood fill
void floodFill(vector<vector<int>>& image, int sr, int sc, int newColor, int originalColor) {
    // Base case: if current pixel is out of bounds or not the original color, return
    if (sr < 0 || sr >= image.size() || sc < 0 || sc >= image[0].size() || image[sr][sc] != originalColor) {
        return;
    }
    
    // Change the color of the current pixel
    image[sr][sc] = newColor;
    
    // Recursively call flood fill for neighboring pixels
    for (int i = 0; i < 4; ++i) {
        floodFill(image, sr + dr[i], sc + dc[i], newColor, originalColor);
    }
}

int main() {
    // Example usage
    vector<vector<int>> image = {
        {1, 1, 1, 1, 1},
        {1, 1, 0, 0, 1},
        {1, 0, 1, 0, 1},
        {1, 0, 0, 1, 1},
        {1, 1, 1, 1, 1}
    };
    
    int sr = 2, sc = 2; // Starting position
    int newColor = 2;   // New color to fill
    int originalColor = image[sr][sc]; // Original color
    
    floodFill(image, sr, sc, newColor, originalColor);
    
    // Output the result
    for (const auto& row : image) {
        for (int val : row) {
            cout << val << " ";
        }
        cout << endl;
    }
    
    return 0;
}
```

In this implementation:

- `floodFill()` function performs the actual flood fill. It takes the image, starting row and column, the new color to fill, and the original color of the starting pixel.
- Base case checks if the current pixel is out of bounds or not of the original color.
- If the base case is not met, it changes the color of the current pixel and recursively calls `floodFill()` for its neighbors.
- `main()` function provides an example usage, defining an image as a 2D vector and performing flood fill from a starting point.

You can adjust the starting point, original color, and new color according to your requirements.

### 1. Algorithms & Data Structures (C++): Find the Town Judge

To find the town judge in a town where there may be a judge or not, you can use a graph-based approach. In this problem, each person in the town is represented by a node, and if person A trusts person B, there's a directed edge from A to B. The town judge is someone who is trusted by everyone else but trusts no one themselves. This means the town judge has an in-degree of N - 1 (where N is the number of people) and an out-degree of 0.

Here's a C++ implementation of the algorithm using adjacency lists:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int findJudge(int N, vector<vector<int>>& trust) {
    // Initialize vectors to store in-degree and out-degree of each person
    vector<int> inDegree(N + 1, 0); // 1-indexed
    vector<int> outDegree(N + 1, 0); // 1-indexed
    
    // Calculate in-degree and out-degree for each person
    for (const auto& t : trust) {
        outDegree[t[0]]++;
        inDegree[t[1]]++;
    }
    
    // Find the potential town judge
    for (int i = 1; i <= N; ++i) {
        if (inDegree[i] == N - 1 && outDegree[i] == 0) {
            return i; // Found the town judge
        }
    }
    
    return -1; // No town judge found
}

int main() {
    // Example usage
    int N = 4;
    vector<vector<int>> trust = {{1, 3}, {1, 4}, {2, 3}, {2, 4}, {4, 3}};
    cout << "The town judge is at position: " << findJudge(N, trust) << endl;
    
    return 0;
}
```

This code first calculates the in-degree and out-degree for each person based on the given trust relationships. Then, it iterates through each person to find the one with an in-degree of N - 1 and an out-degree of 0, which represents the town judge. If such a person is found, their position (index) is returned; otherwise, -1 is returned to indicate that there is no town judge.

### 1. Algorithms & Data Structures (C++): Graphs: Exercise: Check Balanced - LeetCode 110

LeetCode problem 110, "Check Balanced", is a classic problem in graph theory and can be solved using depth-first search (DFS). The problem asks you to determine whether a given undirected graph is a tree. A tree is a connected graph with no cycles.

Here's the general approach to solve this problem:

1. **Check for Cycle**: Use DFS to traverse the graph. While traversing, keep track of visited vertices and parent of each vertex. If you encounter a vertex that is already visited and it's not the parent of the current vertex, then there exists a cycle in the graph, and it cannot be a tree.

2. **Check for Connectivity**: After DFS traversal, check if all vertices are visited. If not, the graph is not connected, and hence not a tree.

3. **Final Check**: If the graph passes the above two conditions, it is a tree.

Here's a sample implementation in C++:

```cpp
#include <iostream>
#include <vector>
#include <unordered_set>

using namespace std;

class Graph {
    vector<vector<int>> adj;

public:
    Graph(int n) : adj(n) {}

    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    bool isCyclicUtil(int v, vector<bool>& visited, int parent) {
        visited[v] = true;
        for (int u : adj[v]) {
            if (!visited[u]) {
                if (isCyclicUtil(u, visited, v))
                    return true;
            } else if (u != parent) {
                return true;
            }
        }
        return false;
    }

    bool isCyclic() {
        vector<bool> visited(adj.size(), false);
        for (int i = 0; i < adj.size(); ++i) {
            if (!visited[i] && isCyclicUtil(i, visited, -1))
                return true;
        }
        return false;
    }

    bool isConnected() {
        vector<bool> visited(adj.size(), false);
        dfs(0, visited);
        for (bool v : visited) {
            if (!v) return false; // Not all vertices are reachable
        }
        return true;
    }

    void dfs(int v, vector<bool>& visited) {
        visited[v] = true;
        for (int u : adj[v]) {
            if (!visited[u]) {
                dfs(u, visited);
            }
        }
    }
};

bool isValidTree(int n, vector<vector<int>>& edges) {
    if (edges.size() != n - 1) return false; // Necessary condition for a tree
    Graph graph(n);
    for (auto& edge : edges) {
        graph.addEdge(edge[0], edge[1]);
    }
    if (graph.isCyclic()) return false;
    if (!graph.isConnected()) return false;
    return true;
}

int main() {
    int n = 5;
    vector<vector<int>> edges = {{0, 1}, {0, 2}, {0, 3}, {1, 4}};
    cout << (isValidTree(n, edges) ? "Valid Tree" : "Not a Valid Tree") << endl;
    return 0;
}
```

This implementation checks whether the given graph is a valid tree or not. The `isValidTree` function returns true if the graph is a valid tree, otherwise false.

### 1. Algorithms & Data Structures (C++): Graphs: Exercise: First Common Ancestor - LeetCode 236

The problem you're referring to, LeetCode problem 236, is a classic algorithmic problem involving binary trees, not graphs. The problem is commonly known as "Lowest Common Ancestor (LCA) of a Binary Tree."

Here's the problem statement:

Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.

The definition of the LCA is the lowest node in the tree that has both `p` and `q` as descendants (where we allow a node to be a descendant of itself).

To solve this problem, you can use various approaches such as recursive DFS (Depth-First Search), iterative DFS, or even BFS (Breadth-First Search).

Here's a general outline of how you can solve this problem recursively:

1. Start from the root of the binary tree.
2. If the root is null or equal to either `p` or `q`, return the root.
3. Recursively search for `p` and `q` in the left and right subtrees.
4. If both `p` and `q` are found in different subtrees, return the current root as the LCA.
5. If only one of `p` or `q` is found, return that node as a potential ancestor for further search.
6. If neither `p` nor `q` is found, return null.

Here's a simple recursive C++ implementation:

```cpp
#include <iostream>

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (!root || root == p || root == q)
            return root;

        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);

        if (left && right) // If both p and q are found in different subtrees
            return root;
        else if (left) // If only p or q is found in the left subtree
            return left;
        else if (right) // If only p or q is found in the right subtree
            return right;
        else // If neither p nor q is found
            return nullptr;
    }
};

int main() {
    // Example usage
    Solution solution;
    TreeNode* root = new TreeNode(3);
    root->left = new TreeNode(5);
    root->right = new TreeNode(1);
    root->left->left = new TreeNode(6);
    root->left->right = new TreeNode(2);
    root->left->right->left = new TreeNode(7);
    root->left->right->right = new TreeNode(4);
    root->right->left = new TreeNode(0);
    root->right->right = new TreeNode(8);

    TreeNode* p = root->left;
    TreeNode* q = root->right;

    TreeNode* lca = solution.lowestCommonAncestor(root, p, q);
    if (lca)
        std::cout << "Lowest Common Ancestor: " << lca->val << std::endl;
    else
        std::cout << "No common ancestor found." << std::endl;

    // Don't forget to free the memory allocated for the tree nodes
    return 0;
}
```

This implementation will find the lowest common ancestor of the given two nodes `p` and `q` in the binary tree.

### 1. Algorithms & Data Structures (C++): Solving maze routing problems

Solving maze routing problems involves finding a path from the starting point to the destination within a maze, navigating through obstacles. Here's a high-level approach using C++ and common algorithms and data structures:

1. **Representing the Maze**:
   - You can represent the maze as a 2D grid. Each cell can represent a passage or a wall.
   - Define a data structure to represent the maze. You can use a 2D array or a vector of vectors in C++.

2. **Depth-First Search (DFS)** or **Breadth-First Search (BFS)**:
   - Both DFS and BFS are popular algorithms for traversing graphs.
   - DFS explores as far as possible along each branch before backtracking.
   - BFS explores the neighbor nodes at the current depth before moving on to nodes at the next depth.
   - Choose DFS if you want to explore as deep as possible before backtracking, or BFS if you want to find the shortest path.

3. **Algorithm Steps**:
   - Start from the entrance of the maze.
   - Explore adjacent cells.
   - If a cell is unvisited and accessible, mark it as visited and continue exploration.
   - Repeat until reaching the destination or all accessible cells have been explored.

4. **Backtracking**:
   - When using DFS, if you reach a dead end, backtrack to the last junction and explore another path.
   - Use a stack to keep track of the path during DFS.

5. **Queue for BFS**:
   - Use a queue to implement BFS. When exploring a cell, enqueue its neighboring cells.

6. **Path Finding**:
   - Once you reach the destination, trace back the path from the destination to the start.
   - This can be done by storing the parent of each cell during traversal.

7. **Implementation** (Basic Pseudocode):

```cpp
// Pseudocode for DFS

DFS(maze, start, end):
    stack.push(start)
    while stack is not empty:
        current = stack.top()
        stack.pop()
        if current == end:
            // Path found
            return path
        mark current as visited
        for each neighbor of current:
            if neighbor is accessible and not visited:
                stack.push(neighbor)
                set parent of neighbor to current
    // No path found
    return empty path

// Pseudocode for BFS

BFS(maze, start, end):
    queue.enqueue(start)
    while queue is not empty:
        current = queue.front()
        queue.dequeue()
        if current == end:
            // Path found
            return path
        mark current as visited
        for each neighbor of current:
            if neighbor is accessible and not visited:
                queue.enqueue(neighbor)
                set parent of neighbor to current
    // No path found
    return empty path
```

1. **Optimizations**:
   - Use memoization or dynamic programming to avoid redundant computations.
   - Implement heuristics if you want to use A* search for more efficient pathfinding.

1. **Testing**:
   - Test your implementation with various maze configurations, including mazes with multiple solutions or no solution at all.

1. **Error Handling**:

- Handle cases where the start or end points are invalid, or the maze is not navigable.

By following these steps and using appropriate algorithms and data structures, you can effectively solve maze routing problems in C++.
