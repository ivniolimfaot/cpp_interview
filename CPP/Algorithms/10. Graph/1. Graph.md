
### 1. Algorithms & Data Structures (C++): Data Structure : Graph

A graph is a collection of nodes (or vertices) connected by edges. Graphs can represent various real-world and abstract concepts like social networks, computer networks, transportation systems, and more.

#### Types of Graphs

1. **Undirected Graph**: Edges have no direction. If there is an edge between vertex \( u \) and vertex \( v \), you can traverse it in both directions.
2. **Directed Graph (Digraph)**: Edges have a direction. If there is an edge from vertex \( u \) to vertex \( v \), you can only traverse from \( u \) to \( v \).

#### Properties of Graphs

1. **Vertices (V)**: The nodes in the graph.
2. **Edges (E)**: The connections between the nodes.
3. **Degree**: Number of edges incident to a vertex. For directed graphs, this includes:
   - **In-degree**: Number of incoming edges to a vertex.
   - **Out-degree**: Number of outgoing edges from a vertex.
4. **Path**: A sequence of vertices where each adjacent pair is connected by an edge.
5. **Cycle**: A path that starts and ends at the same vertex, with all edges and vertices distinct (except for the start/end vertex).
6. **Connected Graph**: There's a path between any pair of vertices (in undirected graphs).
7. **Strongly Connected Graph**: In directed graphs, there's a path between any pair of vertices in both directions.
8. **Weight**: Some graphs have weights assigned to edges, representing costs, lengths, or capacities.

#### Graph Representations in C++

1. **Adjacency Matrix**
   - A 2D array of size \( V \times V \) where an element \( matrix[i][j] \) indicates the presence (and possibly weight) of an edge between vertices \( i \) and \( j \).
   - Space complexity: \( O(V^2) \)

2. **Adjacency List**
   - An array of lists. The list at index \( i \) contains all vertices connected to vertex \( i \).
   - Space complexity: \( O(V + E) \)

3. **Edge List**
   - A list of all edges, where each edge is represented as a pair or tuple \( (u, v, weight) \).
   - Space complexity: \( O(E) \)

### 1. Algorithms & Data Structures (C++): Graph Key Concepts

Graphs are fundamental data structures used to represent relationships between pairs of objects. In C++, you can implement graphs using various techniques, such as adjacency matrix, adjacency list, or an edge list. Here are some key concepts related to graphs and their implementation in C++:

1. **Graph Representation**:
   - **Adjacency Matrix**: A 2D array where each cell (i, j) represents whether there is an edge between vertices i and j.
   - **Adjacency List**: A vector or array of lists/arrays where each list/array contains the neighbors of a vertex.
   - **Edge List**: A list of tuples (or pairs) representing edges and optionally their weights.

2. **Graph Traversal**:
   - **Breadth-First Search (BFS)**: Visit nodes level by level starting from a source vertex.
   - **Depth-First Search (DFS)**: Explore as far as possible along each branch before backtracking.

3. **Shortest Path Algorithms**:
   - **Dijkstra's Algorithm**: Finds the shortest path from a source node to all other nodes in a weighted graph.
   - **Bellman-Ford Algorithm**: Computes the shortest paths from a single source vertex to all other vertices in a weighted graph, even if it contains negative weight edges.
   - **Floyd-Warshall Algorithm**: Finds the shortest paths between all pairs of vertices in a weighted graph.

4. **Minimum Spanning Tree (MST)**:
   - **Kruskal's Algorithm**: Finds the minimum spanning tree of a connected, undirected graph.
   - **Prim's Algorithm**: Another algorithm to find the minimum spanning tree.

5. **Topological Sorting**: Arranges the vertices of a directed acyclic graph (DAG) into a linear ordering such that for every directed edge uv from vertex u to vertex v, u comes before v in the ordering.

6. **Graph Coloring**: Assigns colors to the vertices of a graph in such a way that no two adjacent vertices have the same color.

7. **Strongly Connected Components (SCC)**:
   - **Kosaraju's Algorithm**: Finds all strongly connected components in a directed graph.

8. **Applications**:
   - Graphs are used to model networks, social networks, transportation systems, etc.
   - Google Maps uses graph algorithms to find the shortest path between two locations.
   - Social media platforms use graph algorithms for friend recommendations.

When implementing these algorithms in C++, you'll typically use data structures like vectors, arrays, priority queues, and possibly custom data structures for efficient graph manipulation and traversal. Additionally, you might need to implement classes for vertices and edges depending on the complexity of your graph operations.

### 1. Algorithms & Data Structures (C++): Applications of graphs

Graphs are incredibly versatile data structures with numerous applications across various domains. Some common applications of graphs include:

1. **Social Networks**: Social media platforms like Facebook, Twitter, and LinkedIn utilize graphs to represent connections between users. Nodes represent individuals, and edges represent relationships or interactions between them.

2. **Network Routing**: Graphs are used to model networks of interconnected devices, such as the internet or transportation systems. Routing algorithms like Dijkstra's or Bellman-Ford algorithm are applied to find the shortest path between nodes.

3. **Recommendation Systems**: Graphs can be employed to model user-item interactions in recommendation systems. Nodes represent users and items, and edges represent user-item interactions. Algorithms like collaborative filtering or personalized PageRank can then be applied to make recommendations.

4. **Geographical Information Systems (GIS)**: Graphs are used to model geographical data, such as maps and road networks. Routing algorithms are applied to find the shortest or fastest path between locations.

5. **Computer Networks**: Graphs are used to model computer networks, where nodes represent devices like computers or routers, and edges represent connections between them. Graph algorithms are applied for tasks such as network topology analysis, routing, and network flow optimization.

6. **Circuit Design**: Graphs are used to model electrical circuits, where components like resistors, capacitors, and transistors are represented as nodes, and connections between them as edges. Graph algorithms are applied to analyze circuit properties and optimize designs.

7. **E-commerce**: Graphs can be used to model relationships between products, customers, and transactions in e-commerce platforms. Algorithms are applied for tasks like product recommendation, fraud detection, and customer segmentation.

8. **Bioinformatics**: Graphs are used to model biological data, such as protein-protein interactions, genetic pathways, and evolutionary relationships. Graph algorithms are applied for tasks like identifying functional modules in protein networks, predicting protein structures, and analyzing genetic sequences.

9. **Natural Language Processing (NLP)**: Graphs are used to represent relationships between words or documents in text data. Algorithms like PageRank or community detection are applied for tasks like document clustering, sentiment analysis, and information retrieval.

10. **Game Development**: Graphs are used to model game worlds, where nodes represent game objects like characters, items, and locations, and edges represent relationships or interactions between them. Graph algorithms are applied for tasks like pathfinding, AI behavior modeling, and game state analysis.

These are just a few examples of the wide-ranging applications of graphs in various fields. The flexibility and power of graph algorithms make them indispensable tools for solving complex problems across domains.

### 1. Algorithms & Data Structures (C++): Graph: Big O

The Big O notation for algorithms and data structures can vary depending on the specific operations being performed and the underlying implementation. For graphs in C++, here are some common operations and their typical Big O complexities:

1. **Space Complexity:**
   - The space complexity of a graph is typically O(V + E), where V is the number of vertices and E is the number of edges. This accounts for the space required to store the vertices and edges, often in adjacency lists or matrices.

2. **Time Complexity:**
   - **Adding/Removing a Vertex:** O(1) to O(V) - Adding or removing a vertex can require updating adjacency lists or matrices. In the worst case, removing a vertex might require updating all edges.
   - **Adding/Removing an Edge:** O(1) to O(V) - Adding or removing an edge might involve updating adjacency lists or matrices. In the worst case, adding or removing an edge might require updating all edges connected to the vertex.
   - **Finding if an Edge Exists:** O(degree) - In adjacency lists, it's typically O(degree), where degree is the number of edges incident to a vertex. In adjacency matrices, it's O(1).
   - **Traversing all Vertices/Edges:** O(V + E) - Traversing all vertices or edges typically involves visiting each vertex once and each edge once, which gives O(V + E) time complexity.
   - **Depth-First Search (DFS) and Breadth-First Search (BFS):** O(V + E) - Both DFS and BFS visit each vertex and edge once, giving O(V + E) time complexity.
   - **Shortest Path Algorithms (e.g., Dijkstra's, Bellman-Ford):** O((V + E) log V) - For Dijkstra's algorithm with a binary heap, and O(VE) for Bellman-Ford. These algorithms typically involve visiting each vertex and edge, with additional operations for updating priority queues or distance arrays.
   - **Minimum Spanning Tree Algorithms (e.g., Prim's, Kruskal's):** O(E log V) - For Prim's algorithm with a binary heap, and O(E log E) for Kruskal's algorithm with sorting. These algorithms involve sorting edges and/or maintaining priority queues.

These complexities are based on typical implementations and assumptions. Actual performance can vary based on factors like the specific graph structure, the chosen algorithm, and the efficiency of underlying data structures.

### 1. Algorithms & Data Structures (C++): Types Of Graphs

Graphs are fundamental data structures used to model pairwise relations between objects. In the context of C++ and computer science in general, graphs are used in a variety of applications, from representing networks to solving complex problems. Here are the main types of graphs:

#### 1. **Directed vs. Undirected Graphs**

- **Directed Graph (Digraph):**
  - Edges have a direction, indicating a one-way relationship.
  - Example: Twitter follows, where an edge from node A to node B means A follows B.
  
- **Undirected Graph:**
  - Edges have no direction, indicating a two-way relationship.
  - Example: Facebook friendships, where an edge between node A and node B means A and B are friends.

#### 2. **Weighted vs. Unweighted Graphs**

- **Weighted Graph:**
  - Edges have weights, which represent the cost, distance, or any quantitative value between nodes.
  - Example: Road networks, where the weight of an edge might represent the distance between two cities.

- **Unweighted Graph:**
  - Edges do not have weights; all edges are considered equal.
  - Example: Simple social networks where the presence or absence of an edge is the only information.

- For unweighted graphs, you can represent the graph using adjacency lists or adjacency matrices. Since all edges have the same weight, you don't need to store weights explicitly.
- For weighted graphs, you typically use adjacency lists to represent the graph structure efficiently, and you'll need to store the weights along with the vertices and edges.

#### 3. **Connected vs. Disconnected Graphs**

- **Connected Graph:**
  - There is a path between any pair of vertices.
  - Example: A computer network where each computer can communicate with any other computer.

- **Disconnected Graph:**
  - At least one pair of vertices has no path between them.
  - Example: Two separate islands, each with its own network of bridges.

#### 4. **Cyclic vs. Acyclic Graphs**

- **Cyclic Graph:**
  - Contains at least one cycle, a path where the first and last vertices are the same.
  - Example: A transportation network with a circular route.

- **Acyclic Graph:**
  - Does not contain any cycles.
  - Example: A family tree, which is a directed acyclic graph (DAG).

#### 5. **Trees and Forests**

- **Tree:**
  - A special type of acyclic, connected graph.
  - Has a hierarchical structure with a single root and no cycles.
  - Example: Organizational charts.

- **Forest:**
  - A collection of disjoint trees.
  - Example: Multiple separate family trees.

#### 6. **Bipartite Graphs**

- **Bipartite Graph:**
  - Vertices can be divided into two disjoint sets such that every edge connects a vertex in one set to a vertex in the other set.
  - Example: Job assignment problems where one set represents jobs and the other represents workers.

#### 7. **Complete Graphs**

- **Complete Graph (Kn):**
  - Every pair of distinct vertices is connected by a unique edge.
  - Example: A fully connected network where every node is connected to every other node.

#### 8. **Subgraphs**

- **Subgraph:**
  - A subset of a graph's vertices and edges forming a graph.
  - Example: A specific section of a social network graph.

  Subgraphs can be categorized based on the relationships between their vertices and edges:

    1. **Induced Subgraph**: An induced subgraph of G is obtained by including all vertices and edges of G that belong to a subset of vertices. In other words, an induced subgraph is formed by taking a subset of vertices and including all edges between those vertices that exist in the original graph.
    2. **Spanning Subgraph**: A spanning subgraph of G is a subgraph that contains all the vertices of G. In other words, it's a subgraph that covers every vertex in the original graph.

#### 9. **Planar Graphs**

- **Planar Graph:**
  - Can be drawn on a plane without any edges crossing.
  - Example: Road maps.

#### 10. **Dense vs. Sparse Graphs**

- **Dense Graph:**
  - A graph with a relatively high number of edges.
  - Example: A network where almost every node is connected to almost every other node.

- **Sparse Graph:**
  - A graph with relatively few edges.
  - Example: A large road network with few direct routes between cities.

### 1. Algorithms & Data Structures (C++): Graphs: Connected Components

In an undirected graph, a connected component is a maximal subgraph in which any two vertices are connected to each other by paths, and which is connected to no additional vertices in the supergraph.

#### Identifying Connected Components

To find connected components in a graph, we typically use Depth-First Search (DFS) or Breadth-First Search (BFS). Here’s a step-by-step approach:

1. **Representation**: Represent the graph using an adjacency list.
2. **Visited Array**: Keep track of visited nodes to avoid cycles and reprocessing.
3. **DFS/BFS**: Use DFS or BFS to explore all nodes in a component starting from an unvisited node.

#### Implementation in C++

Here's a simple implementation using DFS:

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to perform DFS
void DFS(int node, const vector<vector<int>>& adj, vector<bool>& visited) {
    visited[node] = true;
    for (int neighbor : adj[node]) {
        if (!visited[neighbor]) {
            DFS(neighbor, adj, visited);
        }
    }
}

// Function to find connected components
int findConnectedComponents(int n, const vector<vector<int>>& adj) {
    vector<bool> visited(n, false);
    int count = 0;
    for (int i = 0; i < n; ++i) {
        if (!visited[i]) {
            DFS(i, adj, visited);
            ++count; // New connected component found
        }
    }
    return count;
}

int main() {
    // Number of vertices
    int n = 7;
    // Adjacency list of the graph
    vector<vector<int>> adj = {
        {1, 2},    // edges from node 0
        {0, 3},    // edges from node 1
        {0},       // edges from node 2
        {1},       // edges from node 3
        {5, 6},    // edges from node 4
        {4},       // edges from node 5
        {4}        // edges from node 6
    };

    // Find and print the number of connected components
    int connectedComponents = findConnectedComponents(n, adj);
    cout << "Number of connected components: " << connectedComponents << endl;

    return 0;
}
```

#### Explanation

1. **DFS Function**: Recursively visits all the vertices connected to a given vertex.
2. **findConnectedComponents Function**: Iterates through all vertices, and if a vertex hasn't been visited, starts a DFS from it, marking all reachable vertices. Each DFS call signifies a new connected component.
3. **Main Function**: Defines the graph and calls the function to count connected components.

#### Example

Given the adjacency list:

- Node 0 is connected to nodes 1 and 2.
- Node 1 is connected to nodes 0 and 3.
- Node 2 is connected to node 0.
- Node 3 is connected to node 1.
- Node 4 is connected to nodes 5 and 6.
- Node 5 is connected to node 4.
- Node 6 is connected to node 4.

The graph has two connected components:

1. Component 1: Nodes 0, 1, 2, 3
2. Component 2: Nodes 4, 5, 6

#### Conclusion

Understanding connected components helps in various applications, from network analysis to image processing. This simple DFS-based approach in C++ demonstrates how to identify and count the number of connected components in an undirected graph.

### 1. Algorithms & Data Structures (C++): Graph Representation

#### 1. Adjacency Matrix

An adjacency matrix is a 2D array where each cell represents the presence or absence of an edge between vertices.

```cpp
#include <iostream>
#include <vector>

using namespace std;

class Graph {
private:
    vector<vector<int>> adjMatrix;
    int numVertices;

public:
    Graph(int vertices) {
        numVertices = vertices;
        adjMatrix.resize(vertices, vector<int>(vertices, 0));
    }

    void addEdge(int i, int j) {
        adjMatrix[i][j] = 1;
        adjMatrix[j][i] = 1; // Remove this line for directed graphs
    }

    void removeEdge(int i, int j) {
        adjMatrix[i][j] = 0;
        adjMatrix[j][i] = 0; // Remove this line for directed graphs
    }

    bool isEdge(int i, int j) {
        return adjMatrix[i][j] == 1;
    }

    void display() {
        for (int i = 0; i < numVertices; ++i) {
            for (int j = 0; j < numVertices; ++j) {
                cout << adjMatrix[i][j] << " ";
            }
            cout << endl;
        }
    }
};

int main() {
    Graph g(4);

    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 2);
    g.addEdge(2, 3);

    g.display();

    return 0;
}
```

#### 2. Adjacency List

An adjacency list represents a graph as an array of lists, where each list contains the vertices adjacent to a specific vertex.

```cpp
#include <iostream>
#include <vector>
#include <list>

using namespace std;

class Graph {
private:
    vector<list<int>> adjList;
    int numVertices;

public:
    Graph(int vertices) {
        numVertices = vertices;
        adjList.resize(vertices);
    }

    void addEdge(int i, int j) {
        adjList[i].push_back(j);
        adjList[j].push_back(i); // Remove this line for directed graphs
    }

    void removeEdge(int i, int j) {
        adjList[i].remove(j);
        adjList[j].remove(i); // Remove this line for directed graphs
    }

    bool isEdge(int i, int j) {
        for (int vertex : adjList[i]) {
            if (vertex == j) {
                return true;
            }
        }
        return false;
    }

    void display() {
        for (int i = 0; i < numVertices; ++i) {
            cout << i << ": ";
            for (int vertex : adjList[i]) {
                cout << vertex << " ";
            }
            cout << endl;
        }
    }
};

int main() {
    Graph g(4);

    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 2);
    g.addEdge(2, 3);

    g.display();

    return 0;
}
```

#### 3. Edge List

An edge list represents a graph as a list of edges, where each edge is a pair (or triplet for weighted graphs) of vertices.

```cpp
#include <iostream>
#include <vector>

using namespace std;

class Graph {
private:
    vector<pair<int, int>> edgeList;
    int numVertices;

public:
    Graph(int vertices) {
        numVertices = vertices;
    }

    void addEdge(int i, int j) {
        edgeList.push_back({i, j});
    }

    void removeEdge(int i, int j) {
        for (auto it = edgeList.begin(); it != edgeList.end(); ++it) {
            if (it->first == i && it->second == j) {
                edgeList.erase(it);
                break;
            }
        }
    }

    bool isEdge(int i, int j) {
        for (const auto& edge : edgeList) {
            if (edge.first == i && edge.second == j) {
                return true;
            }
        }
        return false;
    }

    void display() {
        for (const auto& edge : edgeList) {
            cout << "(" << edge.first << ", " << edge.second << ")" << endl;
        }
    }
};

int main() {
    Graph g(4);

    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 2);
    g.addEdge(2, 3);

    g.display();

    return 0;
}
```

### Summary of Graph Representations

| Representation  | Space Complexity | Add Edge | Remove Edge | Check Edge | Best Use Case      |
|-----------------|------------------|----------|-------------|------------|--------------------|
| Adjacency Matrix| \( O(V^2) \)     | \( O(1) \)| \( O(1) \)  | \( O(1) \) | Dense graphs       |
| Adjacency List  | \( O(V + E) \)   | \( O(1) \)| \( O(V) \)  | \( O(V) \) | Sparse graphs      |
| Edge List       | \( O(E) \)       | \( O(1) \)| \( O(E) \)  | \( O(E) \) | Iterating edges, Kruskal's algorithm|

Each graph representation has its advantages and is suitable for different types of operations and graph densities. The choice of representation depends on the specific requirements of the graph operations you need to perform.

### 1. Algorithms & Data Structures (C++): Graph Representations: Packed Adjacency List

The **Packed Adjacency List** representation is a compact way of storing graph data. It reduces the overhead associated with storing adjacency lists separately for each vertex. Instead, all adjacency lists are concatenated into a single contiguous array, with an additional array used to mark the boundaries of these lists.

#### Components

1. **Adjacency Array (`adj`)**: A single array that contains all the adjacency lists concatenated together.
2. **Offset Array (`offset`)**: An array where each element marks the starting index in the `adj` array for the corresponding vertex's adjacency list.

##### Example

Consider the following directed graph:

```bash
0: 1, 2
1: 2
2: 0, 3
3: 3
```

- **Vertices**: 0, 1, 2, 3
- **Edges**: (0->1), (0->2), (1->2), (2->0), (2->3), (3->3)

##### Adjacency Lists

```bash
0: [1, 2]
1: [2]
2: [0, 3]
3: [3]
```

##### Packed Adjacency List Representation

- **Adjacency Array (`adj`)**: [1, 2, 2, 0, 3, 3]
- **Offset Array (`offset`)**: [0, 2, 3, 5]

Here, `offset[i]` gives the starting index in `adj` for the adjacency list of vertex `i`.

#### C++ Implementation

Below is a C++ implementation of the Packed Adjacency List representation.

```cpp
#include <iostream>
#include <vector>

class PackedAdjacencyList {
private:
    std::vector<int> adj;
    std::vector<int> offset;
    int numVertices;

public:
    PackedAdjacencyList(int n) : numVertices(n), offset(n + 1, 0) {}

    void addEdge(int u, int v) {
        adj.push_back(v);
        offset[u + 1]++;
    }

    void finalize() {
        for (int i = 1; i <= numVertices; ++i) {
            offset[i] += offset[i - 1];
        }
    }

    void print() const {
        std::cout << "Adjacency Array: ";
        for (int v : adj) {
            std::cout << v << " ";
        }
        std::cout << "\nOffset Array: ";
        for (int o : offset) {
            std::cout << o << " ";
        }
        std::cout << "\n";
    }

    std::vector<int> getNeighbors(int u) const {
        std::vector<int> neighbors;
        for (int i = offset[u]; i < offset[u + 1]; ++i) {
            neighbors.push_back(adj[i]);
        }
        return neighbors;
    }
};

int main() {
    int numVertices = 4;
    PackedAdjacencyList graph(numVertices);

    // Adding edges
    graph.addEdge(0, 1);
    graph.addEdge(0, 2);
    graph.addEdge(1, 2);
    graph.addEdge(2, 0);
    graph.addEdge(2, 3);
    graph.addEdge(3, 3);

    // Finalize to compute offsets
    graph.finalize();

    // Print the packed adjacency list representation
    graph.print();

    // Get and print neighbors of vertex 2
    std::vector<int> neighbors = graph.getNeighbors(2);
    std::cout << "Neighbors of vertex 2: ";
    for (int n : neighbors) {
        std::cout << n << " ";
    }
    std::cout << "\n";

    return 0;
}
```

#### Explanation

1. **Initialization**: The constructor initializes the `numVertices` and sets up the `offset` array with one extra element (to handle the end boundary).

2. **Adding Edges**: The `addEdge` function appends the destination vertex to the `adj` array and increments the count in the `offset` array for the start vertex.

3. **Finalizing**: The `finalize` function computes the cumulative sums in the `offset` array to determine the starting indices of each vertex's adjacency list.

4. **Printing**: The `print` function outputs the `adj` and `offset` arrays.

5. **Retrieving Neighbors**: The `getNeighbors` function retrieves the adjacency list for a given vertex using the `offset` array to find the correct indices in the `adj` array.

This approach ensures that the graph is stored compactly, minimizing memory usage while still allowing efficient access to each vertex's adjacency list.

### 1. Algorithms & Data Structures (C++): Comparison Of Graph Representations

In C++, graphs can be represented in various ways, each with its advantages and disadvantages. The choice of representation depends on factors like the type of graph (directed or undirected), the operations to be performed frequently, and memory constraints. Here's a comparison of common graph representations:

1. **Adjacency Matrix:**
   - A 2D array of size V x V (where V is the number of vertices).
   - If graph is weighted, matrix stores weights of edges, otherwise 0 or 1 indicating presence or absence of edge.
   - Pros:
     - Simple to implement.
     - Easy to access the weight of an edge between two vertices.
     - Checking whether there is an edge between two vertices takes O(1) time.
   - Cons:
     - Consumes more space for sparse graphs (graphs with fewer edges).
     - Adding or removing vertices is costly (O(V^2)).
     - Iterating over all edges takes O(V^2) time.

2. **Adjacency List:**
   - Array of lists, where each element is a list of vertices adjacent to the corresponding vertex.
   - Can be implemented using arrays, vectors, or linked lists.
   - Pros:
     - Memory efficient for sparse graphs.
     - Adding or removing vertices/edges is efficient (O(1) or O(E)).
     - Iterating over all edges takes O(V + E) time.
   - Cons:
     - Accessing the weight of an edge between two vertices might be slower compared to adjacency matrix.
     - Less convenient for dense graphs.

3. **Edge List:**
   - A list of edges, where each edge is represented as a pair (u, v) denoting an edge between vertex u and vertex v.
   - Can be augmented with a third element for weighted graphs.
   - Pros:
     - Very memory efficient for sparse graphs.
     - Efficient for certain algorithms like Kruskal's Minimum Spanning Tree algorithm.
   - Cons:
     - Checking for existence of an edge between two vertices may require traversing the entire list.
     - Not suitable for algorithms requiring quick access to adjacent vertices.

4. **Compact Representations (Bitsets, Bitboards, etc.):**
   - Especially useful for very dense graphs or specialized scenarios.
   - Pros:
     - Extremely memory efficient for large, dense graphs.
     - Fast bitwise operations for certain graph algorithms.
   - Cons:
     - Limited to certain types of graphs and operations.
     - Implementations can be complex and require careful handling.

The choice of representation depends heavily on the characteristics of the graph and the operations you intend to perform on it. For example, if memory is a concern and the graph is sparse, an adjacency list might be preferable. If the graph is dense and memory isn't a concern, an adjacency matrix might be more efficient.

### 1. Algorithms & Data Structures (C++): Graph Representations: Directed Graph

A directed graph (or digraph) is a set of vertices connected by edges, where the edges have a direction associated with them. This means if there is an edge from vertex \( u \) to vertex \( v \), it does not imply there is an edge from vertex \( v \) to vertex \( u \).

The two most common ways to represent a directed graph are:

1. **Adjacency Matrix**
2. **Adjacency List**

#### Adjacency Matrix

An adjacency matrix is a 2D array where the element at row \( i \) and column \( j \) is `1` if there is a directed edge from vertex \( i \) to vertex \( j \), and `0` otherwise.

##### Example

Consider a directed graph with vertices \( V = \{0, 1, 2, 3\} \) and edges \( E = \{(0, 1), (1, 2), (2, 0), (2, 3)\} \).

The adjacency matrix would be:

\[
\begin{array}{c|cccc}
  & 0 & 1 & 2 & 3 \\
\hline
0 & 0 & 1 & 0 & 0 \\
1 & 0 & 0 & 1 & 0 \\
2 & 1 & 0 & 0 & 1 \\
3 & 0 & 0 & 0 & 0 \\
\end{array}
\]

##### C++ Implementation

```cpp
#include <iostream>
#include <vector>

#define V 4

void printAdjacencyMatrix(int graph[V][V]) {
    for (int i = 0; i < V; i++) {
        for (int j = 0; j < V; j++) {
            std::cout << graph[i][j] << " ";
        }
        std::cout << std::endl;
    }
}

int main() {
    int graph[V][V] = { {0, 1, 0, 0},
                        {0, 0, 1, 0},
                        {1, 0, 0, 1},
                        {0, 0, 0, 0} };

    printAdjacencyMatrix(graph);

    return 0;
}
```

#### Adjacency List

An adjacency list is an array of lists. The array index represents the vertex, and each element in the list at that index represents the vertices adjacent to that vertex.

##### Example

Using the same graph \( V = \{0, 1, 2, 3\} \) and \( E = \{(0, 1), (1, 2), (2, 0), (2, 3)\} \), the adjacency list would be:

\[
\begin{array}{c|c}
Vertex & Adjacency List \\
\hline
0 & 1 \\
1 & 2 \\
2 & 0, 3 \\
3 & \text{(empty)} \\
\end{array}
\]

##### C++ Implementation

```cpp
#include <iostream>
#include <vector>

class Graph {
    int V;
    std::vector<int>* adj;

public:
    Graph(int V);
    void addEdge(int v, int w);
    void printGraph();
};

Graph::Graph(int V) {
    this->V = V;
    adj = new std::vector<int>[V];
}

void Graph::addEdge(int v, int w) {
    adj[v].push_back(w);
}

void Graph::printGraph() {
    for (int v = 0; v < V; ++v) {
        std::cout << "Adjacency list of vertex " << v << "\nhead ";
        for (auto x : adj[v])
            std::cout << "-> " << x;
        std::cout << std::endl;
    }
}

int main() {
    Graph graph(4);
    graph.addEdge(0, 1);
    graph.addEdge(1, 2);
    graph.addEdge(2, 0);
    graph.addEdge(2, 3);

    graph.printGraph();

    return 0;
}
```

#### Comparison

- **Space Complexity**:
  - Adjacency Matrix: \( O(V^2) \)
  - Adjacency List: \( O(V + E) \)

- **Time Complexity for checking if there is an edge from u to v**:
  - Adjacency Matrix: \( O(1) \)
  - Adjacency List: \( O(V) \) in the worst case

- **Time Complexity for iterating over all edges**:
  - Adjacency Matrix: \( O(V^2) \)
  - Adjacency List: \( O(V + E) \)

Choosing between these representations depends on the density of the graph and the types of operations that need to be performed. For dense graphs, an adjacency matrix may be more efficient, whereas for sparse graphs, an adjacency list is typically better.

### 1. Algorithms & Data Structures (C++): Graph: Adding/Removing a Vertex

In graph theory, adding or removing a vertex is a fundamental operation. In C++, graphs can be represented in multiple ways, such as using an adjacency matrix or an adjacency list. Below, I will provide an example for both representations, showing how to add and remove vertices.

#### Adjacency List Representation

An adjacency list representation uses a vector of lists (or vectors) where each list corresponds to a vertex and contains the neighboring vertices.

##### Adding a Vertex

To add a vertex to an adjacency list, you simply need to add an empty list (or vector) to the existing vector of lists.

##### Removing a Vertex

Removing a vertex involves:

1. Removing the corresponding list from the vector of lists.
2. Removing all occurrences of this vertex in other lists.

Here is the implementation:

```cpp
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>

class Graph {
public:
    std::vector<std::list<int>> adjList;

    void addVertex() {
        adjList.push_back(std::list<int>());
    }

    void removeVertex(int vertex) {
        // Remove all edges to this vertex
        for (auto& neighbors : adjList) {
            neighbors.remove(vertex);
        }

        // Remove the vertex's list of neighbors
        adjList.erase(adjList.begin() + vertex);

        // Decrement the value of all vertices that are greater than 'vertex'
        for (auto& neighbors : adjList) {
            for (auto& neighbor : neighbors) {
                if (neighbor > vertex) {
                    neighbor--;
                }
            }
        }
    }

    void addEdge(int src, int dest) {
        adjList[src].push_back(dest);
        adjList[dest].push_back(src); // Assuming an undirected graph
    }

    void printGraph() {
        for (int i = 0; i < adjList.size(); i++) {
            std::cout << "Vertex " << i << ":";
            for (int neighbor : adjList[i]) {
                std::cout << " " << neighbor;
            }
            std::cout << std::endl;
        }
    }
};

int main() {
    Graph g;
    g.addVertex();
    g.addVertex();
    g.addVertex();
    g.addEdge(0, 1);
    g.addEdge(1, 2);
    g.printGraph();

    std::cout << "After adding a vertex:" << std::endl;
    g.addVertex();
    g.addEdge(2, 3);
    g.printGraph();

    std::cout << "After removing vertex 1:" << std::endl;
    g.removeVertex(1);
    g.printGraph();

    return 0;
}
```

#### Adjacency Matrix Representation

An adjacency matrix is a 2D vector where each cell (i, j) represents the presence (or weight) of an edge between vertices i and j.

##### Adding a Vertex

To add a vertex, you need to add a new row and a new column to the existing matrix.

##### Removing a Vertex

Removing a vertex involves:

1. Removing the corresponding row.
2. Removing the corresponding column.

Here is the implementation:

```cpp
#include <iostream>
#include <vector>

class Graph {
public:
    std::vector<std::vector<int>> adjMatrix;

    void addVertex() {
        int n = adjMatrix.size();
        for (auto& row : adjMatrix) {
            row.push_back(0);
        }
        adjMatrix.push_back(std::vector<int>(n + 1, 0));
    }

    void removeVertex(int vertex) {
        // Remove the row
        adjMatrix.erase(adjMatrix.begin() + vertex);

        // Remove the column
        for (auto& row : adjMatrix) {
            row.erase(row.begin() + vertex);
        }
    }

    void addEdge(int src, int dest) {
        adjMatrix[src][dest] = 1;
        adjMatrix[dest][src] = 1; // Assuming an undirected graph
    }

    void printGraph() {
        for (const auto& row : adjMatrix) {
            for (int val : row) {
                std::cout << val << " ";
            }
            std::cout << std::endl;
        }
    }
};

int main() {
    Graph g;
    g.addVertex();
    g.addVertex();
    g.addVertex();
    g.addEdge(0, 1);
    g.addEdge(1, 2);
    g.printGraph();

    std::cout << "After adding a vertex:" << std::endl;
    g.addVertex();
    g.addEdge(2, 3);
    g.printGraph();

    std::cout << "After removing vertex 1:" << std::endl;
    g.removeVertex(1);
    g.printGraph();

    return 0;
}
```

In both examples, adding and removing vertices are demonstrated along with adding edges to illustrate the changes in the graph structure. This should provide a solid understanding of how to manipulate graph vertices in C++.

Certainly! The edge list representation of a graph is a straightforward way to represent a graph as a list of edges. Each edge is represented as a pair (or tuple) of vertices.

#### Edge List Representation

An edge list is simply a list of pairs (tuples) representing the edges of the graph. This is a very flexible and simple representation, especially useful for sparse graphs.

##### Adding a Vertex

In an edge list representation, adding a vertex doesn't require any structural changes to the existing edge list. You simply need to track the count of vertices separately if needed.

##### Removing a Vertex

Removing a vertex involves removing all edges that contain that vertex.

Here is the implementation:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

class Graph {
public:
    std::vector<std::pair<int, int>> edgeList;
    int numVertices;

    Graph() : numVertices(0) {}

    void addVertex() {
        numVertices++;
    }

    void removeVertex(int vertex) {
        // Remove all edges that contain this vertex
        edgeList.erase(
            std::remove_if(edgeList.begin(), edgeList.end(),
                           [vertex](const std::pair<int, int>& edge) {
                               return edge.first == vertex || edge.second == vertex;
                           }),
            edgeList.end()
        );

        // Decrement the value of all vertices that are greater than 'vertex'
        for (auto& edge : edgeList) {
            if (edge.first > vertex) edge.first--;
            if (edge.second > vertex) edge.second--;
        }

        numVertices--;
    }

    void addEdge(int src, int dest) {
        edgeList.push_back(std::make_pair(src, dest));
    }

    void printGraph() {
        std::cout << "Edge List:" << std::endl;
        for (const auto& edge : edgeList) {
            std::cout << edge.first << " -- " << edge.second << std::endl;
        }
    }
};

int main() {
    Graph g;
    g.addVertex();
    g.addVertex();
    g.addVertex();
    g.addEdge(0, 1);
    g.addEdge(1, 2);
    g.printGraph();

    std::cout << "After adding a vertex:" << std::endl;
    g.addVertex();
    g.addEdge(2, 3);
    g.printGraph();

    std::cout << "After removing vertex 1:" << std::endl;
    g.removeVertex(1);
    g.printGraph();

    return 0;
}
```

#### Explanation

1. **Adding a Vertex**: Increases the `numVertices` count. This operation is O(1).
2. **Removing a Vertex**:
   - Iterates over the edge list to remove all edges containing the specified vertex. This operation is O(E), where E is the number of edges.
   - Adjusts the vertex indices for vertices greater than the removed vertex.
3. **Adding an Edge**: Adds a pair to the edge list. This operation is O(1).
4. **Printing the Graph**: Iterates over the edge list to print each edge. This operation is O(E).

This representation is ideal for sparse graphs where the number of edges is much less than the square of the number of vertices, as it provides efficient storage and straightforward manipulation.

#### Complexity analysis

##### Adjacency List Representation

###### Adding a Vertex

- **Operation**: Append an empty list to the vector of lists.
- **Time Complexity**: \(O(1)\)

###### Removing a Vertex

- **Operation**:
  1. Remove all edges pointing to the vertex: Iterate through all lists and remove occurrences of the vertex.
  2. Remove the vertex’s list.
  3. Adjust vertex indices in remaining lists.
- **Time Complexity**: \(O(V + E)\)
  - Removing edges: \(O(E)\)
  - Adjusting indices: \(O(V \times d)\), where \(d\) is the average degree of vertices, typically \(O(1)\) in sparse graphs, thus \(O(V)\).

##### Adjacency Matrix Representation

###### Adding a Vertex

- **Operation**: Add a row and a column to the matrix.
- **Time Complexity**: \(O(V^2)\) (due to resizing and copying the matrix)

###### Removing a Vertex

- **Operation**:
  1. Remove the row corresponding to the vertex.
  2. Remove the column corresponding to the vertex.
- **Time Complexity**: \(O(V^2)\)

##### Edge List Representation

###### Adding a Vertex

- **Operation**: Increment the vertex count.
- **Time Complexity**: \(O(1)\)

###### Removing a Vertex

- **Operation**:
  1. Remove all edges containing the vertex.
  2. Adjust vertex indices in remaining edges.
- **Time Complexity**: \(O(E)\)
  - Removing edges: \(O(E)\)
  - Adjusting indices: \(O(E)\)

##### Summary of Complexities

| Operation               | Adjacency List | Adjacency Matrix | Edge List |
|-------------------------|----------------|------------------|-----------|
| **Add Vertex**          | \(O(1)\)       | \(O(V^2)\)       | \(O(1)\)  |
| **Remove Vertex**       | \(O(V + E)\)   | \(O(V^2)\)       | \(O(E)\)  |
| **Add Edge**            | \(O(1)\)       | \(O(1)\)         | \(O(1)\)  |

##### Explanation

- **Adjacency List**: Efficient for both sparse and dense graphs. Adding/removing vertices and edges is generally fast, but removing vertices requires adjusting the indices in the lists.
- **Adjacency Matrix**: Best for dense graphs due to high space complexity (\(O(V^2)\)). Adding/removing vertices is costly due to the need to resize the matrix. Adding edges is very fast.
- **Edge List**: Simple and flexible, particularly efficient for sparse graphs. Vertex count is tracked separately. Removing vertices requires scanning the edge list but doesn't involve complex data restructuring. Adding edges is straightforward and efficient.

### 1. Algorithms & Data Structures (C++): Graph: Adding/Removing an Edge

Adding and removing edges in a graph are fundamental operations in graph data structures. Let's consider how to implement these operations in C++ for both adjacency list and adjacency matrix representations.

#### Adjacency List Representation

In an adjacency list representation, each vertex has a list of edges that connect it to other vertices.

##### Adding an Edge

To add an edge between vertices `u` and `v` in an undirected graph:

1. Add `v` to the adjacency list of `u`.
2. Add `u` to the adjacency list of `v`.

Here's how you can implement this in C++:

```cpp
#include <iostream>
#include <vector>
#include <list>

using namespace std;

class Graph {
public:
    int V;
    vector<list<int>> adj;

    Graph(int V) {
        this->V = V;
        adj.resize(V);
    }

    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u); // For undirected graph
    }

    void removeEdge(int u, int v) {
        adj[u].remove(v);
        adj[v].remove(u); // For undirected graph
    }

    void printGraph() {
        for (int i = 0; i < V; ++i) {
            cout << "Adjacency list of vertex " << i << ":\n";
            for (auto x : adj[i])
                cout << "-> " << x;
            cout << "\n";
        }
    }
};

int main() {
    Graph g(5);
    g.addEdge(0, 1);
    g.addEdge(0, 4);
    g.addEdge(1, 2);
    g.addEdge(1, 3);
    g.addEdge(1, 4);
    g.addEdge(2, 3);
    g.addEdge(3, 4);

    cout << "Graph before removing edge:\n";
    g.printGraph();

    g.removeEdge(1, 4);

    cout << "Graph after removing edge:\n";
    g.printGraph();

    return 0;
}
```

##### Removing an Edge

To remove an edge between vertices `u` and `v`:

1. Remove `v` from the adjacency list of `u`.
2. Remove `u` from the adjacency list of `v`.

This can be done using the `remove` function from the `<list>` library in C++.

#### Adjacency Matrix Representation

In an adjacency matrix representation, we use a 2D array (matrix) to represent the edges between vertices.

##### Adding an Edge

To add an edge between vertices `u` and `v`:

1. Set `adj[u][v]` to 1.
2. Set `adj[v][u]` to 1 (for undirected graph).

Here's the implementation in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

class Graph {
public:
    int V;
    vector<vector<int>> adj;

    Graph(int V) {
        this->V = V;
        adj.resize(V, vector<int>(V, 0));
    }

    void addEdge(int u, int v) {
        adj[u][v] = 1;
        adj[v][u] = 1; // For undirected graph
    }

    void removeEdge(int u, int v) {
        adj[u][v] = 0;
        adj[v][u] = 0; // For undirected graph
    }

    void printGraph() {
        for (int i = 0; i < V; ++i) {
            cout << "Adjacency matrix of vertex " << i << ":\n";
            for (int j = 0; j < V; ++j)
                cout << adj[i][j] << " ";
            cout << "\n";
        }
    }
};

int main() {
    Graph g(5);
    g.addEdge(0, 1);
    g.addEdge(0, 4);
    g.addEdge(1, 2);
    g.addEdge(1, 3);
    g.addEdge(1, 4);
    g.addEdge(2, 3);
    g.addEdge(3, 4);

    cout << "Graph before removing edge:\n";
    g.printGraph();

    g.removeEdge(1, 4);

    cout << "Graph after removing edge:\n";
    g.printGraph();

    return 0;
}
```

##### Removing an Edge

To remove an edge between vertices `u` and `v`:

1. Set `adj[u][v]` to 0.
2. Set `adj[v][u]` to 0 (for undirected graph).

This can be done by directly accessing and modifying the matrix elements.

#### Edge List Representation

In an edge list representation, you maintain a list of edges. Each edge can be represented as a pair of integers (for an unweighted graph) or a tuple of integers (for a weighted graph).

##### Adding an Edge

To add an edge in an edge list, you simply append a new edge to the list.

##### Removing an Edge

To remove an edge in an edge list, you find the edge and remove it from the list.

Here's how you can implement an edge list in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class Graph {
public:
    int V;
    vector<pair<int, int>> edgeList;

    Graph(int V) {
        this->V = V;
    }

    void addEdge(int u, int v) {
        edgeList.push_back({u, v});
    }

    void removeEdge(int u, int v) {
        edgeList.erase(remove(edgeList.begin(), edgeList.end(), make_pair(u, v)), edgeList.end());
        edgeList.erase(remove(edgeList.begin(), edgeList.end(), make_pair(v, u)), edgeList.end()); // For undirected graph
    }

    void printGraph() {
        cout << "Edge list of the graph:\n";
        for (auto edge : edgeList) {
            cout << "(" << edge.first << ", " << edge.second << ")\n";
        }
    }
};

int main() {
    Graph g(5);
    g.addEdge(0, 1);
    g.addEdge(0, 4);
    g.addEdge(1, 2);
    g.addEdge(1, 3);
    g.addEdge(1, 4);
    g.addEdge(2, 3);
    g.addEdge(3, 4);

    cout << "Graph before removing edge:\n";
    g.printGraph();

    g.removeEdge(1, 4);

    cout << "Graph after removing edge:\n";
    g.printGraph();

    return 0;
}
```

#### Complexity analysis

##### Adjacency List Representation

##### 1. Adding an Edge

- **Operation**: Adding an edge between vertices `u` and `v`.
- **Time Complexity**:
  - Adding an edge involves appending `v` to the adjacency list of `u` and `u` to the adjacency list of `v`.
  - Both `push_back` operations take \(O(1)\) time.
  - **Total**: \(O(1)\).

##### 2. Removing an Edge

- **Operation**: Removing an edge between vertices `u` and `v`.
- **Time Complexity**:
  - Removing an element from a list requires finding the element first, which takes \(O(\text{degree}(u))\) time for `u` and \(O(\text{degree}(v))\) time for `v`.
  - The removal itself is \(O(1)\) once the element is found.
  - **Total**: \(O(\text{degree}(u) + \text{degree}(v))\).

##### Adjacency Matrix Representation

###### 1. Adding an Edge

- **Operation**: Adding an edge between vertices `u` and `v`.
- **Time Complexity**:
  - Setting `adj[u][v]` and `adj[v][u]` to 1 takes \(O(1)\) time each.
  - **Total**: \(O(1)\).

###### 2. Removing an Edge

- **Operation**: Removing an edge between vertices `u` and `v`.
- **Time Complexity**:
  - Setting `adj[u][v]` and `adj[v][u]` to 0 takes \(O(1)\) time each.
  - **Total**: \(O(1)\).

##### Edge List Representation

###### 1. Adding an Edge

- **Operation**: Adding an edge between vertices `u` and `v`.
- **Time Complexity**:
  - Appending the edge \((u, v)\) to the edge list takes \(O(1)\) time.
  - **Total**: \(O(1)\).

###### 2. Removing an Edge

- **Operation**: Removing an edge between vertices `u` and `v`.
- **Time Complexity**:
  - Finding the edge \((u, v)\) in the list takes \(O(E)\) time, where \(E\) is the number of edges.
  - Removing the edge takes \(O(1)\) time.
  - **Total**: \(O(E)\).

##### Summary of Complexity Analysis

| Operation           | Adjacency List         | Adjacency Matrix | Edge List        |
|---------------------|------------------------|------------------|------------------|
| **Add Edge**        | \(O(1)\)               | \(O(1)\)         | \(O(1)\)         |
| **Remove Edge**     | \(O(\text{deg}(u) + \text{deg}(v))\) | \(O(1)\)         | \(O(E)\)         |

- **Adjacency List**: Efficient for adding edges and reasonably efficient for removing edges if the degree of the vertices is low.
- **Adjacency Matrix**: Both adding and removing edges are very efficient (\(O(1)\)) but can be space-inefficient for sparse graphs.
- **Edge List**: Adding edges is efficient (\(O(1)\)), but removing edges can be inefficient (\(O(E)\)).

Each representation has its trade-offs, and the choice depends on the specific requirements of the application and the graph's characteristics (e.g., density, frequency of edge operations).

### 1. Algorithms & Data Structures (C++): Graphs: Degree of a Vertex

In graph theory, the degree of a vertex is the number of edges connected to it. In the context of C++, we can represent a graph using various data structures like adjacency matrices, adjacency lists, or edge lists. Each representation has its own method for calculating the degree of a vertex.

#### 1. Adjacency Matrix

An adjacency matrix is a 2D array where each cell (i, j) is 1 if there is an edge between vertex i and vertex j, otherwise it is 0.

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Function to calculate the degree of a vertex in an adjacency matrix
int degreeAdjMatrix(const vector<vector<int>>& adjMatrix, int vertex) {
    int degree = 0;
    int n = adjMatrix.size();
    for (int i = 0; i < n; ++i) {
        if (adjMatrix[vertex][i] == 1) {
            degree++;
        }
    }
    return degree;
}

int main() {
    // Example graph represented as an adjacency matrix
    vector<vector<int>> adjMatrix = {
        {0, 1, 0, 1},
        {1, 0, 1, 0},
        {0, 1, 0, 1},
        {1, 0, 1, 0}
    };

    int vertex = 1;
    cout << "Degree of vertex " << vertex << " is " << degreeAdjMatrix(adjMatrix, vertex) << endl;

    return 0;
}
```

#### 2. Adjacency List

An adjacency list represents a graph as an array of lists. The index of the array represents the vertex, and the list at each index represents its neighbors.

```cpp
#include <iostream>
#include <vector>
#include <list>

using namespace std;

// Function to calculate the degree of a vertex in an adjacency list
int degreeAdjList(const vector<list<int>>& adjList, int vertex) {
    return adjList[vertex].size();
}

int main() {
    // Example graph represented as an adjacency list
    vector<list<int>> adjList = {
        {1, 3},    // neighbors of vertex 0
        {0, 2},    // neighbors of vertex 1
        {1, 3},    // neighbors of vertex 2
        {0, 2}     // neighbors of vertex 3
    };

    int vertex = 1;
    cout << "Degree of vertex " << vertex << " is " << degreeAdjList(adjList, vertex) << endl;

    return 0;
}
```

#### Explanation

1. **Adjacency Matrix**:
    - We use a nested loop to traverse the row corresponding to the vertex. Each time we encounter a '1', it means there is an edge, so we increment the degree.

2. **Adjacency List**:
    - For the adjacency list, the degree of a vertex is simply the size of the list at the index representing the vertex. This gives the number of neighbors directly.

#### Notes

- In the adjacency matrix, the time complexity to calculate the degree of a vertex is \(O(n)\), where \(n\) is the number of vertices.
- In the adjacency list, the time complexity to calculate the degree of a vertex is \(O(1)\) because accessing the list and getting its size is a constant-time operation.

These methods allow us to efficiently compute the degree of a vertex in different representations of a graph in C++.

## Traversing Graphs

### 1. Algorithms & Data Structures (C++): Breadth First Search

Breadth-First Search (BFS) is an essential algorithm in computer science for traversing or searching tree or graph data structures. It explores the neighbor nodes at the present depth before moving on to nodes at the next depth level. This algorithm is particularly useful for finding the shortest path in unweighted graphs.

#### BFS Algorithm in C++

Here’s how you can implement the BFS algorithm in C++:

1. **Graph Representation:** Use an adjacency list to represent the graph.
2. **Queue:** Use a queue to keep track of the nodes to be explored.
3. **Visited Array:** Keep track of visited nodes to avoid reprocessing.

#### Steps

1. **Initialize the queue with the starting node.**
2. **Mark the starting node as visited.**
3. **While the queue is not empty:**
   - Dequeue a node.
   - Process the node (e.g., print it or store it).
   - Enqueue all its unvisited neighbors and mark them as visited.

Here's a sample implementation:

```cpp
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

// Function to perform BFS on the graph
void BFS(int start, vector<vector<int>>& adjList, vector<bool>& visited) {
    queue<int> q;
    q.push(start);
    visited[start] = true;

    while (!q.empty()) {
        int node = q.front();
        q.pop();
        cout << node << " ";

        for (int neighbor : adjList[node]) {
            if (!visited[neighbor]) {
                q.push(neighbor);
                visited[neighbor] = true;
            }
        }
    }
}

int main() {
    // Number of nodes in the graph
    int numNodes = 6;

    // Adjacency list representation of the graph
    vector<vector<int>> adjList(numNodes);

    // Adding edges to the graph
    adjList[0].push_back(1);
    adjList[0].push_back(2);
    adjList[1].push_back(3);
    adjList[1].push_back(4);
    adjList[2].push_back(4);
    adjList[3].push_back(5);
    adjList[4].push_back(5);

    // Visited array to keep track of visited nodes
    vector<bool> visited(numNodes, false);

    // Perform BFS starting from node 0
    BFS(0, adjList, visited);

    return 0;
}
```

#### Explanation

1. **Graph Representation:** The graph is represented as an adjacency list, where each node points to a list of its neighbors. This is efficient for both space and time when dealing with sparse graphs.

2. **Initialization:** The `visited` vector is initialized to `false` for all nodes, indicating that no nodes have been visited yet.

3. **BFS Function:**
   - The `queue` is used to manage the order of node exploration.
   - The starting node is pushed to the queue and marked as visited.
   - The while loop runs until the queue is empty, processing each node by printing it and enqueuing its unvisited neighbors.

#### Time Complexity

- The time complexity of BFS is \(O(V + E)\), where \(V\) is the number of vertices and \(E\) is the number of edges.

#### Space Complexity

- The space complexity of BFS is \(O(V)\) for storing the queue and the visited list.

This implementation and explanation should help you understand the BFS algorithm and how to implement it in C++.

### 1. Algorithms & Data Structures (C++): Breadth First Search for Disconnected Graph

Sure, implementing Breadth First Search (BFS) for a disconnected graph in C++ involves visiting all the vertices of the graph, even those that are not connected to the starting vertex. Here's how you can do it:

```cpp
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

// Class representing a graph
class Graph {
    int V; // Number of vertices

    // Pointer to an array containing adjacency lists
    vector<int> *adj;

public:
    Graph(int V); // Constructor
    void addEdge(int v, int w); // Function to add an edge to the graph
    void BFS(); // Breadth First Search function
    void BFSUtil(int v, vector<bool> &visited); // Utility function for BFS
};

Graph::Graph(int V) {
    this->V = V;
    adj = new vector<int>[V];
}

void Graph::addEdge(int v, int w) {
    adj[v].push_back(w); // Add w to v’s list.
}

void Graph::BFSUtil(int v, vector<bool> &visited) {
    // Create a queue for BFS
    queue<int> queue;

    // Mark the current node as visited and enqueue it
    visited[v] = true;
    queue.push(v);

    // 'i' will be used to get all adjacent vertices of a vertex
    vector<int>::iterator i;

    while (!queue.empty()) {
        // Dequeue a vertex from queue and print it
        v = queue.front();
        cout << v << " ";
        queue.pop();

        // Get all adjacent vertices of the dequeued vertex v
        // If an adjacent has not been visited, then mark it
        // visited and enqueue it
        for (i = adj[v].begin(); i != adj[v].end(); ++i) {
            if (!visited[*i]) {
                visited[*i] = true;
                queue.push(*i);
            }
        }
    }
}

void Graph::BFS() {
    // Mark all the vertices as not visited
    vector<bool> visited(V, false);

    // Call the recursive helper function to print DFS traversal
    // starting from all vertices one by one
    for (int i = 0; i < V; i++) {
        if (!visited[i]) {
            BFSUtil(i, visited);
        }
    }
}

int main() {
    // Create a graph given in the above diagram
    Graph g(6);
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 2);
    g.addEdge(3, 4);
    g.addEdge(4, 5);

    cout << "Breadth First Traversal of disconnected graph: \n";
    g.BFS();

    return 0;
}
```

In this code:

- We create a `Graph` class to represent the graph.
- The `addEdge` function is used to add an edge between two vertices.
- The `BFS` function is the main function to perform BFS. It calls `BFSUtil` for all vertices one by one.
- The `BFSUtil` function performs the actual BFS traversal. It takes a starting vertex and a boolean vector to keep track of visited vertices.

This implementation ensures that all the vertices of the graph are visited, even if the graph is disconnected.

### 1. Algorithms & Data Structures (C++): Depth First Search

DFS starts at a source node and explores as far as possible along each branch before backtracking. It uses a stack data structure, either explicitly with a stack or implicitly with recursion.

#### Steps of DFS

1. Start at the root node (or any arbitrary node in the case of a graph).
2. Visit the node and mark it as visited.
3. For each adjacent node, if it hasn't been visited, recursively visit it.

#### Types of DFS

1. **Recursive DFS**: Uses the system's call stack.
2. **Iterative DFS**: Uses an explicit stack.

#### DFS Implementation in C++

Here's a C++ implementation of DFS for a graph using both recursive and iterative methods.

##### Recursive DFS

```cpp
#include <iostream>
#include <vector>
using namespace std;

void dfs_recursive(int node, vector<vector<int>>& adj, vector<bool>& visited) {
    // Mark the current node as visited
    visited[node] = true;
    cout << node << " ";

    // Recur for all the vertices adjacent to this vertex
    for (int neighbor : adj[node]) {
        if (!visited[neighbor]) {
            dfs_recursive(neighbor, adj, visited);
        }
    }
}

int main() {
    int n = 6; // Number of vertices
    vector<vector<int>> adj(n);

    // Graph edges (example)
    adj[0] = {1, 2};
    adj[1] = {0, 3, 4};
    adj[2] = {0, 4};
    adj[3] = {1, 5};
    adj[4] = {1, 2, 5};
    adj[5] = {3, 4};

    vector<bool> visited(n, false);

    // Perform DFS starting from node 0
    dfs_recursive(0, adj, visited);

    return 0;
}
```

##### Iterative DFS

```cpp
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

void dfs_iterative(int start, vector<vector<int>>& adj, vector<bool>& visited) {
    stack<int> s;
    s.push(start);

    while (!s.empty()) {
        int node = s.top();
        s.pop();

        if (!visited[node]) {
            visited[node] = true;
            cout << node << " ";

            // Push all unvisited neighbors to the stack
            for (int neighbor : adj[node]) {
                if (!visited[neighbor]) {
                    s.push(neighbor);
                }
            }
        }
    }
}

int main() {
    int n = 6; // Number of vertices
    vector<vector<int>> adj(n);

    // Graph edges (example)
    adj[0] = {1, 2};
    adj[1] = {0, 3, 4};
    adj[2] = {0, 4};
    adj[3] = {1, 5};
    adj[4] = {1, 2, 5};
    adj[5] = {3, 4};

    vector<bool> visited(n, false);

    // Perform DFS starting from node 0
    dfs_iterative(0, adj, visited);

    return 0;
}
```

#### Explanation

1. **Graph Representation**: The graph is represented using an adjacency list. `adj` is a vector of vectors, where each `adj[i]` contains the list of nodes adjacent to node `i`.

2. **Visited Array**: `visited` is a vector of booleans indicating whether a node has been visited to avoid cycles and redundant visits.

3. **Recursive DFS**:
   - Starts from a node, marks it as visited, and recursively visits all its unvisited neighbors.

4. **Iterative DFS**:
   - Uses an explicit stack to manage the nodes to visit. Starts from a node, marks it as visited, and pushes its unvisited neighbors onto the stack.

#### Key Points

- **Time Complexity**: O(V + E), where V is the number of vertices and E is the number of edges. Each vertex and edge is processed once.
- **Space Complexity**: O(V) for the visited array and the call stack in recursive DFS or the explicit stack in iterative DFS.

DFS is used in various applications, including pathfinding, topological sorting, and detecting cycles in graphs.

### 1. Algorithms & Data Structures (C++): Depth First Search for Disconnected Graph

Depth First Search (DFS) is a fundamental graph traversal algorithm used to explore the vertices of a graph. When dealing with a disconnected graph (a graph with multiple disconnected components), you can apply DFS separately to each component to visit all vertices.

Here's how you can implement DFS for a disconnected graph in C++:

```cpp
#include <iostream>
#include <vector>
#include <stack>
#include <unordered_set>

using namespace std;

// Define a graph class
class Graph {
    int V; // Number of vertices
    vector<vector<int>> adj; // Adjacency list

public:
    Graph(int V) : V(V), adj(V) {}

    // Function to add an edge to the graph
    void addEdge(int v, int w) {
        adj[v].push_back(w);
        adj[w].push_back(v); // For undirected graph
    }

    // DFS traversal from a given vertex
    void DFSUtil(int v, unordered_set<int>& visited) {
        // Mark the current node as visited and print it
        visited.insert(v);
        cout << v << " ";

        // Recur for all the vertices adjacent to this vertex
        for (int u : adj[v]) {
            if (visited.find(u) == visited.end()) {
                DFSUtil(u, visited);
            }
        }
    }

    // DFS traversal of the vertices reachable from a given vertex
    void DFS(int v) {
        unordered_set<int> visited;

        // Call the recursive helper function
        DFSUtil(v, visited);

        // Traverse the remaining vertices that may not be reachable from the given vertex
        for (int i = 0; i < V; ++i) {
            if (visited.find(i) == visited.end()) {
                DFSUtil(i, visited);
            }
        }
    }
};

int main() {
    // Create a graph with 5 vertices
    Graph g(5);
    // Add edges
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(3, 4);

    cout << "Depth First Traversal for disconnected graph:" << endl;
    g.DFS(0); // Start DFS from vertex 0

    return 0;
}
```

This code defines a Graph class with methods to add edges and perform DFS traversal. The `DFSUtil` method is a recursive utility function to perform DFS from a given vertex, and the `DFS` method starts DFS traversal from a given vertex and handles disconnected components by traversing each of them. Finally, the `main` function demonstrates how to use this class to perform DFS on a disconnected graph.

### 1. Algorithms & Data Structures (C++): Graph: All Paths From Source to Target

To find all paths from a source node to a target node in a graph, we can use Depth-First Search (DFS). Let's go through the implementation step-by-step in C++.

#### Step-by-Step Implementation

1. **Graph Representation**:
    - Use an adjacency list to represent the graph. This can be done using a vector of vectors, where `graph[i]` contains a list of nodes adjacent to node `i`.

2. **DFS to Explore Paths**:
    - Use DFS to explore all possible paths from the source to the target.
    - Keep track of the current path using a vector and store all paths in a vector of vectors.

#### Code Example

Here's a complete C++ code example to find all paths from source to target in a directed graph:

```cpp
#include <iostream>
#include <vector>
using namespace std;

class Solution {
public:
    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
        vector<vector<int>> allPaths;
        vector<int> currentPath;
        dfs(graph, 0, currentPath, allPaths);
        return allPaths;
    }
    
private:
    void dfs(vector<vector<int>>& graph, int node, vector<int>& currentPath, vector<vector<int>>& allPaths) {
        currentPath.push_back(node);
        
        if (node == graph.size() - 1) {
            allPaths.push_back(currentPath);
        } else {
            for (int nextNode : graph[node]) {
                dfs(graph, nextNode, currentPath, allPaths);
            }
        }
        
        currentPath.pop_back();  // Backtrack
    }
};

int main() {
    Solution solution;
    vector<vector<int>> graph = {{1, 2}, {3}, {3}, {}};
    
    vector<vector<int>> allPaths = solution.allPathsSourceTarget(graph);
    
    for (const auto& path : allPaths) {
        for (int node : path) {
            cout << node << " ";
        }
        cout << endl;
    }
    
    return 0;
}
```

#### Explanation

1. **Graph Input**:
    - The graph is represented as `vector<vector<int>> graph` where `graph[i]` contains all nodes that node `i` points to.
    - Example: `graph = {{1, 2}, {3}, {3}, {}}` represents a graph where:
      - Node 0 points to nodes 1 and 2.
      - Node 1 points to node 3.
      - Node 2 points to node 3.
      - Node 3 has no outgoing edges.

2. **DFS Function**:
    - `dfs` function takes the current node, the current path, and the list of all paths found so far.
    - It adds the current node to the path and checks if this node is the target node (`node == graph.size() - 1`). If so, the current path is added to the list of all paths.
    - If the current node is not the target, the function recursively explores all adjacent nodes.
    - After exploring all adjacent nodes, the function backtracks by removing the current node from the path.

3. **Main Function**:
    - An instance of the `Solution` class is created, and the `allPathsSourceTarget` method is called with the graph.
    - The resulting paths are printed.

This implementation uses a depth-first search approach and backtracking to explore all possible paths from the source node (0) to the target node (`graph.size() - 1`).

### 1. Algorithms & Data Structures (C++): Find Connected Components

#### Connected Components

##### Definition

In an undirected graph, a **connected component** is a maximal subgraph in which any two vertices are connected to each other by paths, and which is connected to no additional vertices in the supergraph.

##### Algorithm to Find Connected Components

One common algorithm to find connected components in a graph is **Depth-First Search (DFS)**.

Here's a step-by-step procedure:

1. **Initialize:**
   - Create a visited array to keep track of visited nodes.
   - Initialize all values in the visited array to false.

2. **Iterate through all nodes:**
   - For each unvisited node, perform DFS.
   - Mark all nodes reachable from the node as visited and part of the same component.

3. **Track Components:**
   - Use a counter or list to track all nodes in each component.

##### Example Code in C++

```cpp
#include <iostream>
#include <vector>

using namespace std;

void DFS(int v, vector<vector<int>>& adj, vector<bool>& visited) {
    visited[v] = true;
    for (int u : adj[v]) {
        if (!visited[u]) {
            DFS(u, adj, visited);
        }
    }
}

void findConnectedComponents(int n, vector<vector<int>>& adj) {
    vector<bool> visited(n, false);
    int componentCount = 0;

    for (int i = 0; i < n; ++i) {
        if (!visited[i]) {
            ++componentCount;
            cout << "Component " << componentCount << ": ";
            DFS(i, adj, visited);
            for (int j = 0; j < n; ++j) {
                if (visited[j]) {
                    cout << j << " ";
                    visited[j] = false; // Reset visited for next component
                }
            }
            cout << endl;
        }
    }
}

int main() {
    int n = 5;
    vector<vector<int>> adj(n);
    adj[0] = {1, 2};
    adj[1] = {0, 2};
    adj[2] = {0, 1};
    adj[3] = {4};
    adj[4] = {3};

    findConnectedComponents(n, adj);
    return 0;
}
```

### 1. Algorithms & Data Structures (C++): Graphs: Route Between Nodes

In graph theory, determining if there is a route between two nodes in a graph is a common problem. This can be solved using search algorithms like Breadth-First Search (BFS) or Depth-First Search (DFS). Below, I'll provide a C++ implementation of both methods to check if there is a route between two nodes in a graph.

#### Graph Representation

First, let's represent the graph using an adjacency list. We will use the `unordered_map` from the C++ Standard Library to store the adjacency list of the graph. The key will be the node, and the value will be a list of adjacent nodes.

#### BFS Implementation

BFS is a good choice when the graph is large and we want to find the shortest path between two nodes. Here's how you can implement it:

```cpp
#include <iostream>
#include <unordered_map>
#include <vector>
#include <queue>
#include <unordered_set>

class Graph {
public:
    void addEdge(int src, int dest) {
        adjacencyList[src].push_back(dest);
        adjacencyList[dest]; // Ensure the destination node is created in the adjacency list even if it has no outgoing edges
    }

    bool isRouteBFS(int start, int end) {
        if (start == end) return true;

        std::queue<int> toVisit;
        std::unordered_set<int> visited;

        toVisit.push(start);

        while (!toVisit.empty()) {
            int current = toVisit.front();
            toVisit.pop();

            if (current == end) {
                return true;
            }

            visited.insert(current);

            for (int neighbor : adjacencyList[current]) {
                if (visited.find(neighbor) == visited.end()) {
                    toVisit.push(neighbor);
                }
            }
        }

        return false;
    }

private:
    std::unordered_map<int, std::vector<int>> adjacencyList;
};

int main() {
    Graph g;
    g.addEdge(1, 2);
    g.addEdge(2, 3);
    g.addEdge(3, 4);
    g.addEdge(4, 5);
    g.addEdge(1, 6);
    g.addEdge(6, 7);
    g.addEdge(7, 3);

    int start = 1;
    int end = 5;

    if (g.isRouteBFS(start, end)) {
        std::cout << "There is a route from " << start << " to " << end << "\n";
    } else {
        std::cout << "There is no route from " << start << " to " << end << "\n";
    }

    return 0;
}
```

#### DFS Implementation

DFS can also be used to solve this problem. It is generally simpler but may be less efficient than BFS in terms of finding the shortest path.

```cpp
#include <iostream>
#include <unordered_map>
#include <vector>
#include <unordered_set>

class Graph {
public:
    void addEdge(int src, int dest) {
        adjacencyList[src].push_back(dest);
        adjacencyList[dest]; // Ensure the destination node is created in the adjacency list even if it has no outgoing edges
    }

    bool isRouteDFS(int start, int end) {
        std::unordered_set<int> visited;
        return dfs(start, end, visited);
    }

private:
    std::unordered_map<int, std::vector<int>> adjacencyList;

    bool dfs(int current, int end, std::unordered_set<int>& visited) {
        if (current == end) return true;

        visited.insert(current);

        for (int neighbor : adjacencyList[current]) {
            if (visited.find(neighbor) == visited.end()) {
                if (dfs(neighbor, end, visited)) {
                    return true;
                }
            }
        }

        return false;
    }
};

int main() {
    Graph g;
    g.addEdge(1, 2);
    g.addEdge(2, 3);
    g.addEdge(3, 4);
    g.addEdge(4, 5);
    g.addEdge(1, 6);
    g.addEdge(6, 7);
    g.addEdge(7, 3);

    int start = 1;
    int end = 5;

    if (g.isRouteDFS(start, end)) {
        std::cout << "There is a route from " << start << " to " << end << "\n";
    } else {
        std::cout << "There is no route from " << start << " to " << end << "\n";
    }

    return 0;
}
```

#### Explanation

1. **Graph Representation**: The graph is represented using an adjacency list stored in an `unordered_map`.
2. **BFS**:
   - Uses a queue to explore nodes level by level.
   - Nodes are marked as visited by adding them to a `unordered_set`.
3. **DFS**:
   - Uses a recursive function to explore nodes depth-wise.
   - A `unordered_set` keeps track of visited nodes to prevent cycles.

You can choose either BFS or DFS depending on your needs. BFS is typically better for finding the shortest path, while DFS is simpler and may be faster for deeper searches in sparse graphs.

### 1. Algorithms & Data Structures (C++): Graph: Breadth First Search vs Depth First Search

Sure, let's compare Breadth-First Search (BFS) and Depth-First Search (DFS) algorithms for traversing or searching in graphs using C++.

#### Breadth-First Search (BFS)

**BFS** is an algorithm for traversing or searching tree or graph data structures. It starts at the root (or an arbitrary node in the case of a graph) and explores the neighbor nodes at the present depth prior to moving on to nodes at the next depth level.

##### Characteristics

- **Queue-based:** BFS uses a queue to keep track of the next node to explore.
- **Layer-wise traversal:** Explores all neighbors at the present depth level before moving on to the next level.
- **Shortest Path:** In an unweighted graph, BFS can be used to find the shortest path from the source node to any other node.

#### Depth-First Search (DFS)

**DFS** is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node and explores as far as possible along each branch before backtracking.

##### Characteristics

- **Stack-based:** DFS can be implemented using recursion (implicit stack) or an explicit stack.
- **Depth-wise traversal:** Explores each branch as far as possible before backtracking.
- **Cycle Detection:** Useful for detecting cycles in a graph.

#### Comparison

- **Use Cases:**
  - BFS is generally used for finding the shortest path in unweighted graphs and for level-order traversal.
  - DFS is used for problems that require backtracking, like solving puzzles and games, and for cycle detection in graphs.
  
- **Space Complexity:**
  - BFS requires more memory, proportional to the width of the graph (O(V) in the worst case for a graph with V vertices).
  - DFS requires memory proportional to the depth of the graph (O(V) in the worst case).

- **Traversal Order:**
  - BFS explores neighbors level by level.
  - DFS explores as far down a branch as possible before backtracking.

By understanding these differences and characteristics, you can choose the appropriate algorithm based on the specific requirements of your problem.

## Cycle detection

### 1. Algorithms & Data Structures (C++): Cycle Detection in Undirected Graphs

Using DFS, we can detect a cycle in an undirected graph by tracking the visited vertices and the parent of each vertex.

#### Algorithm

1. Initialize a `visited` array to keep track of visited vertices.
2. For each unvisited vertex, perform DFS:
   - Mark the current vertex as visited.
   - For each adjacent vertex:
     - If it is not visited, recursively perform DFS with the adjacent vertex as the current vertex and the current vertex as its parent.
     - If it is visited and it is not the parent of the current vertex, a cycle is detected.

##### C++ Implementation

```cpp
#include <iostream>
#include <vector>
using namespace std;

class Graph {
    int V;
    vector<vector<int>> adj;

public:
    Graph(int V) {
        this->V = V;
        adj.resize(V);
    }

    void addEdge(int v, int w) {
        adj[v].push_back(w);
        adj[w].push_back(v);
    }

    bool isCyclicUtil(int v, vector<bool>& visited, int parent) {
        visited[v] = true;

        for (int i : adj[v]) {
            if (!visited[i]) {
                if (isCyclicUtil(i, visited, v)) {
                    return true;
                }
            } else if (i != parent) {
                return true;
            }
        }
        return false;
    }

    bool isCyclic() {
        vector<bool> visited(V, false);

        for (int u = 0; u < V; u++) {
            if (!visited[u]) {
                if (isCyclicUtil(u, visited, -1)) {
                    return true;
                }
            }
        }
        return false;
    }
};

int main() {
    Graph g1(5);
    g1.addEdge(0, 1);
    g1.addEdge(1, 2);
    g1.addEdge(2, 0);
    g1.addEdge(0, 3);
    g1.addEdge(3, 4);

    if (g1.isCyclic()) {
        cout << "Graph contains cycle\n";
    } else {
        cout << "Graph doesn't contain cycle\n";
    }

    return 0;
}
```

### 1. Algorithms & Data Structures (C++): Cycle Detection in Directed Graph

Cycle detection in a directed graph is a classic problem in computer science. Detecting cycles in directed graphs is important in various applications, such as verifying the correctness of complex networks, detecting deadlocks in operating systems, and analyzing dependency graphs in software.

Here's a step-by-step explanation and implementation of cycle detection in a directed graph using Depth-First Search (DFS) in C++:

#### Steps to Detect a Cycle in a Directed Graph

1. **Representation of the Graph**:
    - Use an adjacency list to represent the graph.

2. **Depth-First Search (DFS)**:
    - Perform DFS traversal of the graph.
    - Maintain two arrays (or sets):
        - `visited`: Keeps track of all the vertices that have been visited to avoid reprocessing them.
        - `recStack`: Keeps track of vertices in the current recursion stack of the DFS to detect cycles.

3. **Cycle Detection Logic**:
    - During DFS traversal, if you encounter a vertex that is already in the recursion stack, a cycle is detected.

#### Implementation in C++

Here is the implementation of the cycle detection algorithm using DFS:

```cpp
#include <iostream>
#include <vector>
#include <stack>

using namespace std;

class Graph {
private:
    int V; // Number of vertices
    vector<vector<int>> adj; // Adjacency list

    // Utility function for DFS and cycle detection
    bool dfs(int v, vector<bool> &visited, vector<bool> &recStack) {
        // Mark the current node as visited and part of the recursion stack
        visited[v] = true;
        recStack[v] = true;

        // Recur for all vertices adjacent to this vertex
        for (int neighbor : adj[v]) {
            // If the neighbor is not visited, recurse on it
            if (!visited[neighbor] && dfs(neighbor, visited, recStack))
                return true;
            // If the neighbor is already in the recursion stack, there's a cycle
            else if (recStack[neighbor])
                return true;
        }

        // Remove the vertex from recursion stack
        recStack[v] = false;
        return false;
    }

public:
    Graph(int V) {
        this->V = V;
        adj.resize(V);
    }

    // Function to add an edge to the graph
    void addEdge(int v, int w) {
        adj[v].push_back(w);
    }

    // Function to detect cycle in the graph
    bool hasCycle() {
        vector<bool> visited(V, false);
        vector<bool> recStack(V, false);

        // Call the recursive helper function to detect cycle in different DFS trees
        for (int i = 0; i < V; i++) {
            if (!visited[i]) {
                if (dfs(i, visited, recStack))
                    return true;
            }
        }
        return false;
    }
};

int main() {
    // Create a graph given in the example
    Graph g(4);
    g.addEdge(0, 1);
    g.addEdge(1, 2);
    g.addEdge(2, 0);
    g.addEdge(2, 3);

    if (g.hasCycle())
        cout << "Graph contains a cycle\n";
    else
        cout << "Graph doesn't contain a cycle\n";

    return 0;
}
```

#### Explanation

1. **Graph Class**:
    - The `Graph` class holds the number of vertices (`V`) and an adjacency list (`adj`).

2. **addEdge Function**:
    - Adds directed edges to the graph.

3. **dfs Function**:
    - Performs DFS and detects cycles using the `visited` and `recStack` arrays.
    - If a node is visited again while it's still in the recursion stack (`recStack`), a cycle is detected.

4. **hasCycle Function**:
    - Iterates over all vertices, and if a vertex is not visited, it calls the `dfs` function.
    - If any call to `dfs` returns true, indicating a cycle, it returns true.

5. **main Function**:
    - Creates a graph and adds edges.
    - Checks if the graph contains a cycle and prints the result.

#### Conclusion

This implementation efficiently detects cycles in a directed graph using DFS. The time complexity of this algorithm is \(O(V + E)\), where \(V\) is the number of vertices and \(E\) is the number of edges in the graph.

### 1. Algorithms & Data Structures (C++): Graph: Hamiltonian Cycles [RETURN]

A Hamiltonian cycle in a graph is a cycle that visits each vertex exactly once and returns to the starting vertex. Finding a Hamiltonian cycle is a well-known problem in computer science, specifically in the area of graph theory, and it is known to be NP-complete. In this guide, we will discuss how to implement a solution to find Hamiltonian cycles in a graph using C++.

#### Graph Representation

To represent a graph, we typically use an adjacency matrix or an adjacency list. For the purpose of this guide, we'll use an adjacency matrix.

#### Adjacency Matrix

An adjacency matrix is a 2D array where the element at row `i` and column `j` is `1` if there is an edge between vertex `i` and vertex `j`, and `0` otherwise.

```cpp
#include <iostream>
#include <vector>
using namespace std;

class Graph {
private:
    int numVertices;
    vector<vector<int>> adjMatrix;

public:
    Graph(int numVertices);
    void addEdge(int i, int j);
    bool isEdge(int i, int j);
    void display();
    bool isHamiltonianCycle();
    bool isSafe(int v, vector<int>& path, int pos);
    bool hamCycleUtil(vector<int>& path, int pos);
};

Graph::Graph(int numVertices) {
    this->numVertices = numVertices;
    adjMatrix = vector<vector<int>>(numVertices, vector<int>(numVertices, 0));
}

void Graph::addEdge(int i, int j) {
    adjMatrix[i][j] = 1;
    adjMatrix[j][i] = 1; // Because the graph is undirected
}

bool Graph::isEdge(int i, int j) {
    return adjMatrix[i][j] == 1;
}

void Graph::display() {
    for (int i = 0; i < numVertices; i++) {
        for (int j = 0; j < numVertices; j++) {
            cout << adjMatrix[i][j] << " ";
        }
        cout << endl;
    }
}
```

#### Hamiltonian Cycle Detection

To detect a Hamiltonian cycle, we can use a backtracking approach. The idea is to start from an arbitrary vertex and try to build the cycle by adding one vertex at a time, ensuring that we do not revisit any vertex and that we can form a cycle by connecting the last vertex back to the starting vertex.

##### Helper Functions

We need a helper function `isSafe` to check if it is possible to add a vertex to the current path, and another helper function `hamCycleUtil` to perform the recursive backtracking.

```cpp
bool Graph::isSafe(int v, vector<int>& path, int pos) {
    // Check if this vertex is an adjacent vertex of the previously added vertex.
    if (!isEdge(path[pos - 1], v)) {
        return false;
    }
    // Check if the vertex has already been included.
    for (int i = 0; i < pos; i++) {
        if (path[i] == v) {
            return false;
        }
    }
    return true;
}

bool Graph::hamCycleUtil(vector<int>& path, int pos) {
    // Base case: If all vertices are included in the cycle
    if (pos == numVertices) {
        // And if there is an edge from the last included vertex to the first vertex
        return isEdge(path[pos - 1], path[0]);
    }

    // Try different vertices as the next candidate in the Hamiltonian Cycle.
    for (int v = 1; v < numVertices; v++) {
        // Check if this vertex can be added to Hamiltonian Cycle
        if (isSafe(v, path, pos)) {
            path[pos] = v;
            if (hamCycleUtil(path, pos + 1)) {
                return true;
            }
            // If adding vertex v doesn't lead to a solution, remove it
            path[pos] = -1;
        }
    }
    return false;
}

bool Graph::isHamiltonianCycle() {
    vector<int> path(numVertices, -1);
    // Start at vertex 0
    path[0] = 0;
    if (!hamCycleUtil(path, 1)) {
        cout << "No Hamiltonian Cycle found" << endl;
        return false;
    }
    // Print the solution
    cout << "Hamiltonian Cycle found: ";
    for (int i = 0; i < numVertices; i++) {
        cout << path[i] << " ";
    }
    cout << path[0] << endl; // To show the complete cycle
    return true;
}
```

#### Example Usage

Here is an example of how you can create a graph and find Hamiltonian cycles in it.

```cpp
int main() {
    Graph g(5);
    g.addEdge(0, 1);
    g.addEdge(1, 2);
    g.addEdge(2, 3);
    g.addEdge(3, 4);
    g.addEdge(4, 0);
    g.addEdge(1, 3);

    g.display();
    g.isHamiltonianCycle();

    return 0;
}
```

#### Explanation

- The `Graph` class contains methods to create the graph, add edges, and check for Hamiltonian cycles.
- The `isHamiltonianCycle` method uses backtracking to try and build the Hamiltonian cycle starting from vertex `0`.
- The `isSafe` method ensures that the vertex can be added to the path without violating the Hamiltonian cycle conditions.
- The `hamCycleUtil` method is the core recursive function that attempts to construct the cycle.

This approach guarantees finding a Hamiltonian cycle if it exists, but due to its NP-complete nature, it may not be feasible for large graphs.

### 1. Algorithms & Data Structures (C++): Backedge Detection

Backedge detection is a concept in graph theory, particularly relevant in the context of depth-first search (DFS) traversal of graphs. A backedge in a DFS traversal indicates a cycle in the graph. Here's a detailed explanation on how to detect backedges using C++.

#### Concepts

1. **Graph Representation**:
    - A graph can be represented using an adjacency list or an adjacency matrix. The adjacency list is more space-efficient for sparse graphs.
  
2. **DFS Traversal**:
    - Depth-First Search (DFS) is used to explore the nodes of a graph systematically. In DFS, we visit a node and then recursively visit all its neighbors that haven't been visited yet.

3. **Types of Edges in DFS**:
    - **Tree Edge**: An edge leading to a vertex that has not been visited.
    - **Back Edge**: An edge that connects a vertex to an ancestor in the DFS tree.
    - **Forward Edge**: An edge that connects a vertex to a descendant in the DFS tree.
    - **Cross Edge**: Any other edge.

4. **Backedge Detection**:
    - A backedge indicates a cycle. In an undirected graph, a backedge is identified if we encounter an already visited vertex that is not the parent of the current vertex.
    - In a directed graph, it means there is a path from the current node to an ancestor in the recursion stack.

#### Implementation

Here's how you can implement backedge detection in C++ using DFS:

```cpp
#include <iostream>
#include <vector>
#include <list>

class Graph {
    int V; // Number of vertices
    std::vector<std::list<int>> adj; // Adjacency list

    void DFSUtil(int v, std::vector<bool>& visited, std::vector<int>& parent, bool& hasBackEdge);

public:
    Graph(int V); // Constructor
    void addEdge(int v, int w); // Function to add an edge to graph
    bool containsBackEdge(); // Function to check if graph contains back edge
};

Graph::Graph(int V) {
    this->V = V;
    adj.resize(V);
}

void Graph::addEdge(int v, int w) {
    adj[v].push_back(w); // Add w to v’s list.
}

void Graph::DFSUtil(int v, std::vector<bool>& visited, std::vector<int>& parent, bool& hasBackEdge) {
    visited[v] = true;

    for (int u : adj[v]) {
        if (!visited[u]) {
            parent[u] = v;
            DFSUtil(u, visited, parent, hasBackEdge);
        }
        else if (u != parent[v]) {
            // If an adjacent is visited and not parent of current vertex, then there is a back edge.
            hasBackEdge = true;
            return;
        }
    }
}

bool Graph::containsBackEdge() {
    std::vector<bool> visited(V, false);
    std::vector<int> parent(V, -1);
    bool hasBackEdge = false;

    for (int i = 0; i < V; ++i) {
        if (!visited[i]) {
            DFSUtil(i, visited, parent, hasBackEdge);
            if (hasBackEdge) return true;
        }
    }
    return false;
}

int main() {
    Graph g(4);
    g.addEdge(0, 1);
    g.addEdge(1, 2);
    g.addEdge(2, 0);
    g.addEdge(2, 3);

    if (g.containsBackEdge())
        std::cout << "Graph contains back edge (cycle detected)" << std::endl;
    else
        std::cout << "Graph doesn't contain back edge" << std::endl;

    return 0;
}
```

#### Explanation

1. **Graph Construction**:
    - The graph is represented using an adjacency list. The `addEdge` function adds an edge to the graph.

2. **DFS Utility Function**:
    - The `DFSUtil` function performs a depth-first search starting from a given vertex.
    - It marks nodes as visited and keeps track of the parent of each node to detect backedges.

3. **Backedge Detection**:
    - The `containsBackEdge` function iterates through all vertices and initiates a DFS from each unvisited vertex.
    - If a backedge is detected during DFS (an already visited node that is not the parent), the function returns true, indicating a cycle.

This implementation effectively detects backedges in a graph using DFS, which is crucial for understanding cycles in graphs.

## Shortest Path

### 1. Algorithms & Data Structures (C++): Graph: Shortest Path Problem (Theory)

The shortest path problem involves finding the shortest path or the minimum distance from a source vertex to a destination vertex in a graph. This problem can be categorized into different types based on the graph's properties and the specific requirements of the path finding:

1. **Single Source Shortest Path (SSSP):** Finding the shortest path from a single source vertex to all other vertices in the graph.
2. **Single Destination Shortest Path:** Finding the shortest path from all vertices to a single destination vertex.
3. **Single Pair Shortest Path:** Finding the shortest path between a given pair of vertices.
4. **All Pairs Shortest Path (APSP):** Finding the shortest path between every pair of vertices in the graph.

### 1. Algorithms & Data Structures (C++): Shortest Path

Shortest path algorithms are fundamental in computer science and are used in various applications such as network routing, GPS navigation, and even in games. There are several algorithms to find the shortest path in a graph, each with its own characteristics and use cases. In C++, you can implement these algorithms using different data structures like arrays, linked lists, priority queues, or even custom data structures depending on the requirements of the problem.

Here's a brief overview of some popular shortest path algorithms:

1. **Dijkstra's Algorithm**: This algorithm finds the shortest path from a source vertex to all other vertices in a weighted graph with non-negative edge weights. It uses a priority queue to greedily select the vertex with the smallest distance from the source and updates the distances to adjacent vertices.

2. **Bellman-Ford Algorithm**: Unlike Dijkstra's algorithm, Bellman-Ford can handle graphs with negative edge weights, but it is slower. It iterates over all edges multiple times, relaxing them to find the shortest path. It can also detect negative cycles.

3. **Floyd-Warshall Algorithm**: This algorithm finds the shortest paths between all pairs of vertices in a weighted graph. It works for both positive and negative edge weights (but no negative cycles). It uses dynamic programming to build a matrix of shortest distances.

4. **A* Search Algorithm**: A* is a best-first search algorithm that finds the shortest path from a start node to a goal node in a graph, using a heuristic function to guide the search. It combines the benefits of Dijkstra's algorithm and greedy search.

5. **Bidirectional Search**: This is not exactly an algorithm but a technique to find the shortest path between two vertices by simultaneously performing a forward search from the source vertex and a backward search from the destination vertex, meeting in the middle.

Implementing these algorithms involves understanding the underlying principles and data structures involved. In C++, you might use classes and structs to represent graphs and vertices, and standard library containers like vectors, sets, maps, or priority queues to manage data efficiently.

### 1. Algorithms & Data Structures (C++): Shortest Path using Breadth First Search [RETURN]

Breadth First Search (BFS) is a common algorithm used to find the shortest path in an unweighted graph. In an unweighted graph, the shortest path between two nodes is the path with the least number of edges. BFS is well-suited for this task because it explores all neighbors of a node before moving on to nodes at the next level of depth.

Here is a step-by-step explanation of how to implement BFS for finding the shortest path in C++:

#### Steps to Implement BFS for Shortest Path

1. **Initialize the Graph**: Represent the graph using an adjacency list.
2. **Set Up BFS**: Use a queue to manage the BFS process.
3. **Track Visited Nodes**: Use a boolean array to track which nodes have been visited to prevent cycles.
4. **Track Distance**: Use an array to store the distance from the source node to each node.
5. **Track Path**: Optionally, use an array to store the previous node for each node to reconstruct the path.

#### C++ Code Implementation

Here's a complete example of how to find the shortest path using BFS in C++:

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <climits>

using namespace std;

// Function to perform BFS and find the shortest path
void BFS(const vector<vector<int>>& graph, int start, vector<int>& distance, vector<int>& previous) {
    queue<int> q;
    vector<bool> visited(graph.size(), false);

    // Initialize start node
    q.push(start);
    visited[start] = true;
    distance[start] = 0;

    while (!q.empty()) {
        int node = q.front();
        q.pop();

        // Explore all neighbors
        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {
                q.push(neighbor);
                visited[neighbor] = true;
                distance[neighbor] = distance[node] + 1;
                previous[neighbor] = node;
            }
        }
    }
}

// Function to reconstruct the shortest path
vector<int> reconstructPath(int start, int end, const vector<int>& previous) {
    vector<int> path;
    for (int at = end; at != -1; at = previous[at]) {
        path.push_back(at);
    }
    reverse(path.begin(), path.end());

    // Check if the start node is in the path
    if (path[0] == start) {
        return path;
    } else {
        return {}; // Return an empty path if there is no valid path
    }
}

int main() {
    int n = 6; // Number of nodes in the graph
    vector<vector<int>> graph(n);

    // Define edges of the graph (undirected)
    graph[0] = {1, 2};
    graph[1] = {0, 3, 4};
    graph[2] = {0, 4};
    graph[3] = {1, 5};
    graph[4] = {1, 2, 5};
    graph[5] = {3, 4};

    int start = 0;
    int end = 5;

    vector<int> distance(n, INT_MAX);
    vector<int> previous(n, -1);

    // Perform BFS
    BFS(graph, start, distance, previous);

    // Reconstruct the shortest path
    vector<int> path = reconstructPath(start, end, previous);

    // Output the shortest path
    if (!path.empty()) {
        cout << "Shortest path from " << start << " to " << end << " is: ";
        for (int node : path) {
            cout << node << " ";
        }
        cout << endl;
    } else {
        cout << "No path found from " << start << " to " << end << endl;
    }

    return 0;
}
```

#### Explanation

1. **Graph Representation**: The graph is represented as an adjacency list using a `vector<vector<int>>`.
2. **BFS Function**:
    - Initializes the queue with the start node.
    - Uses a `visited` array to track visited nodes.
    - Uses a `distance` array to track the shortest distance from the start node.
    - Uses a `previous` array to track the path.
3. **Path Reconstruction**:
    - Constructs the path from the end node back to the start node using the `previous` array.
    - Checks if the path is valid by ensuring the start node is at the beginning of the reconstructed path.
4. **Main Function**:
    - Defines the graph and edges.
    - Performs BFS.
    - Reconstructs and prints the shortest path.

This implementation ensures an efficient search for the shortest path in an unweighted graph using BFS.

### 1. Algorithms & Data Structures (C++): Why does Depth First Search not work for SSSP?

Depth First Search (DFS) is not well-suited for Single-Source Shortest Path (SSSP) problems primarily due to its nature of exploration. DFS is a traversal algorithm that explores as far as possible along each branch before backtracking. While this approach is excellent for exploring or searching a graph, it does not guarantee the shortest path between two nodes.

Here are a few reasons why DFS is not suitable for SSSP:

1. **Non-optimal paths**: DFS explores the graph deeply before considering neighboring vertices. It may find a path from the source to the destination, but it is not guaranteed to be the shortest path. DFS does not consider the weight of edges, which is essential for finding the shortest path.

2. **Backtracking**: DFS explores one branch of the graph as far as possible before backtracking to explore other branches. This approach can lead to inefficiency, as it may explore many unnecessary paths before finding the shortest one.

3. **Lack of information**: DFS does not maintain information about the shortest path found so far. It simply explores the graph until it reaches the destination node. Without keeping track of the path length, DFS cannot guarantee the shortest path.

### 1. Algorithms & Data Structures (C++): Breadth First Search Over Binary Weighted Graphs [RETURN]

Breadth First Search (BFS) is a fundamental algorithm used for traversing or searching tree or graph data structures. In the context of binary weighted graphs (where weights are either 0 or 1), BFS can be particularly useful for finding the shortest path from a source vertex to a destination vertex.

Here's how you can implement BFS for binary weighted graphs in C++:

#### Key Concepts

1. **Binary Weighted Graph**: A graph where each edge has a weight of either 0 or 1.
2. **Deque**: Using a double-ended queue (deque) to efficiently handle the traversal, as it allows adding elements to both the front and the back.
3. **0-1 BFS**: A specialized form of BFS that handles edges with weights of 0 and 1 by utilizing a deque.

#### Algorithm

1. **Initialization**:
   - Use a deque to store pairs of (node, distance).
   - Initialize the distances to all vertices as infinity.
   - Set the distance to the source node as 0.

2. **Traversal**:
   - While the deque is not empty:
     - Extract the front node from the deque.
     - For each neighbor of the current node:
       - If the edge weight is 0 and the new calculated distance is less than the stored distance, update the distance and add the neighbor to the front of the deque.
       - If the edge weight is 1 and the new calculated distance is less than the stored distance, update the distance and add the neighbor to the back of the deque.

#### Implementation in C++

Here's a C++ implementation of the 0-1 BFS algorithm for binary weighted graphs:

```cpp
#include <iostream>
#include <vector>
#include <deque>
#include <utility> // for std::pair
#include <climits> // for INT_MAX

using namespace std;

void zeroOneBFS(vector<vector<pair<int, int>>> &graph, int src) {
    int n = graph.size();
    vector<int> dist(n, INT_MAX);
    deque<int> dq;
    
    // Initialize source node
    dist[src] = 0;
    dq.push_back(src);
    
    while (!dq.empty()) {
        int v = dq.front();
        dq.pop_front();
        
        // Process all neighbors
        for (auto &edge : graph[v]) {
            int u = edge.first;
            int weight = edge.second;
            
            if (dist[v] + weight < dist[u]) {
                dist[u] = dist[v] + weight;
                if (weight == 0) {
                    dq.push_front(u);
                } else {
                    dq.push_back(u);
                }
            }
        }
    }
    
    // Print shortest distances from src
    for (int i = 0; i < n; ++i) {
        cout << "Distance from node " << src << " to node " << i << " is " << dist[i] << endl;
    }
}

int main() {
    // Number of vertices
    int V = 5;
    
    // Graph representation: adjacency list of pairs (neighbor, weight)
    vector<vector<pair<int, int>>> graph(V);
    
    // Example edges: (src, dest, weight)
    graph[0].push_back({1, 0});
    graph[0].push_back({2, 1});
    graph[1].push_back({2, 0});
    graph[1].push_back({3, 1});
    graph[2].push_back({3, 0});
    graph[3].push_back({4, 1});
    
    int src = 0; // Starting node
    zeroOneBFS(graph, src);
    
    return 0;
}
```

#### Explanation

1. **Graph Representation**: The graph is represented using an adjacency list where each node stores a list of pairs. Each pair consists of a neighboring node and the weight of the edge connecting them.
2. **Distance Vector**: A vector `dist` is used to store the shortest distance from the source node to each node.
3. **Deque for Traversal**: The deque `dq` is used to efficiently manage the nodes during the BFS traversal. Nodes connected by edges with weight 0 are added to the front, and nodes connected by edges with weight 1 are added to the back.
4. **Updating Distances**: The distances are updated only if a shorter path is found, ensuring the shortest path is found for all nodes from the source.

This implementation efficiently handles binary weighted graphs and finds the shortest path using the 0-1 BFS approach.

### 1. Algorithms & Data Structures (C++): Dijastra Algorithm

Dijkstra's algorithm is a classic algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later. The algorithm exists in many variants; Dijkstra's original variant found the shortest path between two nodes, but a more common variant fixes a single node as the "source" node and finds shortest paths from the source to all other nodes in the graph, producing a shortest-path tree.

#### Dijkstra's Algorithm Overview

1. **Initialization**:
   - Set the distance to the source node to 0 and the distance to all other nodes to infinity.
   - Mark all nodes as unvisited. Create a set of all the unvisited nodes called the unvisited set.
   - Set the initial node as current.

2. **Visit the unvisited node with the smallest known distance from the start node**:
   - For the current node, consider all its unvisited neighbors and calculate their tentative distances. Compare the newly calculated tentative distance to the current assigned value and assign the smaller one. For example, if the current node A is marked with a distance of 6, and the edge connecting it with a neighbor B has length 2, then the distance to B through A will be 6 + 2 = 8. If B was previously marked with a distance greater than 8 then change it to 8. Otherwise, keep the current value.
   - After considering all the neighbors of the current node, mark the current node as visited and remove it from the unvisited set. A visited node will never be checked again.

3. **Repeat**:
   - Select the unvisited node that is marked with the smallest tentative distance, set it as the new "current node", and go back to step 2.

4. **Termination**:
   - The algorithm terminates when the destination node is marked visited (in the case of finding the shortest path to a specific node) or when the smallest tentative distance among the unvisited nodes is infinity (indicating that the remaining unvisited nodes are inaccessible from the source).

Here's a step-by-step outline of how Dijkstra's Algorithm works, followed by a sample implementation in C++.

#### Steps of Dijkstra's Algorithm

1. **Initialize:**
   - Set the distance to the source node to zero.
   - Set the distance to all other nodes to infinity.
   - Create a priority queue (min-heap) and insert the source node with a distance of zero.
   - Mark all nodes as unvisited.

2. **Main Loop:**
   - While there are unvisited nodes:
     - Extract the node with the smallest distance from the priority queue (let's call this node `u`).
     - For each neighbor `v` of `u`:
       - Calculate the tentative distance from the source to `v` through `u`.
       - If this tentative distance is less than the currently known distance to `v`, update the distance to `v` and add `v` to the priority queue.
     - Mark `u` as visited.

3. **Completion:**
   - Once all nodes have been visited, the algorithm is complete, and the shortest path from the source to each node is known.

#### C++ Implementation

Here is a sample implementation of Dijkstra's Algorithm in C++ using a priority queue:

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <utility>
#include <climits>

using namespace std;

typedef pair<int, int> pii;  // Pair to represent (distance, vertex)

// Function to implement Dijkstra's algorithm
void dijkstra(int source, vector<vector<pii>>& adj, vector<int>& distances) {
    int n = adj.size();
    distances.assign(n, INT_MAX);  // Initialize distances to infinity
    distances[source] = 0;  // Distance to source is 0

    // Priority queue to store (distance, vertex)
    priority_queue<pii, vector<pii>, greater<pii>> pq;
    pq.push({0, source});

    while (!pq.empty()) {
        
        

        int dist = pq.top().first;
        int u = pq.top().second;
        pq.pop();

        cout << dist << "\n";
        cout << u << "\n";

        if (dist > distances[u]) {
            continue;
        }

        for (const auto& edge : adj[u]) {
            
            int v = edge.first;
            int weight = edge.second;

            if (distances[u] + weight < distances[v]) {

                distances[v] = distances[u] + weight;
                pq.push({distances[v], v});
            }
        }
    }
}

int main() {

    int numberOfVertex = 7; 
    vector<vector<pii>> adj(numberOfVertex);
    
    adj[0] = std::vector<pii>{{1,3}, {2,20}, {5, 13}};
    adj[1] = std::vector<pii>{{0, 3}};
    adj[2] = std::vector<pii>{{0,20}, {3, 1}};
    adj[3] = std::vector<pii>{{2, 1}, {4,1}};
    adj[4] = std::vector<pii>{{3,1}, {5, 1}};
    adj[5] = std::vector<pii>{{4,1}, {6,1}, {0, 13}};
    adj[6] = std::vector<pii>{{5, 1}};
    

    int source = 0; 
    
    vector<int> distances;
    dijkstra(source, adj, distances);

    cout << "Shortest distances from source " << source << ":" << endl;
    for (int i = 0; i < numberOfVertex; ++i) {
        if (distances[i] == INT_MAX) {
            cout << "Vertex " << i << ": INFINITY" << endl;
        } else {
            cout << "Vertex " << i << ": " << distances[i] << endl;
        }
    }

    return 0;
}
```

#### Explanation

- **Graph Representation:** The graph is represented as an adjacency list using a vector of vectors of pairs. Each pair represents a neighboring vertex and the weight of the edge connecting to it.
- **Priority Queue:** The priority queue (min-heap) is used to efficiently get the next vertex with the smallest distance.
- **Distance Updates:** For each vertex, the algorithm updates the distances to its neighbors if a shorter path is found.

This implementation ensures that the shortest path from the source to all other vertices is found efficiently.

#### Complexity analysis

The time complexity of Dijkstra's Algorithm depends on the data structures used to implement the priority queue and the graph. Here's a brief complexity analysis for the provided C++ implementation:

##### Time Complexity

1. **Initialization:**
   - Setting up the distances vector and priority queue takes \(O(V)\) time, where \(V\) is the number of vertices.

2. **Priority Queue Operations:**
   - Inserting all vertices into the priority queue takes \(O(V \log V)\) time since each insertion operation is \(O(\log V)\).
   - Each vertex is extracted from the priority queue exactly once, and each extraction operation is \(O(\log V)\), leading to a total of \(O(V \log V)\) time for extractions.

3. **Relaxation of Edges:**
   - For each vertex, the algorithm checks all its adjacent edges. The total number of edge relaxations is \(O(E)\), where \(E\) is the number of edges.
   - Each edge relaxation involves a decrease-key operation on the priority queue, which takes \(O(\log V)\) time. Therefore, the total time for edge relaxations is \(O(E \log V)\).

Combining these, the overall time complexity is:
\[ O((V + E) \log V) \]
Since in the worst case \(E\) can be \(O(V^2)\), the complexity can be simplified to:
\[ O(E \log V) \]

##### Space Complexity

- The algorithm uses a priority queue, which stores at most \(V\) elements, leading to \(O(V)\) space.
- The adjacency list representation of the graph uses \(O(V + E)\) space.
- The distances vector uses \(O(V)\) space.

Therefore, the overall space complexity is:
\[ O(V + E) \]

In summary:

- **Time Complexity:** \(O(E \log V)\)
- **Space Complexity:** \(O(V + E)\)

#### Limitation of Dijikstra

Dijkstra's algorithm is a fundamental algorithm for finding the shortest path in a graph from a source node to all other nodes. While it's quite efficient in finding the shortest path in weighted graphs with non-negative edge weights, it does have some limitations:

1. **Doesn't Work with Negative Weights**: Dijkstra's algorithm doesn't work when the graph has edges with negative weights. This is because it relies on the property that once a node is marked as visited, its shortest path is finalized. With negative weights, it's possible to find a shorter path even after a node has been marked as visited.

2. **Doesn't Handle Graphs with Negative Cycles**: Even if all edge weights are non-negative, Dijkstra's algorithm can fail if the graph contains a negative cycle (a cycle whose total weight is negative). This is because in the presence of a negative cycle, there is no well-defined shortest path, as one can keep traversing the cycle to decrease the path length indefinitely.

3. **Inefficient for Dense Graphs**: While Dijkstra's algorithm performs well for sparse graphs (where the number of edges is much less than the number of nodes), it becomes inefficient for dense graphs. In dense graphs, the priority queue operations required by Dijkstra's algorithm can become quite expensive.

4. **Requires Priority Queue**: Dijkstra's algorithm requires a priority queue to efficiently select the next node to visit. Implementing a priority queue can add complexity to the algorithm, especially in languages like C++ where the standard library's priority queue doesn't support efficient decrease-key operations.

5. **Memory Usage**: In its typical form, Dijkstra's algorithm uses a lot of memory since it needs to keep track of the shortest distances from the source node to all other nodes in the graph. This memory requirement can be prohibitive for very large graphs.

These limitations make Dijkstra's algorithm unsuitable for certain types of graphs or situations. For cases where negative weights or negative cycles are present, algorithms like Bellman-Ford or Floyd-Warshall are more appropriate.

### 1. Algorithms & Data Structures (C++): All Pairs Shortest Path [RETURN]

The All Pairs Shortest Path (APSP) problem involves finding the shortest paths between all pairs of vertices in a weighted graph. One of the most well-known algorithms for solving this problem is the Floyd-Warshall algorithm, which is efficient for dense graphs. Here's a basic explanation of how it works in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

const int INF = 1e9; // Infinity value to represent unreachable nodes

// Function to find the shortest paths between all pairs of vertices
void floydWarshall(vector<vector<int>>& graph, int V) {
    vector<vector<int>> dist(V, vector<int>(V, INF)); // Initialize distances with infinity

    // Copy the graph to dist matrix
    for (int i = 0; i < V; ++i)
        for (int j = 0; j < V; ++j)
            dist[i][j] = graph[i][j];

    // Update distances by considering all vertices as intermediate vertices
    for (int k = 0; k < V; ++k) {
        for (int i = 0; i < V; ++i) {
            for (int j = 0; j < V; ++j) {
                // If vertex k is on the shortest path from i to j,
                // then update the value of dist[i][j]
                if (dist[i][k] != INF && dist[k][j] != INF && dist[i][k] + dist[k][j] < dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                }
            }
        }
    }

    // Output the shortest distances between every pair of vertices
    for (int i = 0; i < V; ++i) {
        for (int j = 0; j < V; ++j) {
            if (dist[i][j] == INF)
                cout << "INF\t";
            else
                cout << dist[i][j] << "\t";
        }
        cout << endl;
    }
}

int main() {
    // Example graph represented as an adjacency matrix
    vector<vector<int>> graph = {
        {0, 5, INF, 10},
        {INF, 0, 3, INF},
        {INF, INF, 0, 1},
        {INF, INF, INF, 0}
    };

    int V = graph.size();
    floydWarshall(graph, V);
    return 0;
}
```

In this implementation, `INF` represents infinity or unreachable vertices. The `floydWarshall` function iterates through all pairs of vertices and checks if there is a shorter path through the intermediate vertex `k`. If such a path exists, it updates the distance accordingly. Finally, it outputs the shortest distances between every pair of vertices.

### 1. Algorithms & Data Structures (C++): Floyd Warshall Algorithm [RETURN]

The Floyd-Warshall algorithm is a dynamic programming algorithm used to find the shortest paths between all pairs of vertices in a weighted graph with positive or negative edge weights (but with no negative cycles). It's particularly useful for finding shortest paths in dense graphs, where other algorithms like Dijkstra's or Bellman-Ford might be inefficient.

Here's a brief overview of how the algorithm works:

1. **Initialization**: Initialize a 2D array `dist[][]` where `dist[i][j]` will represent the shortest distance between vertex `i` and vertex `j`. If there's no edge between `i` and `j`, set `dist[i][j]` to infinity, and set `dist[i][i]` to 0. Also, initialize `dist[][]` with the weights of the edges.

2. **Main Loop**: Iterate over all vertices `k` from 1 to `V` (where `V` is the number of vertices in the graph). For each pair of vertices `i` and `j`, check if going through vertex `k` shortens the path from `i` to `j`. If it does, update the value of `dist[i][j]` to the new shorter path.

3. **Optimization**: The time complexity of the Floyd-Warshall algorithm is O(V^3), where `V` is the number of vertices in the graph. It's quite efficient for dense graphs but can be slower than other algorithms like Dijkstra's or Bellman-Ford for sparse graphs.

Here's a simple implementation of the Floyd-Warshall algorithm in C++:

```cpp
#include <iostream>
#include <vector>
using namespace std;

#define INF 999999

void floydWarshall(vector<vector<int>>& graph, int V) {
    vector<vector<int>> dist = graph;

    // Main loop
    for (int k = 0; k < V; k++) {
        for (int i = 0; i < V; i++) {
            for (int j = 0; j < V; j++) {
                if (dist[i][k] != INF && dist[k][j] != INF && dist[i][k] + dist[k][j] < dist[i][j])
                    dist[i][j] = dist[i][k] + dist[k][j];
            }
        }
    }

    // Printing the shortest distances
    cout << "Shortest distances between every pair of vertices:\n";
    for (int i = 0; i < V; i++) {
        for (int j = 0; j < V; j++) {
            if (dist[i][j] == INF)
                cout << "INF\t";
            else
                cout << dist[i][j] << "\t";
        }
        cout << endl;
    }
}

int main() {
    int V, E;
    cout << "Enter the number of vertices and edges: ";
    cin >> V >> E;

    // Initialize the graph with INF as initial distances
    vector<vector<int>> graph(V, vector<int>(V, INF));

    cout << "Enter the edges (source, destination, weight):\n";
    for (int i = 0; i < E; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        graph[u][v] = w;
    }

    // Calling the Floyd-Warshall function
    floydWarshall(graph, V);

    return 0;
}
```

This implementation takes input for the number of vertices and edges, and then for each edge, it takes the source vertex, destination vertex, and the weight of the edge. It then applies the Floyd-Warshall algorithm to find the shortest distances between all pairs of vertices and prints the result.

### 1. Algorithms & Data Structures (C++): Bellman-Ford Algorithm [RETURN]

The Bellman-Ford algorithm is a popular algorithm used for finding the shortest paths from a single source vertex to all other vertices in a weighted graph, even in the presence of negative weight edges, as long as there are no negative weight cycles reachable from the source vertex. Here's how it works:

1. Initialize distances: Set the distance to the source vertex to 0, and set the distance to all other vertices to infinity.
2. Relax edges: Iterate over all edges in the graph and relax each edge. Relaxing an edge means attempting to improve the shortest path to the destination vertex using the current shortest path to the source vertex and the weight of the edge.
3. Repeat relaxation: Repeat step 2 for |V| - 1 times, where |V| is the number of vertices in the graph. This ensures that the shortest paths are found even in the presence of negative weight edges, as the longest possible shortest path in a graph with |V| vertices is of length |V| - 1.
4. Check for negative weight cycles: After performing |V| - 1 iterations of relaxation, if there are still improvements to be made to the distances, then there must be a negative weight cycle in the graph reachable from the source vertex.

Here's a C++ implementation of the Bellman-Ford algorithm:

```cpp
#include <iostream>
#include <vector>
#include <limits>

using namespace std;

struct Edge {
    int source, destination, weight;
};

void bellmanFord(vector<Edge>& edges, int numVertices, int source) {
    vector<int> distance(numVertices, numeric_limits<int>::max());
    distance[source] = 0;

    for (int i = 0; i < numVertices - 1; ++i) {
        for (const auto& edge : edges) {
            if (distance[edge.source] != numeric_limits<int>::max() &&
                distance[edge.source] + edge.weight < distance[edge.destination]) {
                distance[edge.destination] = distance[edge.source] + edge.weight;
            }
        }
    }

    // Check for negative weight cycles
    for (const auto& edge : edges) {
        if (distance[edge.source] != numeric_limits<int>::max() &&
            distance[edge.source] + edge.weight < distance[edge.destination]) {
            cout << "Graph contains negative weight cycle reachable from source vertex." << endl;
            return;
        }
    }

    // Print shortest distances
    cout << "Shortest distances from source vertex " << source << ":" << endl;
    for (int i = 0; i < numVertices; ++i) {
        cout << "Vertex " << i << ": " << distance[i] << endl;
    }
}

int main() {
    int numVertices = 5;
    int source = 0; // Source vertex

    // Example graph
    vector<Edge> edges = {
        {0, 1, -1},
        {0, 2, 4},
        {1, 2, 3},
        {1, 3, 2},
        {1, 4, 2},
        {3, 2, 5},
        {3, 1, 1},
        {4, 3, -3}
    };

    bellmanFord(edges, numVertices, source);

    return 0;
}
```

This code demonstrates the Bellman-Ford algorithm with an example graph. You can modify the `edges` vector to represent your own graph.

### 1. Algorithms & Data Structures (C++): A* search algorithm [RETURN]

The A* (A-star) search algorithm is a widely used pathfinding and graph traversal algorithm, known for its efficiency and accuracy. It's especially popular in fields like AI, robotics, and game development.

#### Key Concepts

1. **Graph Representation**: The algorithm operates on a graph, which can be represented using adjacency lists, adjacency matrices, or edge lists. Nodes represent points or states, and edges represent possible transitions or paths between nodes.

2. **Heuristic Function (h(n))**: This function estimates the cost to reach the goal from node \( n \). A common heuristic for grid-based pathfinding is the Euclidean distance or Manhattan distance.

3. **Cost Function (g(n))**: This function represents the cost from the start node to node \( n \).

4. **Evaluation Function (f(n))**: This combines the cost function and the heuristic function: \( f(n) = g(n) + h(n) \). A* uses this function to prioritize nodes.

#### Algorithm Steps

1. **Initialization**:
   - Create an open list (priority queue) to store nodes to be evaluated.
   - Create a closed list to store nodes already evaluated.
   - Add the start node to the open list with \( f(start) = g(start) + h(start) \).

2. **Main Loop**:
   - While the open list is not empty:
     - Extract the node with the lowest \( f(n) \) value from the open list.
     - If this node is the goal, reconstruct and return the path.
     - Move the node to the closed list.
     - For each neighbor of the current node:
       - If the neighbor is in the closed list, skip it.
       - Calculate \( g(neighbor) = g(current) + cost(current, neighbor) \).
       - If the neighbor is not in the open list or \( g(neighbor) \) is lower than the previously recorded cost:
         - Update \( g(neighbor) \) and \( f(neighbor) \).
         - Set the current node as the neighbor's parent.
         - Add the neighbor to the open list if not already present.

3. **Path Reconstruction**:
   - Once the goal is reached, reconstruct the path by tracing back from the goal to the start using the parent references.

#### Example Code in C++

Here is a basic implementation of the A* algorithm in C++:

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_set>
#include <unordered_map>
#include <cmath>

struct Node {
    int x, y;
    Node(int x, int y) : x(x), y(y) {}

    bool operator==(const Node& other) const {
        return x == other.x && y == other.y;
    }
};

struct NodeHash {
    std::size_t operator()(const Node& node) const {
        return std::hash<int>()(node.x) ^ std::hash<int>()(node.y);
    }
};

struct NodeInfo {
    Node parent;
    double g, h;
    NodeInfo(Node parent, double g, double h) : parent(parent), g(g), h(h) {}
};

struct Compare {
    bool operator()(const std::pair<Node, double>& a, const std::pair<Node, double>& b) {
        return a.second > b.second;
    }
};

double heuristic(const Node& a, const Node& b) {
    return std::sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
}

std::vector<Node> get_neighbors(const Node& node) {
    std::vector<Node> neighbors;
    neighbors.push_back(Node(node.x + 1, node.y));
    neighbors.push_back(Node(node.x - 1, node.y));
    neighbors.push_back(Node(node.x, node.y + 1));
    neighbors.push_back(Node(node.x, node.y - 1));
    return neighbors;
}

std::vector<Node> reconstruct_path(std::unordered_map<Node, NodeInfo, NodeHash>& node_map, Node& start, Node& goal) {
    std::vector<Node> path;
    Node current = goal;
    while (current != start) {
        path.push_back(current);
        current = node_map[current].parent;
    }
    path.push_back(start);
    std::reverse(path.begin(), path.end());
    return path;
}

std::vector<Node> astar(const Node& start, const Node& goal) {
    std::priority_queue<std::pair<Node, double>, std::vector<std::pair<Node, double>>, Compare> open_list;
    std::unordered_set<Node, NodeHash> closed_list;
    std::unordered_map<Node, NodeInfo, NodeHash> node_map;

    open_list.push({start, 0});
    node_map[start] = NodeInfo(start, 0, heuristic(start, goal));

    while (!open_list.empty()) {
        Node current = open_list.top().first;
        open_list.pop();

        if (current == goal) {
            return reconstruct_path(node_map, const_cast<Node&>(start), const_cast<Node&>(goal));
        }

        closed_list.insert(current);

        for (Node& neighbor : get_neighbors(current)) {
            if (closed_list.find(neighbor) != closed_list.end()) continue;

            double tentative_g = node_map[current].g + 1;  // Assuming uniform cost for simplicity
            bool is_better_path = node_map.find(neighbor) == node_map.end() || tentative_g < node_map[neighbor].g;

            if (is_better_path) {
                node_map[neighbor] = NodeInfo(current, tentative_g, heuristic(neighbor, goal));
                double f = tentative_g + node_map[neighbor].h;
                open_list.push({neighbor, f});
            }
        }
    }

    return {};  // No path found
}

int main() {
    Node start(0, 0);
    Node goal(5, 5);
    std::vector<Node> path = astar(start, goal);

    if (!path.empty()) {
        std::cout << "Path found:" << std::endl;
        for (Node& node : path) {
            std::cout << "(" << node.x << "," << node.y << ")" << std::endl;
        }
    } else {
        std::cout << "No path found." << std::endl;
    }

    return 0;
}
```

#### Explanation

- **Node Structure**: Represents a point in the grid with x and y coordinates.
- **Heuristic Function**: Calculates the Euclidean distance between two nodes.
- **Priority Queue**: The open list is implemented as a priority queue, ordered by the \( f(n) \) value.
- **Path Reconstruction**: Traces back from the goal to the start node using parent references stored in a map.

This implementation is basic and can be enhanced with various optimizations and adaptations for specific use cases.

## Minimum Spanning Tree

### 1. Algorithms & Data Structures (C++): Minimum Spanning Tree: Theory

A **Minimum Spanning Tree (MST)** of a graph is a subset of the edges that connects all vertices in the graph without any cycles and with the minimum possible total edge weight.

#### Key Concepts

1. **Spanning Tree**: A spanning tree of a graph \( G \) is a subgraph that includes all the vertices of \( G \) and is a single connected component without cycles.
2. **Minimum Spanning Tree**: An MST is a spanning tree with the minimum possible sum of edge weights.

#### Applications

- Network design (e.g., designing minimum cost telecommunication networks)
- Approximation algorithms for NP-hard problems
- Cluster analysis

#### Properties

1. **Uniqueness**: A graph can have more than one MST if multiple edges have the same weight.
2. **Cycle Property**: For any cycle in the graph, the heaviest edge in the cycle cannot be part of the MST.
3. **Cut Property**: For any cut in the graph, the smallest weight edge crossing the cut must be in the MST.

### 1. Algorithms & Data Structures (C++): Minimum Spanning Tree: Kruskal's Algorithm [RETURN]

Kruskal's algorithm is a popular algorithm in graph theory used to find the Minimum Spanning Tree (MST) of a connected, undirected graph. The MST is a subset of the edges that connects all vertices in the graph without any cycles and with the minimum possible total edge weight.

#### Steps of Kruskal's Algorithm

1. **Sort all the edges in non-decreasing order of their weight.**
2. **Initialize an empty spanning tree (initially contains no edges).**
3. **Repeat until the spanning tree has \( V-1 \) edges (where \( V \) is the number of vertices):**
   - Pick the smallest edge from the sorted list.
   - Check if adding this edge creates a cycle using the Union-Find data structure.
   - If it doesn't form a cycle, include this edge in the spanning tree.
   - If it forms a cycle, discard the edge.

#### Implementation in C++

Here's a simple implementation of Kruskal's algorithm using C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// Edge structure to represent a graph edge
struct Edge {
    int src, dest, weight;
};

// Union-Find data structure to detect cycles
class UnionFind {
    vector<int> parent, rank;
public:
    UnionFind(int n) : parent(n), rank(n, 0) {
        for (int i = 0; i < n; ++i) parent[i] = i;
    }

    int find(int u) {
        if (u != parent[u])
            parent[u] = find(parent[u]);
        return parent[u];
    }

    bool unionSets(int u, int v) {
        int rootU = find(u);
        int rootV = find(v);
        if (rootU == rootV) return false;
        if (rank[rootU] > rank[rootV])
            parent[rootV] = rootU;
        else if (rank[rootU] < rank[rootV])
            parent[rootU] = rootV;
        else {
            parent[rootV] = rootU;
            rank[rootU]++;
        }
        return true;
    }
};

class Graph {
public:
    Graph(int V, int E) : V(V), E(E) {
        edges = vector<Edge>(E);
    }

    void addEdge(int index, int u, int v, int w) {
        edges[index] = {u, v, w};
    }

    void kruskalMST() {
        sort(edges.begin(), edges.end(), [](Edge a, Edge b) {
            return a.weight < b.weight;
        });

        UnionFind uf(V);
        vector<Edge> mst;

        for (Edge& edge : edges) {
            if (uf.unionSets(edge.src, edge.dest)) {
                mst.push_back(edge);
            }
        }

        cout << "Edges in the Minimum Spanning Tree:\n";
        for (Edge& edge : mst) {
            cout << edge.src << " -- " << edge.dest << " == " << edge.weight << endl;
        }
    }

private:
    int V, E;
    vector<Edge> edges;
};

int main() {
    int V = 4;  // Number of vertices
    int E = 5;  // Number of edges
    Graph g(V, E);

    g.addEdge(0, 0, 1, 10);
    g.addEdge(1, 0, 2, 6);
    g.addEdge(2, 0, 3, 5);
    g.addEdge(3, 1, 3, 15);
    g.addEdge(4, 2, 3, 4);

    g.kruskalMST();

    return 0;
}
```

#### Explanation

1. **Graph Initialization**: The `Graph` class is initialized with the number of vertices \( V \) and edges \( E \).
2. **Adding Edges**: The `addEdge` function is used to add edges to the graph.
3. **Kruskal's MST Function**:
   - **Sorting**: The edges are sorted based on their weight.
   - **Union-Find**: A Union-Find data structure is used to keep track of the sets of vertices and to detect cycles.
   - **Building MST**: Edges are added to the MST if they don't form a cycle.

This code outputs the edges included in the MST along with their weights.

### 1. Algorithms & Data Structures (C++): Minimum Spanning Tree: Prim's Algorithm [RETURN]

Prim's algorithm is a popular method used to find the Minimum Spanning Tree (MST) of a connected, undirected graph. Here's a basic explanation of how Prim's algorithm works:

1. **Initialization**: Start with an arbitrary vertex as the initial vertex and mark it as visited.

2. **Selecting Edges**: Find the minimum-weight edge that connects a visited vertex to an unvisited vertex. Add this edge to the MST and mark the newly visited vertex as visited.

3. **Repeat**: Repeat step 2 until all vertices are visited.

4. **Termination**: Once all vertices are visited, the algorithm terminates, and the resulting tree is the MST of the graph.

Here's a simple implementation of Prim's algorithm in C++ using adjacency matrix representation:

```cpp
#include <iostream>
#include <climits>
using namespace std;

#define V 5 // Number of vertices

int minKey(int key[], bool mstSet[]) {
    int min = INT_MAX, min_index;
    for (int v = 0; v < V; v++)
        if (mstSet[v] == false && key[v] < min)
            min = key[v], min_index = v;
    return min_index;
}

void printMST(int parent[], int graph[V][V]) {
    cout << "Edge \tWeight\n";
    for (int i = 1; i < V; i++)
        cout << parent[i] << " - " << i << " \t" << graph[i][parent[i]] << " \n";
}

void primMST(int graph[V][V]) {
    int parent[V]; // Array to store constructed MST
    int key[V]; // Key values used to pick minimum weight edge in cut
    bool mstSet[V]; // To represent set of vertices not yet included in MST

    // Initialize all keys as INFINITE
    for (int i = 0; i < V; i++)
        key[i] = INT_MAX, mstSet[i] = false;

    // Always include first 0th vertex in MST.
    key[0] = 0;
    parent[0] = -1; // First node is always root of MST

    // The MST will have V vertices
    for (int count = 0; count < V - 1; count++) {
        // Pick the minimum key vertex not yet included in MST
        int u = minKey(key, mstSet);
        // Add the picked vertex to the MST Set
        mstSet[u] = true;
        // Update key value and parent index of the adjacent vertices of the picked vertex.
        // Consider only those vertices which are not yet included in MST
        for (int v = 0; v < V; v++)
            // graph[u][v] is non zero only for adjacent vertices of m
            // mstSet[v] is false for vertices not yet included in MST
            // Update the key only if graph[u][v] is smaller than key[v]
            if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v])
                parent[v] = u, key[v] = graph[u][v];
    }

    // print the constructed MST
    printMST(parent, graph);
}

int main() {
    // Sample graph
    int graph[V][V] = {
        {0, 2, 0, 6, 0},
        {2, 0, 3, 8, 5},
        {0, 3, 0, 0, 7},
        {6, 8, 0, 0, 9},
        {0, 5, 7, 9, 0}
    };

    // Print the solution
    primMST(graph);

    return 0;
}
```

This implementation finds the MST of a sample graph and prints the edges along with their weights. You can modify the `graph` array to represent your own graph.

### 1. Algorithms & Data Structures (C++): Prim's vs Kruskal [RETURN]

Prim's and Kruskal's algorithms are both used for finding the minimum spanning tree (MST) of a weighted graph. Here's a comparison between the two:

1. **Algorithm Type**:
   - Prim's: Prim's algorithm is a greedy algorithm.
   - Kruskal's: Kruskal's algorithm is also a greedy algorithm.

2. **Approach**:
   - Prim's: It grows the minimum spanning tree from an arbitrary vertex by adding the cheapest edge to the tree that doesn't form a cycle until all vertices are included.
   - Kruskal's: It selects edges in ascending order of weight and adds them to the growing forest (initially individual vertices) if they don't create a cycle until all vertices are connected.

3. **Complexity**:
   - Prim's: The time complexity of Prim's algorithm is O(V^2) with an adjacency matrix representation, and O(E log V) with an adjacency list representation using a priority queue.
   - Kruskal's: The time complexity of Kruskal's algorithm is O(E log E) with a sorting operation, where E is the number of edges.

4. **Edge Selection**:
   - Prim's: It selects the minimum-weight edge incident to the tree at each step.
   - Kruskal's: It selects edges based solely on weight, without considering the connectivity of the graph.

5. **Use Cases**:
   - Prim's: It's generally faster for dense graphs (graphs with a large number of edges).
   - Kruskal's: It's often preferred for sparse graphs (graphs with relatively few edges).

6. **Space Complexity**:
   - Prim's: Requires O(V) space for the priority queue plus O(V^2) or O(V) space for storing the adjacency matrix or adjacency list, respectively.
   - Kruskal's: Requires O(E + V) space for the disjoint-set data structure.

7. **Implementation**:
   - Prim's: Typically implemented using a priority queue for efficient selection of minimum-weight edges.
   - Kruskal's: Typically implemented using a disjoint-set data structure for efficient cycle detection.

8. **Parallelization**:
   - Kruskal's: Easier to parallelize since the edge selection is independent.
   - Prim's: More challenging to parallelize due to the dependency on the current tree.

In summary, both Prim's and Kruskal's algorithms are efficient ways to find the minimum spanning tree of a graph, but the choice between them often depends on the specific characteristics of the graph and the available resources.

### 1. Algorithms & Data Structures (C++): Prims: Commutable Islands [RETURN]

Prim's algorithm is a method used to find the minimum spanning tree (MST) of a weighted undirected graph. It's a greedy algorithm that starts with an arbitrary vertex and repeatedly grows a tree by adding the cheapest edge that connects a vertex in the tree to a vertex outside the tree until all vertices are included.

In the context of "Commutable Islands," which seems like a graph problem, it's likely that you have a set of islands (vertices) and bridges connecting them (edges), each with a certain cost. The task may be to find the minimum cost to connect all islands, or to determine the cost of the minimum spanning tree (MST) of the graph representing these islands and bridges.

Here's a basic outline of how you might implement Prim's algorithm in C++ for this problem:

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <climits>

using namespace std;

// Structure to represent a vertex and its corresponding cost
struct Node {
    int vertex;
    int cost;
};

// Function to implement Prim's algorithm
int primMST(vector<vector<Node>>& graph) {
    int n = graph.size(); // Number of vertices
    vector<bool> visited(n, false); // To keep track of visited vertices
    int minCost = 0; // Total cost of MST

    // Priority queue to store vertices along with their costs
    priority_queue<Node, vector<Node>, greater<Node>> pq;

    // Start from the first vertex
    pq.push({0, 0});

    while (!pq.empty()) {
        // Extract the vertex with the minimum cost
        Node curr = pq.top();
        pq.pop();

        int u = curr.vertex;
        int cost = curr.cost;

        // If vertex u is already visited, skip it
        if (visited[u])
            continue;

        // Mark vertex u as visited
        visited[u] = true;

        // Add the cost of the edge to the total cost
        minCost += cost;

        // Visit all adjacent vertices of u
        for (const auto& neighbor : graph[u]) {
            int v = neighbor.vertex;
            int weight = neighbor.cost;
            if (!visited[v])
                pq.push({v, weight});
        }
    }

    return minCost;
}

int main() {
    // Example graph representation (adjacency list)
    vector<vector<Node>> graph = {
        {{1, 2}, {2, 3}},
        {{0, 2}, {2, 4}, {3, 5}},
        {{0, 3}, {1, 4}, {3, 6}},
        {{1, 5}, {2, 6}}
    };

    int minCost = primMST(graph);
    cout << "Minimum cost to connect all islands: " << minCost << endl;

    return 0;
}
```

In this implementation, `Node` represents a vertex and its corresponding cost. The `primMST` function calculates the minimum cost to connect all islands using Prim's algorithm. The `main` function provides an example graph represented as an adjacency list and calculates the minimum cost. You can adjust the graph representation and input as per your specific problem requirements.

### 1. Algorithms & Data Structures (C++): Build Roads [RETURN]

To implement an algorithm for building roads in C++, you typically want to find a minimal spanning tree (MST) of a given graph. Prim's or Kruskal's algorithm are commonly used for this purpose. Here's a basic outline of how you might implement Kruskal's algorithm to build roads:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct Edge {
    int u, v, weight;
};

class Graph {
    int V;
    vector<Edge> edges;

public:
    Graph(int V) : V(V) {}

    void addEdge(int u, int v, int weight) {
        edges.push_back({u, v, weight});
    }

    int findParent(vector<int>& parent, int i) {
        if (parent[i] == -1)
            return i;
        return findParent(parent, parent[i]);
    }

    void unionSets(vector<int>& parent, int u, int v) {
        int uSet = findParent(parent, u);
        int vSet = findParent(parent, v);
        parent[uSet] = vSet;
    }

    void buildRoads() {
        sort(edges.begin(), edges.end(), [](const Edge& a, const Edge& b) {
            return a.weight < b.weight;
        });

        vector<int> parent(V, -1);
        cout << "Minimum Spanning Tree edges (u-v) with weights:\n";
        for (const Edge& edge : edges) {
            int u = edge.u;
            int v = edge.v;
            int uSet = findParent(parent, u);
            int vSet = findParent(parent, v);
            if (uSet != vSet) {
                cout << u << "-" << v << " (" << edge.weight << ")\n";
                unionSets(parent, uSet, vSet);
            }
        }
    }
};

int main() {
    int V, E;
    cout << "Enter the number of vertices and edges: ";
    cin >> V >> E;

    Graph graph(V);
    cout << "Enter edges (u v weight):\n";
    for (int i = 0; i < E; ++i) {
        int u, v, weight;
        cin >> u >> v >> weight;
        graph.addEdge(u, v, weight);
    }

    graph.buildRoads();

    return 0;
}
```

This code takes input of the number of vertices and edges, followed by the details of each edge (source, destination, weight). Then, it builds the MST using Kruskal's algorithm and outputs the edges forming the minimum spanning tree. These edges represent the roads that need to be built.

### 1. Algorithms & Data Structures (C++): Ring MST [RETURN]

A Ring Minimum Spanning Tree (Ring MST) is a variation of the Minimum Spanning Tree problem where the resultant tree forms a ring, meaning it has a cycle of length equal to the number of vertices in the graph. A spanning tree is a subset of the edges of a connected, edge-weighted graph that connects all the vertices together without any cycles and with the minimum possible total edge weight.

Implementing a Ring MST algorithm typically involves modifying an existing MST algorithm to ensure that the resulting spanning tree forms a ring. One common algorithm used for finding MSTs is Kruskal's algorithm or Prim's algorithm. Here's a high-level approach to modifying Kruskal's algorithm for Ring MST:

1. Run Kruskal's algorithm to find the Minimum Spanning Tree (MST) of the given graph.
2. After obtaining the MST, check if it forms a ring.
3. If the MST doesn't form a ring, add the minimum weight edge that completes the ring while avoiding creating cycles.
4. Return the resultant ring MST.

Below is a simplified implementation of Kruskal's algorithm in C++ along with modifications to ensure that the resultant tree forms a ring:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// Data structure to represent a graph edge
struct Edge {
    int src, dest, weight;
};

// Data structure to represent a graph
class Graph {
public:
    vector<Edge> edges; // array to store graph edges
    int V; // number of vertices

    // Constructor
    Graph(int V) {
        this->V = V;
    }

    // Function to add an edge to the graph
    void addEdge(int src, int dest, int weight) {
        edges.push_back({src, dest, weight});
    }

    // Kruskal's algorithm to find MST
    vector<Edge> kruskalMST() {
        vector<Edge> result;

        // Sort all the edges in non-decreasing order of their weight
        sort(edges.begin(), edges.end(), [](const Edge& a, const Edge& b) {
            return a.weight < b.weight;
        });

        // Create disjoint sets
        vector<int> parent(V, -1);

        int edgeCount = 0;
        int i = 0;
        // Number of edges to be taken is equal to V-1
        while (edgeCount < V - 1 && i < edges.size()) {
            Edge next_edge = edges[i++];

            // Find root endpoints of the current edge
            int x = find(parent, next_edge.src);
            int y = find(parent, next_edge.dest);

            // If including this edge does't cause cycle, include it
            if (x != y) {
                result.push_back(next_edge);
                unionSet(parent, x, y);
                edgeCount++;
            }
        }

        return result;
    }

private:
    // Find set of an element i
    int find(vector<int>& parent, int i) {
        if (parent[i] == -1)
            return i;
        return find(parent, parent[i]);
    }

    // Perform union of two subsets
    void unionSet(vector<int>& parent, int x, int y) {
        int xset = find(parent, x);
        int yset = find(parent, y);
        parent[xset] = yset;
    }
};

// Function to check if the MST forms a ring
bool formsRingMST(const Graph& g, const vector<Edge>& mst) {
    // A spanning tree with V vertices has exactly V-1 edges
    if (mst.size() != g.V - 1)
        return false;

    // Check if the MST contains any vertex with degree > 2
    vector<int> degree(g.V, 0);
    for (const auto& edge : mst) {
        degree[edge.src]++;
        degree[edge.dest]++;
    }
    for (int d : degree) {
        if (d > 2)
            return false;
    }

    return true;
}

// Function to find the minimum weight edge that completes the ring
Edge findMinWeightEdge(const Graph& g, const vector<Edge>& mst) {
    // Initialize minimum weight to infinity
    Edge minEdge = {-1, -1, INT_MAX};

    // Iterate through all edges not present in MST
    for (const auto& edge : g.edges) {
        if (find(mst.begin(), mst.end(), edge) == mst.end()) {
            // Update minEdge if weight of current edge is less than minEdge
            if (edge.weight < minEdge.weight)
                minEdge = edge;
        }
    }

    return minEdge;
}

// Function to convert MST to ring MST
vector<Edge> convertToRingMST(const Graph& g, const vector<Edge>& mst) {
    if (!formsRingMST(g, mst)) {
        // Find the minimum weight edge that completes the ring
        Edge minEdge = findMinWeightEdge(g, mst);

        // Add the minimum weight edge to MST to complete the ring
        vector<Edge> ringMST = mst;
        ringMST.push_back(minEdge);
        return ringMST;
    }
    return mst;
}

int main() {
    // Create a graph
    int V = 4;
    Graph g(V);

    // Add edges
    g.addEdge(0, 1, 10);
    g.addEdge(0, 2, 6);
    g.addEdge(0, 3, 5);
    g.addEdge(1, 3, 15);
    g.addEdge(2, 3, 4);

    // Find MST
    vector<Edge> mst = g.kruskalMST();

    // Convert MST to Ring MST
    vector<Edge> ringMST = convertToRingMST(g, mst);

    // Output the edges of the Ring MST
    cout << "Edges of the Ring MST:\n";
    for (const auto& edge : ringMST) {
        cout << edge.src << " - " << edge.dest << " : " << edge.weight << "\n";
    }

    return 0;
}
```

This code demonstrates a basic implementation of Kruskal's algorithm to find the MST of a given graph, followed by modifications to ensure the resultant tree forms a ring.

## Topological Sorting

### 1. Algorithms & Data Structures (C++): Graph: Topological Ordering

Topological ordering, or topological sorting, of a directed graph is a linear ordering of its vertices such that for every directed edge \( uv \) from vertex \( u \) to vertex \( v \), \( u \) comes before \( v \) in the ordering. This is only possible if the graph has no directed cycles, meaning it is a Directed Acyclic Graph (DAG).

#### Key Concepts

##### Directed Acyclic Graph (DAG)

- A directed graph with no cycles.
- Contains vertices connected by directed edges.
- Important in various applications like scheduling tasks, resolving symbol dependencies in linkers, and data serialization.

##### Applications of Topological Ordering

1. **Task Scheduling**: Order of tasks where certain tasks must be performed before others.
2. **Course Prerequisites**: Ordering of courses to be taken based on prerequisites.
3. **Dependency Resolution**: Managing dependencies in systems such as package managers.

### 1. Algorithms & Data Structures (C++): Topological sorting: Theory

Topological sorting is a fundamental concept in computer science, particularly in the field of algorithms and data structures. It is used to order the vertices of a directed acyclic graph (DAG) such that for every directed edge \( uv \) from vertex \( u \) to vertex \( v \), \( u \) comes before \( v \) in the ordering. This ordering is known as a topological order.

#### Algorithms for Topological Sorting

There are two primary algorithms used for topological sorting:

1. **Kahn's Algorithm**:
    - This algorithm uses an in-degree-based approach.
    - Steps:
        1. Compute in-degree (number of incoming edges) for each vertex.
        2. Collect all vertices with in-degree 0 into a queue.
        3. While the queue is not empty:
            - Remove a vertex \( u \) from the queue.
            - Append \( u \) to the topological order.
            - For each vertex \( v \) adjacent to \( u \):
                - Decrease the in-degree of \( v \) by 1.
                - If \( v \) now has an in-degree of 0, add \( v \) to the queue.
    - If the graph has a cycle, the queue will be empty before all vertices are processed, indicating that a topological sort is not possible.

2. **Depth-First Search (DFS)-Based Algorithm**:
    - This algorithm leverages the properties of DFS to produce a topological sort.
    - Steps:
        1. Initialize all vertices as unvisited.
        2. For each unvisited vertex, perform a DFS.
        3. On reaching a vertex where no further vertices can be visited, add that vertex to a stack.
        4. After the DFS completes, the stack will contain the vertices in topologically sorted order (pop the vertices from the stack to get the order).
    - During the DFS, if a back edge is detected (an edge pointing to an ancestor in the current DFS path), the graph contains a cycle, and a topological sort is not possible.

#### Example in C++

Here is a simple implementation of both algorithms in C++:

**Kahn's Algorithm**:

```cpp
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

void topologicalSortKahn(int V, vector<vector<int>>& adj) {
    vector<int> in_degree(V, 0);

    for (int u = 0; u < V; u++) {
        for (int v : adj[u]) {
            in_degree[v]++;
        }
    }

    queue<int> q;
    for (int i = 0; i < V; i++) {
        if (in_degree[i] == 0) {
            q.push(i);
        }
    }

    vector<int> top_order;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        top_order.push_back(u);

        for (int v : adj[u]) {
            if (--in_degree[v] == 0) {
                q.push(v);
            }
        }
    }

    if (top_order.size() != V) {
        cout << "Graph has a cycle\n";
    } else {
        for (int i : top_order) {
            cout << i << " ";
        }
        cout << endl;
    }
}

int main() {
    int V = 6;
    vector<vector<int>> adj(V);

    adj[5].push_back(2);
    adj[5].push_back(0);
    adj[4].push_back(0);
    adj[4].push_back(1);
    adj[2].push_back(3);
    adj[3].push_back(1);

    topologicalSortKahn(V, adj);

    return 0;
}
```

**DFS-Based Algorithm**:

```cpp
#include <iostream>
#include <vector>
#include <stack>

using namespace std;

void dfs(int v, vector<vector<int>>& adj, vector<bool>& visited, stack<int>& Stack) {
    visited[v] = true;

    for (int u : adj[v]) {
        if (!visited[u]) {
            dfs(u, adj, visited, Stack);
        }
    }

    Stack.push(v);
}

void topologicalSortDFS(int V, vector<vector<int>>& adj) {
    stack<int> Stack;
    vector<bool> visited(V, false);

    for (int i = 0; i < V; i++) {
        if (!visited[i]) {
            dfs(i, adj, visited, Stack);
        }
    }

    while (!Stack.empty()) {
        cout << Stack.top() << " ";
        Stack.pop();
    }
    cout << endl;
}

int main() {
    int V = 6;
    vector<vector<int>> adj(V);

    adj[5].push_back(2);
    adj[5].push_back(0);
    adj[4].push_back(0);
    adj[4].push_back(1);
    adj[2].push_back(3);
    adj[3].push_back(1);

    topologicalSortDFS(V, adj);

    return 0;
}
```

These implementations illustrate the essential steps of Kahn's algorithm and the DFS-based algorithm for topological sorting. Both provide a reliable way to determine a valid topological order of a DAG.


## SCC

### 1. Algorithms & Data Structures (C++): SCC Theory

Strongly Connected Components (SCC) are a key concept in graph theory, particularly in the context of directed graphs. Here, we'll cover the theoretical aspects of SCCs and how they can be identified in a directed graph.

#### Definition

A **strongly connected component** of a directed graph is a maximal subgraph in which every pair of vertices (u, v) is reachable from each other. In other words, there is a directed path from \( u \) to \( v \) and a directed path from \( v \) to \( u \) for every pair of vertices within the component.

#### Properties of SCCs

1. **Decomposition**: Any directed graph can be decomposed into SCCs, and these components form a Directed Acyclic Graph (DAG) when considered as single vertices. This is known as the **condensation** of the graph.
2. **Maximality**: Each SCC is maximal, meaning it cannot be extended by including an adjacent vertex without losing the property of mutual reachability.
3. **Uniqueness**: The set of SCCs is unique for any given directed graph.

### 1. Algorithms & Data Structures (C++): Kosaraju Algorithm for Strongly Connected Component [RETURN]

Kosaraju's algorithm is a popular algorithm used to find strongly connected components (SCCs) in a directed graph. SCCs are subsets of vertices within a graph where every vertex in the subset is reachable from every other vertex. Here's how Kosaraju's algorithm works:

1. **First DFS (Depth-First Search)**:
   - Perform a DFS traversal of the graph and keep track of the order in which vertices are finished (i.e., they've been fully explored).
   - At the end of this DFS traversal, store the vertices in a stack based on the order in which they were finished.

2. **Transpose the Graph**:
   - Create a new graph where all the edges are reversed. This is done by reversing the direction of each edge in the original graph.

3. **Second DFS**:
   - Pop vertices from the stack generated in the first step in the order of their finishing times.
   - For each popped vertex, if it has not been visited in the second DFS, start a new DFS from it.
   - Each DFS traversal from a new vertex in this step identifies a new strongly connected component.

Here's a C++ implementation of Kosaraju's algorithm:

```cpp
#include <iostream>
#include <vector>
#include <stack>
#include <algorithm>

using namespace std;

// Depth First Search (DFS)
void DFS(int node, vector<int> adj[], vector<bool>& visited, stack<int>& finishedStack) {
    visited[node] = true;
    for (int neighbor : adj[node]) {
        if (!visited[neighbor]) {
            DFS(neighbor, adj, visited, finishedStack);
        }
    }
    finishedStack.push(node); // Push the node to the stack after all its neighbors are visited
}

// Utility function to perform DFS on transposed graph
void DFSUtil(int node, vector<int> transpose[], vector<bool>& visited) {
    visited[node] = true;
    cout << node << " ";
    for (int neighbor : transpose[node]) {
        if (!visited[neighbor]) {
            DFSUtil(neighbor, transpose, visited);
        }
    }
}

// Function to find and print strongly connected components
void KosarajuSCC(int V, vector<int> adj[]) {
    vector<bool> visited(V, false);
    stack<int> finishedStack;

    // Step 1: First DFS to fill the stack based on finishing times
    for (int i = 0; i < V; ++i) {
        if (!visited[i]) {
            DFS(i, adj, visited, finishedStack);
        }
    }

    // Transpose the graph
    vector<int> transpose[V];
    for (int i = 0; i < V; ++i) {
        for (int neighbor : adj[i]) {
            transpose[neighbor].push_back(i);
        }
    }

    // Step 2: Reset visited array
    fill(visited.begin(), visited.end(), false);

    // Step 3: Second DFS to process the vertices in order of their finishing times
    while (!finishedStack.empty()) {
        int node = finishedStack.top();
        finishedStack.pop();
        if (!visited[node]) {
            cout << "SCC: ";
            DFSUtil(node, transpose, visited);
            cout << endl;
        }
    }
}

int main() {
    int V, E;
    cout << "Enter the number of vertices and edges: ";
    cin >> V >> E;

    vector<int> adj[V]; // Adjacency list representation

    cout << "Enter the edges (from -> to):\n";
    for (int i = 0; i < E; ++i) {
        int from, to;
        cin >> from >> to;
        adj[from].push_back(to);
    }

    cout << "Strongly Connected Components:\n";
    KosarajuSCC(V, adj);

    return 0;
}
```

This code prompts the user to enter the number of vertices and edges, followed by the edges of the directed graph. Then it prints the strongly connected components of the graph using Kosaraju's algorithm.

### 1. Algorithms & Data Structures (C++): Condensed Component Graph [RETURN]

A Condensed Component Graph (CCG) is a representation used in graph theory to simplify complex graphs by condensing strongly connected components into single nodes. This condensed graph retains essential information about the original graph's structure while simplifying it for certain operations or analyses.

Here's a high-level overview of how you can implement a Condensed Component Graph in C++:

1. **Identify Strongly Connected Components (SCCs)**:
   - Implement a Strongly Connected Components algorithm like Tarjan's Algorithm or Kosaraju's Algorithm to identify SCCs in the original graph.
   - Store the SCCs in a data structure such as a vector or a list.

2. **Build the Condensed Graph**:
   - Create a new graph structure for the condensed graph. You can use an adjacency list or matrix representation depending on the size and characteristics of your graph.
   - Iterate through each SCC in the original graph.
   - For each SCC, collapse it into a single node and add it to the condensed graph.
   - Traverse the original graph's edges. For each edge `(u, v)`, if `u` and `v` belong to different SCCs, add an edge from the condensed node representing `u`'s SCC to the condensed node representing `v`'s SCC in the condensed graph.

3. **Implement Graph Data Structures**:
   - Define classes or structs to represent both the original and condensed graphs.
   - Each node in the graph should contain information about its outgoing edges or adjacent nodes.

4. **Implement Graph Traversal and Operations**:
   - Implement algorithms like Breadth-First Search (BFS) or Depth-First Search (DFS) to traverse the condensed graph.
   - You may also want to implement other operations such as finding shortest paths, detecting cycles, or performing topological sorting on the condensed graph.

5. **Test Your Implementation**:
   - Create test cases to ensure that your implementation of the Condensed Component Graph produces correct results.
   - Test it on graphs of various sizes and complexities to verify its efficiency and accuracy.

Here's a basic example of how you might represent a Condensed Component Graph in C++:

```cpp
#include <iostream>
#include <vector>
#include <unordered_set>

using namespace std;

// Structure to represent a graph node
struct Node {
    vector<int> neighbors;
};

// Condensed Component Graph
class CondensedGraph {
private:
    vector

<pair<int, unordered_set<int>>> condensed_graph;

public:
    // Add an edge between two SCCs in the condensed graph
    void addEdge(int u, int v) {
        condensed_graph[u].second.insert(v);
    }

    // Print the condensed graph
    void printCondensedGraph() {
        for (auto& [node, neighbors] : condensed_graph) {
            cout << "Node " << node << ": ";
            for (int neighbor : neighbors) {
                cout << neighbor << " ";
            }
            cout << endl;
        }
    }
};

int main() {
    // Create a sample graph
    vector<Node> graph(5);
    graph[0].neighbors = {1};
    graph[1].neighbors = {2};
    graph[2].neighbors = {0, 3};
    graph[3].neighbors = {4};
    graph[4].neighbors = {3};

    // Perform SCC algorithm to find strongly connected components
    // Implement this part using Tarjan's Algorithm or Kosaraju's Algorithm

    // Create a CondensedGraph object
    CondensedGraph condensedGraph;

    // Add edges between SCCs in the condensed graph
    // Implement this part based on the SCC results

    // Print the condensed graph
    condensedGraph.printCondensedGraph();

    return 0;
}
```

This code provides a basic framework for implementing a Condensed Component Graph in C++. You'll need to complete it by implementing SCC algorithms and the logic to add edges between SCCs in the condensed graph. Additionally, you may need to refine and optimize the implementation based on your specific requirements and the characteristics of your input graphs.

### 1. Algorithms & Data Structures (C++): Graph Coloring [RETURN]

Graph coloring is a fundamental problem in computer science and involves assigning colors to vertices of a graph in such a way that no two adjacent vertices have the same color. This problem has various applications, including register allocation in compilers, scheduling problems, and map coloring.

In C++, you can implement graph coloring using various algorithms such as backtracking, greedy algorithms, or constraint satisfaction algorithms like the Welsh–Powell algorithm or the DSatur algorithm. Here's a basic outline of how you could implement a simple graph coloring algorithm using backtracking:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// Graph class representing an undirected graph using adjacency lists
class Graph {
    int V; // Number of vertices
    vector<vector<int>> adj; // Adjacency list

public:
    Graph(int V) : V(V), adj(V) {}

    // Function to add an edge between two vertices
    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    // Function to check if it's safe to color vertex v with color c
    bool isSafe(int v, vector<int>& color, int c) {
        for (int u : adj[v]) {
            if (color[u] == c)
                return false;
        }
        return true;
    }

    // Recursive function to assign colors to vertices using backtracking
    bool graphColoringUtil(vector<int>& color, int v, int numColors) {
        if (v == V)
            return true;

        for (int c = 1; c <= numColors; ++c) {
            if (isSafe(v, color, c)) {
                color[v] = c;
                if (graphColoringUtil(color, v + 1, numColors))
                    return true;
                color[v] = 0; // Backtrack
            }
        }
        return false;
    }

    // Function to perform graph coloring
    void graphColoring(int numColors) {
        vector<int> color(V, 0); // Initialize all vertices with no color

        if (graphColoringUtil(color, 0, numColors)) {
            cout << "Graph can be colored with " << numColors << " colors. Colors of vertices:\n";
            for (int i = 0; i < V; ++i)
                cout << "Vertex " << i << ": Color " << color[i] << "\n";
        } else {
            cout << "Graph cannot be colored with " << numColors << " colors.\n";
        }
    }
};

int main() {
    Graph g(5); // Create a graph with 5 vertices

    // Add edges
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 2);
    g.addEdge(1, 3);
    g.addEdge(2, 3);
    g.addEdge(3, 4);

    int numColors = 3; // Number of colors
    g.graphColoring(numColors);

    return 0;
}
```

This code defines a `Graph` class representing an undirected graph using adjacency lists. It includes functions to add edges, check if it's safe to color a vertex, and a recursive function to perform graph coloring using backtracking. Finally, in the `main` function, it creates a sample graph, specifies the number of colors, and calls the `graphColoring` function to perform graph coloring.
