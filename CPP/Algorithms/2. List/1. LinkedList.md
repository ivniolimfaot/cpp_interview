# Linked List (Single, Simple)

## Theory

### 1. Algorithms & Data Structures (C++): What are Linked Lists

A linked list is a fundamental data structure in computer science used to store a sequence of elements. In a linked list, each element is stored in a node, and each node contains two parts: the data itself, and a reference (or pointer) to the next node in the sequence. This arrangement allows for dynamic memory allocation, making linked lists a flexible data structure.

In a singly linked list, each node only has a reference to the next node in the sequence, forming a unidirectional chain. Meanwhile, in a doubly linked list, each node has references to both the next and the previous nodes, creating a bidirectional chain.

Advantages:

1. Dynamic Size: Linked lists can easily grow or shrink in size at runtime since memory allocation is not required to be contiguous.
2. Insertions and Deletions: Insertions and deletions at any position in the list can be done efficiently by adjusting pointers, whereas in arrays, these operations may require shifting elements.
3. Memory Efficiency: Linked lists can use memory more efficiently than arrays, especially when the size of the data structure is not known in advance.

Disadvantages:

1. Random Access: Unlike arrays, linked lists do not support constant-time random access to elements. Traversing a linked list requires sequential access from the beginning.
2. Extra Memory: Linked lists require additional memory for storing pointers to the next (and possibly previous) nodes, which can increase memory overhead compared to arrays.
3. Cache Performance: Arrays often have better cache performance since they store elements contiguously in memory, leading to fewer cache misses during traversal.

Overall, linked lists are particularly useful when frequent insertions and deletions are required, or when the size of the data structure needs to be dynamic. They are commonly used as building blocks for more complex data structures such as stacks, queues, and hash tables.

#### Types of Linked List

In C++, linked lists are a fundamental data structure consisting of a sequence of elements, each containing a reference (or pointer) to the next element in the sequence. There are several types of linked lists, each with its own characteristics and use cases. Here are the most common types:

1. **Singly Linked List**:
   * In a singly linked list, each element, or node, contains data and a reference to the next node in the sequence.
   * It has a forward direction only, meaning you can only traverse the list from the head to the tail.
   * Singly linked lists are relatively simple to implement and use less memory compared to other types of linked lists.

2. **Doubly Linked List**:
   * In a doubly linked list, each node contains a reference to both the next and the previous nodes in the sequence.
   * This bidirectional linking allows traversal in both forward and backward directions, which can be useful in certain situations.
   * Doubly linked lists require more memory per node due to the additional pointer to the previous node.

3. **Circular Linked List**:
   * In a circular linked list, the last node points back to the first node, forming a circular structure.
   * This can simplify certain operations, such as traversal or rotation, since there is no "end" to the list.
   * Circular linked lists can be either singly or doubly linked.

4. **Sorted Linked List**:
   * A sorted linked list maintains its elements in sorted order, typically ascending or descending.
   * Insertions in a sorted linked list require maintaining the sorted order, which may involve traversing the list to find the correct position for insertion.
   * Sorted linked lists are useful when you frequently need to insert elements in sorted order and maintain that order without the need for sorting the entire list.

5. **Sparse Linked List**:
   * A sparse linked list is a variation that optimizes storage for lists with many null or default values.
   * Instead of storing every element, it only stores elements that differ from the default value.
   * This can save memory in situations where the majority of elements have default values.

6. **Unrolled Linked List**:
    * Unrolled linked lists store multiple elements in each node, allowing for better cache performance and reduced memory overhead compared to traditional linked lists.
    * Each node in an unrolled linked list contains an array or vector to hold multiple elements along with pointers to the next node.

Each type of linked list has its advantages and disadvantages, and the choice depends on the specific requirements of the application you are working on.

#### Why do we use Linked List

Linked lists are fundamental data structures in computer science and are commonly used for various reasons:

1. **Dynamic Size**: Linked lists can dynamically grow and shrink in size. Unlike arrays, where the size is fixed once allocated, linked lists can easily accommodate changes in size by simply adding or removing nodes.

2. **Memory Allocation**: Linked lists provide flexibility in memory allocation. Each node can be allocated independently in memory, allowing for efficient usage of memory and easy expansion without the need for contiguous memory blocks like arrays.

3. **Insertions and Deletions**: Linked lists excel in insertions and deletions, especially in scenarios where frequent modifications are expected. Adding or removing elements in a linked list typically involves adjusting pointers, which can be done in constant time (O(1)) for insertions and deletions at the beginning or end of the list, and linear time (O(n)) for insertions and deletions at arbitrary positions.

4. **No Pre-allocation**: Linked lists do not require pre-allocation of memory for a fixed number of elements, unlike arrays. This can be advantageous when the number of elements is unknown or varies widely.

5. **Ease of Implementation**: Linked lists are relatively easy to implement and understand compared to some other data structures like trees or graphs. They involve simple pointer manipulation, making them suitable for educational purposes and as building blocks for more complex data structures.

6. **Versatility**: Linked lists come in various forms such as singly linked lists, doubly linked lists, and circular linked lists. Each type offers different trade-offs in terms of memory usage, traversal speed, and ease of manipulation, allowing developers to choose the most appropriate type based on their specific requirements.

However, it's worth noting that linked lists also have some drawbacks, such as inefficient random access (O(n) time complexity) and increased memory overhead due to storing pointers. Therefore, their usage should be carefully considered based on the specific requirements of the problem at hand.

#### Conception of Node

In C++ programming, when dealing with linked lists, a fundamental concept is the notion of a "Node." A Node represents an individual element within the linked list. Each Node contains two primary components:

1. **Data**: This is the actual value or payload that the Node holds. It could be of any data type depending on the requirements of your linked list. For instance, if you're creating a linked list of integers, the data part of the Node would be an integer. If it's a linked list of strings, the data part would be a string, and so on.

2. **Pointer(s)**: These are references or pointers to other Nodes. In a singly linked list, each Node typically contains a single pointer, called the "next" pointer, which points to the next Node in the sequence. In a doubly linked list, each Node contains two pointers: one pointing to the next Node (often called "next"), and one pointing to the previous Node (often called "prev").

Here's a simple example of what a Node might look like in C++:

```cpp
template <typename T>
struct Node {
    T data;           // Data part of the Node
    Node<T>* next;    // Pointer to the next Node
};
```

In this example, `T` is a template parameter representing the data type of the Node's payload. This allows you to create Nodes containing data of any type without having to define multiple versions of the Node structure.

Once you have defined the Node structure, you can create instances of Node to build your linked list. Here's a basic example of how you might create a Node:

```cpp
Node<int>* newNode = new Node<int>(); // Creating a Node with integer data
newNode->data = 10;                    // Assigning a value to the data part
newNode->next = nullptr;               // Initializing the next pointer (typically to nullptr initially)
```

This creates a Node with an integer data part (value 10) and initializes its next pointer to `nullptr`, indicating that it currently doesn't point to any other Node.

### Linked List: Implementation

Here's a basic implementation of a singly linked list in C++:

```cpp
#include <iostream>

using namespace std;

// Node class represents each node in the linked list
class Node {
public:
    int data;
    Node* next;
    Node(int d) : data(d), next(nullptr) {}
};

// LinkedList class represents the linked list
class LinkedList {
private:
    Node* head;
public:
    // Constructor to initialize an empty linked list
    LinkedList() : head(nullptr) {}

    // Constructor to initialize linked list with an array
    LinkedList(int arr[], int n) {
        head = nullptr;
        for (int i = 0; i < n; i++)
            append(arr[i]);
    }

    int length() {
        int length = 0;
        Node* current = head;
        
        // Traverse the list and count nodes
        while (current != nullptr) {
            length++;
            current = current->next;
        }
        return length;
    }

    // Function to add a node to the front of the list
    void push_front(int val) {
        Node* newNode = new Node(val); // Create a new node with the given value
        newNode->next = head; // Set the new node's next pointer to the current head
        head = newNode; // Update the head pointer to point to the new node
    }

    // Function to add a node at the end of the linked list
    void push_back(int data) {
        Node* newNode = new Node(data);
        if (head == nullptr) {
            head = newNode;
            return;
        }
        Node* temp = head;
        while (temp->next != nullptr)
            temp = temp->next;
        temp->next = newNode;
    }

    void pop_front() {
        if (head == nullptr) {
            std::cout << "List is empty. Nothing to delete.\n";
            return;
        }
        Node* temp = head;
        head = head->next;
        delete temp;
    }

        // Function to delete the last node of the linked list
    void pop_back() {
        if (!head) {
            std::cout << "List is empty. Nothing to delete.\n";
            return;
        }
        if (!head->next) {
            delete head;
            head = nullptr;
            return;
        }
        Node* temp = head;
        while (temp->next->next) {
            temp = temp->next;
        }
        delete temp->next;
        temp->next = nullptr;
    }


    // Function to delete a node from any position in the list
    void deleteNode(int position) {
        if (head == nullptr) {
            cout << "List is empty" << endl;
            return;
        }
        Node* temp = head;
        if (position == 0) {
            head = head->next;
            delete temp;
            return;
        }
        for (int i = 0; temp != nullptr && i < position - 1; i++) {
            temp = temp->next;
        }
        if (temp == nullptr || temp->next == nullptr) {
            cout << "Position is out of bounds" << endl;
            return;
        }
        Node* nodeToDelete = temp->next;
        temp->next = nodeToDelete->next;
        delete nodeToDelete;
    }
    // Function to display the linked list
    void display() {
        Node* temp = head;
        while (temp != nullptr) {
            cout << temp->data << "->";
            temp = temp->next;
        }
        cout << endl;
    }

    void clear() {
        while (head != nullptr) {
            Node* temp = head;
            head = head->next;
            delete temp;
        }
    }

    // Method to get the last element of the list
    Node* getLast() {
        if (head) {
            Node* temp = head;
            while (temp->next) {
                temp = temp->next;
            }
            return temp-;
        }
        return head;
    }

    // Method to get the first element of the list
    Node* getFirst() {
        return head;
    }

    // Function to get data at a specific position
    int GetAt(int position) {
        Node* current = head;
        int currentPosition = 0;

        // Traverse the list until either reaching the end or the desired position
        while (current != nullptr && currentPosition < position) {
            current = current->next;
            currentPosition++;
        }

        // If current is nullptr, it means position is out of bounds
        if (current == nullptr) {
            std::cerr << "Error: Position out of bounds\n";
            return -1; // Return a sentinel value to indicate error
        }

        // Otherwise, return the data at the desired position
        return current->data;
    }

        // Function to insert a node after a given position
    void insertAfter(int position, int data) {
        // Create a new node
        Node* newNode = new Node(data);

        // If list is empty, insert at the beginning
        if (head == nullptr) {
            head = newNode;
            return;
        }

        // Traverse the list to find the position
        Node* current = head;
        for (int i = 1; i < position && current != nullptr; ++i) {
            current = current->next;
        }

        // If the position is beyond the end of the list, insert at the end
        if (current == nullptr) {
            std::cerr << "Position out of range. Inserting at the end." << std::endl;
            Node* tail = head;
            while (tail->next != nullptr) {
                tail = tail->next;
            }
            tail->next = newNode;
        } else {
            // Insert the new node after the current position
            newNode->next = current->next;
            current->next = newNode;
        }
    }
};

int main() {
    // Creating a linked list using the constructor with an array
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    LinkedList ll(arr, n);

    // Displaying the linked list
    ll.display();

    return 0;
}
```

In this example:

* We have a `Node` class representing each node in the linked list.
* We have a `LinkedList` class representing the linked list itself.
* The `LinkedList` class has two constructors:
  1. A default constructor that initializes an empty linked list.
  2. A constructor that takes an array and its size as parameters to initialize the linked list with the elements of the array.
* The `push_back` function is used to add elements to the end of the linked list.
* The `push_front` function is used to add elements to the begining of the linked list.
* The `display` function is used to print the elements of the linked list.

### Complexity analysis

1. **Access/Search (by index or value):**
   * Time Complexity: O(n)
   * Explanation: In a singly linked list, accessing or searching for an element typically requires traversing the list from the head (or possibly the tail) until the desired element is found. Since there is no direct access to elements by index, you may need to iterate through all or part of the list.

2. **Insertion (at the beginning):**
   * Time Complexity: O(1)
   * Explanation: Inserting a node at the beginning of a singly linked list involves updating the head pointer to point to the new node. This operation can be done in constant time regardless of the size of the list.

3. **Insertion (at the end, if tail pointer is available):**
   * Time Complexity: O(1)
   * Explanation: If the linked list maintains a tail pointer, inserting a node at the end involves updating the tail pointer to point to the new node, which can be done in constant time.

4. **Insertion (at the end, without tail pointer):**
   * Time Complexity: O(n)
   * Explanation: Without a tail pointer, inserting a node at the end requires traversing the entire list to find the last node, then updating its next pointer to point to the new node.

5. **Insertion (in the middle):**
   * Time Complexity: O(n)
   * Explanation: Inserting a node in the middle of a singly linked list requires traversing the list to find the node at the desired position. This operation may involve traversing approximately half of the list on average.

6. **Deletion (from the beginning):**
   * Time Complexity: O(1)
   * Explanation: Deleting the first node of a singly linked list involves updating the head pointer to point to the second node, which can be done in constant time.

7. **Deletion (from the end, if tail pointer is available):**
   * Time Complexity: O(n)
   * Explanation: Without a tail pointer, deleting the last node of a singly linked list requires traversing the entire list to find the second-to-last node, then updating its next pointer to nullptr. If a tail pointer is available, this operation can be done in constant time.

8. **Deletion (from the end, without tail pointer):**
   * Time Complexity: O(n)
   * Explanation: Deleting the last node of a singly linked list without a tail pointer involves traversing the entire list to find the last node and the second-to-last node, then updating the second-to-last node's next pointer to nullptr.

9. **Deletion (from the middle):**
   * Time Complexity: O(n)
   * Explanation: Deleting a node from the middle of a singly linked list requires traversing the list to find the node to be deleted and its predecessor node. This operation may involve traversing approximately half of the list on average.

10. **Traversal (length):**

* Time Complexity: O(n)
* Explanation: To traverse the entire linked list, you need to visit each node once, resulting in a time complexity of O(n).

1. **Concatenation (Joining two lists):**

* Time Complexity: O(1)
* Explanation: Concatenating two linked lists involves updating the next pointer of the last node of the first list to point to the head of the second list. This operation has a constant time complexity.

1. **Reversal:**

* Time Complexity: O(n)
* Explanation: Reversing a linked list requires iterating through the list once and updating the pointers of each node to reverse the direction. This operation has a time complexity of O(n).

These complexities describe the upper bounds on the performance of the corresponding operations. Depending on the specific implementation and optimizations, actual performance may vary.

### Linked List in the Memory

In C++, a linked list is a data structure consisting of a sequence of elements, each of which points to the next element in the sequence. Unlike arrays, linked lists do not have a predetermined fixed size, and elements can be easily inserted or removed without reallocation or reorganization of the entire structure.

In memory, a linked list is typically represented as a series of nodes. Each node contains two components: the data, which holds the value of the element, and a pointer/reference to the next node in the sequence.

To form a linked list, you would create instances of nodes and link them together. The last node's `next` pointer would typically be set to `nullptr` to indicate the end of the list.

In memory, this would look like:

```bash
Node 1: [data: 10][next: ] --> Node 2: [data: 20][next: ] --> Node 3: [data: 30][next: nullptr]
```

Each node is allocated memory dynamically (using `new` in C++), and they are linked together via the `next` pointers.

Remember, when using linked lists, it's important to properly manage memory allocation and deallocation to prevent memory leaks. When done using the list, make sure to deallocate the memory for each node to avoid memory leaks.

### 1. Algorithms & Data Structures (C++): Linked Lists vs Arrays

Linked lists and arrays are two fundamental data structures in computer science, each with its own strengths and weaknesses. Let's compare them in terms of various aspects:

1. **Memory Allocation:**
   * **Arrays:** Contiguous block of memory is allocated for elements, ensuring efficient access but may lead to memory fragmentation.
   * **Linked Lists:** Elements are scattered in memory, connected via pointers, which can lead to less efficient memory access but avoids fragmentation and allows dynamic memory allocation.

2. **Insertion and Deletion:**
   * **Arrays:** Insertion and deletion can be costly, especially in the middle, as elements may need to be shifted.
   * **Linked Lists:** Insertion and deletion are generally faster, especially for singly linked lists when inserting/deleting at the beginning or end. However, accessing arbitrary elements requires traversal from the head, which can be slower.

3. **Access Time:**
   * **Arrays:** Constant-time access to elements given the index (O(1)).
   * **Linked Lists:** Access time is O(n) as it requires traversing from the head (for singly linked lists) or both directions (for doubly linked lists) to find the desired element.

4. **Memory Overhead:**
   * **Arrays:** Fixed memory overhead for storing the elements and possibly some additional memory for bookkeeping.
   * **Linked Lists:** Additional memory overhead for storing pointers/references to the next (and possibly previous) nodes.

5. **Dynamic Size:**
   * **Arrays:** Often have a fixed size, though dynamic arrays (like `std::vector` in C++) can resize dynamically.
   * **Linked Lists:** Can dynamically grow or shrink without the need for resizing.

6. **Cache Performance:**
   * **Arrays:** Better cache performance due to contiguous memory access, leading to fewer cache misses.
   * **Linked Lists:** Poor cache performance due to scattered memory access, leading to more cache misses.

7. **Implementation Complexity:**
   * **Arrays:** Generally simpler to implement and understand.
   * **Linked Lists:** More complex due to the need to manage pointers and dynamic memory allocation.

Choose arrays when:

* You need fast random access.
* Memory is a concern and the size of the data is known in advance.
* You are dealing with small or fixed-size collections.

Choose linked lists when:

* You frequently insert or delete elements, especially at the beginning or end of the list.
* Memory usage is dynamic and unpredictable.
* You can tolerate slower access times for fast insertion and deletion.

In C++, the standard library provides both array-like (`std::array`, `std::vector`) and linked list-like (`std::list`) containers, allowing you to choose based on your specific requirements.

### 1. Algorithms & Data Structures (C++): Linked Lists: Linked Lists with Iterators

Certainly! Implementing a linked list with iterators in C++ can be quite useful for efficient traversal and manipulation of the list elements. Here's an example implementation:

```cpp
#include <iostream>

// Node class representing each element in the linked list
template <typename T>
class Node {
public:
    T data;
    Node* next;

    Node(const T& newData) : data(newData), next(nullptr) {}
};

// Iterator class to traverse the linked list
template <typename T>
class LinkedListIterator {
    Node<T>* current;

public:
    LinkedListIterator(Node<T>* node) : current(node) {}

    T& operator*() const {
        return current->data;
    }

    LinkedListIterator<T>& operator++() {
        current = current->next;
        return *this;
    }

    LinkedListIterator<T> operator++(int) {
        LinkedListIterator<T> old = *this;
        ++(*this);
        return old;
    }

    bool operator==(const LinkedListIterator<T>& other) const {
        return current == other.current;
    }

    bool operator!=(const LinkedListIterator<T>& other) const {
        return !(*this == other);
    }
};

// Linked list class
template <typename T>
class LinkedList {
private:
    Node<T>* head;

public:
    LinkedList() : head(nullptr) {}

    ~LinkedList() {
        while (head) {
            Node<T>* temp = head;
            head = head->next;
            delete temp;
        }
    }

    // Function to insert a new element at the beginning of the list
    void insert(const T& data) {
        Node<T>* newNode = new Node<T>(data);
        newNode->next = head;
        head = newNode;
    }

    // Function to return an iterator pointing to the first element of the list
    LinkedListIterator<T> begin() const {
        return LinkedListIterator<T>(head);
    }

    // Function to return an iterator pointing to the end of the list
    LinkedListIterator<T> end() const {
        return LinkedListIterator<T>(nullptr);
    }
};

int main() {
    LinkedList<int> myList;
    myList.insert(10);
    myList.insert(20);
    myList.insert(30);

    // Iterating through the list using iterators
    for (LinkedListIterator<int> it = myList.begin(); it != myList.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

In this code:

* The `Node` class represents each element in the linked list. It contains data and a pointer to the next node.
* The `LinkedListIterator` class provides the iterator interface for traversing the linked list.
* The `LinkedList` class manages the linked list and provides functions like `insert`, `begin`, and `end`.
* In the `main` function, we demonstrate the usage of the linked list by inserting elements and iterating through them using iterators.

### 1. Algorithms & Data Structures (C++): Linked List Remove Duplicates

#### Using a Hash Set

This approach uses extra space to keep track of the values that have already been seen. It has a time complexity of \(O(n)\) and a space complexity of \(O(n)\).

##### Code

```cpp
#include <iostream>
#include <unordered_set>

struct Node {
    int data;
    Node* next;
    Node(int d) : data(d), next(nullptr) {}
};

void removeDuplicates(Node* head) {
    if (!head) return;

    std::unordered_set<int> seen;
    Node* current = head;
    Node* prev = nullptr;

    while (current) {
        if (seen.find(current->data) != seen.end()) {
            prev->next = current->next;
            delete current;
        } else {
            seen.insert(current->data);
            prev = current;
        }
        current = prev->next;
    }
}

// Helper function to print the linked list
void printList(Node* head) {
    Node* temp = head;
    while (temp) {
        std::cout << temp->data << " ";
        temp = temp->next;
    }
    std::cout << std::endl;
}

// Helper function to create a new node
Node* push(Node* head, int data) {
    Node* new_node = new Node(data);
    new_node->next = head;
    head = new_node;
    return head;
}

int main() {
    Node* head = nullptr;
    head = push(head, 10);
    head = push(head, 12);
    head = push(head, 11);
    head = push(head, 11);
    head = push(head, 12);
    head = push(head, 11);
    head = push(head, 10);

    std::cout << "Original list: ";
    printList(head);

    removeDuplicates(head);

    std::cout << "List after removing duplicates: ";
    printList(head);

    return 0;
}
```

#### Without Using Extra Space (Two-pointer Technique)

This approach does not use extra space and has a time complexity of \(O(n^2)\) because it requires nested loops to compare each element with all subsequent elements.

##### Code

```cpp
#include <iostream>

struct Node {
    int data;
    Node* next;
    Node(int d) : data(d), next(nullptr) {}
};

void removeDuplicates(Node* head) {
    if (!head) return;

    Node* current = head;
    while (current) {
        Node* runner = current;
        while (runner->next) {
            if (runner->next->data == current->data) {
                Node* temp = runner->next;
                runner->next = runner->next->next;
                delete temp;
            } else {
                runner = runner->next;
            }
        }
        current = current->next;
    }
}

// Helper function to print the linked list
void printList(Node* head) {
    Node* temp = head;
    while (temp) {
        std::cout << temp->data << " ";
        temp = temp->next;
    }
    std::cout << std::endl;
}

// Helper function to create a new node
Node* push(Node* head, int data) {
    Node* new_node = new Node(data);
    new_node->next = head;
    head = new_node;
    return head;
}

int main() {
    Node* head = nullptr;
    head = push(head, 10);
    head = push(head, 12);
    head = push(head, 11);
    head = push(head, 11);
    head = push(head, 12);
    head = push(head, 11);
    head = push(head, 10);

    std::cout << "Original list: ";
    printList(head);

    removeDuplicates(head);

    std::cout << "List after removing duplicates: ";
    printList(head);

    return 0;
}
```

#### Explanation

* **Using a Hash Set:**
  * Traverse the list, and for each node, check if its value is in the hash set.
  * If it is, delete the node.
  * If it is not, add the value to the hash set and move to the next node.
  
* **Without Using Extra Space:**
  * For each node, use a runner pointer to check all subsequent nodes for duplicates.
  * If a duplicate is found, delete it.
  * Move the current node pointer to the next node and repeat the process.

Choose the method based on the constraints of your problem and the efficiency requirements.

### 1. Algorithms & Data Structures (C++): Linked List: Find Kth Node From End

To find the Kth node from the end of a linked list in C++, we can use the two-pointer technique (also known as the "runner" technique). This method is efficient and works in O(n) time complexity with O(1) extra space complexity.

Here is a step-by-step explanation and the implementation:

#### Explanation

1. **Initialize two pointers**: `fast` and `slow`. Both pointers start at the head of the list.
2. **Move the `fast` pointer K nodes ahead**: This creates a gap of K nodes between `fast` and `slow`.
3. **Move both pointers until the `fast` pointer reaches the end**: When `fast` reaches the end, `slow` will be at the Kth node from the end.
4. **Return the node pointed by `slow`**: This node is the Kth node from the end.

#### Implementation

Here's how you can implement this in C++:

```cpp
#include <iostream>

struct Node {
    int data;
    Node* next;
    Node(int x) : data(x), next(nullptr) {}
};

class LinkedList {
public:
    Node* head;

    LinkedList() : head(nullptr) {}

    void append(int data) {
        if (!head) {
            head = new Node(data);
            return;
        }
        Node* temp = head;
        while (temp->next) {
            temp = temp->next;
        }
        temp->next = new Node(data);
    }

    Node* findKthFromEnd(int k) {
        if (!head || k <= 0) return nullptr;

        Node* fast = head;
        Node* slow = head;

        // Move fast pointer k nodes ahead
        for (int i = 0; i < k; ++i) {
            if (!fast) return nullptr;  // If k is larger than the length of the list
            fast = fast->next;
        }

        // Move both pointers until fast reaches the end
        while (fast) {
            fast = fast->next;
            slow = slow->next;
        }

        return slow;
    }

    void printList() {
        Node* temp = head;
        while (temp) {
            std::cout << temp->data << " -> ";
            temp = temp->next;
        }
        std::cout << "NULL\n";
    }
};

int main() {
    LinkedList list;
    list.append(1);
    list.append(2);
    list.append(3);
    list.append(4);
    list.append(5);

    list.printList();

    int k = 2;
    Node* kthNode = list.findKthFromEnd(k);
    if (kthNode) {
        std::cout << "The " << k << "th node from the end is: " << kthNode->data << std::endl;
    } else {
        std::cout << "The list is shorter than " << k << " nodes.\n";
    }

    return 0;
}
```

#### Explanation of the Code

* **Node Struct**: Defines a node of the linked list.
* **LinkedList Class**: Manages the linked list and includes methods to append nodes, find the Kth node from the end, and print the list.
* **append(int data)**: Adds a new node with the given data at the end of the list.
* **findKthFromEnd(int k)**: Finds and returns the Kth node from the end of the list.
  * Moves the `fast` pointer `k` nodes ahead.
  * Moves both `fast` and `slow` pointers until `fast` reaches the end.
  * Returns the `slow` pointer, which points to the Kth node from the end.
* **printList()**: Prints the entire linked list.
* **main()**: Demonstrates the functionality by creating a linked list, printing it, and finding the Kth node from the end.

By using this implementation, you can efficiently find the Kth node from the end of a linked list.

### 1. Algorithms & Data Structures (C++): Linked List: Partition List

The idea is to rearrange the list so that all nodes less than `x` come before nodes greater than or equal to `x`. This problem can be tackled efficiently using two pointers.

Here's the approach:

1. Create two dummy nodes, `before` and `after`, which will act as the heads of two lists.
2. Iterate through the original list, and for each node, append it to the `before` list if its value is less than `x`, or to the `after` list otherwise.
3. After the iteration, link the end of the `before` list to the beginning of the `after` list.
4. Return the head of the `before` list (skipping the dummy node).

Here's the C++ code to implement this approach:

```cpp
#include <iostream>

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        if (!head) return head;
        
        ListNode beforeHead(0); // Dummy node for the list of nodes less than x
        ListNode afterHead(0);  // Dummy node for the list of nodes greater than or equal to x
        ListNode *before = &beforeHead;
        ListNode *after = &afterHead;
        
        while (head) {
            if (head->val < x) {
                before->next = head;
                before = before->next;
            } else {
                after->next = head;
                after = after->next;
            }
            head = head->next;
        }
        
        after->next = NULL; // End the after list
        before->next = afterHead.next; // Connect before list to after list
        
        return beforeHead.next; // The first node is the dummy node, so we skip it
    }
};

// Helper function to print the linked list
void printList(ListNode* head) {
    while (head != NULL) {
        std::cout << head->val << " -> ";
        head = head->next;
    }
    std::cout << "NULL" << std::endl;
}

int main() {
    // Creating a linked list: 1 -> 4 -> 3 -> 2 -> 5 -> 2
    ListNode* head = new ListNode(1);
    head->next = new ListNode(4);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(2);
    head->next->next->next->next = new ListNode(5);
    head->next->next->next->next->next = new ListNode(2);

    std::cout << "Original list: ";
    printList(head);

    Solution sol;
    ListNode* partitionedHead = sol.partition(head, 3);

    std::cout << "Partitioned list around 3: ";
    printList(partitionedHead);

    return 0;
}
```

### Explanation

* **ListNode Structure:** Defines the structure of a node in the linked list.
* **Solution Class:**
  * **partition Function:** Takes the head of a linked list and an integer `x` as input. It partitions the list such that all nodes with values less than `x` come before nodes with values greater than or equal to `x`.
  * Two dummy nodes `beforeHead` and `afterHead` are used to simplify list operations. `before` and `after` pointers are used to build the `before` and `after` lists.
  * The function iterates through the original list, placing nodes into either the `before` or `after` list based on their values.
  * Finally, the `before` list is linked to the `after` list and the combined list is returned.
* **printList Function:** Helper function to print the linked list.
* **main Function:** Creates an example linked list, applies the partition function, and prints the result.

This code ensures that the relative order of nodes in the original list is preserved in the partitioned list.

### 1. Algorithms & Data Structures (C++): Linked List: Add Two Numbers

To solve the problem of adding two numbers represented by linked lists, where each node contains a single digit and the digits are stored in reverse order, we need to simulate the addition process digit by digit. Below is the detailed step-by-step solution in C++.

#### Problem Explanation

Given two non-empty linked lists representing two non-negative integers, the digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.

#### Example

**Input:**

* List1: 2 -> 4 -> 3 (represents the number 342)
* List2: 5 -> 6 -> 4 (represents the number 465)

**Output:**

* Result: 7 -> 0 -> 8 (represents the number 807)

#### Steps to Solve

1. **Initialization**:
   * Create a dummy node to act as the head of the result linked list.
   * Use pointers to traverse the input linked lists and the result linked list.
   * Initialize a variable to keep track of the carry.

2. **Traverse and Add**:
   * Iterate through the linked lists until both are exhausted and there is no carry left.
   * Add the values of the current nodes (if they exist) and the carry.
   * Update the carry and the result node's value.

3. **Create New Nodes**:
   * For each sum calculated, create a new node and append it to the result linked list.

4. **Handle Remaining Carry**:
   * If there's a carry left after the main loop, add a new node with the carry value.

5. **Return the Result**:
   * The result linked list is pointed to by the next of the dummy node.

#### Implementation in C++

Here's the complete implementation in C++:

```cpp
#include <iostream>

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        // Dummy node to act as the head of the result list
        ListNode* dummyHead = new ListNode(0);
        ListNode* p = l1, *q = l2, *current = dummyHead;
        int carry = 0;
        
        while (p != nullptr || q != nullptr) {
            // Get the values from the current nodes, or 0 if we've reached the end
            int x = (p != nullptr) ? p->val : 0;
            int y = (q != nullptr) ? q->val : 0;
            
            // Calculate the sum and update the carry
            int sum = carry + x + y;
            carry = sum / 10;
            
            // Create a new node with the digit value and append it to the result
            current->next = new ListNode(sum % 10);
            current = current->next;
            
            // Move to the next nodes in the input lists
            if (p != nullptr) p = p->next;
            if (q != nullptr) q = q->next;
        }
        
        // If there is a carry left, add a new node with the carry value
        if (carry > 0) {
            current->next = new ListNode(carry);
        }
        
        // The result list is next to the dummy head
        return dummyHead->next;
    }
};

int main() {
    // Create first number: 342
    ListNode* l1 = new ListNode(2);
    l1->next = new ListNode(4);
    l1->next->next = new ListNode(3);
    
    // Create second number: 465
    ListNode* l2 = new ListNode(5);
    l2->next = new ListNode(6);
    l2->next->next = new ListNode(4);
    
    Solution solution;
    ListNode* result = solution.addTwoNumbers(l1, l2);
    
    // Print the result: 807
    while (result != nullptr) {
        std::cout << result->val;
        if (result->next != nullptr) std::cout << " -> ";
        result = result->next;
    }
    std::cout << std::endl;
    
    return 0;
}
```

#### Explanation

1. **Initialization**: The `dummyHead` node helps simplify edge cases handling. Pointers `p` and `q` traverse the input lists, and `current` builds the result list.

2. **Traverse and Add**: The loop continues until both input lists are fully traversed. It adds corresponding digits and the carry from the previous addition.

3. **Handle Remaining Carry**: If a carry remains after processing both lists, it's added as a new node.

4. **Return the Result**: The function returns the node next to the `dummyHead`, which is the actual start of the resulting sum list.

This approach ensures efficient traversal and summation, with clear handling of carries between digits.

### 1. Algorithms & Data Structures (C++): Linked List Cycle

Detecting a cycle in a linked list is a common problem in data structures and algorithms. Here’s how you can approach solving this problem in C++ using Floyd’s Cycle-Finding Algorithm, also known as the Tortoise and Hare algorithm.

#### Explanation of the Algorithm

The idea behind Floyd's Cycle-Finding Algorithm is to have two pointers, one moving twice as fast as the other. If there is a cycle, the fast pointer (hare) will eventually meet the slow pointer (tortoise). If there is no cycle, the fast pointer will reach the end of the list.

1. **Initialization**: Start both pointers at the head of the linked list.
2. **Iteration**: Move the slow pointer one step at a time and the fast pointer two steps at a time.
3. **Cycle Detection**: If the fast pointer meets the slow pointer, there is a cycle. If the fast pointer reaches the end of the list, there is no cycle.

#### Implementation in C++

Here is a C++ implementation of this algorithm:

```cpp
#include <iostream>

class ListNode {
public:
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    bool hasCycle(ListNode *head) {
        if (!head || !head->next) return false;

        ListNode *slow = head;
        ListNode *fast = head->next;

        while (slow != fast) {
            if (!fast || !fast->next) return false;

            slow = slow->next;
            fast = fast->next->next;
        }
        return true;
    }
};

// Helper function to create a cycle in the linked list for testing
void createCycle(ListNode *head, int pos) {
    if (pos == -1) return;

    ListNode *cycleNode = nullptr;
    ListNode *tail = head;
    int index = 0;

    while (tail->next) {
        if (index == pos) cycleNode = tail;
        tail = tail->next;
        index++;
    }
    tail->next = cycleNode;
}

int main() {
    // Create a linked list: 3 -> 2 -> 0 -> -4, and make a cycle at position 1 (2 -> 0 -> -4 -> 2)
    ListNode *head = new ListNode(3);
    head->next = new ListNode(2);
    head->next->next = new ListNode(0);
    head->next->next->next = new ListNode(-4);
    
    // Create cycle
    createCycle(head, 1);

    Solution solution;
    bool result = solution.hasCycle(head);

    std::cout << (result ? "Cycle detected." : "No cycle detected.") << std::endl;

    // Clean up memory (in a real scenario, ensure no cycle exists before deleting to avoid memory leaks)
    head->next->next->next->next = nullptr; // Break the cycle to prevent memory leak
    delete head->next->next->next;
    delete head->next->next;
    delete head->next;
    delete head;

    return 0;
}
```

### Steps Explained

1. **Class Definitions**:
   - `ListNode`: Represents a node in the linked list.
   - `Solution`: Contains the method `hasCycle` to detect if there is a cycle in the linked list.

2. **`hasCycle` Method**:
   - Check if the list is empty or has only one node (no cycle possible).
   - Initialize two pointers, `slow` and `fast`.
   - Iterate through the list, moving `slow` one step and `fast` two steps.
   - If `slow` and `fast` meet, a cycle is detected.
   - If `fast` reaches the end, the list has no cycle.

3. **Helper Function**:
   - `createCycle` is used to create a cycle in the linked list for testing purposes.

4. **Main Function**:
   - Create a linked list and a cycle.
   - Use the `hasCycle` method to detect the cycle and print the result.
   - Clean up the memory to avoid leaks.

This implementation efficiently detects a cycle in a linked list using O(1) additional space and O(n) time complexity.

### 1. Algorithms & Data Structures (C++): Intersection Of Two Linked Lists

Finding the intersection of two linked lists is a common problem in data structures and algorithms. The goal is to determine if two singly linked lists intersect, and if they do, find the node at which the intersection begins. The intersection is defined by reference, not by value.

Here's how you can approach solving this problem in C++:

#### Algorithm

1. **Calculate the Lengths**: First, traverse both lists to calculate their lengths.
2. **Align the Starts**: Align the starting points of both lists by advancing the pointer of the longer list by the difference in lengths.
3. **Traverse and Compare**: Traverse both lists in tandem, comparing nodes by reference. The first node that is the same in both lists is the intersection node.

#### Steps

1. **Calculate the lengths of both lists**:
   - Traverse each list to get their lengths.
2. **Align the starting points**:
   - Calculate the difference in lengths.
   - Move the pointer of the longer list ahead by the difference in lengths.
3. **Find the intersection**:
   - Traverse both lists together and compare nodes.

#### Implementation

Here is a sample implementation in C++:

```cpp
#include <iostream>

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        // Get the lengths of both lists
        int lenA = getLength(headA);
        int lenB = getLength(headB);
        
        // Align the start points
        while (lenA > lenB) {
            headA = headA->next;
            lenA--;
        }
        while (lenB > lenA) {
            headB = headB->next;
            lenB--;
        }
        
        // Traverse both lists together to find the intersection
        while (headA != headB) {
            headA = headA->next;
            headB = headB->next;
        }
        
        return headA;
    }
    
private:
    int getLength(ListNode *head) {
        int length = 0;
        while (head != NULL) {
            length++;
            head = head->next;
        }
        return length;
    }
};

int main() {
    // Example usage:
    ListNode *intersect = new ListNode(8);
    intersect->next = new ListNode(4);
    intersect->next->next = new ListNode(5);

    ListNode *headA = new ListNode(4);
    headA->next = new ListNode(1);
    headA->next->next = intersect;

    ListNode *headB = new ListNode(5);
    headB->next = new ListNode(6);
    headB->next->next = new ListNode(1);
    headB->next->next->next = intersect;

    Solution sol;
    ListNode *result = sol.getIntersectionNode(headA, headB);
    
    if (result) {
        std::cout << "Intersection at node with value: " << result->val << std::endl;
    } else {
        std::cout << "No intersection." << std::endl;
    }

    return 0;
}
```

#### Explanation

1. **getLength**: This helper function calculates the length of a linked list.
2. **getIntersectionNode**: This function first aligns the starts of both lists by advancing the pointer of the longer list. Then, it traverses both lists in parallel, comparing nodes until it finds the intersection or reaches the end of the lists.

#### Edge Cases

- If either list is empty, return `NULL`.
- If there's no intersection, return `NULL`.
- Lists may intersect at any node, including the first or last node.

This approach ensures that the time complexity is \(O(m + n)\), where \(m\) and \(n\) are the lengths of the two linked lists, and the space complexity is \(O(1)\) since we're only using a few extra variables.

### 1. Algorithms & Data Structures (C++): Palindrome Linked List

To determine if a singly linked list is a palindrome in C++, we can use a two-pointer approach to find the middle of the list, reverse the second half, and then compare the two halves. Here is a step-by-step breakdown of the algorithm:

1. **Find the middle of the linked list**: Use the slow and fast pointer technique. The slow pointer moves one step at a time, while the fast pointer moves two steps at a time. When the fast pointer reaches the end, the slow pointer will be at the middle.

2. **Reverse the second half of the list**: Starting from the middle, reverse the second half of the linked list.

3. **Compare the two halves**: Compare the first half and the reversed second half of the list. If they are the same, the linked list is a palindrome.

4. **Restore the list (optional)**: Reverse the second half again to restore the original list structure.

Here is the C++ implementation of the algorithm:

```cpp
#include <iostream>

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if (!head || !head->next) return true;

        // Step 1: Find the middle of the linked list
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast->next && fast->next->next) {
            slow = slow->next;
            fast = fast->next->next;
        }

        // Step 2: Reverse the second half of the list
        ListNode* secondHalf = reverseList(slow->next);

        // Step 3: Compare the first and the second half
        ListNode* firstHalf = head;
        ListNode* secondHalfCopy = secondHalf; // To restore the list later
        bool result = true;
        while (result && secondHalf) {
            if (firstHalf->val != secondHalf->val) {
                result = false;
            }
            firstHalf = firstHalf->next;
            secondHalf = secondHalf->next;
        }

        // Step 4: Restore the list (optional)
        slow->next = reverseList(secondHalfCopy);

        return result;
    }

private:
    ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr;
        ListNode* current = head;
        while (current) {
            ListNode* nextNode = current->next;
            current->next = prev;
            prev = current;
            current = nextNode;
        }
        return prev;
    }
};

// Helper function to create a linked list from an array
ListNode* createLinkedList(const std::vector<int>& arr) {
    if (arr.empty()) return nullptr;
    ListNode* head = new ListNode(arr[0]);
    ListNode* current = head;
    for (size_t i = 1; i < arr.size(); ++i) {
        current->next = new ListNode(arr[i]);
        current = current->next;
    }
    return head;
}

// Helper function to print a linked list
void printLinkedList(ListNode* head) {
    while (head) {
        std::cout << head->val << " ";
        head = head->next;
    }
    std::cout << std::endl;
}

int main() {
    std::vector<int> arr = {1, 2, 3, 2, 1};
    ListNode* head = createLinkedList(arr);
    Solution solution;
    bool result = solution.isPalindrome(head);
    std::cout << "Is palindrome: " << (result ? "Yes" : "No") << std::endl;

    // Optional: Print the restored linked list
    printLinkedList(head);

    // Clean up the allocated memory
    while (head) {
        ListNode* temp = head;
        head = head->next;
        delete temp;
    }

    return 0;
}
```

#### Explanation:

- **Finding the middle**: The `slow` pointer reaches the middle while the `fast` pointer reaches the end.
- **Reversing the second half**: The `reverseList` function inverts the second half of the list.
- **Comparing both halves**: The first half and the reversed second half are compared node by node.
- **Restoring the list**: The reversed second half is reversed again to restore the original list (this step is optional if you don't need to keep the original list intact).

This algorithm runs in O(n) time complexity due to the single pass needed to find the middle and the single pass for reversing and comparing the halves. The space complexity is O(1) as we are only using a few extra pointers.

### 1. Algorithms & Data Structures (C++): Find Middle Of Linked List

To find the middle of a linked list in C++, you can use the fast-slow pointer approach. Here's how it works:

1. Initialize two pointers, `slow` and `fast`, both pointing to the head of the linked list.
2. Move `slow` one step at a time while moving `fast` two steps at a time.
3. When `fast` reaches the end of the list (i.e., `fast->next` or `fast->next->next` is `nullptr`), `slow` will be at the middle of the list.

Here's the C++ code implementation:

```cpp
#include <iostream>

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

ListNode* findMiddle(ListNode* head) {
    if (head == nullptr || head->next == nullptr)
        return head; // Empty list or single node list
    
    ListNode* slow = head;
    ListNode* fast = head;
    
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
    }
    
    return slow;
}

// Utility function to print the linked list
void printList(ListNode* head) {
    while (head != nullptr) {
        std::cout << head->val << " ";
        head = head->next;
    }
    std::cout << std::endl;
}

int main() {
    // Create a sample linked list: 1 -> 2 -> 3 -> 4 -> 5 -> nullptr
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);
    
    std::cout << "Original List: ";
    printList(head);
    
    ListNode* middle = findMiddle(head);
    std::cout << "Middle of the List: " << middle->val << std::endl;
    
    return 0;
}
```

This code will output:

```bash
Original List: 1 2 3 4 5 
Middle of the List: 3
```

This approach has a time complexity of O(N) where N is the number of nodes in the linked list and requires only a constant amount of extra space.

### 1. Algorithms & Data Structures (C++): Immutable List

An immutable list in C++ can be implemented using various approaches. One common approach is to use a linked list structure where each node contains a value and a pointer to the next node. However, instead of allowing modification of the list, operations return a new list with the desired changes while keeping the original list unchanged.

Here's a simple implementation of an immutable linked list in C++:

```cpp
#include <iostream>

template <typename T>
class ImmutableList {
private:
    T value;
    const ImmutableList<T>* next;

public:
    ImmutableList(const T& value, const ImmutableList<T>* next = nullptr)
        : value(value), next(next) {}

    // Function to prepend a value to the list
    ImmutableList<T> prepend(const T& value) const {
        return ImmutableList(value, this);
    }

    // Function to get the value at the head of the list
    T head() const {
        return value;
    }

    // Function to get the tail of the list
    ImmutableList<T> tail() const {
        return *next;
    }

    // Function to check if the list is empty
    bool isEmpty() const {
        return next == nullptr;
    }
};

int main() {
    // Create an empty list
    ImmutableList<int> emptyList(0);

    // Add some elements
    ImmutableList<int> list = emptyList.prepend(3).prepend(2).prepend(1);

    // Print the elements of the list
    while (!list.isEmpty()) {
        std::cout << list.head() << " ";
        list = list.tail();
    }
    std::cout << std::endl;

    return 0;
}
```

In this implementation:

* The `ImmutableList` class represents a node in the linked list. It contains a `value` and a pointer to the next node, which is a `const` pointer to ensure immutability.
* The `prepend` function is used to add a new element to the beginning of the list, returning a new list with the new element added.
* The `head` function returns the value at the head of the list.
* The `tail` function returns a new list containing all elements except the head.
* The `isEmpty` function checks if the list is empty.

This implementation demonstrates how you can create and manipulate an immutable list in C++.

### 1. Algorithms & Data Structures (C++): Insert in Sorted Linked List

Inserting an element into a sorted linked list in C++ involves finding the correct position to insert the new element while maintaining the sorted order of the list. Here's a basic implementation:

```cpp
#include <iostream>

using namespace std;

// Define the structure of a node in the linked list
struct Node {
    int data;
    Node* next;
};

// Function to create a new node
Node* createNode(int data) {
    Node* newNode = new Node;
    newNode->data = data;
    newNode->next = nullptr;
    return newNode;
}

// Function to insert a new node into a sorted linked list
void insertSorted(Node*& head, int data) {
    Node* newNode = createNode(data);
    
    // If the list is empty or the new data is less than the first element
    if (head == nullptr || data < head->data) {
        newNode->next = head;
        head = newNode;
        return;
    }
    
    Node* current = head;
    while (current->next != nullptr && current->next->data < data) {
        current = current->next;
    }
    
    newNode->next = current->next;
    current->next = newNode;
}

// Function to print the linked list
void printList(Node* head) {
    while (head != nullptr) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

int main() {
    Node* head = nullptr;
    insertSorted(head, 5);
    insertSorted(head, 3);
    insertSorted(head, 8);
    insertSorted(head, 1);
    insertSorted(head, 6);
    
    cout << "Sorted Linked List: ";
    printList(head);
    
    return 0;
}
```

In this code:

* We define a `Node` structure to represent each element in the linked list.
* `createNode` function creates a new node with the given data.
* `insertSorted` function inserts a new node into the sorted linked list while maintaining the sorted order.
* `printList` function is used to print the elements of the linked list.
* In the `main` function, we create a sorted linked list by inserting elements in a sorted order and then print the list.

### 1. Algorithms & Data Structures (C++): Inserting in a Sorted Linked List

Inserting a new node into a sorted linked list in C++ involves traversing the list to find the correct position for insertion while maintaining the sorted order. Here's a simple implementation:

```cpp
#include <iostream>

struct Node {
    int data;
    Node* next;
    Node(int value) : data(value), next(nullptr) {}
};

void insertSorted(Node*& head, int value) {
    Node* newNode = new Node(value);
    
    // If the list is empty or the new node's value is less than the head's value
    // Insert the new node at the beginning
    if (head == nullptr || value < head->data) {
        newNode->next = head;
        head = newNode;
        return;
    }

    // Traverse the list to find the correct position to insert the new node
    Node* current = head;
    while (current->next != nullptr && current->next->data < value) {
        current = current->next;
    }

    // Insert the new node after the current node
    newNode->next = current->next;
    current->next = newNode;
}

void printList(Node* head) {
    while (head != nullptr) {
        std::cout << head->data << " ";
        head = head->next;
    }
    std::cout << std::endl;
}

int main() {
    Node* head = nullptr;
    
    // Inserting elements into the sorted linked list
    insertSorted(head, 5);
    insertSorted(head, 10);
    insertSorted(head, 7);
    insertSorted(head, 3);
    insertSorted(head, 12);

    // Print the sorted linked list
    std::cout << "Sorted Linked List: ";
    printList(head);

    return 0;
}
```

This code defines a `Node` structure representing each element in the linked list. The `insertSorted` function inserts a new node into the sorted linked list while maintaining the sorted order. Finally, the `printList` function prints the elements of the linked list.

When you run this program, it will output:

```bash
Sorted Linked List: 3 5 7 10 12 
```

This demonstrates the sorted insertion of elements into the linked list.

### 1. Algorithms & Data Structures (C++): Intersection Of Two Linked List - Linked List

Certainly! Finding the intersection of two linked lists involves determining if there are any common nodes between them. Here's a basic implementation in C++:

```cpp
#include <iostream>

using namespace std;

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if (!headA || !headB)
            return nullptr;

        ListNode *a = headA;
        ListNode *b = headB;

        // Traverse both lists until they meet or reach the end
        while (a != b) {
            // If a has reached the end, move it to the head of B
            if (!a)
                a = headB;
            else
                a = a->next;
            
            // If b has reached the end, move it to the head of A
            if (!b)
                b = headA;
            else
                b = b->next;
        }

        // a (or b) will be either nullptr (no intersection) or the intersection point
        return a;
    }
};

int main() {
    // Example usage
    ListNode *intersection = new ListNode(8);
    
    ListNode *headA = new ListNode(4);
    headA->next = new ListNode(1);
    headA->next->next = intersection;
    headA->next->next->next = new ListNode(4);
    headA->next->next->next->next = new ListNode(5);

    ListNode *headB = new ListNode(5);
    headB->next = new ListNode(6);
    headB->next->next = new ListNode(1);
    headB->next->next->next = intersection;

    Solution solution;
    ListNode *result = solution.getIntersectionNode(headA, headB);

    if (result)
        cout << "Intersection node value: " << result->val << endl;
    else
        cout << "No intersection found." << endl;

    return 0;
}
```

In this implementation, we have a class `Solution` that contains the method `getIntersectionNode`, which takes in the heads of two linked lists `headA` and `headB`. The method iterates through both lists simultaneously until they meet at the intersection point or reach the end. If there's no intersection, it returns `nullptr`. Otherwise, it returns the node where they intersect.

In the `main` function, I've provided an example usage with two linked lists that intersect at node with value `8`. You can modify it to test with your own linked lists.

### 1. Algorithms & Data Structures (C++): List vs Linked List

In C++, both lists and linked lists are fundamental data structures, but they serve different purposes and have different characteristics.

**List (std::list)**:

1. **Implementation**: Lists in C++ are typically implemented as doubly-linked lists. This means that each element of the list contains pointers to both the next and the previous elements in the list.
  
2. **Insertion and Deletion**: Insertion and deletion operations in a list are efficient, even at arbitrary positions within the list. This is because inserting or deleting an element in a linked list only requires updating the pointers of adjacent nodes.

3. **Access Time**: Accessing elements in a list is slower compared to arrays or vectors because lists don't support random access. To access an element at a specific position, you have to traverse the list from the beginning or end until you reach the desired position.

4. **Iterators**: Lists support bidirectional iterators, meaning you can traverse the elements forwards and backwards efficiently.

5. **Memory Overhead**: Lists have a higher memory overhead compared to arrays or vectors because of the additional memory required for storing the pointers to the next and previous elements.

**Linked List**:

1. **Flexibility**: Linked lists are more flexible than arrays or vectors because they don't require contiguous memory allocation. They can easily grow or shrink in size without the need for reallocation.

2. **Implementation**: There are different types of linked lists such as singly-linked lists, doubly-linked lists, and circular linked lists. Each type has its own advantages and use cases. Singly-linked lists only have pointers to the next element, while doubly-linked lists have pointers to both the next and previous elements.

3. **Insertion and Deletion**: Similar to lists, insertion and deletion operations in linked lists are efficient because they only involve updating pointers. However, the efficiency may vary depending on whether it's a singly or doubly-linked list and the position of insertion/deletion.

4. **Access Time**: Accessing elements in a linked list is slower compared to arrays, vectors, or lists because linked lists don't support random access. You have to traverse the list from the beginning (or end, in the case of doubly-linked lists) until you reach the desired position.

5. **Memory Overhead**: Linked lists also have a higher memory overhead compared to arrays or vectors due to the pointers required for linking the elements.

**Summary**:

* Use lists (std::list) when you need efficient insertion and deletion operations at arbitrary positions and don't require frequent random access.
* Use linked lists when you need flexibility in memory allocation, such as when you expect frequent insertions or deletions at the beginning or middle of the list, or when contiguous memory allocation is not feasible.

### 1. Algorithms & Data Structures (C++): List: Find Longest String

To find the longest string in a list of strings in C++, you can iterate through the list and keep track of the longest string encountered so far. Here's a simple example using a `std::vector` to represent the list of strings:

```cpp
#include <iostream>
#include <vector>
#include <string>

std::string findLongestString(const std::vector<std::string>& strings) {
    if (strings.empty()) {
        // Handle empty list case
        return "";
    }
    
    std::string longest = strings[0]; // Assume first string is the longest
    
    // Iterate through the list starting from the second string
    for (size_t i = 1; i < strings.size(); ++i) {
        if (strings[i].length() > longest.length()) {
            longest = strings[i];
        }
    }
    
    return longest;
}

int main() {
    std::vector<std::string> strings = {"apple", "banana", "orange", "kiwi", "strawberry"};
    
    std::string longest = findLongestString(strings);
    
    if (longest.empty()) {
        std::cout << "List is empty." << std::endl;
    } else {
        std::cout << "Longest string: " << longest << std::endl;
    }
    
    return 0;
}
```

In this code:

* The function `findLongestString` takes a vector of strings as input and returns the longest string found in the list.
* Inside the function, it first checks if the list is empty. If it is, it returns an empty string.
* Otherwise, it assumes the first string in the list is the longest.
* It then iterates through the remaining strings in the list and updates the `longest` variable if it encounters a longer string.
* Finally, it returns the longest string found.
* In the `main` function, a sample list of strings is created, and the `findLongestString` function is called to find the longest string.

### 1. Algorithms & Data Structures (C++): List: Max Profit

Sure, let's create a C++ function to find the maximum profit that can be obtained by buying and selling a stock given its price on different days. We can solve this problem using a simple algorithm that iterates through the prices and keeps track of the minimum price seen so far and the maximum profit that can be obtained.

Here's the implementation:

```cpp
#include <vector>
#include <algorithm>
#include <iostream>

int maxProfit(std::vector<int>& prices) {
    if (prices.empty())
        return 0;
    
    int minPrice = prices[0];
    int maxProfit = 0;
    
    for (int i = 1; i < prices.size(); ++i) {
        maxProfit = std::max(maxProfit, prices[i] - minPrice);
        minPrice = std::min(minPrice, prices[i]);
    }
    
    return maxProfit;
}

int main() {
    // Example usage
    std::vector<int> prices = {7, 1, 5, 3, 6, 4};
    std::cout << "Maximum profit: " << maxProfit(prices) << std::endl;
    return 0;
}
```

This code defines a function `maxProfit` which takes a vector of stock prices and returns the maximum profit that can be obtained by buying and selling the stock once. The `main()` function provides an example of how to use this function with a vector of prices.

The algorithm iterates through the prices, keeping track of the minimum price seen so far (`minPrice`) and updating the maximum profit (`maxProfit`) if a higher profit can be obtained by selling at the current price. Finally, it returns the maximum profit.

### 1. Algorithms & Data Structures (C++): List: Max Sub Array

The maximum subarray problem is a classic problem in computer science and is often used to illustrate various algorithmic techniques, such as dynamic programming or the divide and conquer approach. Here's a simple implementation of finding the maximum subarray sum using Kadane's algorithm, which is an efficient dynamic programming approach:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int maxSubArray(vector<int>& nums) {
    int maxSum = nums[0];
    int currentSum = nums[0];
    
    for (int i = 1; i < nums.size(); ++i) {
        currentSum = max(nums[i], currentSum + nums[i]);
        maxSum = max(maxSum, currentSum);
    }
    
    return maxSum;
}

int main() {
    vector<int> nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
    cout << "Maximum subarray sum: " << maxSubArray(nums) << endl;
    return 0;
}
```

This code finds the maximum sum of a contiguous subarray within the input array `nums`. The time complexity of this algorithm is O(n), where n is the size of the input array.

### 1. Algorithms & Data Structures (C++): List: Remove Duplicates

To remove duplicates from a list in C++, you can use various approaches. One common method is to use a set to keep track of elements you've seen so far. Here's a sample implementation:

```cpp
#include <iostream>
#include <list>
#include <unordered_set>

template <typename T>
void removeDuplicates(std::list<T>& lst) {
    std::unordered_set<T> seen;
    auto it = lst.begin();
    while (it != lst.end()) {
        if (seen.find(*it) != seen.end()) {
            it = lst.erase(it);
        } else {
            seen.insert(*it);
            ++it;
        }
    }
}

int main() {
    std::list<int> myList = {1, 2, 3, 2, 4, 5, 3, 6, 7, 4};
    
    std::cout << "Original List: ";
    for (const auto& item : myList) {
        std::cout << item << " ";
    }
    std::cout << std::endl;
    
    removeDuplicates(myList);
    
    std::cout << "List after removing duplicates: ";
    for (const auto& item : myList) {
        std::cout << item << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

This code defines a function `removeDuplicates` that takes a list by reference and removes duplicates using an unordered set to track elements that have been seen. Then, in the `main` function, it demonstrates how to use this function by creating a list of integers, removing duplicates, and printing the result.

### 1. Algorithms & Data Structures (C++): List: Rotate

Rotating a list in C++ involves shifting its elements by a certain number of positions. There are multiple ways to implement this operation, but let's discuss a simple approach using an array-based list. Here's a basic implementation of a function to rotate a list:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Function to rotate a list to the left by 'shift' positions
void rotateList(vector<int>& arr, int shift) {
    int n = arr.size();
    if (n == 0) return; // Empty list

    shift = shift % n; // Handle shifts larger than the list size

    if (shift < 0) {
        shift += n; // Convert negative shift to positive
    }

    // Reverse the first part of the list (0 to shift-1)
    reverse(arr.begin(), arr.begin() + shift);

    // Reverse the second part of the list (shift to n-1)
    reverse(arr.begin() + shift, arr.end());

    // Reverse the entire list
    reverse(arr.begin(), arr.end());
}

// Function to display a list
void displayList(const vector<int>& arr) {
    for (int num : arr) {
        cout << num << " ";
    }
    cout << endl;
}

int main() {
    vector<int> myList = {1, 2, 3, 4, 5};

    cout << "Original List: ";
    displayList(myList);

    int shiftAmount = 2; // Number of positions to rotate
    rotateList(myList, shiftAmount);

    cout << "List after rotating left by " << shiftAmount << " positions: ";
    displayList(myList);

    return 0;
}
```

This implementation rotates the list to the left by a specified number of positions. It utilizes the `reverse()` function from the `<algorithm>` header to reverse different parts of the list.

Remember to include necessary headers (`iostream`, `<vector>`, and `<algorithm>`) at the beginning of your program. This implementation assumes that you're using a vector to represent your list. If you're using a different data structure, you'll need to adjust the implementation accordingly.

### 1. Algorithms & Data Structures (C++): Lists

Certainly! Lists are fundamental data structures in computer science that store a collection of items, where each item holds a relative position with respect to the others. In C++, lists can be implemented in various ways, each with its own advantages and disadvantages. Here's a brief overview of some common types of lists and their implementations in C++:

1. **Array-based Lists:**
   * **Vector**: The `std::vector` in C++ is a dynamic array that can resize itself automatically when needed. It provides constant time access to elements and amortized constant time insertion at the end.

   ```cpp
   #include <vector>
   std::vector<int> myVector;
   ```

2. **Linked Lists:**
   * **Singly Linked List**: Each element in the list contains a reference to the next element in the sequence.

   ```cpp
   struct Node {
       int data;
       Node* next;
   };
   ```

   * **Doubly Linked List**: Each element contains references to both the next and previous elements.

   ```cpp
   struct Node {
       int data;
       Node* prev;
       Node* next;
   };
   ```

3. **Forward List**:
   * `std::forward_list` is a singly linked list provided by the C++ standard library. It allows forward traversal only (from beginning to end) and does not support bidirectional traversal like the doubly linked list.

   ```cpp
   #include <forward_list>
   std::forward_list<int> myForwardList;
   ```

4. **Circular Linked List**:
   * In this list, the last node points back to the first node, forming a circle.

   ```cpp
   struct Node {
       int data;
       Node* next;
   };
   ```

5. **Other Implementations**:
   * Apart from the standard implementations, you can create your own custom implementations of lists based on the specific requirements of your application.

Each type of list has its own advantages and use cases. For example, arrays (like vectors) provide fast access to elements through indexing but may be inefficient for insertions and deletions at arbitrary positions. Linked lists, on the other hand, allow efficient insertions and deletions anywhere in the list but may have slower access times.

When choosing a list implementation, it's essential to consider the operations you'll perform most frequently and the performance characteristics of each implementation with respect to those operations.

### 1. Algorithms & Data Structures (C++): Loop detection

In the context of algorithms and data structures, loop detection typically refers to finding whether a linked list contains a cycle or loop. This problem is often encountered in computer science interviews and is crucial for understanding and implementing various algorithms involving linked lists.

Here's a common approach to detect loops in a linked list using C++:

```cpp
#include <iostream>

struct Node {
    int data;
    Node* next;
    
    Node(int data) : data(data), next(nullptr) {}
};

bool hasCycle(Node* head) {
    if (head == nullptr || head->next == nullptr)
        return false; // No loop if list is empty or has only one node
    
    Node* slow = head;
    Node* fast = head->next;

    while (fast != nullptr && fast->next != nullptr) {
        if (slow == fast) {
            return true; // Loop detected
        }
        slow = slow->next;
        fast = fast->next->next;
    }

    return false; // No loop detected
}

int main() {
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);
    head->next->next->next->next = head; // Creating a cycle

    if (hasCycle(head)) {
        std::cout << "The linked list contains a cycle." << std::endl;
    } else {
        std::cout << "The linked list does not contain a cycle." << std::endl;
    }

    // Clean up memory (not necessary for demonstrating the algorithm)
    Node* current = head;
    while (current != nullptr) {
        Node* temp = current;
        current = current->next;
        delete temp;
    }

    return 0;
}
```

In this code:

* We use two pointers, `slow` and `fast`, to traverse the list. `slow` moves one step at a time, while `fast` moves two steps at a time.
* If there's a loop in the list, `slow` and `fast` pointers will eventually meet at some point.
* If there's no loop, `fast` will reach the end of the list (i.e., become `nullptr`) before `slow` reaches it.

This algorithm has a time complexity of O(n) and a space complexity of O(1), where n is the number of nodes in the linked list.

### 1. Algorithms & Data Structures (C++): Middle Element

To find the middle element of a singly linked list, you typically use two pointers: one slow pointer and one fast pointer. The slow pointer moves one step at a time, while the fast pointer moves two steps at a time. When the fast pointer reaches the end of the list, the slow pointer will be at the middle element.

Here's how you can implement this in C++:

```cpp
#include <iostream>

using namespace std;

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

ListNode* findMiddle(ListNode* head) {
    if (head == nullptr) return nullptr; // Empty list
    ListNode* slow = head;
    ListNode* fast = head;
    
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
    }
    
    return slow;
}

int main() {
    // Example usage
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);

    ListNode* middle = findMiddle(head);
    if (middle != nullptr)
        cout << "Middle element: " << middle->val << endl;
    else
        cout << "List is empty!" << endl;

    // Freeing memory
    while (head != nullptr) {
        ListNode* temp = head;
        head = head->next;
        delete temp;
    }
    
    return 0;
}
```

This code defines a `ListNode` struct representing nodes in the linked list, and a `findMiddle` function to find the middle element. The `main` function demonstrates how to use this function with an example linked list. Finally, it deallocates the memory allocated for the linked list to prevent memory leaks.

### 1. Algorithms & Data Structures (C++): Middle Node of List - Slow and Fast Pointer Approach

Certainly! The slow and fast pointer approach, also known as the tortoise and hare algorithm, is a widely used technique to find the middle node of a linked list. Here's how it works:

```cpp
#include <iostream>

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

ListNode* middleNode(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;
    
    // Move 'fast' pointer two steps ahead and 'slow' pointer one step ahead
    // When 'fast' reaches the end, 'slow' will be at the middle.
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
    }
    
    return slow;
}

// Utility function to print the linked list
void printList(ListNode* head) {
    while (head != nullptr) {
        std::cout << head->val << " ";
        head = head->next;
    }
    std::cout << std::endl;
}

int main() {
    // Example usage
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);

    std::cout << "Original list: ";
    printList(head);

    ListNode* middle = middleNode(head);
    std::cout << "Middle node value: " << middle->val << std::endl;

    return 0;
}
```

In this approach, we use two pointers, `slow` and `fast`, initially pointing to the head of the list. In each iteration of the loop, the `slow` pointer moves one step forward, while the `fast` pointer moves two steps forward. This way, when the `fast` pointer reaches the end of the list, the `slow` pointer will be at the middle node.

### 1. Algorithms & Data Structures (C++): Midpoint Linked List

Sure! Implementing a function to find the midpoint of a linked list in C++ involves using the slow and fast pointer approach. Here's how you can do it:

```cpp
#include <iostream>

using namespace std;

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

ListNode* findMidpoint(ListNode* head) {
    if (head == nullptr || head->next == nullptr) {
        return head; // If the list is empty or has only one node, return head
    }

    ListNode *slow = head;
    ListNode *fast = head;

    // Move fast pointer two steps at a time and slow pointer one step at a time
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
    }

    return slow; // Slow pointer will be at the midpoint when fast pointer reaches the end
}

// Utility function to print the linked list
void printList(ListNode *head) {
    while (head != nullptr) {
        cout << head->val << " ";
        head = head->next;
    }
    cout << endl;
}

int main() {
    // Creating a sample linked list: 1->2->3->4->5
    ListNode *head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);

    cout << "Original Linked List: ";
    printList(head);

    ListNode *midpoint = findMidpoint(head);
    cout << "Midpoint of the Linked List: " << midpoint->val << endl;

    return 0;
}
```

In this code:

* We define a `ListNode` struct to represent each node of the linked list.
* The `findMidpoint` function takes the head of the linked list as input and returns a pointer to the midpoint node.
* We use the slow and fast pointer approach where the slow pointer moves one step at a time and the fast pointer moves two steps at a time. When the fast pointer reaches the end of the list, the slow pointer will be at the midpoint.
* The `printList` function is a utility function to print the linked list.
* In the `main` function, we create a sample linked list, print it, find the midpoint, and print the value of the midpoint node.

### 1. Algorithms & Data Structures (C++): Odd Even Linked List

An odd-even linked list problem involves rearranging a linked list such that all nodes with odd indices appear before nodes with even indices. Here's how you can implement this in C++:

```cpp
#include <iostream>

using namespace std;

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        if (!head || !head->next)
            return head;

        ListNode* odd = head;
        ListNode* even = head->next;
        ListNode* evenHead = even;

        while (even && even->next) {
            odd->next = even->next;
            odd = odd->next;
            even->next = odd->next;
            even = even->next;
        }

        odd->next = evenHead;
        return head;
    }
};

// Utility function to print the linked list
void printList(ListNode* head) {
    while (head) {
        cout << head->val << " ";
        head = head->next;
    }
    cout << endl;
}

int main() {
    // Create a sample linked list: 1->2->3->4->5
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);

    Solution sol;
    ListNode* result = sol.oddEvenList(head);

    cout << "Original List: ";
    printList(head);

    cout << "Odd-Even List: ";
    printList(result);

    return 0;
}
```

In this solution:

* We iterate through the linked list, starting with the head.
* At each iteration, we move the odd-indexed nodes to the front and even-indexed nodes to the back.
* Finally, we connect the last odd node with the head of the even list to form a single list.

### 1. Algorithms & Data Structures (C++): Pairwise Swap of Adjacent Nodes using Links

Sure, here's an implementation in C++ for pairwise swapping of adjacent nodes in a linked list:

```cpp
#include <iostream>

// Define the structure for a node in the linked list
struct Node {
    int data;
    Node* next;
    
    Node(int value) : data(value), next(nullptr) {}
};

// Function to add a node at the end of the linked list
void append(Node* &head, int value) {
    Node* newNode = new Node(value);
    if (head == nullptr) {
        head = newNode;
        return;
    }
    Node* temp = head;
    while (temp->next != nullptr) {
        temp = temp->next;
    }
    temp->next = newNode;
}

// Function to swap nodes pairwise in a linked list
void pairwiseSwap(Node* &head) {
    if (head == nullptr || head->next == nullptr)
        return;
    
    Node* prev = head;
    Node* current = head->next;
    
    head = current; // New head of the list
    
    while (true) {
        Node* nextNode = current->next;
        current->next = prev;
        
        if (nextNode == nullptr || nextNode->next == nullptr) {
            prev->next = nextNode;
            break;
        }
        
        prev->next = nextNode->next;
        prev = nextNode;
        current = prev->next;
    }
}

// Function to print the linked list
void printList(Node* head) {
    while (head != nullptr) {
        std::cout << head->data << " ";
        head = head->next;
    }
    std::cout << std::endl;
}

// Function to delete the linked list to prevent memory leaks
void deleteList(Node* &head) {
    while (head != nullptr) {
        Node* temp = head;
        head = head->next;
        delete temp;
    }
}

int main() {
    // Example usage
    Node* head = nullptr;
    append(head, 1);
    append(head, 2);
    append(head, 3);
    append(head, 4);
    append(head, 5);
    
    std::cout << "Original list: ";
    printList(head);
    
    pairwiseSwap(head);
    
    std::cout << "List after pairwise swapping: ";
    printList(head);
    
    // Delete the list to free memory
    deleteList(head);
    
    return 0;
}
```

This code defines a basic singly linked list with nodes having integer data. The `pairwiseSwap` function swaps adjacent nodes pairwise in the list. The `append` function adds nodes to the end of the list, and the `printList` function prints the elements of the list. Finally, the `deleteList` function deletes the list to prevent memory leaks.

### 1. Algorithms & Data Structures (C++): Palindrome linked list

Sure! Implementing a palindrome checker for a linked list involves traversing the list efficiently while simultaneously checking if the elements form a palindrome. Here's a C++ implementation:

```cpp
#include <iostream>

using namespace std;

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if (!head || !head->next)
            return true;
        
        // Find the middle of the linked list
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast->next && fast->next->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        
        // Reverse the second half of the linked list
        ListNode* prev = nullptr;
        ListNode* curr = slow->next;
        while (curr) {
            ListNode* nextTemp = curr->next;
            curr->next = prev;
            prev = curr;
            curr = nextTemp;
        }
        
        // Compare the first half and reversed second half
        ListNode* p1 = head;
        ListNode* p2 = prev;
        while (p2) {
            if (p1->val != p2->val)
                return false;
            p1 = p1->next;
            p2 = p2->next;
        }
        return true;
    }
};

// Utility function to print the linked list
void printList(ListNode* head) {
    while (head) {
        cout << head->val << " ";
        head = head->next;
    }
    cout << endl;
}

int main() {
    // Example usage
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(2);
    head->next->next->next->next = new ListNode(1);

    Solution solution;
    cout << "Original List: ";
    printList(head);
    if (solution.isPalindrome(head))
        cout << "The list is a palindrome.\n";
    else
        cout << "The list is not a palindrome.\n";

    // Free memory
    while (head) {
        ListNode* temp = head;
        head = head->next;
        delete temp;
    }
    
    return 0;
}
```

This code first finds the middle of the linked list using the slow and fast pointer technique. Then, it reverses the second half of the list. Finally, it compares the first half with the reversed second half to determine if the linked list is a palindrome or not.

### 1. Algorithms & Data Structures (C++): Palindrome linked list: Complexity analysis

To analyze the complexity of checking whether a linked list is a palindrome in C++, let's break down the process into steps:

1. **Reverse the second half of the linked list**: To check if a linked list is a palindrome, we need to compare the first half of the list with the reversed second half. So, first, we need to find the midpoint of the list and then reverse the second half of the list.

2. **Compare the first half with the reversed second half**: Once we have the reversed second half of the list, we can start comparing it with the first half. If every element matches, the list is a palindrome.

Let's analyze the complexity of each step:

1. **Finding the midpoint and reversing the second half**:
   * Finding the midpoint: To find the midpoint, we need to traverse the list once, which takes O(n) time, where n is the number of elements in the list.
   * Reversing the second half: Reversing a linked list requires traversing the second half once, which also takes O(n/2) time.
   * So, the total time complexity for this step is O(n/2) + O(n) ≈ O(n).

2. **Comparing the first half with the reversed second half**:
   * To compare the first half with the reversed second half, we need to traverse both halves once, which takes O(n/2) + O(n/2) = O(n) time.

Therefore, the overall time complexity of checking whether a linked list is a palindrome using this approach is O(n).

In terms of space complexity, we are not using any additional data structures apart from a few pointers, so the space complexity is O(1).

This analysis assumes a singly linked list. If it's a doubly linked list, the reversal step would be simpler, but the overall complexity would still remain O(n).

### 1. Algorithms & Data Structures (C++): Palindrome Linked Lists - Linked List

Sure, implementing a function to check if a linked list is a palindrome in C++ is an interesting problem. Here's how you could approach it:

```cpp
#include <iostream>
#include <stack>

using namespace std;

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

bool isPalindrome(ListNode* head) {
    if (!head || !head->next)
        return true;
    
    // Find the middle of the linked list
    ListNode* slow = head;
    ListNode* fast = head;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
    }
    
    // Reverse the second half of the linked list
    ListNode* prev = nullptr;
    ListNode* curr = slow;
    ListNode* next = nullptr;
    while (curr) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }
    
    // Compare the first and second halves
    ListNode* firstHalf = head;
    ListNode* secondHalf = prev;
    while (secondHalf) {
        if (firstHalf->val != secondHalf->val)
            return false;
        firstHalf = firstHalf->next;
        secondHalf = secondHalf->next;
    }
    
    return true;
}

// Function to print the linked list
void printList(ListNode* head) {
    ListNode* temp = head;
    while (temp != NULL) {
        cout << temp->val << " ";
        temp = temp->next;
    }
    cout << endl;
}

int main() {
    // Example usage
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(2);
    head->next->next->next->next = new ListNode(1);
    
    cout << "Original list: ";
    printList(head);
    
    if (isPalindrome(head))
        cout << "The linked list is a palindrome." << endl;
    else
        cout << "The linked list is not a palindrome." << endl;
    
    // Free memory
    while (head != nullptr) {
        ListNode* temp = head;
        head = head->next;
        delete temp;
    }
    
    return 0;
}
```

This code defines a linked list structure (`ListNode`) and implements a function `isPalindrome` to check if the given linked list is a palindrome. It uses the approach of reversing the second half of the linked list and then comparing it with the first half. The function `printList` is just a utility function to print the linked list elements, and the `main` function demonstrates its usage with an example.

### 1. Algorithms & Data Structures (C++): Recursive Display for Linked List

Sure! In C++, you can implement a recursive function to display the elements of a linked list. Here's an example implementation:

```cpp
#include <iostream>

// Node structure for the linked list
struct Node {
    int data;
    Node* next;
    
    Node(int val) : data(val), next(nullptr) {}
};

// Function to recursively display the linked list
void displayList(Node* head) {
    // Base case: If the current node is null, return
    if (head == nullptr)
        return;

    // Display the data of the current node
    std::cout << head->data << " ";

    // Recursively call the function for the next node
    displayList(head->next);
}

int main() {
    // Create a sample linked list: 1 -> 2 -> 3 -> 4 -> 5
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);
    head->next->next->next->next = new Node(5);

    // Display the linked list
    std::cout << "Linked List: ";
    displayList(head);
    std::cout << std::endl;

    // Clean up memory (deallocation)
    Node* current = head;
    while (current != nullptr) {
        Node* temp = current;
        current = current->next;
        delete temp;
    }

    return 0;
}
```

In this example, the `displayList()` function takes the head of the linked list as an argument and recursively displays each node's data. The function stops when it reaches the end of the list (when the current node is `nullptr`). Finally, in the `main()` function, a sample linked list is created and displayed using the `displayList()` function, followed by memory deallocation to prevent memory leaks.

### 1. Algorithms & Data Structures (C++): Recursive Display of Linked List

Sure! Below is an example of how you can recursively display the elements of a linked list in C++:

```cpp
#include <iostream>

// Define the structure of a node in the linked list
struct Node {
    int data;
    Node* next;
    
    Node(int val) : data(val), next(nullptr) {}
};

// Function to recursively display the linked list
void displayLinkedList(Node* head) {
    if (head == nullptr) {
        // Base case: if the current node is nullptr, return
        return;
    }
    
    // Display the data of the current node
    std::cout << head->data << " ";
    
    // Recursively call the function for the next node
    displayLinkedList(head->next);
}

int main() {
    // Create a sample linked list: 1 -> 2 -> 3 -> 4 -> 5
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);
    head->next->next->next->next = new Node(5);
    
    // Display the linked list recursively
    std::cout << "Linked List: ";
    displayLinkedList(head);
    
    // Cleanup: delete the allocated memory
    Node* current = head;
    while (current != nullptr) {
        Node* temp = current;
        current = current->next;
        delete temp;
    }
    
    return 0;
}
```

This code defines a basic linked list structure and a function `displayLinkedList` that recursively displays the elements of the linked list. The `main` function creates a sample linked list and calls the display function. Finally, it cleans up the memory by deleting the allocated nodes.

### 1. Algorithms & Data Structures (C++): Remove Loop (Cycle) from Linked List

Removing a loop or cycle from a linked list involves detecting the loop and then breaking the cycle at some point. One common algorithm to achieve this is called Floyd's Cycle Detection Algorithm, also known as the "tortoise and hare" algorithm. Here's how it works:

1. Use two pointers, often referred to as slow and fast pointers, initially pointing to the head of the linked list.
2. Move the slow pointer one step at a time and the fast pointer two steps at a time.
3. If the slow pointer and fast pointer meet at some point, it indicates the presence of a cycle.
4. Once the cycle is detected, reset one of the pointers to the head of the list and move both pointers one step at a time until they meet again. The meeting point is the start of the cycle.
5. Break the cycle by setting the next pointer of the node before the meeting point to null.

Here's the C++ implementation:

```cpp
#include <iostream>

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

class Solution {
public:
    void removeCycle(ListNode *head) {
        if (!head || !head->next)
            return;

        // Detect cycle using Floyd's Cycle Detection Algorithm
        ListNode *slow = head, *fast = head;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
            if (slow == fast)
                break;
        }

        // If no cycle found
        if (slow != fast)
            return;

        // Move one pointer back to the head
        slow = head;

        // Find the start of the cycle
        while (slow != fast) {
            slow = slow->next;
            fast = fast->next;
        }

        // Break the cycle
        ListNode *prev = nullptr;
        while (head != slow) {
            prev = slow;
            slow = slow->next;
            head = head->next;
        }
        // prev now points to the node before the start of the cycle
        prev->next = nullptr;
    }
};

// Utility function to print the linked list
void printList(ListNode *head) {
    while (head) {
        std::cout << head->val << " -> ";
        head = head->next;
    }
    std::cout << "nullptr" << std::endl;
}

int main() {
    // Creating a sample linked list with a cycle
    ListNode *head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = head->next; // Creating a cycle

    Solution sol;
    sol.removeCycle(head);

    std::cout << "Linked list after removing the cycle:" << std::endl;
    printList(head);

    // Clean up memory
    while (head) {
        ListNode *temp = head;
        head = head->next;
        delete temp;
    }

    return 0;
}
```

This implementation first detects the cycle using Floyd's algorithm, then finds the start of the cycle, and finally breaks the cycle.

### 1. Algorithms & Data Structures (C++): Sort linked list

Certainly! Here's an implementation of sorting a linked list using the Merge Sort algorithm in C++:

```cpp
#include <iostream>

using namespace std;

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

// Function to merge two sorted linked lists
ListNode* merge(ListNode* l1, ListNode* l2) {
    if (!l1) return l2;
    if (!l2) return l1;

    if (l1->val < l2->val) {
        l1->next = merge(l1->next, l2);
        return l1;
    } else {
        l2->next = merge(l1, l2->next);
        return l2;
    }
}

// Function to perform merge sort on a linked list
ListNode* sortList(ListNode* head) {
    // Base case: if the list is empty or has only one element
    if (!head || !head->next) return head;

    // Find the middle of the list
    ListNode *slow = head, *fast = head->next;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
    }

    ListNode* secondHalf = slow->next;
    slow->next = nullptr;

    // Recursively sort the two halves
    ListNode* firstHalf = sortList(head);
    secondHalf = sortList(secondHalf);

    // Merge the sorted halves
    return merge(firstHalf, secondHalf);
}

// Function to print a linked list
void printList(ListNode* head) {
    while (head) {
        cout << head->val << " ";
        head = head->next;
    }
    cout << endl;
}

int main() {
    // Example usage
    ListNode* head = new ListNode(4);
    head->next = new ListNode(2);
    head->next->next = new ListNode(1);
    head->next->next->next = new ListNode(3);

    cout << "Original list: ";
    printList(head);

    head = sortList(head);

    cout << "Sorted list: ";
    printList(head);

    return 0;
}
```

This code defines a linked list structure `ListNode` and implements the Merge Sort algorithm to sort the linked list. The `sortList` function recursively divides the list into halves, sorts them individually, and then merges them back together. Finally, the `printList` function is used to print the sorted list.

### 1. Algorithms & Data Structures (C++): Sort linked list: Complexity analysis

Sorting a linked list involves rearranging its elements so that they are in a specific order, typically non-decreasing or non-increasing. Several sorting algorithms can be applied to linked lists, each with its own time and space complexities. Let's analyze the complexity of sorting a linked list using various sorting algorithms:

1. **Insertion Sort**:
   * Time Complexity: \(O(n^2)\) in the worst-case scenario. Since insertion sort iterates over each element in the list and potentially swaps it with preceding elements, the time complexity is quadratic.
   * Space Complexity: \(O(1)\). Insertion sort typically performs sorting in place without requiring additional space.

2. **Selection Sort**:
   * Time Complexity: \(O(n^2)\) in all cases. Selection sort also iterates over the list, but in each iteration, it finds the minimum element and places it at the beginning, which requires \(O(n)\) comparisons for each element.
   * Space Complexity: \(O(1)\). Similar to insertion sort, selection sort operates in place.

3. **Merge Sort**:
   * Time Complexity: \(O(n \log n)\). Merge sort consistently exhibits this time complexity, even for linked lists. It recursively divides the list into halves until each sublist contains only one element, then merges the sorted sublists.
   * Space Complexity: \(O(\log n)\). Merge sort typically requires additional space for recursion stack due to its divide-and-conquer approach.

4. **Quick Sort**:
   * Time Complexity: \(O(n \log n)\) on average case, but \(O(n^2)\) in the worst case. Quick sort's time complexity depends on the choice of the pivot element. In the worst-case scenario, the pivot is either the smallest or largest element, resulting in unbalanced partitioning.
   * Space Complexity: \(O(\log n)\) on average. Similar to merge sort, quick sort also requires additional space for recursion stack.

5. **Heap Sort**:
   * Time Complexity: \(O(n \log n)\) in all cases. Heap sort first builds a max-heap from the elements and then repeatedly extracts the maximum element from the heap, resulting in sorted order.
   * Space Complexity: \(O(1)\). Unlike merge sort and quick sort, heap sort doesn't require additional space proportional to the input size.

Among these algorithms, merge sort and heap sort are more efficient for linked lists due to their consistent \(O(n \log n)\) time complexity and space efficiency. However, merge sort is preferred over heap sort for linked lists because it's stable and doesn't rely on random access, which is not a natural operation for linked lists.

### 1. Algorithms & Data Structures (C++): Sorted Linked Lists

Sorted linked lists are a fundamental data structure in computer science, especially for maintaining a sorted collection of elements efficiently. In C++, you can implement a sorted linked list by ensuring that elements are inserted into the list in a sorted order.

Here's a basic implementation of a sorted linked list in C++:

```cpp
#include <iostream>

// Node class represents each element in the linked list
class Node {
public:
    int data;
    Node* next;

    Node(int value) {
        data = value;
        next = nullptr;
    }
};

// SortedLinkedList class represents the sorted linked list
class SortedLinkedList {
private:
    Node* head;

public:
    SortedLinkedList() {
        head = nullptr;
    }

    // Function to insert a new node with given value into the sorted linked list
    void insert(int value) {
        Node* newNode = new Node(value);
        
        // If the list is empty or the new node's value is less than the head's value
        if (head == nullptr || value < head->data) {
            newNode->next = head;
            head = newNode;
        } else {
            Node* current = head;
            while (current->next != nullptr && current->next->data < value) {
                current = current->next;
            }
            newNode->next = current->next;
            current->next = newNode;
        }
    }

    // Function to display the sorted linked list
    void display() {
        Node* current = head;
        while (current != nullptr) {
            std::cout << current->data << " ";
            current = current->next;
        }
        std::cout << std::endl;
    }
};

int main() {
    SortedLinkedList list;

    // Insert elements into the sorted linked list
    list.insert(5);
    list.insert(10);
    list.insert(2);
    list.insert(8);

    // Display the sorted linked list
    std::cout << "Sorted Linked List: ";
    list.display();

    return 0;
}
```

In this implementation:

* The `Node` class represents each element in the linked list.
* The `SortedLinkedList` class manages the linked list and provides functions to insert elements into the list while maintaining the sorted order.
* The `insert` function inserts a new node with the given value into the sorted linked list.
* The `display` function prints the elements of the sorted linked list.

This implementation ensures that elements are inserted into the list in such a way that the list remains sorted at all times.

## Cycle Detection

### 1. Algorithms & Data Structures (C++): Detect Cycle in a Linked List

Detecting a cycle in a linked list is a classic problem that can be efficiently solved using Floyd’s Cycle-Finding Algorithm, also known as the Tortoise and Hare algorithm. This algorithm uses two pointers moving at different speeds to detect a cycle.

Here’s a step-by-step guide and a C++ implementation to detect a cycle in a singly linked list:

### Steps

1. **Initialize Two Pointers:** Start with two pointers, both at the head of the linked list. Let’s call them `slow` and `fast`.
2. **Move the Pointers:** Move `slow` one step at a time and `fast` two steps at a time.
3. **Check for Cycle:**
   * If `fast` or `fast->next` becomes `NULL`, it means there is no cycle (since the end of the list is reached).
   * If `slow` and `fast` meet at some point, then there is a cycle in the list.
4. **Return Result:** If the pointers meet, return `true`. If `fast` reaches the end, return `false`.

### C++ Implementation

```cpp
#include <iostream>

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

bool hasCycle(ListNode *head) {
    if (!head) return false;
    
    ListNode *slow = head;
    ListNode *fast = head;
    
    while (fast && fast->next) {
        slow = slow->next;           // Move slow pointer by 1
        fast = fast->next->next;     // Move fast pointer by 2
        
        if (slow == fast) {
            return true;             // Cycle detected
        }
    }
    
    return false;                    // No cycle
}

int main() {
    // Example usage:
    ListNode *head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = head->next; // Creates a cycle

    if (hasCycle(head)) {
        std::cout << "Cycle detected in the linked list." << std::endl;
    } else {
        std::cout << "No cycle in the linked list." << std::endl;
    }
    
    // Remember to free the allocated memory in a real application to avoid memory leaks
    // For this example, we are assuming the program ends here and OS cleans up the memory
    return 0;
}
```

### Explanation

* **ListNode Structure:** A simple structure representing a node in the linked list.
* **hasCycle Function:** Implements the Tortoise and Hare algorithm.
  * **Edge Case Check:** If the list is empty (`head == nullptr`), return `false`.
  * **Pointer Initialization:** Both `slow` and `fast` are initialized to the head of the list.
  * **Cycle Detection Loop:** `slow` moves one step, `fast` moves two steps in each iteration. If they meet, a cycle is detected.
  * **End of List Check:** If `fast` or `fast->next` becomes `NULL`, it means there’s no cycle.

### Usage

In the `main` function, we create a linked list with a cycle and check if the `hasCycle` function correctly identifies it. If a cycle is detected, it prints a message indicating so; otherwise, it indicates no cycle is present.

This approach ensures O(n) time complexity with O(1) space complexity, making it efficient and suitable for large linked lists.

## Problems

### 1. Algorithms & Data Structures (C++): Linked List Problems

Certainly! Linked lists are a fundamental data structure in computer science, and there are several common problems and exercises associated with them. Here are a few typical linked list problems along with their solutions in C++:

1. **Reverse a Linked List:**
2. **Detect a Cycle in a Linked List:**
3. **Find the Middle of a Linked List:**
4. **Merge Two Sorted Lists:**
5. **Remove Nth Node From End of List:**
6. **Removing Duplicates**
7. **Intersection Point**

## Reversing

### 1. Algorithms & Data Structures (C++): Linked List: Reversing a Linked List : Recursive Approach

Reversing a linked list using a recursive approach in C++ involves changing the direction of the links between nodes. Here is a step-by-step explanation and implementation of the recursive approach:

#### Step-by-Step Explanation

1. **Base Case**: If the list is empty (head is `nullptr`) or it has only one node (head's next is `nullptr`), return the head. This is the termination condition for the recursion.

2. **Recursive Step**: Reverse the rest of the list beyond the head. To do this, call the reverse function on the next node of the head.

3. **Re-linking**: Once the rest of the list is reversed, the next node (head->next) should point back to the head. Adjust the links to achieve this.

4. **Final Adjustment**: Make sure to set the head's next pointer to `nullptr` to finalize the reversal for the original head node.

#### Implementation in C++

Here is a C++ implementation of reversing a linked list recursively:

```cpp
#include <iostream>

struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

class LinkedList {
public:
    Node* head;

    LinkedList() : head(nullptr) {}

    void append(int data) {
        if (head == nullptr) {
            head = new Node(data);
            return;
        }
        Node* temp = head;
        while (temp->next != nullptr) {
            temp = temp->next;
        }
        temp->next = new Node(data);
    }

    void printList() {
        Node* temp = head;
        while (temp != nullptr) {
            std::cout << temp->data << " -> ";
            temp = temp->next;
        }
        std::cout << "nullptr" << std::endl;
    }

    Node* reverseList(Node* node) {
        // Base case: if head is empty or has reached the list end
        if (node == nullptr || node->next == nullptr) {
            return node;
        }

        // Recursively reverse the rest of the list
        Node* newHead = reverseList(node->next);

        // Adjust the next pointers
        node->next->next = node;
        node->next = nullptr;

        return newHead;
    }

    void reverse() {
        head = reverseList(head);
    }
};

int main() {
    LinkedList list;
    list.append(1);
    list.append(2);
    list.append(3);
    list.append(4);
    list.append(5);

    std::cout << "Original List: ";
    list.printList();

    list.reverse();

    std::cout << "Reversed List: ";
    list.printList();

    return 0;
}
```

#### Explanation of the Code

1. **Node Structure**: The `Node` structure holds the data and a pointer to the next node.

2. **LinkedList Class**:
    * `append(int data)`: Adds a new node with the given data at the end of the list.
    * `printList()`: Prints the linked list.
    * `reverseList(Node* node)`: Recursively reverses the linked list starting from the given node.
    * `reverse()`: A wrapper function that calls `reverseList` starting from the head of the list.

3. **Main Function**:
    * Creates a linked list and appends some nodes.
    * Prints the original list.
    * Calls the `reverse` function to reverse the list.
    * Prints the reversed list.

This approach leverages recursion to reverse the linked list by reversing the smaller sublists until the entire list is reversed. The use of recursion simplifies the code by handling the state through recursive calls rather than explicit loops and stack management.

#### Time Complexity

The time complexity of the recursive approach to reverse a linked list is \( O(n) \), where \( n \) is the number of nodes in the linked list. This is because:

1. **Traversal**: Each node is visited exactly once. During the recursion, we traverse each node from the head to the last node.
2. **Link Adjustments**: Each node has its link adjusted exactly once.

Thus, the total number of operations is proportional to the number of nodes, leading to a time complexity of \( O(n) \).

#### Space Complexity

The space complexity of this approach is \( O(n) \) due to the recursion stack. Here’s why:

1. **Recursive Calls**: For each node in the list, a recursive call is made. This results in a call stack that grows linearly with the number of nodes.
2. **Stack Frames**: Each recursive call consumes a stack frame. Since the maximum depth of the recursion is \( n \), the total space used by the recursion stack is \( O(n) \).

#### Summary

* **Time Complexity**: \( O(n) \)
* **Space Complexity**: \( O(n) \)

This space complexity is a key characteristic of the recursive approach, as it uses additional space on the call stack. In contrast, an iterative approach to reverse the linked list would have a space complexity of \( O(1) \), as it doesn't require additional stack frames.

### 1. Algorithms & Data Structures (C++): Linked List: Reversing a Linked List : Iterative Approach

Reversing a linked list is a common problem that can be solved using an iterative approach. Below is a step-by-step explanation and implementation of how to reverse a singly linked list in C++.

#### Steps to Reverse a Linked List Iteratively

1. **Initialize Pointers**: You need three pointers to keep track of nodes during the reversal process.
   * `prev` to store the previous node, initialized to `nullptr`.
   * `current` to store the current node, initialized to the head of the list.
   * `next` to store the next node, initialized to `nullptr`.

2. **Iterate Through the List**: Loop through the list until `current` becomes `nullptr`.
   * Inside the loop, perform the following steps:
     1. Save the next node: `next = current->next`.
     2. Reverse the link: `current->next = prev`.
     3. Move `prev` and `current` one step forward:
        * `prev = current`
        * `current = next`

3. **Update Head**: After the loop, `prev` will be pointing to the new head of the reversed list. Update the head of the list to `prev`.

#### Implementation in C++

Here's how you can implement this:

```cpp
#include <iostream>

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

class LinkedList {
public:
    // Function to reverse the linked list
    ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr;
        ListNode* current = head;
        ListNode* next = nullptr;

        while (current != nullptr) {
            // Save the next node
            next = current->next;
            // Reverse the link
            current->next = prev;
            // Move forward in the list
            prev = current;
            current = next;
        }

        // Update head to the new front of the list
        return prev;
    }

    // Function to print the linked list
    void printList(ListNode* head) {
        ListNode* temp = head;
        while (temp != nullptr) {
            std::cout << temp->val << " ";
            temp = temp->next;
        }
        std::cout << std::endl;
    }
};

int main() {
    // Create a sample list: 1 -> 2 -> 3 -> 4 -> 5
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);

    LinkedList ll;
    std::cout << "Original List: ";
    ll.printList(head);

    head = ll.reverseList(head);

    std::cout << "Reversed List: ";
    ll.printList(head);

    // Clean up the memory
    ListNode* current = head;
    while (current != nullptr) {
        ListNode* next = current->next;
        delete current;
        current = next;
    }

    return 0;
}
```

#### Explanation

1. **ListNode Struct**: Defines the structure of a node in the linked list.
2. **LinkedList Class**: Contains the `reverseList` method which performs the iterative reversal of the list and a `printList` method to print the list.
3. **reverseList Function**:
   * `prev`, `current`, and `next` pointers are used for the reversal.
   * The while loop continues until `current` becomes `nullptr`.
   * In each iteration, the link of the `current` node is reversed, and the pointers are updated to move forward.
4. **printList Function**: Iterates through the list and prints each node's value.
5. **main Function**: Demonstrates the creation of a linked list, reversing it, and then printing both the original and reversed lists. It also ensures that the dynamically allocated memory is freed at the end.

This code provides a complete example of how to reverse a singly linked list using an iterative approach in C++.

#### Time Complexity

1. **Traversal**: The algorithm iterates through each node of the linked list exactly once. Therefore, the time complexity for traversal is O(n), where n is the number of nodes in the linked list.
2. **Reversal**: Within the traversal, for each node, the algorithm performs constant-time operations like updating pointers. Hence, the time complexity for reversal is also O(n).

Thus, the overall time complexity of the iterative approach to reverse a linked list is O(n).

#### Space Complexity

The iterative approach doesn't use any additional data structures proportional to the size of the input. It only requires a constant amount of extra space for storing pointers. So, the space complexity is O(1), indicating that it's constant space complexity regardless of the size of the linked list.

In summary, the time complexity is O(n) and the space complexity is O(1) for the iterative approach to reverse a linked list.

### 1. Algorithms & Data Structures (C++): Linked List: M, N Reversals

Reversing parts of a linked list, sometimes referred to as "M, N reversals," involves dividing the list into segments of length M and reversing each segment separately. This process is then repeated for segments of length N, until the end of the list is reached. Here's a C++ implementation to achieve this:

```cpp
#include <iostream>

using namespace std;

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        if (head == nullptr || m >= n) return head;

        // Dummy node to simplify edge cases
        ListNode *dummy = new ListNode(0);
        dummy->next = head;
        ListNode *prev = dummy;

        // Move prev to the node before the segment to reverse
        for (int i = 0; i < m - 1; ++i) {
            if (prev == nullptr) return head;
            prev = prev->next;
        }

        // Initialize pointers for reversing the segment
        ListNode *start = prev->next;
        ListNode *then = start->next;

        // Reverse the segment
        for (int i = 0; i < n - m; ++i) {
            if (then == nullptr) break;
            start->next = then->next;
            then->next = prev->next;
            prev->next = then;
            then = start->next;
        }

        return dummy->next;
    }
};

// Utility function to print the linked list
void printList(ListNode *head) {
    while (head != nullptr) {
        cout << head->val << " ";
        head = head->next;
    }
    cout << endl;
}

int main() {
    // Example usage
    ListNode *head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);

    cout << "Original list: ";
    printList(head);

    Solution sol;
    int m = 2, n = 4;
    head = sol.reverseBetween(head, m, n);

    cout << "List after reversing from position " << m << " to " << n << ": ";
    printList(head);

    return 0;
}
```

In this implementation:

* We iterate through the list to find the node before the segment to be reversed.
* Then, we reverse the segment of the list defined by the indices `m` and `n`.
* We update the pointers accordingly to perform the reversal.
* Finally, we return the modified list.

You can customize `m` and `n` in the `main` function to reverse different segments of the list.

### 1. Algorithms & Data Structures (C++): K-Reverse a Linked List

Certainly! Reversing a linked list in groups of K is a common problem in data structures. Here's how you can implement it in C++:

```cpp
#include <iostream>

using namespace std;

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

ListNode* reverseKGroup(ListNode* head, int k) {
    ListNode* curr = head;
    int count = 0;
    while (curr != nullptr && count < k) {
        curr = curr->next;
        count++;
    }
    if (count == k) {
        // Reverse the first K nodes of the linked list
        curr = reverseKGroup(curr, k);
        while (count-- > 0) {
            ListNode* temp = head->next;
            head->next = curr;
            curr = head;
            head = temp;
        }
        head = curr;
    }
    return head;
}

// Utility function to print the linked list
void printList(ListNode* node) {
    while (node != nullptr) {
        cout << node->val << " ";
        node = node->next;
    }
    cout << endl;
}

int main() {
    // Create a linked list: 1->2->3->4->5->6->7->8->9
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);
    head->next->next->next->next->next = new ListNode(6);
    head->next->next->next->next->next->next = new ListNode(7);
    head->next->next->next->next->next->next->next = new ListNode(8);
    head->next->next->next->next->next->next->next->next = new ListNode(9);

    int k = 3; // K value for reversing

    cout << "Original Linked List: ";
    printList(head);

    head = reverseKGroup(head, k);

    cout << "Reversed Linked List in groups of " << k << ": ";
    printList(head);

    return 0;
}
```

This code defines a `ListNode` struct for creating a singly-linked list and implements the `reverseKGroup` function to reverse the list in groups of size K. The `main` function demonstrates its usage by creating a linked list and then reversing it in groups of 3.

### 1. Algorithms & Data Structures (C++): Linked List: Reverse Between

Certainly! Implementing a function to reverse a linked list between two specified positions involves a few steps:

1. Traverse the list to reach the node just before the starting position.
2. Reverse the sublist between the given positions.
3. Update the pointers of the surrounding nodes to maintain the integrity of the list.

Here's a C++ implementation:

```cpp
#include <iostream>

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

ListNode* reverseBetween(ListNode* head, int m, int n) {
    if (head == nullptr || m == n) return head;

    ListNode* dummy = new ListNode(0);
    dummy->next = head;
    ListNode* preStart = dummy;

    // Move preStart to the node just before the sublist to be reversed
    for (int i = 0; i < m - 1; ++i)
        preStart = preStart->next;

    ListNode* start = preStart->next;
    ListNode* then = start->next;

    // Reverse the sublist from m to n
    for (int i = 0; i < n - m; ++i) {
        start->next = then->next;
        then->next = preStart->next;
        preStart->next = then;
        then = start->next;
    }

    return dummy->next;
}

void printList(ListNode* head) {
    while (head != nullptr) {
        std::cout << head->val << " ";
        head = head->next;
    }
    std::cout << std::endl;
}

int main() {
    // Example usage
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);

    std::cout << "Original list: ";
    printList(head);

    int m = 2, n = 4;
    head = reverseBetween(head, m, n);

    std::cout << "List after reversing from position " << m << " to " << n << ": ";
    printList(head);

    return 0;
}
```

This code snippet demonstrates the implementation of the `reverseBetween` function, which takes a linked list `head` and two integers `m` and `n` representing the positions to reverse between. It returns the head of the modified list after reversing the sublist between positions `m` and `n`.

## Interview qustions

### 1. Algorithms & Data Structures (C++): Linked Lists: From Last

In C++, to find the kth element from the end of a singly linked list efficiently, you can use a two-pointer technique. Here's a simple approach:

1. Maintain two pointers, let's call them `fast` and `slow`, initialized to the head of the linked list.
2. Move the `fast` pointer k steps ahead.
3. Then move both `fast` and `slow` pointers simultaneously until `fast` reaches the end of the list.
4. At this point, `slow` will be pointing to the kth element from the end.

Here's how you can implement it:

```cpp
#include <iostream>

using namespace std;

// Node structure
struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

// Function to find the kth element from the end of a linked list
Node* kthFromEnd(Node* head, int k) {
    if (head == nullptr || k <= 0) return nullptr;

    Node* fast = head;
    Node* slow = head;

    // Move fast k steps ahead
    for (int i = 0; i < k; ++i) {
        if (fast == nullptr) return nullptr; // If k is greater than the length of the list
        fast = fast->next;
    }

    // Move both fast and slow pointers simultaneously until fast reaches the end
    while (fast != nullptr) {
        fast = fast->next;
        slow = slow->next;
    }

    return slow;
}

// Function to print the linked list
void printList(Node* head) {
    while (head != nullptr) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

int main() {
    // Creating a sample linked list: 1 -> 2 -> 3 -> 4 -> 5
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);
    head->next->next->next->next = new Node(5);

    cout << "Original linked list: ";
    printList(head);

    int k = 2;
    Node* kth = kthFromEnd(head, k);
    if (kth != nullptr) {
        cout << "The " << k << "th element from the end is: " << kth->data << endl;
    } else {
        cout << "The linked list is too short or invalid value of k." << endl;
    }

    return 0;
}
```

In this example, `k` is set to 2, so it will find the second element from the end of the linked list. You can adjust `k` to find any kth element from the end.

## Merge Sorted

### 1. Algorithms & Data Structures (C++): Merge Sorted Linked Lists

Certainly! Merging two sorted linked lists in C++ involves creating a new sorted list by iterating through both input lists simultaneously, comparing elements, and appending the smaller one to the new list. Here's an implementation:

```cpp
#include <iostream>

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        // Dummy node for the result list
        ListNode* dummy = new ListNode(0);
        ListNode* current = dummy;

        // Merge the lists until one of them is exhausted
        while (l1 != nullptr && l2 != nullptr) {
            if (l1->val < l2->val) {
                current->next = l1;
                l1 = l1->next;
            } else {
                current->next = l2;
                l2 = l2->next;
            }
            current = current->next;
        }

        // Append the remaining nodes of the non-empty list
        current->next = (l1 != nullptr) ? l1 : l2;

        // Store the head of the merged list
        ListNode* result = dummy->next;

        // Clean up dummy node
        delete dummy;

        return result;
    }
};

// Helper function to print a linked list
void printList(ListNode* head) {
    while (head != nullptr) {
        std::cout << head->val << " ";
        head = head->next;
    }
    std::cout << std::endl;
}

int main() {
    // Create two sorted linked lists
    ListNode* l1 = new ListNode(1);
    l1->next = new ListNode(3);
    l1->next->next = new ListNode(5);

    ListNode* l2 = new ListNode(2);
    l2->next = new ListNode(4);
    l2->next->next = new ListNode(6);

    // Merge the lists
    Solution solution;
    ListNode* mergedList = solution.mergeTwoLists(l1, l2);

    // Print the merged list
    std::cout << "Merged List: ";
    printList(mergedList);

    // Clean up memory
    while (mergedList != nullptr) {
        ListNode* temp = mergedList;
        mergedList = mergedList->next;
        delete temp;
    }

    return 0;
}
```

This code creates two sorted linked lists `l1` and `l2`, merges them using the `mergeTwoLists` function, and then prints the merged list. Finally, it deallocates the memory allocated for the linked lists.

### 1. Algorithms & Data Structures (C++): Linked List: Alternate Merge

To merge two linked lists alternately in C++, you'll need to iterate through both lists, taking one element from each list alternately and appending it to the result list. If one list is longer than the other, append the remaining elements of the longer list to the result list.

Here's a basic implementation:

```cpp
#include <iostream>

using namespace std;

// Node structure for a linked list
struct Node {
    int data;
    Node* next;
    
    Node(int val) : data(val), next(nullptr) {}
};

// Function to insert a new node at the end of a linked list
void insert(Node*& head, int val) {
    Node* newNode = new Node(val);
    if (!head) {
        head = newNode;
        return;
    }
    Node* temp = head;
    while (temp->next) {
        temp = temp->next;
    }
    temp->next = newNode;
}

// Function to merge two linked lists alternately
Node* alternateMerge(Node* head1, Node* head2) {
    if (!head1) return head2;
    if (!head2) return head1;
    
    Node* merged = nullptr;
    Node* tail = nullptr;
    while (head1 && head2) {
        if (!merged) {
            merged = head1;
            tail = merged;
            head1 = head1->next;
        } else {
            tail->next = head2;
            tail = tail->next;
            head2 = head2->next;
            tail->next = head1;
            tail = tail->next;
            head1 = head1->next;
        }
    }
    
    if (head1) tail->next = head1;
    if (head2) tail->next = head2;
    
    return merged;
}

// Function to print a linked list
void printList(Node* head) {
    while (head) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

int main() {
    Node* head1 = nullptr;
    Node* head2 = nullptr;
    
    // Insert elements into the first linked list
    insert(head1, 1);
    insert(head1, 3);
    insert(head1, 5);
    
    // Insert elements into the second linked list
    insert(head2, 2);
    insert(head2, 4);
    insert(head2, 6);
    insert(head2, 8);
    
    cout << "First List: ";
    printList(head1);
    cout << "Second List: ";
    printList(head2);
    
    Node* merged = alternateMerge(head1, head2);
    
    cout << "Merged List: ";
    printList(merged);
    
    return 0;
}
```

In this implementation, `alternateMerge` takes two linked lists as input and returns a new linked list that contains elements alternately merged from both input lists. The `printList` function is just a utility function to print the contents of a linked list.

## Middle point

### 1. Algorithms & Data Structures (C++): Linked List: Find Middle Node

To find the middle node of a linked list in C++, you can use the slow and fast pointer technique. Here's how it works:

1. Initialize two pointers, `slow` and `fast`, both pointing to the head of the linked list.
2. Move the `fast` pointer twice as fast as the `slow` pointer. When the `fast` pointer reaches the end of the list, the `slow` pointer will be at the middle node.
3. Return the node pointed to by the `slow` pointer.

Here's a sample implementation:

```cpp
#include <iostream>

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

ListNode* findMiddleNode(ListNode* head) {
    if (head == nullptr)
        return nullptr;

    ListNode* slow = head;
    ListNode* fast = head;

    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
    }

    return slow;
}

int main() {
    // Example usage
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);

    ListNode* middleNode = findMiddleNode(head);
    if (middleNode != nullptr)
        std::cout << "Middle Node: " << middleNode->val << std::endl;
    else
        std::cout << "List is empty." << std::endl;

    return 0;
}
```

In this example, the `findMiddleNode` function returns the middle node of the linked list. You can adjust the logic according to your specific requirements.

### 1. Algorithms & Data Structures (C++): Linked List: Middle Node of List - Slow and Fast Pointer Approach

In C++, finding the middle node of a linked list using the slow and fast pointer approach is a common algorithmic technique. This approach involves using two pointers: one that moves one node at a time (slow pointer) and another that moves two nodes at a time (fast pointer). By the time the fast pointer reaches the end of the list, the slow pointer will be at the middle node.

Here's the implementation:

```cpp
#include <iostream>

// Define the structure for a node in the linked list
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

// Function to find the middle node of a linked list
ListNode* middleNode(ListNode* head) {
    if (head == nullptr || head->next == nullptr) {
        return head;
    }

    ListNode *slow = head;
    ListNode *fast = head;

    // Move the fast pointer two nodes at a time and the slow pointer one node at a time
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
    }

    // At this point, slow pointer is at the middle node
    return slow;
}

// Utility function to print the linked list
void printList(ListNode *head) {
    while (head != nullptr) {
        std::cout << head->val << " ";
        head = head->next;
    }
    std::cout << std::endl;
}

int main() {
    // Example usage
    ListNode *head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);

    std::cout << "Original List: ";
    printList(head);

    ListNode *middle = middleNode(head);
    std::cout << "Middle Node: " << middle->val << std::endl;

    return 0;
}
```

This code defines a simple linked list structure, implements the `middleNode` function using the slow and fast pointer approach, and provides a `printList` function to print the elements of the linked list for demonstration purposes. Finally, it demonstrates the usage of the `middleNode` function in the `main` function with an example linked list.

### 1. Algorithms & Data Structures (C++): Exercise: Find Middle Of The Linked List

To find the middle of a linked list, you can use the slow and fast pointer technique. Here's how it works:

1. Initialize two pointers, slow and fast, both pointing to the head of the linked list.
2. Move the fast pointer twice as fast as the slow pointer. When the fast pointer reaches the end of the list, the slow pointer will be at the middle.
3. Return the node pointed to by the slow pointer.

Here's the C++ code for the function:

```cpp
#include <iostream>

// Define the structure of a node in the linked list
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

ListNode* findMiddle(ListNode* head) {
    if (head == nullptr || head->next == nullptr) {
        return head; // Empty list or single node
    }

    ListNode* slow = head;
    ListNode* fast = head;

    // Move slow pointer by one and fast pointer by two
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
    }

    // Now slow points to the middle node
    return slow;
}

// Function to print the elements of the linked list
void printList(ListNode* head) {
    while (head != nullptr) {
        std::cout << head->val << " ";
        head = head->next;
    }
    std::cout << std::endl;
}

// Test the findMiddle function
int main() {
    // Create a sample linked list: 1->2->3->4->5
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);

    std::cout << "Original List: ";
    printList(head);

    ListNode* middle = findMiddle(head);
    std::cout << "Middle Element: " << middle->val << std::endl;

    return 0;
}
```

This code defines a linked list node structure, implements the findMiddle function, and provides a main function to test the findMiddle function with a sample linked list.

### 1. Algorithms & Data Structures (C++): Singly Linked Lists: Sentinels

Using sentinels in singly linked lists can simplify certain operations and edge cases. Sentinels are special nodes that do not hold any actual data but are used as placeholders at the beginning and/or end of the list. They provide several advantages:

1. **Simplifying edge cases**: Sentinels eliminate the need to handle special cases for an empty list or operations at the beginning or end of the list.

2. **Uniform operations**: With sentinels, all operations (insertion, deletion, traversal) can be performed uniformly throughout the list without extra conditionals to check for special cases.

Here's a basic implementation of a singly linked list with sentinels in C++:

```cpp
#include <iostream>

template<typename T>
class Node {
public:
    T data;
    Node* next;
    Node(T data) : data(data), next(nullptr) {}
};

template<typename T>
class SinglyLinkedList {
private:
    Node<T>* head;
    Node<T>* tail;

public:
    SinglyLinkedList() {
        // Create sentinel nodes
        head = new Node<T>(T());
        tail = new Node<T>(T());
        head->next = tail;
    }

    ~SinglyLinkedList() {
        Node<T>* current = head;
        while (current) {
            Node<T>* next = current->next;
            delete current;
            current = next;
        }
    }

    // Insert at the end of the list
    void insert(T data) {
        Node<T>* newNode = new Node<T>(data);
        newNode->next = tail;
        Node<T>* current = head;
        while (current->next != tail) {
            current = current->next;
        }
        current->next = newNode;
    }

    // Display the list
    void display() {
        Node<T>* current = head->next;
        while (current != tail) {
  
            std::cout << current->data << " ";
            current = current->next;
        }
        std::cout << std::endl;
    }
};

int main() {
    SinglyLinkedList<int> list;
    list.insert(1);
    list.insert(2);
    list.insert(3);
    list.display(); // Output: 1 2 3
    return 0;
}
```

In this implementation, `head` points to the sentinel node before the first actual node, and `tail` points to the sentinel node after the last actual node. This way, even if the list is empty, `head` and `tail` will always exist, simplifying operations.

### 1. Algorithms & Data Structures (C++): Loop removal in Singly Linked Lists: Floyd's Algorithm Explained

Floyd's Algorithm, also known as the Tortoise and Hare algorithm, is a popular technique used for various tasks in linked lists, including loop detection and removal. Let's delve into how it works and how it can be applied to detect and remove loops in a singly linked list using C++.

**1. Loop Detection using Floyd's Algorithm:**

In Floyd's Algorithm, we use two pointers, often referred to as the "slow" and "fast" pointers. The slow pointer moves one step at a time, while the fast pointer moves two steps at a time. If there is a loop in the linked list, these pointers will eventually meet.

Here's how it works in code:

```cpp
bool detectLoop(Node* head) {
    Node* slow = head;
    Node* fast = head;
    
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
        
        // If they meet, it means there's a loop
        if (slow == fast)
            return true;
    }
    
    // If fast reaches the end, no loop exists
    return false;
}
```

**2. Removing the Loop:**

Once we've detected the loop, we need to find the starting point of the loop. Afterward, we can simply set the next pointer of the last node in the loop to null to break the loop.

Here's how it can be implemented:

```cpp
void removeLoop(Node* head) {
    Node* slow = head;
    Node* fast = head;

    // Detect the loop and find the meeting point
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast)
            break;
    }

    // If no loop exists, simply return
    if (fast == nullptr || fast->next == nullptr)
        return;

    // Move slow to the beginning of the list, keeping fast at the meeting point
    slow = head;
    while (slow->next != fast->next) {
        slow = slow->next;
        fast = fast->next;
    }

    // Set the next pointer of the last node in the loop to null
    fast->next = nullptr;
}
```

**3. Example:**

Let's illustrate this with an example:

```bash
1 -> 2 -> 3 -> 4 -> 5 -> 6
          ^         |    |
          |_________|____|
```

In this list, nodes 5 and 6 create a loop. After detecting the loop, we can set the next pointer of node 6 to null to remove the loop:

```bash
1 -> 2 -> 3 -> 4 -> 5 -> 6
```

This code effectively removes the loop from the linked list while preserving the rest of the list's structure. Floyd's Algorithm provides a simple and efficient way to both detect and remove loops in linked lists.

### 1. Algorithms & Data Structures (C++): Loop removal in Singly Linked Lists: Floyd's Algorithm Implemented

Sure, I can guide you through implementing Floyd's algorithm for loop detection and removal in a singly linked list in C++. Floyd's algorithm, also known as the Tortoise and Hare algorithm, is a two-pointer technique used to detect cycles in a linked list.

Here's a step-by-step explanation of how you can implement it:

1. **Node Definition**: Define the structure for a node in the linked list.

2. **Loop Detection**: Implement Floyd's algorithm to detect if there's a loop in the linked list. This involves using two pointers - one slow pointer that moves one step at a time and a fast pointer that moves two steps at a time. If there's a loop, these pointers will meet at some point.

3. **Loop Removal**: After detecting the loop, find the start of the loop. This can be done by moving one pointer to the head of the list and then moving both pointers (slow and fast) one step at a time until they meet again. The meeting point will be the start of the loop. Then, break the loop by setting the next pointer of the node before the start of the loop to null.

Here's a sample implementation in C++:

```cpp
#include <iostream>

using namespace std;

// Node definition
struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

// Function to detect and remove loop
void detectAndRemoveLoop(Node* head) {
    if (head == nullptr || head->next == nullptr)
        return;

    Node* slow = head;
    Node* fast = head;

    // Detect loop
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;

        if (slow == fast)
            break;
    }

    // If loop exists, find the start of the loop
    if (slow == fast) {
        slow = head;
        while (slow->next != fast->next) {
            slow = slow->next;
            fast = fast->next;
        }

        // Break the loop
        fast->next = nullptr;
    }
}

// Function to print the linked list
void printList(Node* node) {
    while (node != nullptr) {
        cout << node->data << " ";
        node = node->next;
    }
    cout << endl;
}

int main() {
    // Creating a linked list with a loop
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);
    head->next->next->next->next = new Node(5);

    // Creating a loop for testing
    head->next->next->next->next->next = head->next->next;

    // Detect and remove loop
    detectAndRemoveLoop(head);

    // Print the linked list
    cout << "Linked List after removing loop: ";
    printList(head);

    return 0;
}
```

This code will create a linked list with a loop, detect the loop using Floyd's algorithm, and then remove the loop if it exists. Finally, it will print the linked list after loop removal.

### 1. Algorithms & Data Structures (C++): Singly Linked List - Rotate

Sure, I can help you with that! Rotating a singly linked list involves shifting its elements to the right or left by a certain number of positions. Here's a C++ implementation for rotating a singly linked list:

```cpp
#include <iostream>

// Definition for singly-linked list node
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

// Function to print the linked list
void printList(ListNode *head) {
    ListNode *curr = head;
    while (curr) {
        std::cout << curr->val << " ";
        curr = curr->next;
    }
    std::cout << std::endl;
}

// Function to rotate a singly linked list to the right by k positions
ListNode* rotateRight(ListNode* head, int k) {
    if (!head || k == 0) return head;

    // Find the length of the list and locate the new head
    int len = 1;
    ListNode *tail = head;
    while (tail->next) {
        tail = tail->next;
        len++;
    }
    k = k % len; // Adjust k if it's greater than the length of the list
    if (k == 0) return head; // No rotation needed

    // Move the tail to the (n-k)th node
    ListNode *newTail = head;
    for (int i = 1; i < len - k; ++i) {
        newTail = newTail->next;
    }

    // Adjust pointers to rotate the list
    tail->next = head;
    head = newTail->next;
    newTail->next = nullptr;

    return head;
}

// Test
int main() {
    // Create a sample linked list: 1 -> 2 -> 3 -> 4 -> 5
    ListNode *head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);

    std::cout << "Original list: ";
    printList(head);

    int k = 2; // Rotate right by 2 positions
    head = rotateRight(head, k);

    std::cout << "Rotated list: ";
    printList(head);

    return 0;
}
```

This code defines a `ListNode` struct for the nodes of the singly linked list and provides a function `rotateRight` to rotate the list to the right by `k` positions. The `printList` function is used to print the list for demonstration purposes. Finally, the `main` function demonstrates how to use the `rotateRight` function with a sample linked list.

### Linked list C++

Certainly! Here's a basic implementation of a singly linked list in C++:

```cpp
#include <iostream>

template <typename T>
class Node {
public:
    T data;
    Node<T>* next;

    Node(T val) : data(val), next(nullptr) {}
};

template <typename T>
class LinkedList {
private:
    Node<T>* head;
public:
    LinkedList() : head(nullptr) {}

    void insert(T val) {
        Node<T>* newNode = new Node<T>(val);
        if (!head) {
            head = newNode;
        } else {
            Node<T>* temp = head;
            while (temp->next) {
                temp = temp->next;
            }
            temp->next = newNode;
        }
    }

    void display() {
        Node<T>* temp = head;
        while (temp) {
            std::cout << temp->data << " -> ";
            temp = temp->next;
        }
        std::cout << "nullptr" << std::endl;
    }

    ~LinkedList() {
        Node<T>* temp;
        while (head) {
            temp = head;
            head = head->next;
            delete temp;
        }
    }
};

int main() {
    LinkedList<int> list;
    list.insert(1);
    list.insert(2);
    list.insert(3);
    list.display();

    return 0;
}
```

This code defines a simple singly linked list with basic operations like insertion and display. You can create a linked list object, insert elements into it, and display the elements. The implementation includes a `Node` class representing individual nodes in the list and a `LinkedList` class for managing the list as a whole.

### 1. Algorithms & Data Structures (C++): Arrays vs Linked List

When comparing arrays and linked lists in the context of algorithms and data structures, each has its own strengths and weaknesses. Let's delve into the comparison:

1. **Memory Allocation**:
    * Arrays: Contiguous memory allocation. Once the size is defined, it's fixed.
    * Linked Lists: Dynamic memory allocation. Nodes are scattered in memory and connected via pointers.

2. **Insertion and Deletion**:
    * Arrays: Insertions and deletions can be inefficient, especially in the middle, as it may require shifting elements.
    * Linked Lists: Efficient for insertions and deletions, especially at the beginning or end, as it involves adjusting pointers.

3. **Access Time**:
    * Arrays: O(1) constant time access if the index is known.
    * Linked Lists: O(n) time for accessing an element, as you need to traverse the list from the head or tail.

4. **Memory Overhead**:
    * Arrays: Typically more memory efficient due to minimal overhead.
    * Linked Lists: Additional memory overhead due to storing pointers for each element.

5. **Size Flexibility**:
    * Arrays: Fixed size unless resized, which may be inefficient.
    * Linked Lists: Dynamic size; can grow or shrink easily without much overhead.

6. **Cache Efficiency**:
    * Arrays: Better cache locality, as elements are stored contiguously.
    * Linked Lists: Poor cache locality, as nodes are scattered in memory.

7. **Implementation Complexity**:
    * Arrays: Simpler implementation and easier to understand.
    * Linked Lists: More complex due to managing pointers and dynamic memory allocation.

8. **Usage**:
    * Arrays: Suitable for random access and when the size is known and won't change frequently.
    * Linked Lists: Ideal for scenarios where frequent insertions and deletions are expected, or when the size is not known beforehand.

Choosing between arrays and linked lists depends on the specific requirements of the problem you're solving. If fast random access is crucial and memory is not a concern, arrays might be preferable. Conversely, if dynamic size and efficient insertions/deletions are more important, linked lists might be the better choice. In some cases, hybrid data structures like dynamic arrays (e.g., `std::vector` in C++) offer a compromise between the two.

### 1. Algorithms & Data Structures (C++): Comparison of Array with Linked List

Certainly! Comparing arrays and linked lists in terms of algorithms and data structures can help in understanding their strengths and weaknesses. Let's break down the comparison:

1. **Memory Representation**:
   * **Array**: Contiguous block of memory where elements are stored consecutively. Accessing elements is efficient using indexing.
   * **Linked List**: Elements are stored in nodes, where each node contains the data and a pointer/reference to the next node. Memory allocation for nodes may not be contiguous, allowing dynamic allocation and flexibility.

2. **Insertion and Deletion**:
   * **Array**: Insertion and deletion operations may require shifting elements to accommodate changes in size. Insertion or deletion at the beginning or middle of the array can be inefficient due to the need for shifting.
   * **Linked List**: Insertion and deletion can be efficient, especially for singly linked lists, as it only requires updating pointers. Deletion can be done in constant time if the node to be deleted is given. However, locating the node may require linear time traversal in the worst case.

3. **Access Time**:
   * **Array**: Accessing elements by index is constant time (O(1)) since arrays provide direct access to memory locations.
   * **Linked List**: Accessing elements by index requires traversing the list from the head (for singly linked list) or tail (for doubly linked list), which is O(n) time complexity in the worst case.

4. **Memory Overhead**:
   * **Array**: Generally has lower memory overhead as it only needs to store the elements and, in some cases, the length of the array.
   * **Linked List**: Requires additional memory for storing pointers/references to the next node, resulting in higher memory overhead per element.

5. **Dynamic Size**:
   * **Array**: In many programming languages, the size of an array is fixed at compile time. Resizing may involve creating a new array and copying elements, which can be inefficient.
   * **Linked List**: Can dynamically grow or shrink without the need for reallocation, making it more flexible for dynamic data structures.

6. **Cache Locality**:
   * **Array**: Provides better cache locality since elements are stored contiguously, leading to better performance in situations where accessing nearby elements is common.
   * **Linked List**: Poor cache locality due to scattered memory locations of nodes, which can lead to more cache misses, especially in large lists.

7. **Traversal**:
   * **Array**: Traversal is straightforward using loops since elements are contiguous in memory.
   * **Linked List**: Traversal requires following pointers from one node to another, which introduces additional overhead compared to array traversal.

In summary, arrays are preferable when random access and efficient traversal are required, especially for small to medium-sized collections with a known fixed size. On the other hand, linked lists are better suited for scenarios where frequent insertion/deletion operations are expected or when the size of the collection is dynamic and unpredictable.
