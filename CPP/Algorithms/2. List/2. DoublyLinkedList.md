### 1. Algorithms & Data Structures (C++): Doubly Linked List

A doubly linked list is a data structure that consists of a sequence of elements, called nodes, where each node stores a reference to the previous and next nodes in the sequence. This allows for efficient insertion, deletion, and traversal operations compared to other data structures like arrays, especially when elements need to be added or removed frequently from the middle of the list.

A doubly linked list is a data structure consisting of a sequence of elements, where each element contains a reference (or pointer) to the previous and the next elements in the sequence. Here's a breakdown of the time and space complexities associated with common operations on a doubly linked list implemented in C++:

1. **Time Complexities:**

* **Access/Search (by index):** O(n)
  * Accessing or searching for an element by index requires traversing the list from either the head or the tail, which takes linear time.

* **Insertion (at beginning or end):** O(1)
  * Inserting an element at either end (head or tail) of the list can be done in constant time since we have direct access to these points.

* **Insertion (at arbitrary position):** O(n)
  * Inserting an element at an arbitrary position requires traversing the list to find the insertion point, which takes linear time in the worst case.

* **Deletion (at beginning or end):** O(1)
  * Deleting an element from either end (head or tail) of the list can be done in constant time since we have direct access to these points.

* **Deletion (at arbitrary position):** O(n)
  * Deleting an element from an arbitrary position requires traversing the list to find the deletion point, which takes linear time in the worst case.

1. **Space Complexity:**

* **Space Complexity for elements:** O(n)
  * The space complexity for the elements themselves is linear since each element consumes a fixed amount of memory.

* **Space Complexity for pointers:** O(n)
  * In addition to the elements themselves, the pointers (previous and next) associated with each element also consume space, contributing to the linear space complexity.

In summary, doubly linked lists offer efficient insertion and deletion at the beginning and end of the list but require linear time for operations involving traversal or manipulation at arbitrary positions. Additionally, the space complexity is linear due to both the elements and the pointers associated with them.

### 1. Algorithms & Data Structures (C++): Doubly-Linked List (Theory)

A doubly-linked list is a data structure that consists of a sequence of elements, called nodes, where each node contains a piece of data and two pointers/references to the previous and next nodes in the sequence. Unlike a singly-linked list, which only has a reference to the next node, a doubly-linked list allows traversal in both forward and backward directions.

Here's a theoretical overview of the main components and operations associated with a doubly-linked list in C++:

#### Node Structure

In C++, a node in a doubly-linked list can be defined using a structure or a class. Each node typically contains the following components:

```cpp
struct Node {
    int data;            // Data stored in the node
    Node* prev;          // Pointer to the previous node
    Node* next;          // Pointer to the next node
};
```

#### Operations

1. **Insertion**:
   * **Insertion at the Beginning**: Insert a new node at the beginning of the list.
   * **Insertion at the End**: Insert a new node at the end of the list.
   * **Insertion at a Given Position**: Insert a new node at a specific position in the list.

2. **Deletion**:
   * **Deletion from the Beginning**: Remove the first node from the list.
   * **Deletion from the End**: Remove the last node from the list.
   * **Deletion from a Given Position**: Remove a node from a specific position in the list.

3. **Traversal**: Traverse the list from the beginning to the end or from the end to the beginning.

4. **Searching**: Search for a specific element/data within the list.

5. **Updating**: Update the data stored in a specific node.

#### Advantages

* Allows traversal in both forward and backward directions.
* Supports efficient insertion and deletion operations at both ends of the list.

#### Disadvantages

* Requires extra memory for storing the previous pointers, increasing memory overhead compared to singly-linked lists.
* Increased complexity in terms of implementation due to managing both forward and backward pointers.

#### Implementation Notes

* Care must be taken to properly update the pointers when performing insertion and deletion operations to maintain the integrity of the list.
* Special cases such as inserting into an empty list or deleting the only node in the list should be handled appropriately.

In C++, it's common to encapsulate the functionality of a doubly-linked list into a class, providing member functions to perform various operations on the list while abstracting the details of node manipulation.

### 1. Algorithms & Data Structures (C++): Insert for Doubly Linked List

Sure, here's a simple implementation of the `insert` function for a doubly linked list in C++:

```cpp
#include <iostream>

// Node structure for doubly linked list
struct Node {
    int data;
    Node* prev;
    Node* next;
    
    Node(int value) : data(value), prev(nullptr), next(nullptr) {}
};

// Doubly linked list class
class DoublyLinkedList {
private:
    Node* head;
    Node* tail;
    
public:
    DoublyLinkedList() : head(nullptr), tail(nullptr) {}
    
    // Function to insert a node at the beginning of the list
    void insertAtBeginning(int value) {
        Node* newNode = new Node(value);
        if (!head) {
            head = tail = newNode;
        } else {
            newNode->next = head;
            head->prev = newNode;
            head = newNode;
        }
    }
    
    // Function to insert a node at the end of the list
    void insertAtEnd(int value) {
        Node* newNode = new Node(value);
        if (!tail) {
            head = tail = newNode;
        } else {
            newNode->prev = tail;
            tail->next = newNode;
            tail = newNode;
        }
    }
    
    // Function to insert a node after a given node
    void insertAfter(Node* prevNode, int value) {
        if (!prevNode) {
            std::cout << "Previous node cannot be null.\n";
            return;
        }
        Node* newNode = new Node(value);
        newNode->next = prevNode->next;
        newNode->prev = prevNode;
        if (prevNode->next)
            prevNode->next->prev = newNode;
        else
            tail = newNode;
        prevNode->next = newNode;
    }
    
    // Function to print the list
    void printList() {
        Node* temp = head;
        while (temp != nullptr) {
            std::cout << temp->data << " ";
            temp = temp->next;
        }
        std::cout << std::endl;
    }
};

int main() {
    DoublyLinkedList dll;
    dll.insertAtBeginning(1);
    dll.insertAtEnd(3);
    dll.insertAfter(dll.head, 2);
    dll.printList(); // Output: 1 2 3
    return 0;
}
```

This code defines a doubly linked list with three operations: `insertAtBeginning`, `insertAtEnd`, and `insertAfter`. You can use these functions to insert nodes at the beginning, end, or after a specified node in the list.

### 1. Algorithms & Data Structures (C++): Insert in a Doubly Linked List

Certainly! Below is a simple implementation of inserting a node in a doubly linked list in C++:

```cpp
#include <iostream>

// Node structure for a doubly linked list
struct Node {
    int data;
    Node* prev;
    Node* next;
    Node(int value) : data(value), prev(nullptr), next(nullptr) {}
};

// Function to insert a new node at the beginning of a doubly linked list
void insertAtBeginning(Node*& head, int value) {
    Node* newNode = new Node(value);
    if (head == nullptr) {
        head = newNode;
    } else {
        newNode->next = head;
        head->prev = newNode;
        head = newNode;
    }
}

// Function to display the doubly linked list
void displayList(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        std::cout << temp->data << " ";
        temp = temp->next;
    }
    std::cout << std::endl;
}

int main() {
    // Initialize an empty doubly linked list
    Node* head = nullptr;

    // Insert nodes at the beginning
    insertAtBeginning(head, 5);
    insertAtBeginning(head, 10);
    insertAtBeginning(head, 15);

    // Display the doubly linked list
    std::cout << "Doubly linked list: ";
    displayList(head);

    return 0;
}
```

In this implementation, the `insertAtBeginning` function inserts a new node with the given value at the beginning of the doubly linked list. The `displayList` function is used to print the contents of the doubly linked list.

You can extend this code to include other operations like insertion at the end, insertion at a specific position, deletion, etc., depending on your requirements.

### 1. Algorithms & Data Structures (C++): Inserting in Doubly Linked Lists

Inserting elements into a doubly linked list involves updating the pointers of the nodes appropriately to maintain the correct sequence. There are three main cases to consider when inserting a new node:

1. **Inserting at the beginning**: Update the pointers of the new node, the current head, and the old head (if any).
2. **Inserting at the end**: Update the pointers of the new node, the current tail, and the old tail (if any).
3. **Inserting at a specific position (in between)**: Traverse the list to find the appropriate position, then update the pointers of the new node, the node before it, and the node after it.

Here's a basic implementation of a doubly linked list in C++ with insertion functions:

```cpp
#include <iostream>

// Node structure for doubly linked list
struct Node {
    int data;
    Node* prev;
    Node* next;
    
    Node(int value) : data(value), prev(nullptr), next(nullptr) {}
};

class DoublyLinkedList {
private:
    Node* head;
    Node* tail;

public:
    DoublyLinkedList() : head(nullptr), tail(nullptr) {}

    // Function to insert a node at the beginning
    void insertAtBeginning(int value) {
        Node* newNode = new Node(value);
        if (!head) {
            head = newNode;
            tail = newNode;
        } else {
            newNode->next = head;
            head->prev = newNode;
            head = newNode;
        }
    }

    // Function to insert a node at the end
    void insertAtEnd(int value) {
        Node* newNode = new Node(value);
        if (!tail) {
            head = newNode;
            tail = newNode;
        } else {
            newNode->prev = tail;
            tail->next = newNode;
            tail = newNode;
        }
    }

    // Function to insert a node at a specific position
    void insertAtPosition(int value, int position) {
        if (position <= 0) {
            std::cout << "Invalid position.\n";
            return;
        }
        Node* newNode = new Node(value);
        if (position == 1) {
            insertAtBeginning(value);
        } else {
            Node* current = head;
            int currentPosition = 1;
            while (current && currentPosition < position - 1) {
                current = current->next;
                currentPosition++;
            }
            if (!current) {
                std::cout << "Position out of bounds.\n";
                return;
            }
            newNode->next = current->next;
            newNode->prev = current;
            if (current->next)
                current->next->prev = newNode;
            current->next = newNode;
        }
    }

    // Function to display the list
    void display() {
        Node* current = head;
        while (current) {
            std::cout << current->data << " ";
            current = current->next;
        }
        std::cout << std::endl;
    }
};

int main() {
    DoublyLinkedList dll;
    dll.insertAtEnd(1);
    dll.insertAtEnd(2);
    dll.insertAtBeginning(0);
    dll.insertAtPosition(3, 3);
    dll.display(); // Output: 0 1 2 3
    return 0;
}
```

This is a basic implementation. You can further optimize and enhance it, for example by adding error handling, destructor for memory deallocation, or additional functionalities like deletion and searching.

### 1. Algorithms & Data Structures (C++): Linked List: Merge Multi-Level Doubly Linked List

To merge multi-level doubly linked lists in C++, you can follow these steps:

1. Define the structure for the doubly linked list node.
2. Implement a function to merge two doubly linked lists.
3. Implement a function to merge multi-level doubly linked lists recursively or iteratively.

Here's a sample implementation:

```cpp
#include <iostream>

using namespace std;

// Structure for the doubly linked list node
struct Node {
    int data;
    Node* prev;
    Node* next;
    Node* child;

    Node(int val) : data(val), prev(nullptr), next(nullptr), child(nullptr) {}
};

// Function to merge two sorted doubly linked lists
Node* merge(Node* first, Node* second) {
    if (!first) return second;
    if (!second) return first;

    if (first->data < second->data) {
        first->next = merge(first->next, second);
        first->next->prev = first;
        first->prev = nullptr;
        return first;
    } else {
        second->next = merge(first, second->next);
        second->next->prev = second;
        second->prev = nullptr;
        return second;
    }
}

// Function to flatten multi-level doubly linked list
Node* flatten(Node* head) {
    if (!head) return head;

    Node* current = head;
    while (current) {
        if (current->child) {
            Node* next = current->next;
            Node* childTail = current->child;
            while (childTail->next) {
                childTail = childTail->next;
            }
            current->next = current->child;
            current->child->prev = current;
            current->child = nullptr;
            childTail->next = next;
            if (next) next->prev = childTail;
        }
        current = current->next;
    }

    return head;
}

// Function to print the doubly linked list
void printList(Node* head) {
    while (head) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

// Sample usage
int main() {
    // Example multi-level doubly linked list
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->prev = head;
    head->next->next = new Node(3);
    head->next->next->prev = head->next;
    head->next->child = new Node(4);
    head->next->child->next = new Node(5);
    head->next->child->next->prev = head->next->child;
    head->next->child->next->next = new Node(6);
    head->next->child->next->next->prev = head->next->child->next;
    head->next->next->child = new Node(7);
    head->next->next->child->next = new Node(8);
    head->next->next->child->next->prev = head->next->next->child;
    head->next->next->child->next->next = new Node(9);
    head->next->next->child->next->next->prev = head->next->next->child->next;

    cout << "Original multi-level doubly linked list:" << endl;
    printList(head);

    head = flatten(head);

    cout << "Flattened doubly linked list:" << endl;
    printList(head);

    return 0;
}
```

This code defines a `Node` structure representing a node in the doubly linked list. The `merge` function merges two sorted doubly linked lists. The `flatten` function flattens a multi-level doubly linked list. Finally, the `printList` function is used to print the contents of the doubly linked list.

You can modify this code according to your requirements and integrate it into your project.

### 1. Algorithms & Data Structures (C++): Playing with links of Doubly Linked List

Doubly linked lists are a fundamental data structure in computer science, offering efficient insertion, deletion, and traversal operations. In C++, you can manipulate doubly linked lists using pointers and structs. Here's a basic implementation to get you started:

```cpp
#include <iostream>

struct Node {
    int data;
    Node* prev;
    Node* next;
    
    Node(int value) : data(value), prev(nullptr), next(nullptr) {}
};

class DoublyLinkedList {
private:
    Node* head;
    Node* tail;

public:
    DoublyLinkedList() : head(nullptr), tail(nullptr) {}

    // Function to insert a node at the end of the list
    void insertEnd(int value) {
        Node* newNode = new Node(value);
        if (head == nullptr) {
            head = tail = newNode;
        } else {
            tail->next = newNode;
            newNode->prev = tail;
            tail = newNode;
        }
    }

    // Function to display the list from head to tail
    void displayForward() {
        Node* current = head;
        while (current != nullptr) {
            std::cout << current->data << " ";
            current = current->next;
        }
        std::cout << std::endl;
    }

    // Function to display the list from tail to head
    void displayBackward() {
        Node* current = tail;
        while (current != nullptr) {
            std::cout << current->data << " ";
            current = current->prev;
        }
        std::cout << std::endl;
    }

    // Function to delete a node by its value
    void deleteNode(int value) {
        Node* current = head;
        while (current != nullptr) {
            if (current->data == value) {
                if (current == head) {
                    head = head->next;
                    if (head != nullptr)
                        head->prev = nullptr;
                } else if (current == tail) {
                    tail = tail->prev;
                    if (tail != nullptr)
                        tail->next = nullptr;
                } else {
                    current->prev->next = current->next;
                    current->next->prev = current->prev;
                }
                delete current;
                return;
            }
            current = current->next;
        }
    }

    // Destructor to free memory
    ~DoublyLinkedList() {
        Node* current = head;
        while (current != nullptr) {
            Node* temp = current;
            current = current->next;
            delete temp;
        }
    }
};

int main() {
    DoublyLinkedList dll;

    dll.insertEnd(1);
    dll.insertEnd(2);
    dll.insertEnd(3);
    dll.insertEnd(4);

    std::cout << "Forward: ";
    dll.displayForward();

    std::cout << "Backward: ";
    dll.displayBackward();

    dll.deleteNode(3);

    std::cout << "Forward after deletion: ";
    dll.displayForward();

    return 0;
}
```

This code provides a basic implementation of a doubly linked list in C++. It allows you to insert nodes at the end of the list, display the list both forward and backward, and delete nodes by their values. You can build upon this foundation to implement additional functionality or optimize it further as needed.

### 1. Algorithms & Data Structures (C++): Reverse a Doubly Linked List

To reverse a doubly linked list in C++, you need to swap the next and previous pointers of each node in the list. Here's a sample implementation:

```cpp
#include <iostream>

// Node structure for doubly linked list
struct Node {
    int data;
    Node* prev;
    Node* next;
};

// Function to reverse a doubly linked list
Node* reverseDoublyLinkedList(Node* head) {
    Node* current = head;
    Node* temp = nullptr;

    // Swap next and prev pointers for all nodes of doubly linked list
    while (current != nullptr) {
        temp = current->prev;
        current->prev = current->next;
        current->next = temp;
        current = current->prev; // Move to the next node
    }

    // Check if list is empty or has only one node
    if (temp != nullptr) {
        head = temp->prev; // Update head to the last node
    }

    return head;
}

// Function to insert a node at the beginning of a doubly linked list
Node* insertNode(Node* head, int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->prev = nullptr;
    newNode->next = head;

    if (head != nullptr) {
        head->prev = newNode;
    }

    return newNode;
}

// Function to display a doubly linked list
void displayList(Node* head) {
    while (head != nullptr) {
        std::cout << head->data << " ";
        head = head->next;
    }
    std::cout << std::endl;
}

int main() {
    Node* head = nullptr;

    // Inserting nodes into the doubly linked list
    head = insertNode(head, 1);
    head = insertNode(head, 2);
    head = insertNode(head, 3);
    head = insertNode(head, 4);
    head = insertNode(head, 5);

    std::cout << "Original list: ";
    displayList(head);

    // Reversing the doubly linked list
    head = reverseDoublyLinkedList(head);

    std::cout << "Reversed list: ";
    displayList(head);

    return 0;
}
```

This code defines a `Node` structure for doubly linked list elements and provides functions to insert nodes, display the list, and reverse it. In the `reverseDoublyLinkedList` function, it iterates through the list, swapping the `prev` and `next` pointers for each node. Finally, it updates the `head` pointer to point to the new first node after reversal.

### 1. Algorithms & Data Structures (C++): Reversing Doubly Linked List

Sure, reversing a doubly linked list in C++ involves swapping the pointers of each node to reverse the direction of the list. Here's how you can implement it:

```cpp
#include <iostream>

// Node structure for doubly linked list
struct Node {
    int data;
    Node* prev;
    Node* next;
    Node(int val) : data(val), prev(nullptr), next(nullptr) {}
};

// Function to reverse a doubly linked list
Node* reverseDoublyLinkedList(Node* head) {
    Node* current = head;
    Node* temp = nullptr;

    // Swap next and prev pointers for all nodes of the doubly linked list
    while (current != nullptr) {
        temp = current->prev;
        current->prev = current->next;
        current->next = temp;
        current = current->prev; // Move to the next node
    }

    // Check if the list is empty or has only one node
    if (temp != nullptr) {
        head = temp->prev; // Update the new head
    }

    return head;
}

// Function to print the doubly linked list
void printDoublyLinkedList(Node* head) {
    while (head != nullptr) {
        std::cout << head->data << " ";
        head = head->next;
    }
    std::cout << std::endl;
}

// Test the implementation
int main() {
    // Create a sample doubly linked list: 1 <-> 2 <-> 3 <-> 4 <-> 5
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->prev = head;
    head->next->next = new Node(3);
    head->next->next->prev = head->next;
    head->next->next->next = new Node(4);
    head->next->next->next->prev = head->next->next;
    head->next->next->next->next = new Node(5);
    head->next->next->next->next->prev = head->next->next->next;

    std::cout << "Original doubly linked list: ";
    printDoublyLinkedList(head);

    // Reverse the doubly linked list
    head = reverseDoublyLinkedList(head);

    std::cout << "Reversed doubly linked list: ";
    printDoublyLinkedList(head);

    return 0;
}
```

This code defines a `Node` struct to represent each node of the doubly linked list. The `reverseDoublyLinkedList` function reverses the list by swapping the `prev` and `next` pointers of each node iteratively. Finally, `printDoublyLinkedList` is used to print the doubly linked list.

### 1. Algorithms & Data Structures (C++): Singly VS Doubly Linked Lists

Singly and doubly linked lists are fundamental data structures in computer science and are used to store collections of data. Here's a comparison between the two:

1. **Memory Usage:**
   * Singly Linked List: Each node in a singly linked list contains a reference to the next node in the sequence. Hence, it uses less memory compared to a doubly linked list.
   * Doubly Linked List: Each node in a doubly linked list contains references to both the next and the previous nodes. This additional reference increases memory usage compared to a singly linked list.

2. **Traversal:**
   * Singly Linked List: Traversal in a singly linked list can only be done in one direction, starting from the head (the first node) and progressing through each subsequent node.
   * Doubly Linked List: Traversal can be done in both directions: forward (from the head to the tail) and backward (from the tail to the head), as each node has references to both its previous and next nodes.

3. **Insertion and Deletion:**
   * Singly Linked List: Insertion and deletion at the beginning of the list can be done efficiently by updating the head pointer. However, for insertion and deletion at arbitrary positions or at the end of the list, traversal from the head to the desired position is necessary, which can take linear time.
   * Doubly Linked List: Similar to a singly linked list, insertion and deletion at the beginning and end of the list can be done efficiently by updating the head and tail pointers. Additionally, insertion and deletion at arbitrary positions can be more efficient since traversal can be done in both directions.

4. **Implementation Complexity:**
   * Singly Linked List: Implementing a singly linked list is generally simpler compared to a doubly linked list due to the lack of backward pointers.
   * Doubly Linked List: Implementing a doubly linked list requires handling both forward and backward pointers, which adds complexity to the implementation.

5. **Memory Management:**
   * Singly Linked List: In memory management systems like C or C++, singly linked lists are generally preferred due to their simpler structure and lower memory overhead.
   * Doubly Linked List: While offering more flexibility, doubly linked lists consume more memory due to the additional pointers per node.

The choice between singly and doubly linked lists depends on the specific requirements of the application. If memory usage needs to be minimized or operations mostly involve traversal from the head, a singly linked list might be preferred. However, if frequent insertion, deletion, or traversal in both directions is required, a doubly linked list might be a better choice despite its slightly higher memory overhead and implementation complexity.

### 1. Algorithms & Data Structures (C++): Sorting Doubly Linked List

Sorting a doubly linked list involves rearranging its elements in a specific order, typically in non-decreasing (ascending) or non-increasing (descending) order. Here's how you can implement sorting algorithms like Bubble Sort, Selection Sort, Insertion Sort, or Merge Sort for a doubly linked list in C++:

```cpp
#include <iostream>

using namespace std;

// Node structure for doubly linked list
struct Node {
    int data;
    Node* prev;
    Node* next;
    Node(int val) : data(val), prev(nullptr), next(nullptr) {}
};

// Function to insert a node at the end of a doubly linked list
void insertEnd(Node*& head, int data) {
    Node* newNode = new Node(data);
    if (!head) {
        head = newNode;
        return;
    }
    Node* temp = head;
    while (temp->next) {
        temp = temp->next;
    }
    temp->next = newNode;
    newNode->prev = temp;
}

// Function to swap data of two nodes
void swapData(Node* a, Node* b) {
    int temp = a->data;
    a->data = b->data;
    b->data = temp;
}

// Bubble sort for doubly linked list
void bubbleSort(Node* head) {
    if (!head || !head->next)
        return;

    Node* end = nullptr;
    bool swapped;
    do {
        swapped = false;
        Node* current = head;
        while (current->next != end) {
            if (current->data > current->next->data) {
                swapData(current, current->next);
                swapped = true;
            }
            current = current->next;
        }
        end = current;
    } while (swapped);
}

// Function to print the doubly linked list
void printList(Node* head) {
    while (head) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

// Driver code
int main() {
    Node* head = nullptr;
    insertEnd(head, 5);
    insertEnd(head, 2);
    insertEnd(head, 10);
    insertEnd(head, 1);
    insertEnd(head, 7);

    cout << "Original list: ";
    printList(head);

    bubbleSort(head);

    cout << "Sorted list: ";
    printList(head);

    return 0;
}
```

This example includes the implementation of Bubble Sort for sorting a doubly linked list in C++. The `Node` struct defines the structure of a doubly linked list node. The `insertEnd` function inserts a node at the end of the list. `swapData` swaps the data of two nodes. `bubbleSort` implements the Bubble Sort algorithm for the doubly linked list. Finally, `printList` prints the elements of the list, and `main` function serves as the driver code.

### 1. Algorithms & Data Structures (C++): Traversing Doubly Linked List

Traversing a doubly linked list in C++ involves moving through each node from the beginning to the end or vice versa, accessing or modifying the data stored in each node. Here's a basic example:

```cpp
#include <iostream>

// Node structure for a doubly linked list
struct Node {
    int data;
    Node* prev;
    Node* next;
    
    // Constructor to initialize node
    Node(int value) : data(value), prev(nullptr), next(nullptr) {}
};

// Function to traverse and print the elements of the doubly linked list forwards
void traverseForward(Node* head) {
    std::cout << "Forward Traversal: ";
    while (head != nullptr) {
        std::cout << head->data << " ";
        head = head->next;
    }
    std::cout << std::endl;
}

// Function to traverse and print the elements of the doubly linked list backwards
void traverseBackward(Node* tail) {
    std::cout << "Backward Traversal: ";
    while (tail != nullptr) {
        std::cout << tail->data << " ";
        tail = tail->prev;
    }
    std::cout << std::endl;
}

int main() {
    // Creating nodes
    Node* head = new Node(1);
    Node* second = new Node(2);
    Node* third = new Node(3);
    Node* fourth = new Node(4);
    
    // Connecting nodes
    head->next = second;
    second->prev = head;
    second->next = third;
    third->prev = second;
    third->next = fourth;
    fourth->prev = third;
    
    // Traversing and printing doubly linked list forwards
    traverseForward(head);
    
    // Traversing and printing doubly linked list backwards
    traverseBackward(fourth);
    
    // Deleting nodes to free memory
    delete head;
    delete second;
    delete third;
    delete fourth;
    
    return 0;
}
```

This code creates a doubly linked list with four nodes, traverses it forwards and backwards, and then deletes the nodes to avoid memory leaks.

### 1. Algorithms & Data Structures (C++): What is Doubly Linked List? Node Class Constructor

A doubly linked list is a type of linked list where each node contains a data field and two pointers, one pointing to the next node in the sequence and the other pointing to the previous node. This allows traversal of the list in both forward and backward directions.

Here's a basic implementation of a node class for a doubly linked list in C++ along with its constructor:

```cpp
#include <iostream>

template <typename T>
class Node {
public:
    T data;
    Node<T>* next;
    Node<T>* prev;

    // Constructor
    Node(const T& value, Node<T>* nextNode = nullptr, Node<T>* prevNode = nullptr) : 
        data(value), next(nextNode), prev(prevNode) {}
};

int main() {
    // Example usage
    Node<int>* node1 = new Node<int>(1);
    Node<int>* node2 = new Node<int>(2);
    Node<int>* node3 = new Node<int>(3);

    // Linking nodes
    node1->next = node2;
    node2->prev = node1;
    node2->next = node3;
    node3->prev = node2;

    // Traversing forward
    Node<int>* current = node1;
    while (current != nullptr) {
        std::cout << current->data << " ";
        current = current->next;
    }
    std::cout << std::endl;

    // Traversing backward
    current = node3;
    while (current != nullptr) {
        std::cout << current->data << " ";
        current = current->prev;
    }
    std::cout << std::endl;

    // Clean up
    delete node1;
    delete node2;
    delete node3;

    return 0;
}
```

In this code:

* The `Node` class template takes a template parameter `T` representing the type of data the node will store.
* It has three member variables: `data` to store the value of the node, `next` to point to the next node, and `prev` to point to the previous node.
* The constructor initializes the `data` member with the given value and sets the `next` and `prev` pointers to the provided nodes or `nullptr` if not provided.
* In the `main()` function, we create three nodes and link them together to form a doubly linked list.
* We then traverse the list both forward and backward to demonstrate the bidirectional traversal capability of the doubly linked list.
* Finally, we delete the dynamically allocated nodes to avoid memory leaks.

### 1. Algorithms & Data Structures (C++): Class ADT for Doubly Linked lists

Certainly! Below is a basic implementation of a doubly linked list in C++:

```cpp
#include <iostream>

template <typename T>
class Node {
public:
    T data;
    Node* prev;
    Node* next;
    Node(T data) : data(data), prev(nullptr), next(nullptr) {}
};

template <typename T>
class DoublyLinkedList {
private:
    Node<T>* head;
    Node<T>* tail;
    int size;

public:
    DoublyLinkedList() : head(nullptr), tail(nullptr), size(0) {}

    ~DoublyLinkedList() {
        Node<T>* current = head;
        while (current != nullptr) {
            Node<T>* next = current->next;
            delete current;
            current = next;
        }
    }

    // Method to add a new node to the end of the list
    void append(T data) {
        Node<T>* newNode = new Node<T>(data);
        if (head == nullptr) {
            head = tail = newNode;
        } else {
            tail->next = newNode;
            newNode->prev = tail;
            tail = newNode;
        }
        size++;
    }

    // Method to print the elements of the list
    void print() {
        Node<T>* current = head;
        while (current != nullptr) {
            std::cout << current->data << " ";
            current = current->next;
        }
        std::cout << std::endl;
    }

    // Method to get the size of the list
    int getSize() const {
        return size;
    }

    // Method to check if the list is empty
    bool isEmpty() const {
        return size == 0;
    }
};

int main() {
    DoublyLinkedList<int> list;
    list.append(1);
    list.append(2);
    list.append(3);

    std::cout << "List elements: ";
    list.print();
    std::cout << "List size: " << list.getSize() << std::endl;

    return 0;
}
```

In this implementation:

* `Node` class represents each node in the doubly linked list. It contains the data and pointers to the previous and next nodes.
* `DoublyLinkedList` class represents the doubly linked list. It contains a pointer to the head node, a pointer to the tail node, and the size of the list.
* Methods include `append()` to add a new node to the end of the list, `print()` to print the elements of the list, `getSize()` to get the size of the list, and `isEmpty()` to check if the list is empty.
* In the `main()` function, a test of the implementation is shown by creating a `DoublyLinkedList<int>`, adding elements to it, and printing its contents and size.

### 1. Algorithms & Data Structures (C++): Delete Element Anywhere in between Doubly Linked List

Deleting an element from a doubly linked list involves finding the node containing the value to delete and then adjusting the pointers of its adjacent nodes to bypass the node to be deleted. Here's a C++ implementation:

```cpp
#include <iostream>

// Node structure for doubly linked list
struct Node {
    int data;
    Node* prev;
    Node* next;
    
    Node(int value) : data(value), prev(nullptr), next(nullptr) {}
};

// Doubly linked list class
class DoublyLinkedList {
private:
    Node* head;
    Node* tail;
    
public:
    DoublyLinkedList() : head(nullptr), tail(nullptr) {}
    
    // Function to insert a node at the end of the list
    void append(int value) {
        Node* newNode = new Node(value);
        if (tail == nullptr) {
            head = tail = newNode;
        } else {
            tail->next = newNode;
            newNode->prev = tail;
            tail = newNode;
        }
    }
    
    // Function to delete a node with given value
    void deleteNode(int value) {
        Node* current = head;
        
        // Traverse the list to find the node with the given value
        while (current != nullptr && current->data != value) {
            current = current->next;
        }
        
        // If node not found
        if (current == nullptr) {
            std::cout << "Node with value " << value << " not found." << std::endl;
            return;
        }
        
        // Adjust pointers of adjacent nodes to bypass the node to be deleted
        if (current->prev != nullptr) {
            current->prev->next = current->next;
        } else {
            head = current->next;
        }
        
        if (current->next != nullptr) {
            current->next->prev = current->prev;
        } else {
            tail = current->prev;
        }
        
        delete current; // Free memory
    }
    
    // Function to display the elements of the list
    void display() {
        Node* current = head;
        while (current != nullptr) {
            std::cout << current->data << " ";
            current = current->next;
        }
        std::cout << std::endl;
    }
};

int main() {
    DoublyLinkedList dll;
    dll.append(1);
    dll.append(2);
    dll.append(3);
    dll.append(4);
    dll.append(5);
    
    std::cout << "Original List: ";
    dll.display();
    
    // Delete element 3
    dll.deleteNode(3);
    std::cout << "List after deleting 3: ";
    dll.display();
    
    // Delete element 1
    dll.deleteNode(1);
    std::cout << "List after deleting 1: ";
    dll.display();
    
    // Delete element 5
    dll.deleteNode(5);
    std::cout << "List after deleting 5: ";
    dll.display();
    
    return 0;
}
```

This implementation allows you to delete elements from anywhere in the doubly linked list.

### 1. Algorithms & Data Structures (C++): Delete Element at Beginning of Doubly Linked List

Deleting an element at the beginning of a doubly linked list in C++ involves adjusting pointers to remove the first node. Here's how you can implement it:

```cpp
#include <iostream>

struct Node {
    int data;
    Node* prev;
    Node* next;
    Node(int val) : data(val), prev(nullptr), next(nullptr) {}
};

class DoublyLinkedList {
private:
    Node* head;
public:
    DoublyLinkedList() : head(nullptr) {}

    // Function to delete the first node
    void deleteFirst() {
        if (head == nullptr) {
            std::cout << "List is empty. Nothing to delete.\n";
            return;
        }
        
        Node* temp = head;
        head = head->next;
        if (head != nullptr) {
            head->prev = nullptr;
        }
        delete temp;
    }

    // Function to display the list
    void display() {
        Node* current = head;
        while (current != nullptr) {
            std::cout << current->data << " ";
            current = current->next;
        }
        std::cout << std::endl;
    }

    // Function to insert a node at the beginning
    void insertFirst(int val) {
        Node* newNode = new Node(val);
        newNode->next = head;
        if (head != nullptr) {
            head->prev = newNode;
        }
        head = newNode;
    }
};

int main() {
    DoublyLinkedList list;
    list.insertFirst(3);
    list.insertFirst(7);
    list.insertFirst(10);
    list.display(); // Output: 10 7 3
    list.deleteFirst();
    list.display(); // Output: 7 3
    list.deleteFirst();
    list.display(); // Output: 3
    list.deleteFirst();
    list.display(); // Output: List is empty. Nothing to delete.

    return 0;
}
```

In this code:

* The `Node` struct represents each element of the doubly linked list, containing data and pointers to the previous and next nodes.
* The `DoublyLinkedList` class manages the operations on the list.
* `deleteFirst()` function removes the first node from the list.
* `display()` function prints the elements of the list.
* `insertFirst()` function inserts a new node at the beginning of the list.

### 1. Algorithms & Data Structures (C++): Deleting from Doubly Linked List

Deleting from a doubly linked list in C++ involves a few steps, primarily identifying the node to delete and then updating the pointers of the adjacent nodes to bypass the node being deleted. Here's a basic example of how you can delete a node from a doubly linked list:

```cpp
#include <iostream>

// Node structure for the doubly linked list
struct Node {
    int data;
    Node* prev;
    Node* next;
    
    Node(int val) : data(val), prev(nullptr), next(nullptr) {}
};

// Function to delete a node from the doubly linked list
void deleteNode(Node* &head, Node* target) {
    // Check if the list is empty or target node is null
    if (head == nullptr || target == nullptr)
        return;
    
    // If the node to be deleted is the head node
    if (head == target) {
        head = target->next; // Update head to the next node
        if (head != nullptr)
            head->prev = nullptr; // Update the new head's previous pointer
        delete target; // Delete the target node
        return;
    }
    
    // Adjust the pointers of the surrounding nodes
    if (target->prev != nullptr)
        target->prev->next = target->next;
    if (target->next != nullptr)
        target->next->prev = target->prev;
    
    // Delete the target node
    delete target;
}

// Function to print the doubly linked list
void printList(Node* head) {
    while (head != nullptr) {
        std::cout << head->data << " ";
        head = head->next;
    }
    std::cout << std::endl;
}

int main() {
    // Creating a sample doubly linked list: 1 <-> 2 <-> 3 <-> 4
    Node* head = new Node(1);
    Node* second = new Node(2);
    Node* third = new Node(3);
    Node* fourth = new Node(4);
    
    head->next = second;
    second->prev = head;
    second->next = third;
    third->prev = second;
    third->next = fourth;
    fourth->prev = third;
    
    std::cout << "Original list: ";
    printList(head);
    
    // Deleting the node containing data 2
    deleteNode(head, second);
    
    std::cout << "List after deletion: ";
    printList(head);
    
    return 0;
}
```

This code demonstrates deleting a node from a doubly linked list in C++. The `deleteNode` function takes the head of the list and the target node to delete. It adjusts the pointers of the previous and next nodes of the target node to bypass it, and then deletes the target node.

### 1. Algorithms & Data Structures (C++): Deleting from Doubly Linked Lists

Deleting from a doubly linked list in C++ involves several steps to ensure proper removal of the node while maintaining the integrity of the list. Here's how you can implement the deletion of a node from a doubly linked list:

```cpp
#include <iostream>

// Define the structure of a node
struct Node {
    int data;
    Node* prev;
    Node* next;
    
    // Constructor to initialize a node
    Node(int value) : data(value), prev(nullptr), next(nullptr) {}
};

// Function to delete a node from a doubly linked list
void deleteNode(Node** head_ref, Node* del_node) {
    // Base case: If the list is empty or del_node is nullptr, return
    if (*head_ref == nullptr || del_node == nullptr)
        return;
    
    // If the node to be deleted is the head node
    if (*head_ref == del_node)
        *head_ref = del_node->next;
    
    // If the node to be deleted is not the last node
    if (del_node->next != nullptr)
        del_node->next->prev = del_node->prev;
    
    // If the node to be deleted is not the first node
    if (del_node->prev != nullptr)
        del_node->prev->next = del_node->next;
    
    // Free the memory occupied by the del_node
    delete del_node;
}

// Function to print the elements of the doubly linked list
void printList(Node* node) {
    while (node != nullptr) {
        std::cout << node->data << " ";
        node = node->next;
    }
    std::cout << std::endl;
}

// Main function
int main() {
    // Create a doubly linked list: 1 <-> 2 <-> 3 <-> 4 <-> 5
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->prev = head;
    head->next->next = new Node(3);
    head->next->next->prev = head->next;
    head->next->next->next = new Node(4);
    head->next->next->next->prev = head->next->next;
    head->next->next->next->next = new Node(5);
    head->next->next->next->next->prev = head->next->next->next;

    std::cout << "Original list: ";
    printList(head);

    // Delete node with value 3
    deleteNode(&head, head->next->next);
    std::cout << "List after deleting node with value 3: ";
    printList(head);

    // Delete node with value 1
    deleteNode(&head, head);
    std::cout << "List after deleting node with value 1: ";
    printList(head);

    // Delete node with value 5
    deleteNode(&head, head->next->next->next->next);
    std::cout << "List after deleting node with value 5: ";
    printList(head);

    return 0;
}
```

This code defines a `Node` struct representing each element of the doubly linked list. The `deleteNode` function is responsible for removing a specific node from the list. Finally, the `printList` function is used to print the elements of the list before and after deletion for demonstration purposes.

### 1. Algorithms & Data Structures (C++): Deletion at the End of the Doubly Linked List

Deleting a node at the end of a doubly linked list in C++ involves a few steps. Here's how you can implement it:

```cpp
#include <iostream>

struct Node {
    int data;
    Node* prev;
    Node* next;
    
    Node(int val) : data(val), prev(nullptr), next(nullptr) {}
};

class DoublyLinkedList {
private:
    Node* head;
    Node* tail;
public:
    DoublyLinkedList() : head(nullptr), tail(nullptr) {}
    
    // Function to delete a node at the end of the doubly linked list
    void deleteEnd() {
        if (tail == nullptr) {
            std::cout << "List is empty. Nothing to delete." << std::endl;
            return;
        }
        
        Node* temp = tail;
        
        if (tail->prev != nullptr) {
            tail = tail->prev;
            tail->next = nullptr;
        } else {
            // If there is only one node in the list
            head = tail = nullptr;
        }
        
        delete temp;
    }
    
    // Function to insert a node at the end of the doubly linked list
    void insertEnd(int val) {
        Node* newNode = new Node(val);
        
        if (tail == nullptr) {
            head = tail = newNode;
        } else {
            tail->next = newNode;
            newNode->prev = tail;
            tail = newNode;
        }
    }
    
    // Function to display the doubly linked list
    void display() {
        Node* current = head;
        while (current != nullptr) {
            std::cout << current->data << " ";
            current = current->next;
        }
        std::cout << std::endl;
    }
};

int main() {
    DoublyLinkedList dll;
    
    dll.insertEnd(1);
    dll.insertEnd(2);
    dll.insertEnd(3);
    
    std::cout << "Original Doubly Linked List: ";
    dll.display();
    
    dll.deleteEnd();
    
    std::cout << "Doubly Linked List after deletion at the end: ";
    dll.display();
    
    return 0;
}
```

This code defines a doubly linked list with nodes having integer data. The `deleteEnd()` function deletes the last node in the list, adjusting pointers accordingly. The `insertEnd()` function inserts a new node at the end of the list. The `display()` function is used to print the elements of the list.

In the `main()` function, we demonstrate the usage of these functions by inserting elements into the list and then deleting the last element.

### 1. Algorithms & Data Structures (C++): Deletion at the Front of the Doubly Linked List

Deleting a node at the front of a doubly linked list in C++ involves a few steps:

1. Check if the list is empty. If it is, there's nothing to delete.
2. If the list is not empty, update the `head` pointer to point to the next node.
3. Free the memory occupied by the node being deleted.
4. If the list is now empty, update the `tail` pointer as well.

Here's a sample C++ code to demonstrate this:

```cpp
#include <iostream>

// Define the structure for a node in the doubly linked list
struct Node {
    int data;
    Node* prev;
    Node* next;
    
    Node(int val) : data(val), prev(nullptr), next(nullptr) {}
};

class DoublyLinkedList {
private:
    Node* head;
    Node* tail;
public:
    DoublyLinkedList() : head(nullptr), tail(nullptr) {}

    // Function to delete a node at the front of the doubly linked list
    void deleteFront() {
        // Check if the list is empty
        if (head == nullptr) {
            std::cout << "List is empty. Nothing to delete." << std::endl;
            return;
        }

        // Save the reference to the node to be deleted
        Node* toDelete = head;

        // Update the head to point to the next node
        head = head->next;

        // If the list is not empty, update the previous pointer of the new head to nullptr
        if (head != nullptr) {
            head->prev = nullptr;
        } else {
            // If the list becomes empty after deletion, update the tail pointer as well
            tail = nullptr;
        }

        // Delete the node
        delete toDelete;
    }

    // Function to display the doubly linked list
    void display() {
        Node* current = head;
        while (current != nullptr) {
            std::cout << current->data << " <-> ";
            current = current->next;
        }
        std::cout << "nullptr" << std::endl;
    }

    // Function to insert a node at the end of the doubly linked list
    void insertEnd(int data) {
        Node* newNode = new Node(data);
        if (tail == nullptr) {
            head = tail = newNode;
        } else {
            tail->next = newNode;
            newNode->prev = tail;
            tail = newNode;
        }
    }
};

int main() {
    DoublyLinkedList dll;
    dll.insertEnd(1);
    dll.insertEnd(2);
    dll.insertEnd(3);
    dll.insertEnd(4);
    dll.display(); // Output: 1 <-> 2 <-> 3 <-> 4 <-> nullptr

    dll.deleteFront();
    dll.display(); // Output: 2 <-> 3 <-> 4 <-> nullptr

    dll.deleteFront();
    dll.display(); // Output: 3 <-> 4 <-> nullptr

    dll.deleteFront();
    dll.display(); // Output: 4 <-> nullptr

    dll.deleteFront();
    dll.display(); // Output: List is empty. Nothing to delete.

    return 0;
}
```

This code demonstrates the deletion of nodes at the front of a doubly linked list in C++.

### 1. Algorithms & Data Structures (C++): Time Complexity : Insert at a Position of a Doubly Linked Lis

In a doubly linked list, inserting an element at a specific position involves traversing the list to find the position where insertion is required and then performing the insertion operation. Here's a brief explanation of the time complexity:

1. **Traversing to the insertion point**: In the worst case, you might need to traverse the list from either the head or the tail to reach the insertion point. This traversal takes O(n) time, where n is the number of elements in the list.

2. **Insertion operation**: After finding the insertion point, the insertion operation itself is generally constant time since we have direct access to the nodes in a doubly linked list. This operation typically involves creating a new node, adjusting the pointers of adjacent nodes, and updating pointers in the new node. So, it's O(1).

Therefore, the time complexity of inserting an element at a specific position in a doubly linked list is O(n) due to the traversal to find the insertion point, where n is the number of elements in the list.

In C++, the implementation might look something like this:

```cpp
#include <iostream>

struct Node {
    int data;
    Node* prev;
    Node* next;
};

// Function to insert a new node at a given position
void insertAtPosition(Node** head_ref, int position, int new_data) {
    // Check if position is valid
    if (position < 1) {
        std::cerr << "Invalid position\n";
        return;
    }

    Node* new_node = new Node();
    new_node->data = new_data;

    if (position == 1) {
        // Insert at the beginning
        new_node->next = *head_ref;
        new_node->prev = nullptr;
        if (*head_ref != nullptr)
            (*head_ref)->prev = new_node;
        *head_ref = new_node;
    } else {
        Node* temp = *head_ref;
        // Traverse to the position
        for (int i = 1; i < position - 1 && temp != nullptr; ++i)
            temp = temp->next;

        if (temp == nullptr) {
            std::cerr << "Position out of range\n";
            return;
        }

        // Insert after temp
        new_node->next = temp->next;
        new_node->prev = temp;
        if (temp->next != nullptr)
            temp->next->prev = new_node;
        temp->next = new_node;
    }
}

// Function to print the doubly linked list
void printList(Node* node) {
    while (node != nullptr) {
        std::cout << node->data << " ";
        node = node->next;
    }
    std::cout << "\n";
}

// Main function
int main() {
    Node* head = nullptr;

    // Inserting elements at different positions
    insertAtPosition(&head, 1, 10);
    insertAtPosition(&head, 2, 20);
    insertAtPosition(&head, 2, 30);
    insertAtPosition(&head, 1, 5);

    // Print the list
    printList(head);

    return 0;
}
```

This code demonstrates how to insert elements at different positions in a doubly linked list in C++.
