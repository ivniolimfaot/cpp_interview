### 1. Algorithms & Data Structures (C++): Using Vector Container

Using the `std::vector` container in C++ for implementing algorithms and data structures provides a versatile and efficient way to manage dynamic arrays. Here are some common operations and scenarios where you might use `std::vector`:

1. **Dynamic Array**: `std::vector` provides a dynamic array that grows automatically as elements are inserted.

    ```cpp
    #include <vector>
    #include <iostream>

    int main() {
        std::vector<int> dynamicArray;
        dynamicArray.push_back(10);
        dynamicArray.push_back(20);
        dynamicArray.push_back(30);

        for (int num : dynamicArray) {
            std::cout << num << " ";
        }

        return 0;
    }
    ```

2. **Iterating over a Vector**:

    ```cpp
    for (auto it = dynamicArray.begin(); it != dynamicArray.end(); ++it) {
        std::cout << *it << " ";
    }
    ```

3. **Accessing Elements**:

    ```cpp
    int thirdElement = dynamicArray[2];
    ```

4. **Inserting and Erasing Elements**:

    ```cpp
    dynamicArray.insert(dynamicArray.begin() + 1, 15); // Insert 15 at index 1
    dynamicArray.erase(dynamicArray.begin() + 2); // Erase element at index 2
    ```

5. **Sorting**:

    ```cpp
    #include <algorithm>

    std::sort(dynamicArray.begin(), dynamicArray.end());
    ```

6. **Searching**:

    ```cpp
    #include <algorithm>

    auto it = std::find(dynamicArray.begin(), dynamicArray.end(), 20);
    if (it != dynamicArray.end()) {
        std::cout << "Element found at index " << std::distance(dynamicArray.begin(), it);
    } else {
        std::cout << "Element not found";
    }
    ```

7. **Resizing**:

    ```cpp
    dynamicArray.resize(10); // Resize to 10 elements
    ```

8. **Capacity**:

    ```cpp
    std::cout << "Size: " << dynamicArray.size() << std::endl;
    std::cout << "Capacity: " << dynamicArray.capacity() << std::endl;
    ```

9. **Clearing the Vector**:

    ```cpp
    dynamicArray.clear();
    ```

`std::vector` provides many other functionalities as well, making it one of the most versatile containers in the C++ Standard Library for managing dynamic arrays.

### 1. Algorithms & Data Structures (C++): Vector

#### Efficiency

Vectors offer constant-time access to elements (`O(1)`), but resizing the vector can be costly if it exceeds its capacity, as it may require allocating new memory and copying existing elements (`O(n)` amortized time).

#### Memory Management

Vectors manage memory dynamically, automatically handling memory allocation and deallocation. They typically allocate more memory than needed to accommodate future growth efficiently.

#### When to Use

Vectors are suitable for situations where you need a dynamic array-like data structure with fast random access and insertion/deletion at the end. However, if you need frequent insertions or deletions in the middle, other data structures like linked lists might be more appropriate due to their better performance characteristics.

### 1. Algorithms & Data Structures (C++): Vector Class

Creating a vector class in C++ is a great exercise to understand how dynamic arrays work. Here's a basic implementation of a vector class along with some common operations like adding elements, accessing elements, and resizing the vector.

```cpp
#include <iostream>

template <typename T>
class Vector {
private:
    T* array;
    size_t capacity;
    size_t length;

public:
    Vector() : capacity(10), length(0) {
        array = new T[capacity];
    }

    ~Vector() {
        delete[] array;
    }

    // Add element at the end
    void push_back(const T& value) {
        if (length >= capacity) {
            resize(capacity * 2); // Double the capacity
        }
        array[length++] = value;
    }

    // Access element at index
    T& operator[](size_t index) {
        if (index >= length) {
            throw std::out_of_range("Index out of range");
        }
        return array[index];
    }

    // Get size of the vector
    size_t size() const {
        return length;
    }

    // Resize the vector
    void resize(size_t newCapacity) {
        T* newArray = new T[newCapacity];
        for (size_t i = 0; i < length; ++i) {
            newArray[i] = array[i];
        }
        delete[] array;
        array = newArray;
        capacity = newCapacity;
    }
};

int main() {
    Vector<int> vec;
    for (int i = 0; i < 20; ++i) {
        vec.push_back(i);
    }

    // Access elements and print
    for (size_t i = 0; i < vec.size(); ++i) {
        std::cout << vec[i] << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

This is a very basic implementation that lacks many features a real-world vector implementation would have (like iterators, iterators range constructors, memory allocation optimizations, etc.), but it serves as a good starting point for understanding the basic functionality of vectors.

When implementing a vector class, remember to handle edge cases like out-of-bounds access and memory management properly. And it's always a good practice to test your implementation with various scenarios to ensure correctness.

### 1. Algorithms & Data Structures (C++): Vector Data Structure

#### Iterating through the vector

```cpp
for (int i = 0; i < myVector.size(); ++i) {
    std::cout << myVector[i] << " ";
}
```

#### Using iterators

```cpp
for (auto it = myVector.begin(); it != myVector.end(); ++it) {
    std::cout << *it << " ";
}
```

#### Clearing the vector

```cpp
myVector.clear(); // Removes all elements from the vector
```

#### Checking if vector is empty

```cpp
if (myVector.empty()) {
    // Vector is empty
}
```

Vectors are quite versatile and provide a lot of functionalities, making them one of the most commonly used data structures in C++. They're especially handy when you need a dynamic array that can grow or shrink in size as needed.

### 1. Algorithms & Data Structures (C++): Vector STL

The Vector STL (Standard Template Library) in C++ is a dynamic array that provides similar functionalities as arrays but with additional capabilities like dynamic resizing, easy insertion and deletion of elements, and automatic memory management. Here's a breakdown of some key aspects:

1. **Dynamic Resizing**: Unlike traditional arrays in C++, vectors can dynamically resize themselves to accommodate more elements. This means you don't need to specify the size upfront, and the vector can grow as needed.

2. **Automatic Memory Management**: Vectors handle memory allocation and deallocation automatically. You don't need to manage memory manually like you would with raw arrays, which helps prevent memory leaks and buffer overflows.

3. **Random Access**: Vectors support random access to elements, meaning you can access any element in constant time using array-like indexing.

4. **Insertion and Deletion**: Vectors provide efficient insertion and deletion of elements at the end (with `push_back()` and `pop_back()`) and in the middle (with `insert()` and `erase()`), although inserting or removing elements in the middle of a vector can be less efficient compared to other data structures like lists.

5. **Iterators**: Vectors support iterators, which allow you to traverse the elements of the vector using iterator-based loops or algorithms from the STL.

### 1. Algorithms & Data Structures (C++): Vector: Find Max Min

To find the maximum and minimum elements in a vector in C++, you can use the `std::max_element` and `std::min_element` functions, respectively, which are provided by the `<algorithm>` header. Here's how you can do it:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {3, 7, 2, 9, 1, 5};
    
    // Finding maximum element
    auto max_itr = std::max_element(vec.begin(), vec.end());
    if (max_itr != vec.end()) {
        std::cout << "Maximum element: " << *max_itr << std::endl;
    } else {
        std::cout << "Vector is empty" << std::endl;
    }

    // Finding minimum element
    auto min_itr = std::min_element(vec.begin(), vec.end());
    if (min_itr != vec.end()) {
        std::cout << "Minimum element: " << *min_itr << std::endl;
    } else {
        std::cout << "Vector is empty" << std::endl;
    }

    return 0;
}
```

In this code:

* `std::max_element` returns an iterator pointing to the maximum element in the vector.
* `std::min_element` returns an iterator pointing to the minimum element in the vector.

Remember to include the necessary headers (`iostream`, `vector`, and `algorithm`) at the beginning of your code. This code will output the maximum and minimum elements of the vector `vec`.

### 1. Algorithms & Data Structures (C++): Vector: Inbuilt Searching

In C++, the `std::vector` container provides a method for searching elements, namely `std::find`, which is defined in the `<algorithm>` header. This function returns an iterator pointing to the first occurrence of the element in the vector, or the `end()` iterator if the element is not found.

Here's how you can use `std::find` with a vector:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {10, 20, 30, 40, 50};

    // Searching for element 30
    auto it = std::find(vec.begin(), vec.end(), 30);

    if (it != vec.end()) {
        std::cout << "Element found at index: " << std::distance(vec.begin(), it) << std::endl;
    } else {
        std::cout << "Element not found" << std::endl;
    }

    return 0;
}
```

In this example, `std::find` searches for the value `30` in the vector `vec`. If it finds the value, it returns an iterator pointing to that position. If not, it returns `vec.end()`. We then check if the iterator is equal to `vec.end()` to determine whether the element was found or not. If it's not equal, we print the index where the element was found; otherwise, we print that the element was not found.

This is a basic example, and you can extend it for more complex scenarios or different data types as needed.

### 1. Algorithms & Data Structures (C++): Vector: Remove Duplicates

To remove duplicates from a vector in C++, you can use various approaches. One common approach is to use the `std::sort` algorithm to sort the vector, then use `std::unique` to remove consecutive duplicates, and finally, erase the elements that `std::unique` moved to the end of the vector. Here's how you can implement it:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

void removeDuplicates(std::vector<int>& vec) {
    // Step 1: Sort the vector
    std::sort(vec.begin(), vec.end());
    
    // Step 2: Remove consecutive duplicates
    auto it = std::unique(vec.begin(), vec.end());
    
    // Step 3: Erase the duplicates
    vec.erase(it, vec.end());
}

int main() {
    std::vector<int> numbers = {1, 2, 3, 2, 4, 5, 3, 6, 7, 4};
    
    std::cout << "Original vector: ";
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    removeDuplicates(numbers);
    
    std::cout << "Vector after removing duplicates: ";
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

This code will output:

```bash
Original vector: 1 2 3 2 4 5 3 6 7 4 
Vector after removing duplicates: 1 2 3 4 5 6 7 
```

This method has a time complexity of O(n log n) due to the sorting operation. If the vector is already sorted or if you want to maintain the original order of elements, you can use alternative approaches such as using a hash set to track unique elements.

### 1. Algorithms & Data Structures (C++): Vector: Rotate

In C++, rotating a vector involves shifting its elements either to the left or right by a specified number of positions. The `rotate` function in the `<algorithm>` header can be used for this purpose. Here's how you can use it:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Rotate left by 2 positions
    std::rotate(vec.begin(), vec.begin() + 2, vec.end());

    // Print the rotated vector
    for (int num : vec) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

This code will output:

```bash
3 4 5 1 2
```

The `rotate` function takes three arguments:

1. `first`: Iterator to the first element in the range.
2. `middle`: Iterator to the element that should become the new first element after rotation.
3. `last`: Iterator to the element past the end of the range.

In the example, `vec.begin()` points to the first element of the vector, `vec.begin() + 2` points to the third element (which becomes the first element after rotation), and `vec.end()` points to one past the last element of the vector.

If you want to rotate the vector to the right, you can simply adjust the `middle` iterator accordingly. For example, to rotate the vector right by 2 positions:

```cpp
std::rotate(vec.rbegin(), vec.rbegin() + 2, vec.rend());
```

This will rotate the vector to the right by 2 positions.

### 1. Algorithms & Data Structures (C++): Arrays vs Vectors

In C++, both arrays and vectors are commonly used data structures for storing sequences of elements. Each has its own characteristics, advantages, and disadvantages. Here’s a comparative overview:

#### Arrays

##### Characteristics

1. **Fixed Size**: The size of an array is determined at compile time and cannot be changed.
2. **Contiguous Memory**: Arrays store elements in contiguous memory locations, which makes them efficient in terms of accessing elements via indexing.
3. **Low-level Structure**: Arrays are a low-level data structure, offering direct access to elements and memory.
4. **Syntax**: Declaring an array is straightforward. For example:

   ```cpp
   int arr[10]; // declares an array of 10 integers
   ```

#### Advantages

1. **Performance**: Due to contiguous memory allocation, arrays provide fast element access using indices (O(1) time complexity).
2. **Memory Overhead**: Arrays do not have extra memory overhead beyond the storage for the elements themselves.
3. **Predictable Memory Use**: Since the size is fixed, memory usage is predictable.

#### Disadvantages

1. **Fixed Size**: Inflexibility in size can be a limitation if the number of elements is not known in advance.
2. **Manual Memory Management**: When using dynamic arrays (allocated with `new`), the programmer must handle memory allocation and deallocation manually.
3. **Lack of Built-in Methods**: Arrays lack built-in functions for common operations (e.g., resizing, inserting).

#### Vectors

##### Characteristics

1. **Dynamic Size**: Vectors can grow and shrink dynamically at runtime.
2. **Contiguous Memory**: Like arrays, vectors also store elements in contiguous memory locations.
3. **STL Container**: Vectors are part of the C++ Standard Template Library (STL), which provides many useful functions.
4. **Syntax**: Declaring a vector is done through the STL:

   ```cpp
   #include <vector>
   std::vector<int> vec; // declares a vector of integers
   ```

#### Advantages

1. **Dynamic Resizing**: Vectors can automatically resize themselves as elements are added or removed.
2. **Ease of Use**: Vectors come with a range of built-in functions such as `push_back`, `pop_back`, `size`, `clear`, and more.
3. **Memory Management**: Memory management is handled automatically by the vector class.
4. **Safety**: Vectors provide bounds checking with the `at` method, which throws an exception if the index is out of range.

#### Disadvantages

1. **Memory Overhead**: Vectors may allocate extra memory to manage future growth, leading to potential memory overhead.
2. **Reallocation Cost**: When a vector grows beyond its current capacity, it needs to allocate new memory and copy existing elements, which can be costly.
3. **Performance Overhead**: The automatic resizing and other additional functionalities introduce slight performance overhead compared to raw arrays.

#### When to Use Each

* **Arrays**:
  * Use arrays when the size of the data is known at compile time and does not change.
  * When you need very fast and predictable access to elements.
  * In performance-critical sections where memory overhead needs to be minimal.

* **Vectors**:
  * Use vectors when the size of the data can change at runtime.
  * When you need built-in methods for manipulating the data (inserting, removing, searching).
  * When you prefer automatic memory management to avoid manual handling of memory.

#### Example Comparison

```cpp
// Array example
#include <iostream>

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    for (int i = 0; i < 5; ++i) {
        std::cout << arr[i] << " ";
    }
    return 0;
}

// Vector example
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    vec.push_back(6); // Adding an element to the vector
    for (int i = 0; i < vec.size(); ++i) {
        std::cout << vec[i] << " ";
    }
    return 0;
}
```

In conclusion, the choice between arrays and vectors in C++ depends on the specific requirements of your application, including the need for dynamic sizing, performance considerations, and ease of use.

### 1. Algorithms & Data Structures (C++): Big O: Vectors

When analyzing algorithms and data structures in C++, understanding their performance characteristics, often expressed in terms of Big O notation, is crucial. Let's delve into the Big O analysis for vectors in C++.

Vectors in C++ are part of the Standard Template Library (STL) and provide dynamic array functionality. Here's a brief overview of some common operations on vectors and their corresponding Big O complexities:

1. **Accessing Elements by Index**:
   * Accessing an element by index: O(1)
   * This is because vectors provide constant-time random access, meaning accessing any element by its index takes the same amount of time regardless of the vector's size.

2. **Insertion and Deletion**:
   * Insertion or deletion at the end of the vector (push_back, pop_back): O(1) amortized
   * This is because vectors typically allocate more memory than needed, and when the vector is full and a new element is added, it reallocates memory, which has a linear cost. However, this reallocation happens infrequently, leading to an amortized constant time complexity.

   * Insertion or deletion at the beginning or in the middle of the vector: O(n)
   * When inserting or deleting elements at positions other than the end, elements need to be shifted to accommodate the change, resulting in a linear time complexity.

3. **Searching**:
   * Linear search (find): O(n)
   * This is because in the worst-case scenario, you may need to traverse the entire vector to find the element you are looking for.

   * Binary search (for sorted vectors): O(log n)
   * If the vector is sorted, binary search can be applied, which has a logarithmic time complexity.

4. **Sorting**:
   * Sorting the entire vector (sort): O(n log n)
   * The standard sort algorithm (usually implemented as an introsort, which is a hybrid sorting algorithm) has an average-case time complexity of O(n log n).

5. **Size and Capacity**:
   * Getting the size of the vector (size): O(1)
   * Getting the current size of the vector is a constant-time operation.

   * Getting the capacity of the vector (capacity): O(1)
   * Similarly, getting the current capacity of the vector is also a constant-time operation.

Overall, vectors in C++ are very efficient for random access and appending elements at the end. However, they might not be the best choice for frequent insertion or deletion operations at the beginning or middle of the vector, as those operations have a linear time complexity. For such cases, other data structures like linked lists or dequeues might be more suitable.

### 1. Algorithms & Data Structures (C++): Sorted Array

In the context of algorithms and data structures in C++, a sorted array is a common structure used to maintain elements in a specific order. Here's a comprehensive overview, including key concepts, operations, and example code.

#### Key Concepts

1. **Sorted Array**: An array where elements are maintained in a sorted order (ascending or descending).
2. **Advantages**:
   * **Fast Search**: Binary search can be used, providing O(log n) search time.
   * **Ordered Data**: Useful for algorithms that require ordered data, like merge sort or certain graph algorithms.
3. **Disadvantages**:
   * **Insertion and Deletion**: These operations can be slow, with O(n) complexity, since elements need to be shifted to maintain order.
   * **Fixed Size**: Static arrays have a fixed size, while dynamic arrays (like `std::vector` in C++) can resize but still have the same insertion and deletion complexity issues.

#### Basic Operations

1. **Search**: Use binary search for efficient look-up.
2. **Insertion**: Insert the new element at the correct position to maintain order.
3. **Deletion**: Remove an element and shift remaining elements to fill the gap.

#### Example Implementation in C++

Here is a simple implementation of a sorted array using a dynamic array (std::vector) in C++:

```cpp
#include <iostream>
#include <vector>
#include <algorithm> // for std::lower_bound

class SortedArray {
private:
    std::vector<int> data;

public:
    // Inserts a value while maintaining the sorted order
    void insert(int value) {
        auto pos = std::lower_bound(data.begin(), data.end(), value);
        data.insert(pos, value);
    }

    // Deletes a value if it exists
    bool remove(int value) {
        auto pos = std::lower_bound(data.begin(), data.end(), value);
        if (pos != data.end() && *pos == value) {
            data.erase(pos);
            return true;
        }
        return false; // Value not found
    }

    // Binary search for a value
    bool search(int value) const {
        auto pos = std::lower_bound(data.begin(), data.end(), value);
        return pos != data.end() && *pos == value;
    }

    // Display the array
    void display() const {
        for (int val : data) {
            std::cout << val << " ";
        }
        std::cout << std::endl;
    }
};

int main() {
    SortedArray sa;
    sa.insert(3);
    sa.insert(1);
    sa.insert(4);
    sa.insert(2);
    
    sa.display(); // Output: 1 2 3 4

    std::cout << "Searching for 3: " << (sa.search(3) ? "Found" : "Not Found") << std::endl;
    std::cout << "Searching for 5: " << (sa.search(5) ? "Found" : "Not Found") << std::endl;
    
    sa.remove(3);
    sa.display(); // Output: 1 2 4

    return 0;
}
```

#### Detailed Explanation

* **Insert Operation**:
  * Uses `std::lower_bound` to find the appropriate position to insert the new element to maintain order.
  * `std::lower_bound` performs a binary search, providing O(log n) time complexity for finding the position.
  * Insertion itself may take O(n) due to shifting elements.

* **Remove Operation**:
  * Again uses `std::lower_bound` to find the position of the element to be removed.
  * If the element is found, it is erased, and elements are shifted, making the operation O(n).

* **Search Operation**:
  * Uses `std::lower_bound` to check if the element exists in the array, providing O(log n) time complexity.

* **Display Operation**:
  * Simply iterates through the vector and prints the elements.

#### Usage

The `SortedArray` class can be used where ordered data is required and where the trade-off between insertion/deletion time and search time is acceptable. It is suitable for applications with frequent search operations but less frequent insertions and deletions.

#### Conclusion

Sorted arrays are a fundamental data structure with specific use cases where their strengths can be leveraged effectively. Understanding their properties and how to implement them in C++ is essential for many algorithmic problems.

### 1. Algorithms & Data Structures (C++): Static Vs Dynamic Arrays - Memory Layout of Main Memory

In C++, static arrays and dynamic arrays (commonly implemented as `std::array` and `std::vector`, respectively) have different memory layouts in main memory.

1. **Static Arrays:**
   * Memory for static arrays is allocated at compile time.
   * The size of a static array must be known at compile time.
   * Memory for static arrays is typically allocated on the stack or in the data segment of the program.
   * Static arrays have a fixed size, which cannot be changed at runtime.
   * Accessing elements of static arrays is typically faster than dynamic arrays because the compiler can optimize memory access patterns.

2. **Dynamic Arrays (std::vector in C++):**
   * Memory for dynamic arrays is allocated at runtime.
   * Dynamic arrays can resize dynamically as elements are added or removed.
   * Dynamic arrays typically use a heap memory allocation, managed by the `new` and `delete` operators or, in modern C++, by `std::allocator`.
   * Dynamic arrays have a more complex memory layout compared to static arrays. They typically consist of a pointer to the dynamically allocated memory block and additional metadata to keep track of the array's size and capacity.
   * Accessing elements of dynamic arrays might involve an additional level of indirection through the pointer to the data, which can introduce slight overhead compared to static arrays.

In terms of memory layout, a static array's memory is contiguous, meaning all elements are stored in adjacent memory locations. On the other hand, a dynamic array's memory might not be contiguous initially, and as elements are added and the array grows beyond its capacity, it might be reallocated to a new memory block, potentially leading to fragmentation.

### 1. Algorithms & Data Structures (C++): Array permutations

Array permutations involve generating all possible arrangements of a given array. In C++, this can be achieved using a backtracking approach or by utilizing the `std::next_permutation` function from the standard library. Here's a detailed explanation and implementation for both methods:

#### Method 1: Backtracking Approach

The backtracking approach recursively generates permutations by swapping elements.

##### Implementation

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

// Function to print the array
void printArray(const std::vector<int>& arr) {
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
}

// Helper function to generate permutations
void permute(std::vector<int>& arr, int start, int end) {
    if (start == end) {
        printArray(arr);
        return;
    }
    for (int i = start; i <= end; i++) {
        std::swap(arr[start], arr[i]);
        permute(arr, start + 1, end);
        std::swap(arr[start], arr[i]); // backtrack
    }
}

int main() {
    std::vector<int> arr = {1, 2, 3};
    permute(arr, 0, arr.size() - 1);
    return 0;
}
```

#### Method 2: Using `std::next_permutation`

The `std::next_permutation` function from the C++ Standard Library generates the next permutation in lexicographical order.

##### Implementation

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

// Function to print the array
void printArray(const std::vector<int>& arr) {
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
}

int main() {
    std::vector<int> arr = {1, 2, 3};
    // Sort the array to start with the smallest lexicographical permutation
    std::sort(arr.begin(), arr.end());

    do {
        printArray(arr);
    } while (std::next_permutation(arr.begin(), arr.end()));

    return 0;
}
```

#### Explanation

1. **Backtracking Approach:**
   * **Base Case:** When `start` equals `end`, it means we have generated a valid permutation, so we print it.
   * **Recursive Case:** We iterate through the array from `start` to `end`, swapping the `start` element with the current element at position `i`, recursively generate permutations for the next part of the array (`start + 1` to `end`), and then backtrack by swapping back.

2. **Using `std::next_permutation`:**
   * First, sort the array to ensure we start with the smallest permutation.
   * Use `std::next_permutation` in a loop to generate and print all possible permutations in lexicographical order until no more permutations are possible.

#### Summary

* The backtracking approach gives a more educational perspective on how permutations are generated by manipulating array elements recursively.
* The `std::next_permutation` method is simpler and leverages the power of the C++ Standard Library to handle permutations efficiently and elegantly.

Choose the method based on your preference or the requirements of your specific problem.

#### Complexity Analysis

##### Method 1: Backtracking Approach

###### Time Complexity

1. **Number of Permutations:** For an array of size \( n \), the total number of permutations is \( n! \) (factorial of \( n \)).
2. **Time per Permutation:** For each permutation, it takes \( O(n) \) time to print or handle the permutation.

Therefore, the total time complexity is \( O(n \times n!) \).

###### Space Complexity

1. **Recursive Call Stack:** The depth of the recursion tree is \( n \), so the maximum space used by the call stack is \( O(n) \).
2. **Auxiliary Space:** We use an array of size \( n \), but this is generally considered part of the input, so it doesn't count towards additional space complexity.

Thus, the space complexity is \( O(n) \) due to the recursion stack.

##### Method 2: Using `std::next_permutation`

###### Time Complexity

1. **Number of Permutations:** Again, the total number of permutations for an array of size \( n \) is \( n! \).
2. **Time per Permutation:** The `std::next_permutation` function generates the next permutation in \( O(n) \) time. This involves identifying the next lexicographical permutation and rearranging the elements.

Therefore, the total time complexity is \( O(n \times n!) \).

###### Space Complexity

1. **Auxiliary Space:** The `std::next_permutation` function itself operates in \( O(1) \) extra space, i.e., it only requires a constant amount of additional memory.
2. **Array Storage:** The input array requires \( O(n) \) space, which is part of the input.

Thus, the space complexity is \( O(1) \) for the function itself, considering the input array is part of the problem.

##### Summary of Complexity

* **Backtracking Approach:**
  * **Time Complexity:** \( O(n \times n!) \)
  * **Space Complexity:** \( O(n) \) due to the recursion stack.

* **Using `std::next_permutation`:**
  * **Time Complexity:** \( O(n \times n!) \)
  * **Space Complexity:** \( O(1) \) for the function itself (excluding input array storage).

Both methods have the same time complexity, but the `std::next_permutation` approach has an advantage in space complexity since it does not use additional stack space for recursion. However, the backtracking approach can be more intuitive and educational for understanding how permutations are generated.

### 1. Algorithms & Data Structures (C++): Array Products

Certainly! Let's discuss the problem of finding the product of all elements in an array except the current element for each position in the array. This problem can be solved efficiently using a combination of prefix and suffix products. Here's the detailed explanation and a C++ implementation.

#### Problem Statement

Given an array of integers, return an array such that each element at index `i` of the output array is the product of all the elements in the input array except the element at `i`.

#### Approach

1. **Create two auxiliary arrays:**
   * `prefixProducts` which stores the product of all elements before the current element.
   * `suffixProducts` which stores the product of all elements after the current element.

2. **Calculate prefix products:**
   * Initialize `prefixProducts[0]` to 1 (since there's no element before the first element).
   * Traverse the array from left to right and fill `prefixProducts` such that `prefixProducts[i]` is the product of all elements from the start up to the element just before `i`.

3. **Calculate suffix products:**
   * Initialize `suffixProducts[n-1]` to 1 (since there's no element after the last element).
   * Traverse the array from right to left and fill `suffixProducts` such that `suffixProducts[i]` is the product of all elements from the end up to the element just after `i`.

4. **Calculate result:**
   * For each element at index `i`, the result is the product of `prefixProducts[i]` and `suffixProducts[i]`.

This approach ensures that we do not use division and handles cases with zero values in the array.

#### C++ Implementation

```cpp
#include <iostream>
#include <vector>

std::vector<int> arrayProducts(const std::vector<int>& nums) {
    int n = nums.size();
    if (n == 0) return {};
    
    std::vector<int> prefixProducts(n, 1);
    std::vector<int> suffixProducts(n, 1);
    std::vector<int> result(n);

    // Fill prefix products
    for (int i = 1; i < n; ++i) {
        prefixProducts[i] = prefixProducts[i - 1] * nums[i - 1];
    }

    // Fill suffix products
    for (int i = n - 2; i >= 0; --i) {
        suffixProducts[i] = suffixProducts[i + 1] * nums[i + 1];
    }

    // Calculate result
    for (int i = 0; i < n; ++i) {
        result[i] = prefixProducts[i] * suffixProducts[i];
    }

    return result;
}

int main() {
    std::vector<int> nums = {1, 2, 3, 4};
    std::vector<int> result = arrayProducts(nums);

    for (int value : result) {
        std::cout << value << " ";
    }

    return 0;
}
```

#### Explanation

* **Prefix Products:**
  * Start with `prefixProducts[0] = 1` because there's no product before the first element.
  * For each element `i` from `1` to `n-1`, compute `prefixProducts[i]` as `prefixProducts[i-1] * nums[i-1]`.

* **Suffix Products:**
  * Start with `suffixProducts[n-1] = 1` because there's no product after the last element.
  * For each element `i` from `n-2` to `0`, compute `suffixProducts[i]` as `suffixProducts[i+1] * nums[i+1]`.

* **Result Array:**
  * For each element `i`, the result at `i` is the product of `prefixProducts[i]` and `suffixProducts[i]`.

This solution runs in O(n) time complexity and uses O(n) additional space, making it both time-efficient and space-efficient for large arrays.

### 1. Algorithms & Data Structures (C++): Array Stabilization

Array stabilization is a problem where you aim to modify an array such that the difference between the maximum and minimum values in any subarray of length \(k\) is minimized. This is a common type of problem in algorithmic challenges, and it typically involves understanding how to efficiently query and manipulate subarrays.

Let's go through an approach to solve this problem using C++.

#### Problem Statement

Given an array \(A\) of length \(n\), and an integer \(k\), find the minimum possible difference between the maximum and minimum values in any subarray of length \(k\).

#### Approach

1. **Sorting and Sliding Window**:
    * Sort the array.
    * Use a sliding window of size \(k\) on the sorted array to find the minimum difference between the maximum and minimum values in the window.

#### Steps

1. **Sort the Array**: Sorting helps in easily accessing the smallest and largest values within any subarray of length \(k\).
2. **Sliding Window Technique**: Use a window of size \(k\) to find the minimum difference between the maximum and minimum values in all possible subarrays of length \(k\).

#### Example

Suppose you have an array \(A = [3, 1, 4, 1, 5, 9]\) and \(k = 3\).

1. **Sort the Array**: \(A_{\text{sorted}} = [1, 1, 3, 4, 5, 9]\)
2. **Sliding Window**:
    * Subarray 1: \([1, 1, 3]\), difference = \(3 - 1 = 2\)
    * Subarray 2: \([1, 3, 4]\), difference = \(4 - 1 = 3\)
    * Subarray 3: \([3, 4, 5]\), difference = \(5 - 3 = 2\)
    * Subarray 4: \([4, 5, 9]\), difference = \(9 - 4 = 5\)

The minimum difference is \(2\).

#### Implementation in C++

Here’s a simple C++ implementation:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>

using namespace std;

int minDifference(vector<int>& arr, int k) {
    if (k <= 1) return 0;

    sort(arr.begin(), arr.end());

    int n = arr.size();
    int min_diff = INT_MAX;

    for (int i = 0; i <= n - k; ++i) {
        int current_diff = arr[i + k - 1] - arr[i];
        min_diff = min(min_diff, current_diff);
    }

    return min_diff;
}

int main() {
    vector<int> arr = {3, 1, 4, 1, 5, 9};
    int k = 3;

    cout << "The minimum possible difference is: " << minDifference(arr, k) << endl;

    return 0;
}
```

#### Explanation

1. **Sorting**: We first sort the array to simplify finding the smallest and largest elements within any subarray.
2. **Sliding Window**: By iterating over the array with a window of size \(k\), we calculate the difference between the first and last elements of the window.
3. **Minimum Difference**: Track the minimum difference encountered during the iteration.

#### Complexity

* **Time Complexity**: \(O(n \log n)\) due to sorting, and \(O(n)\) for the sliding window, making the overall complexity \(O(n \log n)\).
* **Space Complexity**: \(O(1)\) if we sort the array in place, or \(O(n)\) if we create a copy of the array for sorting.

This solution is efficient and straightforward for stabilizing an array as described.

### 1. Algorithms & Data Structures (C++): Arrays Question: Find first and last position of element in sorted Array

To find the first and last position of an element in a sorted array, you can utilize a binary search algorithm. This approach ensures that the solution runs in \(O(\log n)\) time complexity, which is efficient for large arrays.

Here's how you can implement this in C++:

1. **Binary Search for the First Occurrence**: Perform a binary search to find the first occurrence of the target element.
2. **Binary Search for the Last Occurrence**: Perform a binary search to find the last occurrence of the target element.

Let's break down the implementation step by step:

#### Step-by-Step Implementation

##### Function to Find the First Occurrence

```cpp
#include <vector>

int findFirst(const std::vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1;
    int result = -1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            result = mid;  // Update result and search in the left half
            right = mid - 1;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return result;
}

int findLast(const std::vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1;
    int result = -1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            result = mid;  // Update result and search in the right half
            left = mid + 1;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return result;
}

std::pair<int, int> findFirstAndLastPosition(const std::vector<int>& nums, int target) {
    int first = findFirst(nums, target);
    int last = findLast(nums, target);
    return {first, last};
}

int main() {
    std::vector<int> nums = {5, 7, 7, 8, 8, 10};
    int target = 8;

    std::pair<int, int> result = findFirstAndLastPosition(nums, target);

    std::cout << "First Position: " << result.first << std::endl;
    std::cout << "Last Position: " << result.second << std::endl;

    return 0;
}
```

#### Explanation

* **findFirst Function**: This function uses binary search to find the first occurrence of the target. If the middle element `nums[mid]` matches the target, it updates the result and continues searching in the left half to find the first occurrence.
* **findLast Function**: This function uses binary search to find the last occurrence of the target. If the middle element `nums[mid]` matches the target, it updates the result and continues searching in the right half to find the last occurrence.
* **findFirstAndLastPosition Function**: This function combines the results of `findFirst` and `findLast` to return a pair containing the first and last positions of the target element in the array.

This implementation is efficient and leverages the properties of binary search to ensure an optimal solution.

### 1. Algorithms & Data Structures (C++): Divide Array in Sets of K Consecutive Numbers

To solve the problem of dividing an array into sets of \( K \) consecutive numbers, we need to ensure that the array can be partitioned into subsets where each subset contains exactly \( K \) consecutive numbers. Here is a structured approach to solve this problem in C++:

1. **Sort the array**: This ensures that all elements in a potential subset are checked in order.
2. **Use a multiset**: This helps keep track of the frequencies of each number and allows efficient insertion and deletion of elements.

Here's a step-by-step implementation:

#### Step-by-Step Implementation

1. **Include necessary headers:**

   ```cpp
   #include <iostream>
   #include <vector>
   #include <set>
   ```

2. **Define the function:**

   ```cpp
   bool canDivideIntoSets(std::vector<int>& nums, int k) {
       if (nums.size() % k != 0) return false; // Early exit if total elements are not a multiple of k
       
       std::multiset<int> numSet(nums.begin(), nums.end()); // Create a multiset from the array

       while (!numSet.empty()) {
           int start = *numSet.begin(); // Get the smallest element

           for (int i = 0; i < k; ++i) {
               auto it = numSet.find(start + i); // Find the consecutive element
               if (it == numSet.end()) {
                   return false; // If any consecutive element is missing, return false
               }
               numSet.erase(it); // Erase the found element from the multiset
           }
       }

       return true;
   }
   ```

3. **Write the main function to test the solution:**

   ```cpp
   int main() {
       std::vector<int> nums = {1, 2, 3, 3, 4, 4, 5, 6};
       int k = 4;

       if (canDivideIntoSets(nums, k)) {
           std::cout << "The array can be divided into sets of " << k << " consecutive numbers." << std::endl;
       } else {
           std::cout << "The array cannot be divided into sets of " << k << " consecutive numbers." << std::endl;
       }

       return 0;
   }
   ```

#### Explanation

* **Sorting**: We start by sorting the array to simplify the process of finding consecutive numbers.
* **Using a multiset**: The multiset stores all elements and maintains order. It allows multiple occurrences of the same element.
* **Checking consecutive numbers**: By iterating through the smallest element each time, we ensure that we are always forming the smallest possible consecutive set first.
* **Erasing elements**: Once a number is included in a set, it is erased from the multiset, preventing it from being reused in another set.

#### Edge Cases

* **Array size not multiple of \( K \)**: If the size of the array is not a multiple of \( K \), it's impossible to divide it into sets of \( K \) consecutive numbers.
* **Missing consecutive elements**: If any required consecutive number is missing, return false.

This solution ensures that we efficiently check and form the required sets, leveraging the properties of multisets for ordered storage and quick access/removal of elements.

### 1. Algorithms & Data Structures (C++): Find K Closest Elements

#### Problem Statement

Given a sorted array `arr` and a value `x`, find the `k` closest elements to `x` in the array. The result should also be sorted in ascending order.

#### Approach

1. **Binary Search**: Find the position `low` where `x` would be inserted to keep the array sorted.
2. **Two-Pointer Technique**: Initialize two pointers around `low` and expand outwards to find the closest elements.

#### Steps

1. **Binary Search to Find Closest Element**: Use binary search to find the position where `x` would be inserted.
2. **Initialize Two Pointers**: Set one pointer to the left of the found position and the other to the right.
3. **Expand Pointers**: Move the pointers outwards to find the `k` closest elements.

#### Code Implementation

```cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>

using namespace std;

vector<int> findClosestElements(vector<int>& arr, int k, int x) {
    int n = arr.size();
    int low = 0, high = n - 1;
    
    // Binary search to find the closest position to x
    while (low < high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] < x) {
            low = mid + 1;
        } else {
            high = mid;
        }
    }
    
    // Initialize pointers for the two-pointer technique
    int left = low - 1;
    int right = low;
    
    // Result vector
    vector<int> result;
    
    // Find the k closest elements
    while (k--) {
        if (left < 0) {
            result.push_back(arr[right++]);
        } else if (right >= n) {
            result.push_back(arr[left--]);
        } else if (abs(arr[left] - x) <= abs(arr[right] - x)) {
            result.push_back(arr[left--]);
        } else {
            result.push_back(arr[right++]);
        }
    }
    
    // Sort the result as required
    sort(result.begin(), result.end());
    
    return result;
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int k = 4;
    int x = 3;
    
    vector<int> result = findClosestElements(arr, k, x);
    
    cout << "The " << k << " closest elements to " << x << " are: ";
    for (int num : result) {
        cout << num << " ";
    }
    cout << endl;
    
    return 0;
}
```

#### Explanation

1. **Binary Search**: The `low` and `high` variables are used to perform binary search. The loop continues until `low` and `high` converge, pointing to the position where `x` could be inserted.
2. **Two-Pointer Initialization**: `left` is initialized to `low - 1` and `right` to `low`. This setup ensures that we start comparing elements around the insertion point.
3. **Expanding Pointers**: The loop runs `k` times, choosing the closer element between `arr[left]` and `arr[right]` each time and pushing it into the result vector.
4. **Sorting the Result**: Finally, the result vector is sorted to maintain ascending order.

#### Complexity Analysis

* **Time Complexity**: The binary search runs in `O(log n)` time, and finding the `k` closest elements involves a linear scan of `k` elements. Sorting the `k` elements takes `O(k log k)` time. Overall, the complexity is `O(log n + k log k)`.
* **Space Complexity**: The space complexity is `O(k)` for storing the result.

This method ensures that the solution is efficient and handles the requirements of the problem effectively.

### 1. Algorithms & Data Structures (C++): Find Pivot Index

The "pivot index" problem is a common algorithmic challenge where you need to find an index in an array such that the sum of the elements to the left of the index is equal to the sum of the elements to the right. If no such index exists, you should return -1.

Here's a detailed explanation and a C++ implementation to solve this problem:

#### Problem Description

Given an array of integers `nums`, your task is to find the pivot index. The pivot index is defined as the index where the sum of all the numbers to the left of the index is equal to the sum of all the numbers to the right of the index. If there are multiple pivot indexes, you should return the left-most one. If no such index exists, return -1.

#### Approach

1. **Calculate the Total Sum**:
   * First, calculate the total sum of the array.

2. **Iterate and Calculate Left Sum**:
   * Iterate through the array while keeping track of the sum of elements to the left of the current index (`leftSum`).
   * For each index `i`, the right sum can be derived as `totalSum - leftSum - nums[i]`.
   * If `leftSum` equals the right sum at any index, return that index.
   * Update `leftSum` by adding the current element `nums[i]`.

3. **Return Result**:
   * If no pivot index is found, return -1.

#### C++ Implementation

Here's how you can implement this in C++:

```cpp
#include <vector>
#include <numeric> // for accumulate
#include <iostream>

class Solution {
public:
    int pivotIndex(std::vector<int>& nums) {
        int totalSum = std::accumulate(nums.begin(), nums.end(), 0);
        int leftSum = 0;
        
        for (int i = 0; i < nums.size(); ++i) {
            if (leftSum == totalSum - leftSum - nums[i]) {
                return i;
            }
            leftSum += nums[i];
        }
        
        return -1;
    }
};

int main() {
    Solution solution;
    std::vector<int> nums = {1, 7, 3, 6, 5, 6};
    int pivot = solution.pivotIndex(nums);
    std::cout << "Pivot index: " << pivot << std::endl; // Output should be 3
    return 0;
}
```

#### Explanation

1. **Include Necessary Headers**:
   * `#include <vector>`: For using `std::vector`.
   * `#include <numeric>`: For using `std::accumulate`.
   * `#include <iostream>`: For input and output operations.

2. **Calculate Total Sum**:
   * `int totalSum = std::accumulate(nums.begin(), nums.end(), 0);`
     * This line calculates the total sum of all elements in the vector `nums`.

3. **Iterate Through the Array**:
   * Use a for loop to iterate through each index of the array.
   * At each index, check if the left sum equals the right sum using the formula: `leftSum == totalSum - leftSum - nums[i]`.
   * If true, return the current index as the pivot index.

4. **Update Left Sum**:
   * After checking, add the current element `nums[i]` to `leftSum`.

5. **Return -1 if No Pivot Index Found**:
   * If the loop completes without finding a pivot index, return -1.

#### Example Execution

For the input `{1, 7, 3, 6, 5, 6}`:

* Total sum is `28`.
* The pivot index is `3` because the sum of elements to the left (`1 + 7 + 3 = 11`) equals the sum of elements to the right (`5 + 6 = 11`).

This implementation efficiently solves the pivot index problem with a time complexity of O(n), where n is the number of elements in the array, and a space complexity of O(1)

### 1. Algorithms & Data Structures (C++): Find Smallest missing positive number from an unsorted array

To find the smallest missing positive number in an unsorted array using C++, you can implement a solution with a time complexity of O(n) and space complexity of O(1). Here's how you can do it:

#### Approach

1. **Reorder the Array**: Use the array itself to record the presence of numbers. The idea is to place each positive integer `x` (1 ≤ x ≤ n) at the index `x-1`. This can be done by swapping elements.

2. **Identify the Missing Number**: After reordering the array, the first index that doesn't have the correct number (i.e., `array[i] != i+1`) indicates that `i+1` is the smallest missing positive number.

#### Implementation

```cpp
#include <iostream>
#include <vector>

int findSmallestMissingPositive(std::vector<int>& nums) {
    int n = nums.size();

    // Reorder the array elements
    for (int i = 0; i < n; ++i) {
        while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
            std::swap(nums[nums[i] - 1], nums[i]);
        }
    }

    // Find the first missing positive number
    for (int i = 0; i < n; ++i) {
        if (nums[i] != i + 1) {
            return i + 1;
        }
    }

    return n + 1;
}

int main() {
    std::vector<int> nums = {3, 4, -1, 1};
    std::cout << "The smallest missing positive number is: " << findSmallestMissingPositive(nums) << std::endl;
    return 0;
}
```

#### Explanation

1. **Reordering Step**:
    * The outer loop iterates over the array.
    * The inner `while` loop places each element in its correct position if it's in the range [1, n].
    * `std::swap(nums[nums[i] - 1], nums[i]);` swaps the current element to its correct position until the element at index `i` is either out of the range [1, n] or already in its correct position.

2. **Finding the Missing Number**:
    * After reordering, iterate through the array.
    * The first position `i` where `nums[i] != i + 1` indicates that `i + 1` is the smallest missing positive number.
    * If all positions are correctly filled, the smallest missing positive number is `n + 1`.

#### Complexity

* **Time Complexity**: O(n) because each element is swapped at most once.
* **Space Complexity**: O(1) since the reordering is done in place without using extra space.

This method efficiently finds the smallest missing positive number in an unsorted array.

### 1. Algorithms & Data Structures (C++): Find the duplicate

Certainly! Here's a simple algorithm in C++ to find duplicates in an array using a hash set:

```cpp
#include <iostream>
#include <unordered_set>
#include <vector>

std::vector<int> findDuplicates(const std::vector<int>& nums) {
    std::unordered_set<int> seen;
    std::vector<int> duplicates;
    
    for (int num : nums) {
        if (seen.count(num) == 0) {
            seen.insert(num);
        } else {
            duplicates.push_back(num);
        }
    }
    
    return duplicates;
}

int main() {
    std::vector<int> nums = {4, 3, 2, 7, 8, 2, 3, 1};
    std::vector<int> duplicates = findDuplicates(nums);
    
    if (duplicates.empty()) {
        std::cout << "No duplicates found." << std::endl;
    } else {
        std::cout << "Duplicates found: ";
        for (int num : duplicates) {
            std::cout << num << " ";
        }
        std::cout << std::endl;
    }
    
    return 0;
}
```

This code initializes an empty hash set to store seen elements and an empty vector to store duplicates. It iterates through the input array `nums`, for each element it checks if it's already in the hash set. If it's not, it adds it to the hash set. If it is, it adds the element to the `duplicates` vector. Finally, it returns the `duplicates` vector.

### 1. Algorithms & Data Structures (C++): Find the Duplicate Number - Sorting

To solve the "Find the Duplicate Number" problem using sorting in C++, you can follow these steps:

1. **Sort the array**: First, sort the array of numbers.
2. **Find the duplicate**: After sorting, the duplicate number will be next to itself in the sorted array, making it easy to identify.

Here's a detailed implementation:

#### Step-by-Step Implementation

1. **Include necessary headers**: You need to include headers for input/output and for the sorting function.
2. **Sort the array**: Use `std::sort` from the C++ Standard Library to sort the array.
3. **Find the duplicate**: Iterate through the sorted array to find the duplicate number.

#### Code

```cpp
#include <iostream>
#include <vector>
#include <algorithm> // for std::sort

int findDuplicate(std::vector<int>& nums) {
    // Step 1: Sort the array
    std::sort(nums.begin(), nums.end());
    
    // Step 2: Find the duplicate by checking adjacent elements
    for (size_t i = 1; i < nums.size(); ++i) {
        if (nums[i] == nums[i - 1]) {
            return nums[i];
        }
    }
    
    // If no duplicate is found (although the problem guarantees one)
    return -1; // This line should never be reached if input is valid
}

int main() {
    std::vector<int> nums = {3, 1, 3, 4, 2};
    int duplicate = findDuplicate(nums);
    std::cout << "The duplicate number is: " << duplicate << std::endl;
    return 0;
}
```

#### Explanation

1. **Sorting**: `std::sort(nums.begin(), nums.end());` sorts the array in non-decreasing order.
2. **Finding the duplicate**: The loop `for (size_t i = 1; i < nums.size(); ++i)` iterates through the sorted array, and `if (nums[i] == nums[i - 1])` checks if the current element is the same as the previous one, indicating a duplicate.

#### Complexity

* **Time Complexity**: Sorting the array takes \(O(n \log n)\), and the subsequent scan to find the duplicate takes \(O(n)\). Thus, the overall time complexity is \(O(n \log n)\).
* **Space Complexity**: Sorting in-place with `std::sort` uses \(O(1)\) additional space, so the space complexity is \(O(1)\) (not counting the input array).

This solution is efficient for medium-sized arrays and leverages the simplicity of sorting and linear scanning to find the duplicate number.

### 1. Algorithms & Data Structures (C++): Finding a Pair of Elements with sum K

To find a pair of elements in an array that sum up to a given value \( K \), you can use a hash set to store the elements as you iterate through the array. Here's how you can implement it in C++:

```cpp
#include <iostream>
#include <unordered_set>
#include <vector>

std::pair<int, int> findPairWithSumK(const std::vector<int>& nums, int K) {
    std::unordered_set<int> complements;

    for (int num : nums) {
        int complement = K - num;
        if (complements.find(complement) != complements.end()) {
            // Found the pair
            return std::make_pair(num, complement);
        }
        complements.insert(num);
    }

    // No pair found
    return std::make_pair(-1, -1);
}

int main() {
    std::vector<int> nums = {1, 4, 6, 8, 9};
    int K = 10;
    
    std::pair<int, int> result = findPairWithSumK(nums, K);
    
    if (result.first != -1 && result.second != -1) {
        std::cout << "Pair found: " << result.first << ", " << result.second << std::endl;
    } else {
        std::cout << "No pair found with sum " << K << std::endl;
    }

    return 0;
}
```

This code defines a function `findPairWithSumK` that takes a vector of integers `nums` and an integer `K` as input and returns a pair of integers representing the pair of elements that sum up to `K`. If no such pair is found, it returns (-1, -1).

In the `main` function, you can change the values of `nums` and `K` to test different cases. This algorithm has a time complexity of O(n) since it iterates through the array only once.

### 1. Algorithms & Data Structures (C++): Finding a Pair of Elements with sum K in Sorted Array

Certainly! Finding a pair of elements with a sum K in a sorted array can be efficiently done using the two-pointer technique. Here's how you can implement it in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Function to find the pair with given sum K
bool findPairWithSumK(const vector<int>& arr, int K) {
    int left = 0; // Index of the leftmost element
    int right = arr.size() - 1; // Index of the rightmost element

    while (left < right) {
        int currentSum = arr[left] + arr[right];

        if (currentSum == K) {
            cout << "Pair found: " << arr[left] << " + " << arr[right] << " = " << K << endl;
            return true;
        } else if (currentSum < K) {
            left++; // Move the left pointer to increase the sum
        } else {
            right--; // Move the right pointer to decrease the sum
        }
    }

    // If no pair found
    cout << "No pair found with sum " << K << endl;
    return false;
}

int main() {
    vector<int> arr = {1, 3, 5, 7, 9, 11, 13};
    int K = 14;

    findPairWithSumK(arr, K);

    return 0;
}
```

This code defines a function `findPairWithSumK` that takes a sorted array `arr` and a target sum `K` as input and finds a pair of elements in the array whose sum equals `K`. It uses two pointers `left` and `right` which start at the beginning and end of the array respectively and moves them towards each other based on the current sum of elements pointed to by the pointers.

The time complexity of this solution is O(n) since in the worst case, both pointers traverse the entire array once.

### 1. Algorithms & Data Structures (C++): Flip the array

Certainly! Flipping an array, commonly referred to as reversing an array, involves swapping its elements such that the first element becomes the last, the second element becomes the second last, and so on.

Here’s a simple C++ function to flip an array:

```cpp
#include <iostream>
#include <vector>

// Function to flip the array
void flipArray(std::vector<int>& arr) {
    int start = 0;
    int end = arr.size() - 1;
    while (start < end) {
        // Swap the elements at start and end
        std::swap(arr[start], arr[end]);
        // Move start forward and end backward
        start++;
        end--;
    }
}

int main() {
    std::vector<int> arr = {1, 2, 3, 4, 5};

    std::cout << "Original array: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    flipArray(arr);

    std::cout << "Flipped array: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

#### Explanation

1. **Swapping Logic**:
   * Initialize two pointers: `start` at the beginning of the array and `end` at the last element.
   * Use a `while` loop to swap elements until the `start` pointer is less than the `end` pointer.
   * Swap the elements at the `start` and `end` pointers using `std::swap`.
   * Increment the `start` pointer and decrement the `end` pointer to move towards the center of the array.

2. **Main Function**:
   * Initialize a vector `arr` with some elements.
   * Print the original array.
   * Call `flipArray(arr)` to flip the array.
   * Print the flipped array.

This code effectively demonstrates how to flip an array using C++. The swapping logic ensures that the array is reversed in-place, meaning no additional space is required beyond the original array.

### 1. Algorithms & Data Structures (C++): Kadane's Algorithm [RETURN]

Kadane's Algorithm is a classic algorithm used to find the maximum subarray sum within a given array of integers. It's quite efficient with a time complexity of O(n), where n is the size of the array. Here's how it works in C++:

```cpp
#include <iostream>
#include <vector>
#include <climits>

using namespace std;

int kadane(vector<int>& nums) {
    int maxEndingHere = 0;
    int maxSoFar = INT_MIN;

    for (int i = 0; i < nums.size(); ++i) {
        maxEndingHere = max(maxEndingHere + nums[i], nums[i]);
        maxSoFar = max(maxSoFar, maxEndingHere);
    }

    return maxSoFar;
}

int main() {
    // Example usage:
    vector<int> nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
    cout << "Maximum subarray sum: " << kadane(nums) << endl;
    return 0;
}
```

Explanation:

* `maxEndingHere` represents the maximum subarray sum ending at the current position.
* `maxSoFar` represents the maximum subarray sum seen so far.
* We iterate through the array, updating `maxEndingHere` at each step. If adding the current element to the previous subarray sum (`maxEndingHere + nums[i]`) increases the sum, we continue with the updated sum. Otherwise, we start a new subarray at the current element (`nums[i]`).
* At each step, we update `maxSoFar` with the maximum of `maxSoFar` and `maxEndingHere`.

The final `maxSoFar` will give us the maximum subarray sum.

### 1. Algorithms & Data Structures (C++): Kth Largest Element

To find the Kth largest element in an array, there are several approaches you can take. One common method is to use a priority queue (implemented as a max heap in C++).

Here's a basic implementation in C++:

```cpp
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

int findKthLargest(vector<int>& nums, int k) {
    // Create a max heap
    priority_queue<int> maxHeap;

    // Push all elements of the array into the max heap
    for (int num : nums) {
        maxHeap.push(num);
    }

    // Pop k-1 elements from the heap
    for (int i = 0; i < k - 1; ++i) {
        maxHeap.pop();
    }

    // The top element of the heap is the kth largest element
    return maxHeap.top();
}

int main() {
    vector<int> nums = {3, 2, 1, 5, 6, 4};
    int k = 2; // Find the 2nd largest element

    int kthLargest = findKthLargest(nums, k);
    cout << "The " << k << "th largest element is: " << kthLargest << endl;

    return 0;
}
```

This code first creates a max heap from the given array. Then, it pops elements from the heap k-1 times, effectively getting rid of the k-1 largest elements, leaving the kth largest element at the top of the heap.

Remember to handle cases where k might be larger than the array size or negative numbers. Additionally, you can optimize this approach further using a min heap or the quickselect algorithm for better performance.

### 1. Algorithms & Data Structures (C++): Max Consecutive Ones

To find the maximum number of consecutive ones in an array of 0s and 1s using C++, you can iterate through the array and keep track of the current consecutive ones count and the maximum consecutive ones count encountered so far. Here's a simple implementation:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int findMaxConsecutiveOnes(vector<int>& nums) {
    int maxCount = 0;
    int count = 0;

    for (int num : nums) {
        if (num == 1) {
            count++;
            maxCount = max(maxCount, count);
        } else {
            count = 0;
        }
    }

    return maxCount;
}

int main() {
    vector<int> nums = {1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1};
    cout << "Maximum consecutive ones: " << findMaxConsecutiveOnes(nums) << endl;
    return 0;
}
```

This code defines a function `findMaxConsecutiveOnes` that takes a vector of integers as input and returns the maximum number of consecutive ones. In the `main` function, we create a sample array `nums`, call the function, and output the result.

This algorithm has a time complexity of O(n), where n is the length of the input array `nums`.

### 1. Algorithms & Data Structures (C++): Move Zeroes

Moving zeroes to the end of an array is a common problem in coding interviews and algorithmic practice. The task is to rearrange the elements of the array so that all zeroes appear at the end, while maintaining the relative order of non-zero elements. Here's a C++ implementation:

```cpp
#include <iostream>
#include <vector>

using namespace std;

void moveZeroes(vector<int>& nums) {
    int n = nums.size();
    int zeroIndex = 0; // Index to place the next non-zero element

    // Traverse the array
    for (int i = 0; i < n; i++) {
        if (nums[i] != 0) {
            // If the current element is non-zero, move it to the position of zeroIndex
            nums[zeroIndex] = nums[i];
            // Increment zeroIndex to prepare for the next non-zero element
            zeroIndex++;
        }
    }

    // After moving non-zero elements, fill the rest of the array with zeroes
    for (int i = zeroIndex; i < n; i++) {
        nums[i] = 0;
    }
}

int main() {
    vector<int> nums = {0, 1, 0, 3, 12};
    
    cout << "Original Array: ";
    for (int num : nums) {
        cout << num << " ";
    }
    cout << endl;

    moveZeroes(nums);

    cout << "Array after moving zeroes: ";
    for (int num : nums) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}
```

This code defines a function `moveZeroes` that takes a reference to a vector of integers `nums` and rearranges its elements as required. The `main` function demonstrates the usage of this function with a sample array.

### 1. Algorithms & Data Structures (C++): Problem DIVSUB [RETURN]

The DIVSUB problem involves finding a non-empty contiguous subsequence of an array whose sum is divisible by a given number \( k \). Here's a way to solve it in C++:

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>

using namespace std;

pair<int, int> findSubsequence(vector<int>& arr, int k) {
    unordered_map<int, int> modIndex; // Store the index of the first occurrence of each modulo
    int sum = 0;
    modIndex[0] = -1; // Required for handling the case when the whole array is divisible by k
    for (int i = 0; i < arr.size(); ++i) {
        sum = (sum + arr[i]) % k;
        if (modIndex.find(sum) != modIndex.end()) {
            return {modIndex[sum] + 1, i}; // Found a subsequence
        }
        modIndex[sum] = i;
    }
    return {-1, -1}; // No such subsequence found
}

int main() {
    int n, k;
    cin >> n >> k;
    vector<int> arr(n);
    for (int i = 0; i < n; ++i) {
        cin >> arr[i];
    }

    pair<int, int> result = findSubsequence(arr, k);
    if (result.first == -1) {
        cout << "-1\n";
    } else {
        cout << result.first + 1 << " " << result.second + 1 << endl;
    }

    return 0;
}
```

Explanation:

* We use an unordered map to store the index of the first occurrence of each modulo of the cumulative sum of the array elements.
* If at any point, the same modulo occurs again, it means that the subsequence between the two indices has a sum divisible by \( k \).
* We store the indices in the unordered map to find the length of the subsequence.
* We return the indices of the subsequence as a pair.
* If no such subsequence is found, we return {-1, -1}.

This solution has a time complexity of \( O(n) \) where \( n \) is the size of the array.

### 1. Algorithms & Data Structures (C++): Reversing using Sliding Pointers

In C++, reversing an array or a sequence using sliding pointers is a common technique. The idea is to use two pointers, typically starting from the two ends of the array, and swap elements iteratively until they meet in the middle. Here's a simple example of how you can implement this algorithm:

```cpp
#include <iostream>

void reverseArray(int arr[], int size) {
    // Initialize two pointers, one pointing to the beginning and
    // the other pointing to the end of the array
    int start = 0;
    int end = size - 1;

    // Swap elements until the pointers meet in the middle
    while (start < end) {
        // Swap arr[start] and arr[end]
        int temp = arr[start];
        arr[start] = arr[end];
        arr[end] = temp;

        // Move the pointers towards the middle
        start++;
        end--;
    }
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int size = sizeof(arr) / sizeof(arr[0]);

    std::cout << "Original array: ";
    for (int i = 0; i < size; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;

    // Reverse the array
    reverseArray(arr, size);

    std::cout << "Reversed array: ";
    for (int i = 0; i < size; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

In this code:

* The `reverseArray` function takes an integer array `arr` and its size `size` as parameters.
* Two pointers `start` and `end` are initialized at the beginning and end of the array, respectively.
* The function iterates over the array, swapping elements pointed to by `start` and `end` until `start` becomes greater than or equal to `end`.
* The `main` function demonstrates how to use the `reverseArray` function to reverse an array and prints the original and reversed arrays.

This technique is efficient, as it only requires a single pass through the array, resulting in a time complexity of O(n/2) or simply O(n), where n is the number of elements in the array.

### 1. Algorithms & Data Structures (C++): Squares of a Sorted Array

Certainly! The problem "Squares of a Sorted Array" involves taking an array of integers, squaring each integer, and returning an array of squared integers in non-decreasing order. Here's a C++ implementation for this problem:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

vector<int> sortedSquares(vector<int>& nums) {
    int n = nums.size();
    vector<int> result(n);
    
    int left = 0, right = n - 1;
    int index = n - 1;
    
    while (left <= right) {
        int leftSq = nums[left] * nums[left];
        int rightSq = nums[right] * nums[right];
        
        if (leftSq > rightSq) {
            result[index] = leftSq;
            left++;
        } else {
            result[index] = rightSq;
            right--;
        }
        index--;
    }
    
    return result;
}

int main() {
    vector<int> nums = {-4, -1, 0, 3, 10};
    vector<int> result = sortedSquares(nums);

    cout << "Squared sorted array: ";
    for (int num : result) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}
```

This implementation utilizes a two-pointer approach where one pointer starts at the beginning of the array and the other at the end. We square the elements pointed by these pointers and put the larger squared value into the result array, moving the pointers accordingly. Finally, we return the result array.

### 1. Algorithms & Data Structures (C++): Subarray Sort [RETURN]

Subarray sort is a common problem in algorithmic interviews and competitive programming. The task is to find the shortest subarray within a given array that needs to be sorted in order for the entire array to become sorted.

Here's a C++ implementation of an algorithm to solve this problem:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

pair<int, int> findUnsortedSubarray(vector<int>& nums) {
    int n = nums.size();
    int left = 0, right = n - 1;
    
    // Find the left boundary of the unsorted subarray
    while (left < n - 1 && nums[left] <= nums[left + 1]) left++;
    
    // If the array is already sorted
    if (left == n - 1) return {-1, -1};
    
    // Find the right boundary of the unsorted subarray
    while (right > 0 && nums[right] >= nums[right - 1]) right--;
    
    // Find the minimum and maximum values within the unsorted subarray
    int min_val = *min_element(nums.begin() + left, nums.begin() + right + 1);
    int max_val = *max_element(nums.begin() + left, nums.begin() + right + 1);
    
    // Expand the left boundary if necessary
    while (left >= 0 && nums[left] > min_val) left--;
    
    // Expand the right boundary if necessary
    while (right < n && nums[right] < max_val) right++;
    
    return {left + 1, right - 1};
}

int main() {
    vector<int> nums = {1, 3, 5, 4, 2, 6, 7};
    pair<int, int> result = findUnsortedSubarray(nums);
    
    if (result.first == -1 && result.second == -1)
        cout << "The array is already sorted.\n";
    else
        cout << "The unsorted subarray lies between indices " << result.first << " and " << result.second << ".\n";
    
    return 0;
}
```

This code first finds the left boundary of the unsorted subarray by iterating from the beginning of the array until it finds the first decreasing element. Then, it finds the right boundary by iterating from the end of the array until it finds the first increasing element. After that, it finds the minimum and maximum values within this subarray. Finally, it expands the left and right boundaries as necessary to include any elements that need to be sorted.

You can test this code with different arrays to see how it performs.

### 1. Algorithms & Data Structures (C++): Subarray Sum Divisible by N [RETURN]

To find the number of subarrays whose sum is divisible by a given number N, you can utilize the concept of prefix sums and modular arithmetic. Here's how you can implement it in C++:

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>

using namespace std;

int subarraysDivByK(vector<int>& A, int K) {
    unordered_map<int, int> remainderCount;
    remainderCount[0] = 1; // Initialize with one subarray whose sum is divisible by K
    int sum = 0;
    int count = 0;
    
    for (int num : A) {
        sum = (sum + num) % K; // Calculate the cumulative sum modulo K
        if (sum < 0) sum += K; // Ensure sum is positive
        
        // If there exists a subarray whose sum is divisible by K,
        // it means that the difference between two prefix sums is divisible by K.
        // So, we count how many prefix sums have the same remainder when divided by K.
        count += remainderCount[sum];
        
        // Update the count for the current remainder
        remainderCount[sum]++;
    }
    
    return count;
}

int main() {
    vector<int> A = {4, 5, 0, -2, -3, 1};
    int K = 5;
    cout << "Number of subarrays divisible by " << K << ": " << subarraysDivByK(A, K) << endl;
    return 0;
}
```

This code will output the number of subarrays whose sum is divisible by the given number `K`.

Here's a brief explanation of how it works:

1. We maintain a map `remainderCount` to store the count of remainders obtained when the cumulative sum of elements is divided by `K`.
2. We initialize `remainderCount[0]` with 1 to handle the case when the sum of elements up to the current index is divisible by `K`.
3. We iterate through the array, updating the cumulative sum modulo `K`.
4. If the current sum modulo `K` exists in `remainderCount`, it means there exists a subarray whose sum is divisible by `K`. We update the count accordingly.
5. We update `remainderCount` with the current sum modulo `K`.
6. Finally, we return the count of subarrays found.

### 1. Algorithms & Data Structures (C++): Subarray Sum: Kadane's Algorithm [RETURN]

Kadane's Algorithm is a well-known technique for finding the maximum sum subarray within a given array of integers. It's particularly efficient with a time complexity of O(n), where n is the size of the array. Here's how you can implement Kadane's Algorithm in C++:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int maxSubArraySum(vector<int>& nums) {
    int maxSum = nums[0];
    int currentSum = nums[0];

    for (int i = 1; i < nums.size(); ++i) {
        currentSum = max(nums[i], currentSum + nums[i]);
        maxSum = max(maxSum, currentSum);
    }

    return maxSum;
}

int main() {
    vector<int> nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
    cout << "Maximum sum of subarray: " << maxSubArraySum(nums) << endl;
    return 0;
}
```

In this implementation:

1. `maxSum` keeps track of the maximum sum found so far.
2. `currentSum` keeps track of the sum of the current subarray being processed.
3. We iterate through the array, updating `currentSum` to be the maximum of the current element or the sum of the current element and the previous subarray sum.
4. We update `maxSum` to be the maximum of the current `maxSum` and `currentSum`.
5. Finally, we return `maxSum`, which represents the maximum sum of any subarray in the given array.

This algorithm is particularly useful when you only need the sum of the subarray and not the actual subarray itself. It's also very efficient, as it only requires a single pass through the array.

### 1. Algorithms & Data Structures (C++): Vector: Max Sub Array [RETURN]

The maximum subarray problem is a classic algorithmic problem where the task is to find the contiguous subarray within a one-dimensional array, containing at least one number, which has the largest sum. This problem can be solved efficiently using various algorithms, one of the most popular being Kadane's algorithm.

Here's how you can implement Kadane's algorithm in C++ to find the maximum subarray sum:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int maxSubArray(vector<int>& nums) {
    int maxSum = nums[0];
    int currentSum = nums[0];

    for (int i = 1; i < nums.size(); ++i) {
        // Choose between extending the previous subarray or start a new subarray
        currentSum = max(nums[i], currentSum + nums[i]);
        // Update maxSum if the current sum is greater
        maxSum = max(maxSum, currentSum);
    }

    return maxSum;
}

int main() {
    vector<int> nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
    cout << "Maximum subarray sum: " << maxSubArray(nums) << endl;
    return 0;
}
```

This code snippet defines the `maxSubArray` function which takes a vector of integers `nums` and returns the maximum subarray sum. The algorithm iterates through the array once, maintaining two variables `currentSum` and `maxSum`. `currentSum` tracks the maximum sum of subarrays ending at the current position, while `maxSum` keeps track of the overall maximum sum found so far. At each step, it decides whether to start a new subarray or extend the previous one based on which choice yields a larger sum. Finally, it returns the `maxSum`, which represents the maximum subarray sum.
