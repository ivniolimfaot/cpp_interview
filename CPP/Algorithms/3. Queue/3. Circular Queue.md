### 1. Algorithms & Data Structures (C++): Circular Queue

A Circular Queue is a data structure that serves as a queue where the last position is connected back to the first position to make a circle. It overcomes the limitation of a standard queue where insertion can cause overflow and deletion can cause underflow. Circular queues efficiently utilize memory and can be implemented using arrays.

Here's a simple implementation of a Circular Queue in C++:

```cpp
#include <iostream>
using namespace std;

#define SIZE 5

class CircularQueue {
private:
    int front, rear;
    int items[SIZE];

public:
    CircularQueue() {
        front = -1;
        rear = -1;
    }

    // Check if the queue is full
    bool isFull() {
        if ((front == 0 && rear == SIZE - 1) || (rear == front - 1))
            return true;
        return false;
    }

    // Check if the queue is empty
    bool isEmpty() {
        if (front == -1)
            return true;
        return false;
    }

    // Add an element to the queue
    void enqueue(int element) {
        if (isFull()) {
            cout << "Queue is full\n";
            return;
        }
        if (front == -1)
            front = 0;
        rear = (rear + 1) % SIZE;
        items[rear] = element;
        cout << element << " enqueued to queue\n";
    }

    // Remove an element from the queue
    int dequeue() {
        int element;
        if (isEmpty()) {
            cout << "Queue is empty\n";
            return -1;
        }
        element = items[front];
        if (front == rear) {
            front = -1;
            rear = -1;
        } else {
            front = (front + 1) % SIZE;
        }
        return element;
    }

    // Display the elements of the queue
    void display() {
        int i;
        if (isEmpty()) {
            cout << "Queue is empty\n";
            return;
        }
        cout << "Front -> ";
        for (i = front; i != rear; i = (i + 1) % SIZE)
            cout << items[i] << " ";
        cout << items[i] << " ";
        cout << "<- Rear\n";
    }
};

int main() {
    CircularQueue q;

    // Adding elements to Circular Queue
    q.enqueue(10);
    q.enqueue(20);
    q.enqueue(30);
    q.enqueue(40);

    // Display elements present in Circular Queue
    q.display();

    // Deleting elements from Circular Queue
    cout << "Deleted value = " << q.dequeue() << endl;
    cout << "Deleted value = " << q.dequeue() << endl;

    // Remaining elements in Circular Queue
    q.display();

    q.enqueue(50);
    q.enqueue(60);
    q.enqueue(70);

    // Display elements present in Circular Queue
    q.display();

    return 0;
}
```

This implementation includes the basic operations of a Circular Queue:

* **enqueue**: Adds an element to the rear of the queue.
* **dequeue**: Removes an element from the front of the queue.
* **isFull**: Checks if the queue is full.
* **isEmpty**: Checks if the queue is empty.
* **display**: Displays the elements of the queue.

The circular nature of the queue is handled by using the modulo operator (%) to wrap around the rear index when it reaches the end of the array.

### 1. Algorithms & Data Structures (C++): Circular Queue (Implementation)

Certainly! Implementing a circular queue in C++ involves creating a data structure that allows for efficient insertion and deletion operations from both ends of the queue. Here's a basic implementation:

```cpp
#include <iostream>

using namespace std;

class CircularQueue {
private:
    int front, rear, capacity;
    int *arr;

public:
    CircularQueue(int size) {
        capacity = size;
        arr = new int[capacity];
        front = rear = -1;
    }

    ~CircularQueue() {
        delete[] arr;
    }

    // Function to enqueue an element
    void enqueue(int element) {
        if ((rear + 1) % capacity == front) {
            cout << "Queue is full. Enqueue operation failed.\n";
            return;
        }

        if (isEmpty())
            front = 0;

        rear = (rear + 1) % capacity;
        arr[rear] = element;
        cout << element << " enqueued to the queue.\n";
    }

    // Function to dequeue an element
    int dequeue() {
        if (isEmpty()) {
            cout << "Queue is empty. Dequeue operation failed.\n";
            return -1;
        }

        int dequeuedElement = arr[front];
        if (front == rear)
            front = rear = -1;
        else
            front = (front + 1) % capacity;

        return dequeuedElement;
    }

    // Function to check if the queue is empty
    bool isEmpty() {
        return front == -1;
    }

    // Function to check if the queue is full
    bool isFull() {
        return (rear + 1) % capacity == front;
    }

    // Function to get the front element of the queue
    int peek() {
        if (isEmpty()) {
            cout << "Queue is empty. Peek operation failed.\n";
            return -1;
        }
        return arr[front];
    }

    // Function to display the elements of the queue
    void display() {
        if (isEmpty()) {
            cout << "Queue is empty.\n";
            return;
        }

        cout << "Elements in the queue are: ";
        int i = front;
        do {
            cout << arr[i] << " ";
            i = (i + 1) % capacity;
        } while (i != (rear + 1) % capacity);
        cout << endl;
    }
};

int main() {
    CircularQueue cq(5);

    cq.enqueue(1);
    cq.enqueue(2);
    cq.enqueue(3);
    cq.enqueue(4);
    cq.enqueue(5);
    cq.enqueue(6); // Should fail, as the queue is full

    cq.display();

    cout << "Dequeued: " << cq.dequeue() << endl;
    cout << "Dequeued: " << cq.dequeue() << endl;

    cq.display();

    cq.enqueue(6); // Should work, as there's space now
    cq.display();

    return 0;
}
```

This implementation uses an array to store the elements of the queue and maintains two pointers `front` and `rear` to keep track of the front and rear ends of the queue respectively. The modulo operation is used to ensure circular behavior when incrementing these pointers.

### 1. Algorithms & Data Structures (C++): Circular Queue (Theory)

A Circular Queue is a data structure that behaves like a normal queue (FIFO - First In, First Out), but with a fixed size. The main difference between a circular queue and a regular queue is that once the queue becomes full, instead of refusing to accept more elements, it starts overwriting the oldest elements in the queue.

Here's the basic theory behind implementing a Circular Queue in C++:

#### 1. Implementation

In C++, you can implement a Circular Queue using an array and two pointers, `front` and `rear`.

* `front`: points to the first element of the queue.
* `rear`: points to the last element of the queue.

Initially, both `front` and `rear` are set to `-1`.

#### 2. Operations

* **Enqueue (Insertion)**: To insert an element into the circular queue, you move the `rear` pointer to the next available position and insert the element there.

* **Dequeue (Deletion)**: To remove an element from the circular queue, you move the `front` pointer to the next available position and remove the element from there.

#### 3. Handling Circular Nature

Since the queue is circular, after reaching the end of the array, the `rear` pointer wraps around to the beginning, and similarly, after reaching the end, the `front` pointer wraps around to the beginning as well.

#### 4. Overflow and Underflow Conditions

* **Overflow**: Occurs when you try to insert an element into a full queue.
* **Underflow**: Occurs when you try to remove an element from an empty queue.

#### 5. Implementation Tips

* Always check for overflow and underflow conditions.
* Ensure to update the pointers correctly after every insertion and deletion operation.
* Handle the circular nature of the queue properly to avoid incorrect behavior.

#### Sample Code (Partial Implementation)

Here's a simplified implementation of a Circular Queue in C++:

```cpp
#include <iostream>
using namespace std;

#define SIZE 5

class CircularQueue {
private:
    int arr[SIZE];
    int front, rear;

public:
    CircularQueue() {
        front = rear = -1;
    }

    // Function to check if queue is full
    bool isFull() {
        return (front == 0 && rear == SIZE - 1) || (rear == (front - 1) % (SIZE - 1));
    }

    // Function to check if queue is empty
    bool isEmpty() {
        return front == -1;
    }

    // Function to insert an element into the queue
    void enqueue(int value) {
        if (isFull()) {
            cout << "Queue is full!" << endl;
            return;
        }
        if (front == -1)
            front = 0;
        rear = (rear + 1) % SIZE;
        arr[rear] = value;
        cout << value << " enqueued to queue." << endl;
    }

    // Function to remove an element from the queue
    int dequeue() {
        int value;
        if (isEmpty()) {
            cout << "Queue is empty!" << endl;
            return -1;
        }
        value = arr[front];
        if (front == rear)
            front = rear = -1;
        else
            front = (front + 1) % SIZE;
        return value;
    }

    // Function to display the elements of the queue
    void display() {
        if (isEmpty()) {
            cout << "Queue is empty!" << endl;
            return;
        }
        int i = front;
        do {
            cout << arr[i] << " ";
            i = (i + 1) % SIZE;
        } while (i != (rear + 1) % SIZE);
        cout << endl;
    }
};

int main() {
    CircularQueue q;
    q.enqueue(10);
    q.enqueue(20);
    q.enqueue(30);
    q.enqueue(40);
    q.enqueue(50);
    q.enqueue(60); // Queue is full
    cout << "Queue: ";
    q.display();
    cout << "Dequeued: " << q.dequeue() << endl;
    cout << "Queue: ";
    q.display();
    return 0;
}
```

This code provides a basic implementation of a Circular Queue in C++. You can extend it further by adding additional functionalities like peek, clear, etc., as per your requirements.

### 1. Algorithms & Data Structures (C++): Circular Queue Operations

Certainly! A circular queue is a data structure that operates much like a regular queue, but it wraps around itself. This means that when an element is dequeued, the space it occupied becomes available for future enqueue operations. Here's a basic implementation of circular queue operations in C++:

```cpp
#include <iostream>

using namespace std;

class CircularQueue {
private:
    int *arr;
    int front, rear, maxSize;
public:
    CircularQueue(int size) {
        maxSize = size;
        arr = new int[maxSize];
        front = rear = -1;
    }

    ~CircularQueue() {
        delete[] arr;
    }

    bool isEmpty() {
        return front == -1;
    }

    bool isFull() {
        return (front == 0 && rear == maxSize - 1) || (rear == (front - 1) % (maxSize - 1));
    }

    void enqueue(int item) {
        if (isFull()) {
            cout << "Queue is full, cannot enqueue " << item << endl;
            return;
        }

        if (isEmpty()) {
            front = rear = 0;
        } else {
            rear = (rear + 1) % maxSize;
        }
        arr[rear] = item;
        cout << item << " enqueued to queue" << endl;
    }

    int dequeue() {
        if (isEmpty()) {
            cout << "Queue is empty, cannot dequeue" << endl;
            return -1;
        }

        int item = arr[front];
        if (front == rear) {
            front = rear = -1;
        } else {
            front = (front + 1) % maxSize;
        }
        cout << item << " dequeued from queue" << endl;
        return item;
    }

    void display() {
        if (isEmpty()) {
            cout << "Queue is empty" << endl;
            return;
        }

        cout << "Elements in circular queue are:" << endl;
        if (rear >= front) {
            for (int i = front; i <= rear; i++)
                cout << arr[i] << " ";
        } else {
            for (int i = front; i < maxSize; i++)
                cout << arr[i] << " ";
            for (int i = 0; i <= rear; i++)
                cout << arr[i] << " ";
        }
        cout << endl;
    }
};

int main() {
    CircularQueue cq(5);

    cq.enqueue(10);
    cq.enqueue(20);
    cq.enqueue(30);
    cq.enqueue(40);
    cq.enqueue(50);

    cq.display();

    cout << "Dequeued item: " << cq.dequeue() << endl;
    cout << "Dequeued item: " << cq.dequeue() << endl;

    cq.display();

    cq.enqueue(60);
    cq.enqueue(70);

    cq.display();

    return 0;
}
```

This code demonstrates the basic operations of a circular queue:

1. `enqueue`: Adds an element to the rear of the queue.
2. `dequeue`: Removes and returns the element from the front of the queue.
3. `isEmpty`: Checks if the queue is empty.
4. `isFull`: Checks if the queue is full.
5. `display`: Displays the elements of the queue.

In this implementation, the circular nature of the queue is achieved by using modulo operations to wrap around the indices of the array representing the queue.

### 1. Algorithms & Data Structures (C++): Circular queue: dequeue

Certainly! A circular queue is a data structure that follows the First In First Out (FIFO) principle, where elements are inserted at the rear and removed from the front.

In C++, you can implement a circular queue using an array. Here's a basic implementation of the `dequeue` operation for a circular queue:

```cpp
#include <iostream>
using namespace std;

#define MAX_SIZE 100

class CircularQueue {
private:
    int front, rear;
    int arr[MAX_SIZE];

public:
    CircularQueue() {
        front = rear = -1;
    }

    // Function to check if the queue is empty
    bool isEmpty() {
        return (front == -1 && rear == -1);
    }

    // Function to check if the queue is full
    bool isFull() {
        return (rear + 1) % MAX_SIZE == front;
    }

    // Function to enqueue an element
    void enqueue(int value) {
        if (isFull()) {
            cout << "Queue is full. Cannot enqueue.\n";
            return;
        } else if (isEmpty()) {
            front = rear = 0;
        } else {
            rear = (rear + 1) % MAX_SIZE;
        }
        arr[rear] = value;
    }

    // Function to dequeue an element
    void dequeue() {
        if (isEmpty()) {
            cout << "Queue is empty. Cannot dequeue.\n";
            return;
        } else if (front == rear) {
            // If there's only one element in the queue
            front = rear = -1;
        } else {
            front = (front + 1) % MAX_SIZE;
        }
    }

    // Function to display the elements in the queue
    void display() {
        if (isEmpty()) {
            cout << "Queue is empty.\n";
            return;
        }

        int i = front;
        cout << "Queue elements: ";
        do {
            cout << arr[i] << " ";
            i = (i + 1) % MAX_SIZE;
        } while (i != (rear + 1) % MAX_SIZE);
        cout << endl;
    }
};

int main() {
    CircularQueue q;
    q.enqueue(1);
    q.enqueue(2);
    q.enqueue(3);
    q.display();

    q.dequeue();
    q.display();

    q.enqueue(4);
    q.display();

    q.dequeue();
    q.dequeue();
    q.dequeue();
    q.display();

    return 0;
}
```

In this implementation:

* `dequeue()` removes an element from the front of the circular queue. If the queue becomes empty after removal, it updates the front and rear pointers accordingly.
* The circular nature of the queue is handled using the modulo operator `% MAX_SIZE` to wrap around the array when it reaches the end.
* `front` and `rear` are indices pointing to the front and rear elements of the queue respectively.
* `MAX_SIZE` defines the maximum capacity of the circular queue.

### 1. Algorithms & Data Structures (C++): Circular queue: enqueue

To implement the enqueue operation for a circular queue in C++, you need to consider the following steps:

1. Check if the circular queue is full.
2. If it's not full, insert the element at the rear of the queue.
3. Update the rear pointer to the next position.
4. Handle the circular aspect of the queue by considering wrapping around the end of the array if necessary.

Here's a sample implementation:

```cpp
#include <iostream>

#define MAX_SIZE 100

class CircularQueue {
private:
    int front, rear;
    int arr[MAX_SIZE];

public:
    CircularQueue() {
        front = rear = -1;
    }

    // Function to check if the queue is full
    bool isFull() {
        return (front == 0 && rear == MAX_SIZE - 1) || (rear == (front - 1) % (MAX_SIZE - 1));
    }

    // Function to check if the queue is empty
    bool isEmpty() {
        return front == -1;
    }

    // Function to add an element to the queue
    void enqueue(int data) {
        if (isFull()) {
            std::cout << "Queue is full. Cannot enqueue.\n";
            return;
        }

        if (front == -1) {
            front = rear = 0;
        } else {
            rear = (rear + 1) % MAX_SIZE;
        }

        arr[rear] = data;
        std::cout << data << " enqueued to the queue.\n";
    }

    // Function to display elements of the queue
    void display() {
        if (isEmpty()) {
            std::cout << "Queue is empty.\n";
            return;
        }

        int i = front;
        do {
            std::cout << arr[i] << " ";
            i = (i + 1) % MAX_SIZE;
        } while (i != (rear + 1) % MAX_SIZE);
        std::cout << std::endl;
    }
};

int main() {
    CircularQueue q;

    q.enqueue(10);
    q.enqueue(20);
    q.enqueue(30);
    q.enqueue(40);
    q.enqueue(50);

    q.display();

    return 0;
}
```

In this implementation:

* `MAX_SIZE` defines the maximum capacity of the circular queue.
* `front` and `rear` are pointers to the front and rear elements of the queue, respectively.
* The `enqueue()` function adds an element to the queue.
* The `isFull()` and `isEmpty()` functions check if the queue is full or empty, respectively.
* The `display()` function is used to display the elements of the queue.

### 1. Algorithms & Data Structures (C++): Circular queue: operations

In C++, implementing a circular queue involves managing the front and rear pointers to keep track of the elements. Circular queues are often used when you want to efficiently use memory by reusing positions once elements are dequeued. Here are the basic operations for a circular queue:

1. **Enqueue (Insertion)**: Add an element to the rear of the queue.
2. **Dequeue (Deletion)**: Remove an element from the front of the queue.
3. **isEmpty**: Check if the queue is empty.
4. **isFull**: Check if the queue is full.
5. **Front**: Get the element at the front of the queue.
6. **Rear**: Get the element at the rear of the queue.

Here's a basic implementation of a circular queue in C++:

```cpp
#include <iostream>
using namespace std;

#define SIZE 5

class CircularQueue {
private:
    int front, rear;
    int arr[SIZE];

public:
    CircularQueue() {
        front = rear = -1;
    }

    // Function to check if the queue is empty
    bool isEmpty() {
        return (front == -1 && rear == -1);
    }

    // Function to check if the queue is full
    bool isFull() {
        return (rear + 1) % SIZE == front;
    }

    // Function to add an element to the rear of the queue
    void enqueue(int value) {
        if (isFull()) {
            cout << "Queue is full. Cannot enqueue." << endl;
            return;
        } else if (isEmpty()) {
            front = rear = 0;
        } else {
            rear = (rear + 1) % SIZE;
        }
        arr[rear] = value;
        cout << value << " enqueued to the queue." << endl;
    }

    // Function to remove an element from the front of the queue
    void dequeue() {
        if (isEmpty()) {
            cout << "Queue is empty. Cannot dequeue." << endl;
            return;
        } else if (front == rear) {
            cout << arr[front] << " dequeued from the queue." << endl;
            front = rear = -1;
        } else {
            cout << arr[front] << " dequeued from the queue." << endl;
            front = (front + 1) % SIZE;
        }
    }

    // Function to get the element at the front of the queue
    int Front() {
        if (isEmpty()) {
            cout << "Queue is empty." << endl;
            return -1;
        }
        return arr[front];
    }

    // Function to get the element at the rear of the queue
    int Rear() {
        if (isEmpty()) {
            cout << "Queue is empty." << endl;
            return -1;
        }
        return arr[rear];
    }
};

int main() {
    CircularQueue q;

    // Example usage
    q.enqueue(10);
    q.enqueue(20);
    q.enqueue(30);
    q.enqueue(40);
    q.enqueue(50);

    cout << "Front element: " << q.Front() << endl;
    cout << "Rear element: " << q.Rear() << endl;

    q.dequeue();
    q.dequeue();

    cout << "Front element after two dequeues: " << q.Front() << endl;

    return 0;
}
```

This code provides a basic implementation of a circular queue in C++. You can add more operations or modify it according to your requirements.

### 1. Algorithms & Data Structures (C++): Circular Queue: Sorting and Searching

Implementing sorting and searching algorithms on a circular queue in C++ involves a few considerations due to its circular nature. Here's a basic example of how you can implement sorting and searching functionalities on a circular queue:

```cpp
#include <iostream>
using namespace std;

const int MAX_SIZE = 100;

class CircularQueue {
private:
    int arr[MAX_SIZE];
    int front, rear, size;

public:
    CircularQueue() {
        front = rear = -1;
        size = 0;
    }

    bool isEmpty() {
        return size == 0;
    }

    bool isFull() {
        return size == MAX_SIZE;
    }

    void enqueue(int value) {
        if (isFull()) {
            cout << "Queue is full. Cannot enqueue.\n";
            return;
        }
        if (front == -1)  // if queue is initially empty
            front = 0;
        rear = (rear + 1) % MAX_SIZE;
        arr[rear] = value;
        size++;
    }

    int dequeue() {
        if (isEmpty()) {
            cout << "Queue is empty. Cannot dequeue.\n";
            return -1;
        }
        int value = arr[front];
        if (front == rear)  // if only one element is present
            front = rear = -1;
        else
            front = (front + 1) % MAX_SIZE;
        size--;
        return value;
    }

    void display() {
        if (isEmpty()) {
            cout << "Queue is empty.\n";
            return;
        }
        int i = front;
        do {
            cout << arr[i] << " ";
            i = (i + 1) % MAX_SIZE;
        } while (i != (rear + 1) % MAX_SIZE);
        cout << endl;
    }

    // Sorting the circular queue using bubble sort
    void bubbleSort() {
        if (isEmpty()) {
            cout << "Queue is empty. Nothing to sort.\n";
            return;
        }
        for (int i = 0; i < size - 1; i++) {
            for (int j = 0; j < size - i - 1; j++) {
                int nextIdx = (front + j + 1) % MAX_SIZE;
                int nextNextIdx = (front + j + 2) % MAX_SIZE;
                if (arr[nextIdx] > arr[nextNextIdx]) {
                    swap(arr[nextIdx], arr[nextNextIdx]);
                }
            }
        }
    }

    // Searching for an element in the circular queue
    bool search(int key) {
        if (isEmpty()) {
            cout << "Queue is empty. Nothing to search.\n";
            return false;
        }
        int i = front;
        do {
            if (arr[i] == key)
                return true;
            i = (i + 1) % MAX_SIZE;
        } while (i != (rear + 1) % MAX_SIZE);
        return false;
    }
};

int main() {
    CircularQueue cq;
    cq.enqueue(5);
    cq.enqueue(3);
    cq.enqueue(8);
    cq.enqueue(1);
    cq.enqueue(9);

    cout << "Original Circular Queue: ";
    cq.display();

    cq.bubbleSort();
    cout << "Sorted Circular Queue: ";
    cq.display();

    int searchKey = 8;
    if (cq.search(searchKey))
        cout << searchKey << " found in the queue.\n";
    else
        cout << searchKey << " not found in the queue.\n";

    return 0;
}
```

This code provides a basic implementation of a circular queue with sorting and searching functionalities using bubble sort and linear search respectively. You can modify and optimize these functionalities as per your requirements and preferences.

### 1. Algorithms & Data Structures (C++): Circular Queue: Sorting Trade-Offs

When implementing a circular queue in C++ and considering sorting trade-offs, several factors come into play, including time complexity, space complexity, and the specific requirements of your application. Here's a breakdown:

1. **Sorting Frequency**: How often do you need to sort the elements in the circular queue? If sorting is infrequent or not required at all, you might prioritize other aspects of your data structure implementation, such as efficient enqueue and dequeue operations.

2. **Sorting Algorithm Choice**: If sorting is necessary, the choice of sorting algorithm depends on the size of the queue and the data distribution. For smaller queues or nearly sorted data, simple algorithms like insertion sort or bubble sort might be sufficient due to their low overhead. For larger queues or random data, more sophisticated algorithms like quicksort or mergesort might offer better performance on average.

3. **Space Complexity**: Some sorting algorithms have additional space complexity requirements. For example, mergesort typically requires additional space proportional to the size of the input, while in-place algorithms like quicksort have lower space overhead. Consider the memory constraints of your application when choosing a sorting algorithm.

4. **Time Complexity**: The time complexity of sorting impacts the overall performance of operations on the circular queue. While quicksort and mergesort have average-case time complexities of O(n log n), other algorithms like insertion sort have worst-case time complexities of O(n^2). Depending on the size and characteristics of your data, this trade-off might be acceptable.

5. **Stability**: If the order of elements with equal keys needs to be preserved, stability becomes an important consideration when choosing a sorting algorithm. Merge sort is inherently stable, while quicksort is not without additional modifications.

6. **Implementation Complexity**: Consider the complexity of implementing and maintaining the chosen sorting algorithm within your circular queue implementation. Some algorithms, like insertion sort, have simpler implementations compared to others like mergesort or quicksort.

In summary, when designing a circular queue in C++ with sorting capabilities, carefully weigh factors such as sorting frequency, space complexity, time complexity, stability, and implementation complexity to choose the most suitable sorting algorithm for your specific use case.

### 1. Algorithms & Data Structures (C++): Algorithm for Circular Queue operations

A circular queue is a data structure that operates much like a regular queue but with a fixed size. It avoids the wastage of space in a regular queue implementation where elements are dequeued and new elements are enqueued causing the front of the queue to shift and leave empty spaces at the front. Here's a basic algorithm for circular queue operations (enqueue and dequeue) in C++:

```cpp
#include <iostream>

#define SIZE 5

using namespace std;

class CircularQueue {
private:
    int items[SIZE], front, rear;

public:
    CircularQueue() {
        front = -1;
        rear = -1;
    }

    // Function to check if the queue is full
    bool isFull() {
        if ((front == 0 && rear == SIZE - 1) || (rear == (front - 1) % (SIZE - 1))) {
            return true;
        }
        return false;
    }

    // Function to check if the queue is empty
    bool isEmpty() {
        if (front == -1)
            return true;
        else
            return false;
    }

    // Function to add an element to the queue
    void enqueue(int element) {
        if (isFull()) {
            cout << "Queue Overflow \n";
            return;
        }

        if (front == -1) {
            front = 0;
            rear = 0;
        } else if (rear == SIZE - 1 && front != 0) {
            rear = 0;
        } else {
            rear = (rear + 1) % SIZE;
        }
        items[rear] = element;
        cout << element << " enqueued to queue\n";
    }

    // Function to remove an element from the queue
    int dequeue() {
        if (isEmpty()) {
            cout << "Queue Underflow\n";
            return -1;
        }

        int element = items[front];
        if (front == rear) {
            front = -1;
            rear = -1;
        } else {
            front = (front + 1) % SIZE;
        }
        return element;
    }

    // Function to display the queue
    void display() {
        if (isEmpty()) {
            cout << "Queue is empty\n";
            return;
        }
        cout << "Elements in Circular Queue are: ";
        if (rear >= front) {
            for (int i = front; i <= rear; i++)
                cout << items[i] << " ";
        } else {
            for (int i = front; i < SIZE; i++)
                cout << items[i] << " ";

            for (int i = 0; i <= rear; i++)
                cout << items[i] << " ";
        }
        cout << endl;
    }
};

int main() {
    CircularQueue q;

    // Adding elements to the queue
    q.enqueue(10);
    q.enqueue(20);
    q.enqueue(30);
    q.enqueue(40);
    q.enqueue(50);

    // Displaying the queue
    q.display();

    // Removing elements from the queue
    cout << q.dequeue() << " dequeued from queue\n";
    cout << q.dequeue() << " dequeued from queue\n";

    // Displaying the queue after dequeuing
    q.display();

    // Adding more elements after dequeuing
    q.enqueue(60);
    q.enqueue(70);

    // Displaying the queue after enqueuing
    q.display();

    return 0;
}
```

This code provides basic implementations of circular queue operations such as enqueue, dequeue, and display. It also includes checks for queue overflow and underflow.
