### 1. Algorithms & Data Structures (C++): Algorithm development for Double Ended Queue operations

Developing algorithms for Double Ended Queue (Deque) operations involves ensuring efficient insertion and deletion at both ends of the queue. Let's discuss the main operations typically associated with a deque:

1. **Insertion at Front (`push_front`)**: This operation adds an element to the front of the deque.
2. **Insertion at Back (`push_back`)**: This operation adds an element to the back of the deque.
3. **Deletion at Front (`pop_front`)**: This operation removes an element from the front of the deque.
4. **Deletion at Back (`pop_back`)**: This operation removes an element from the back of the deque.
5. **Accessing Front (`front`)**: This operation retrieves the element at the front of the deque.
6. **Accessing Back (`back`)**: This operation retrieves the element at the back of the deque.

Here's a basic implementation of these operations in C++:

```cpp
#include <iostream>
#include <deque>

using namespace std;

int main() {
    deque<int> dq;

    // Insertion at Front
    dq.push_front(1);
    dq.push_front(2);
    dq.push_front(3);

    // Insertion at Back
    dq.push_back(4);
    dq.push_back(5);
    dq.push_back(6);

    // Deletion at Front
    dq.pop_front();

    // Deletion at Back
    dq.pop_back();

    // Accessing Front and Back
    cout << "Front element: " << dq.front() << endl;
    cout << "Back element: " << dq.back() << endl;

    // Displaying the deque
    cout << "Deque: ";
    for (auto it = dq.begin(); it != dq.end(); ++it) {
        cout << *it << " ";
    }
    cout << endl;

    return 0;
}
```

This is a basic implementation. However, if you're interested in the algorithmic details, here's the time complexity analysis for each operation:

* **Insertion at Front (`push_front`)**: O(1)
* **Insertion at Back (`push_back`)**: O(1)
* **Deletion at Front (`pop_front`)**: O(1)
* **Deletion at Back (`pop_back`)**: O(1)
* **Accessing Front (`front`)**: O(1)
* **Accessing Back (`back`)**: O(1)

Deque provides constant time complexity for all these operations because it is implemented as a doubly-linked list or an array-based structure with dynamic resizing. Therefore, it efficiently supports insertion and deletion at both ends.

### 1. Algorithms & Data Structures (C++): Deque STL

Sure! In C++, `std::deque` (pronounced "deck") stands for "double-ended queue". It's a sequence container that allows fast insertion and deletion at both its beginning and its end. Here's how you can use it:

#### Including the necessary header file

```cpp
#include <deque>
```

#### Declaring a deque

```cpp
std::deque<int> myDeque; // Creates an empty deque of integers
```

#### Operations on deque

1. **Insertion and Removal**:
    * `push_back(value)`: Adds an element to the end of the deque.
    * `push_front(value)`: Adds an element to the beginning of the deque.
    * `pop_back()`: Removes the last element from the deque.
    * `pop_front()`: Removes the first element from the deque.

    ```cpp
    myDeque.push_back(10);
    myDeque.push_front(20);
    myDeque.pop_back();
    myDeque.pop_front();
    ```

2. **Accessing Elements**:
    * `front()`: Accesses the first element.
    * `back()`: Accesses the last element.

    ```cpp
    int firstElement = myDeque.front();
    int lastElement = myDeque.back();
    ```

3. **Size and Capacity**:
    * `size()`: Returns the number of elements in the deque.
    * `empty()`: Checks whether the deque is empty or not.

    ```cpp
    int size = myDeque.size();
    bool isEmpty = myDeque.empty();
    ```

4. **Iterating through the deque**:
    You can use iterators to traverse the deque. Here's an example of iterating through a deque:

    ```cpp
    for (auto it = myDeque.begin(); it != myDeque.end(); ++it) {
        // Do something with *it
    }
    ```

#### Advantages of `std::deque`

* **Fast insertion and removal**: Unlike vectors, deques have efficient insertion and deletion at both ends.
* **Dynamic resizing**: Deques grow and shrink dynamically to accommodate elements efficiently.

#### When to use `std::deque`

* When you need fast insertion and deletion at both ends of the sequence.
* When you need dynamic resizing and don't want to pay the cost of reallocation like in vectors.

#### Example

```cpp
#include <iostream>
#include <deque>

int main() {
    std::deque<int> myDeque;

    // Inserting elements
    myDeque.push_back(10);
    myDeque.push_front(20);

    // Accessing elements
    std::cout << "First element: " << myDeque.front() << std::endl;
    std::cout << "Last element: " << myDeque.back() << std::endl;

    // Removing elements
    myDeque.pop_back();
    myDeque.pop_front();

    // Checking size
    std::cout << "Size: " << myDeque.size() << std::endl;

    return 0;
}
```

That's a basic rundown of using `std::deque` in C++! Let me know if you have any specific questions or need further clarification.

### 1. Algorithms & Data Structures (C++): DEQueue ( Double-Ended-Queue )

A double-ended queue, often abbreviated as deque (pronounced "deck"), is a data structure that supports insertion and deletion at both the front and the back of the queue. Implementing a deque in C++ involves various methods to manipulate its contents efficiently. Below is a simple implementation of a deque in C++ using arrays:

```cpp
#include <iostream>

template <typename T>
class Deque {
private:
    T* arr;
    int capacity;
    int front;
    int rear;
    int size;

public:
    Deque(int capacity) : capacity(capacity), front(0), rear(-1), size(0) {
        arr = new T[capacity];
    }

    ~Deque() {
        delete[] arr;
    }

    bool isEmpty() {
        return size == 0;
    }

    bool isFull() {
        return size == capacity;
    }

    void insertFront(T element) {
        if (isFull()) {
            std::cout << "Deque is full. Cannot insert.\n";
            return;
        }
        front = (front - 1 + capacity) % capacity;
        arr[front] = element;
        size++;
    }

    void insertRear(T element) {
        if (isFull()) {
            std::cout << "Deque is full. Cannot insert.\n";
            return;
        }
        rear = (rear + 1) % capacity;
        arr[rear] = element;
        size++;
    }

    T deleteFront() {
        if (isEmpty()) {
            std::cout << "Deque is empty. Cannot delete.\n";
            return T();
        }
        T deleted = arr[front];
        front = (front + 1) % capacity;
        size--;
        return deleted;
    }

    T deleteRear() {
        if (isEmpty()) {
            std::cout << "Deque is empty. Cannot delete.\n";
            return T();
        }
        T deleted = arr[rear];
        rear = (rear - 1 + capacity) % capacity;
        size--;
        return deleted;
    }

    T getFront() {
        if (isEmpty()) {
            std::cout << "Deque is empty. No front element.\n";
            return T();
        }
        return arr[front];
    }

    T getRear() {
        if (isEmpty()) {
            std::cout << "Deque is empty. No rear element.\n";
            return T();
        }
        return arr[rear];
    }
};

int main() {
    Deque<int> deque(5);

    deque.insertFront(10);
    deque.insertRear(20);
    deque.insertFront(30);
    deque.insertRear(40);

    std::cout << "Front element: " << deque.getFront() << std::endl;
    std::cout << "Rear element: " << deque.getRear() << std::endl;

    deque.deleteFront();
    deque.deleteRear();

    std::cout << "Front element after deletion: " << deque.getFront() << std::endl;
    std::cout << "Rear element after deletion: " << deque.getRear() << std::endl;

    return 0;
}
```

This code defines a `Deque` class with methods to insert and delete elements from both ends of the deque. It uses circular arrays to efficiently utilize memory. The main function demonstrates the usage of the deque by inserting elements at both ends, retrieving front and rear elements, and deleting elements from both ends.

### 1. Algorithms & Data Structures (C++): Deque

A deque, short for double-ended queue, is a data structure that allows insertion and deletion of elements from both the front and the back. In C++, you can use the `std::deque` container provided by the Standard Template Library (STL) to implement a deque efficiently. Here's a basic overview of how to use `std::deque` in C++:

#### Including the Necessary Header File

```cpp
#include <deque>
```

#### Declaring a deque

```cpp
std::deque<int> myDeque; // Declaration of a deque of integers
```

#### Inserting Elements

You can insert elements at either end of the deque using `push_front()` and `push_back()` functions:

```cpp
myDeque.push_front(10); // Inserts 10 at the front
myDeque.push_back(20);  // Inserts 20 at the back
```

#### Accessing Elements

You can access elements using array-like indexing or iterators:

```cpp
int frontElement = myDeque.front(); // Retrieves the element at the front
int backElement = myDeque.back();   // Retrieves the element at the back
```

#### Removing Elements

You can remove elements from either end using `pop_front()` and `pop_back()` functions:

```cpp
myDeque.pop_front(); // Removes the element from the front
myDeque.pop_back();  // Removes the element from the back
```

#### Size and Empty Check

You can get the size of the deque and check if it's empty using `size()` and `empty()` functions:

```cpp
size_t dequeSize = myDeque.size(); // Returns the number of elements in the deque
bool isEmpty = myDeque.empty();    // Returns true if the deque is empty, false otherwise
```

#### Iterating Over Elements

You can use iterators to traverse through the deque:

```cpp
for (auto it = myDeque.begin(); it != myDeque.end(); ++it) {
    // Access element using *it
    std::cout << *it << " ";
}
```

#### Clearing the Deque

You can clear all elements from the deque using `clear()`:

```cpp
myDeque.clear(); // Removes all elements from the deque
```

Deques are versatile data structures, offering constant time insertion and deletion at both ends, making them suitable for various applications where elements need to be added or removed from the front and the back frequently.

### 1. Algorithms & Data Structures (C++): DeleteFront() and DeleteRear() from DEQueue

Sure, I can provide you with C++ implementations for `DeleteFront()` and `DeleteRear()` operations for a double-ended queue (Deque). A deque is a data structure that allows insertion and deletion of elements from both the front and the rear.

Here's a simple implementation:

```cpp
#include <iostream>
using namespace std;

#define MAX_SIZE 100

class Deque {
private:
    int arr[MAX_SIZE];
    int front, rear;
public:
    Deque() {
        front = rear = -1;
    }

    bool isEmpty() {
        return (front == -1 && rear == -1);
    }

    bool isFull() {
        return (front == 0 && rear == MAX_SIZE - 1) || (rear == (front - 1) % (MAX_SIZE - 1));
    }

    void insertFront(int key) {
        if (isFull()) {
            cout << "Deque is full. Cannot insert element.\n";
            return;
        }
        if (isEmpty()) {
            front = rear = 0;
        } else if (front == 0) {
            front = MAX_SIZE - 1;
        } else {
            front = (front - 1) % (MAX_SIZE - 1);
        }
        arr[front] = key;
        cout << "Inserted " << key << " at the front.\n";
    }

    void insertRear(int key) {
        if (isFull()) {
            cout << "Deque is full. Cannot insert element.\n";
            return;
        }
        if (isEmpty()) {
            front = rear = 0;
        } else if (rear == MAX_SIZE - 1) {
            rear = 0;
        } else {
            rear = (rear + 1) % (MAX_SIZE - 1);
        }
        arr[rear] = key;
        cout << "Inserted " << key << " at the rear.\n";
    }

    void deleteFront() {
        if (isEmpty()) {
            cout << "Deque is empty. Cannot delete.\n";
            return;
        }
        if (front == rear) {
            cout << "Deleted " << arr[front] << " from the front.\n";
            front = rear = -1;
        } else {
            cout << "Deleted " << arr[front] << " from the front.\n";
            front = (front + 1) % (MAX_SIZE - 1);
        }
    }

    void deleteRear() {
        if (isEmpty()) {
            cout << "Deque is empty. Cannot delete.\n";
            return;
        }
        if (front == rear) {
            cout << "Deleted " << arr[rear] << " from the rear.\n";
            front = rear = -1;
        } else if (rear == 0) {
            cout << "Deleted " << arr[rear] << " from the rear.\n";
            rear = MAX_SIZE - 1;
        } else {
            cout << "Deleted " << arr[rear] << " from the rear.\n";
            rear = (rear - 1) % (MAX_SIZE - 1);
        }
    }

    void display() {
        if (isEmpty()) {
            cout << "Deque is empty.\n";
            return;
        }
        cout << "Deque elements: ";
        int i = front;
        while (i != rear) {
            cout << arr[i] << " ";
            i = (i + 1) % (MAX_SIZE - 1);
        }
        cout << arr[rear] << endl;
    }
};

int main() {
    Deque dq;
    dq.insertFront(5);
    dq.insertRear(10);
    dq.insertFront(3);
    dq.display();
    dq.deleteFront();
    dq.display();
    dq.deleteRear();
    dq.display();
    return 0;
}
```

In this implementation:

* `deleteFront()`: Deletes an element from the front of the deque.
* `deleteRear()`: Deletes an element from the rear of the deque.

Both of these operations handle the cases when the deque is empty or full. They also handle the scenarios where after deletion, the deque becomes empty or only one element is left.


### 1. Algorithms & Data Structures (C++): DEQueue (Double-Ended-Queue)

A Double-Ended Queue (DEQueue) is a data structure that allows insertion and deletion of elements from both the front and the rear ends. In C++, you can implement a DEQueue using various approaches, such as using doubly linked lists or arrays. Here's a simple implementation using a doubly linked list:

```cpp
#include <iostream>

// Node structure for the doubly linked list
template <typename T>
struct Node {
    T data;
    Node* prev;
    Node* next;
    
    Node(const T& d) : data(d), prev(nullptr), next(nullptr) {}
};

// DEQueue class
template <typename T>
class DEQueue {
private:
    Node<T>* front;
    Node<T>* rear;
    int size;

public:
    DEQueue() : front(nullptr), rear(nullptr), size(0) {}

    // Function to check if the DEQueue is empty
    bool isEmpty() const {
        return size == 0;
    }

    // Function to get the size of the DEQueue
    int getSize() const {
        return size;
    }

    // Function to insert an element at the front of the DEQueue
    void insertFront(const T& value) {
        Node<T>* newNode = new Node<T>(value);
        if (isEmpty()) {
            front = rear = newNode;
        } else {
            newNode->next = front;
            front->prev = newNode;
            front = newNode;
        }
        size++;
    }

    // Function to insert an element at the rear of the DEQueue
    void insertRear(const T& value) {
        Node<T>* newNode = new Node<T>(value);
        if (isEmpty()) {
            front = rear = newNode;
        } else {
            rear->next = newNode;
            newNode->prev = rear;
            rear = newNode;
        }
        size++;
    }

    // Function to remove an element from the front of the DEQueue
    T removeFront() {
        if (isEmpty()) {
            std::cerr << "DEQueue is empty. Cannot remove from front.\n";
            exit(EXIT_FAILURE);
        }
        T value = front->data;
        Node<T>* temp = front;
        if (front == rear) {
            front = rear = nullptr;
        } else {
            front = front->next;
            front->prev = nullptr;
        }
        delete temp;
        size--;
        return value;
    }

    // Function to remove an element from the rear of the DEQueue
    T removeRear() {
        if (isEmpty()) {
            std::cerr << "DEQueue is empty. Cannot remove from rear.\n";
            exit(EXIT_FAILURE);
        }
        T value = rear->data;
        Node<T>* temp = rear;
        if (front == rear) {
            front = rear = nullptr;
        } else {
            rear = rear->prev;
            rear->next = nullptr;
        }
        delete temp;
        size--;
        return value;
    }

    // Function to display the elements of the DEQueue
    void display() const {
        if (isEmpty()) {
            std::cout << "DEQueue is empty.\n";
            return;
        }
        Node<T>* current = front;
        while (current != nullptr) {
            std::cout << current->data << " ";
            current = current->next;
        }
        std::cout << std::endl;
    }

    // Destructor to free memory
    ~DEQueue() {
        while (!isEmpty()) {
            removeFront();
        }
    }
};

int main() {
    DEQueue<int> dq;
    
    dq.insertFront(10);
    dq.insertFront(20);
    dq.insertRear(30);
    dq.insertRear(40);
    
    std::cout << "DEQueue elements: ";
    dq.display();
    
    std::cout << "Removed from front: " << dq.removeFront() << std::endl;
    std::cout << "Removed from rear: " << dq.removeRear() << std::endl;
    
    std::cout << "DEQueue elements after removal: ";
    dq.display();
    
    return 0;
}
```

This code provides a basic implementation of a DEQueue using a doubly linked list in C++. You can perform operations like insertion at both ends (`insertFront()` and `insertRear()`), removal from both ends (`removeFront()` and `removeRear()`), check if the DEQueue is empty (`isEmpty()`), get the size of the DEQueue (`getSize()`), and display the elements (`display()`).

### 1. Algorithms & Data Structures (C++): Dequeue in Linked List

Certainly! A deque, short for "double-ended queue," is a data structure that allows insertion and deletion of elements from both the front and the back. Implementing a deque using a linked list involves creating a node structure and managing pointers to maintain the connections between nodes.

Here's a basic implementation of a deque using a doubly linked list in C++:

```cpp
#include <iostream>

template <typename T>
class Node {
public:
    T data;
    Node<T>* next;
    Node<T>* prev;

    Node(const T& newData) : data(newData), next(nullptr), prev(nullptr) {}
};

template <typename T>
class Deque {
private:
    Node<T>* front;
    Node<T>* rear;
    int size;

public:
    Deque() : front(nullptr), rear(nullptr), size(0) {}

    ~Deque() {
        clear();
    }

    void push_front(const T& value) {
        Node<T>* newNode = new Node<T>(value);
        if (isEmpty()) {
            front = rear = newNode;
        } else {
            newNode->next = front;
            front->prev = newNode;
            front = newNode;
        }
        size++;
    }

    void push_back(const T& value) {
        Node<T>* newNode = new Node<T>(value);
        if (isEmpty()) {
            front = rear = newNode;
        } else {
            rear->next = newNode;
            newNode->prev = rear;
            rear = newNode;
        }
        size++;
    }

    void pop_front() {
        if (!isEmpty()) {
            Node<T>* temp = front;
            front = front->next;
            if (front)
                front->prev = nullptr;
            delete temp;
            size--;
            if (isEmpty())
                rear = nullptr;
        }
    }

    void pop_back() {
        if (!isEmpty()) {
            Node<T>* temp = rear;
            rear = rear->prev;
            if (rear)
                rear->next = nullptr;
            delete temp;
            size--;
            if (isEmpty())
                front = nullptr;
        }
    }

    T& front_element() {
        if (!isEmpty())
            return front->data;
        else
            throw std::out_of_range("Deque is empty");
    }

    T& back_element() {
        if (!isEmpty())
            return rear->data;
        else
            throw std::out_of_range("Deque is empty");
    }

    bool isEmpty() {
        return size == 0;
    }

    int getSize() {
        return size;
    }

    void clear() {
        while (!isEmpty())
            pop_front();
    }
};

int main() {
    Deque<int> deque;

    deque.push_front(1);
    deque.push_front(2);
    deque.push_back(3);
    deque.push_back(4);

    std::cout << "Front element: " << deque.front_element() << std::endl;
    std::cout << "Back element: " << deque.back_element() << std::endl;

    deque.pop_front();
    deque.pop_back();

    std::cout << "Front element after pop_front: " << deque.front_element() << std::endl;
    std::cout << "Back element after pop_back: " << deque.back_element() << std::endl;

    return 0;
}
```

This code defines a deque using a doubly linked list. It provides methods to push and pop elements from both the front and the back of the deque, as well as methods to access the front and back elements. Finally, there's a simple demonstration of how to use the deque in the `main` function.

### 1. Algorithms & Data Structures (C++): DeQueue() in Circular Queue

In C++, implementing a `DeQueue()` operation (also known as `pop_front()` in some implementations) in a circular queue involves removing an element from the front of the queue. A circular queue has the property that when an element is dequeued from the front, the next element becomes the new front element, considering the circular nature of the underlying array.

Here's a basic implementation of a circular queue in C++ with a `DeQueue()` operation:

```cpp
#include <iostream>
using namespace std;

const int MAX_SIZE = 100;

class CircularQueue {
private:
    int front, rear, size;
    int arr[MAX_SIZE];

public:
    CircularQueue() {
        front = rear = -1;
        size = 0;
    }

    bool isEmpty() {
        return size == 0;
    }

    bool isFull() {
        return size == MAX_SIZE;
    }

    void enQueue(int value) {
        if (isFull()) {
            cout << "Queue is full. Cannot enqueue." << endl;
            return;
        }

        if (isEmpty()) {
            front = rear = 0;
        } else {
            rear = (rear + 1) % MAX_SIZE;
        }
        arr[rear] = value;
        size++;
    }

    void deQueue() {
        if (isEmpty()) {
            cout << "Queue is empty. Cannot dequeue." << endl;
            return;
        }

        if (front == rear) {
            // Reset front and rear as the queue becomes empty after dequeue
            front = rear = -1;
        } else {
            front = (front + 1) % MAX_SIZE;
        }
        size--;
    }

    void display() {
        if (isEmpty()) {
            cout << "Queue is empty." << endl;
            return;
        }

        int i = front;
        while (i != rear) {
            cout << arr[i] << " ";
            i = (i + 1) % MAX_SIZE;
        }
        cout << arr[rear] << endl;
    }
};

int main() {
    CircularQueue queue;

    queue.enQueue(10);
    queue.enQueue(20);
    queue.enQueue(30);

    cout << "Queue elements: ";
    queue.display();

    queue.deQueue();

    cout << "Queue elements after dequeue: ";
    queue.display();

    return 0;
}
```

In this implementation, `front` and `rear` indices are maintained to represent the front and rear of the queue respectively. When an element is dequeued, `front` is moved one step forward, considering the circular nature of the queue. If `front` becomes equal to `rear`, it means the queue is empty, and both indices are reset accordingly.

### 1. Algorithms & Data Structures (C++): Double Ended Queue

A Double Ended Queue (Deque) is a data structure that allows insertion and deletion of elements from both the front and the back. It's like a combination of a stack and a queue. In C++, you can implement a deque using the `std::deque` container provided by the Standard Template Library (STL). Here's a basic example:

```cpp
#include <iostream>
#include <deque>

int main() {
    // Declare a deque
    std::deque<int> myDeque;

    // Insert elements at the back
    myDeque.push_back(10);
    myDeque.push_back(20);
    myDeque.push_back(30);

    // Insert elements at the front
    myDeque.push_front(5);
    myDeque.push_front(2);

    // Print elements
    std::cout << "Deque elements: ";
    for (int num : myDeque) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    // Remove elements from the back
    myDeque.pop_back();
    myDeque.pop_back();

    // Remove elements from the front
    myDeque.pop_front();

    // Print elements after removal
    std::cout << "Deque elements after removal: ";
    for (int num : myDeque) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

This code demonstrates basic operations on a deque, such as insertion at both ends (`push_back` and `push_front`), removal from both ends (`pop_back` and `pop_front`), and iteration over the elements.

Deques offer constant time insertion and deletion at both ends, making them a versatile data structure for many scenarios.

### 1. Algorithms & Data Structures (C++): Double Ended Queue DEQUEUE

A double-ended queue (deque) is a data structure that allows insertion and deletion of elements from both the front and the back. In C++, you can implement a deque using the `std::deque` container provided by the Standard Template Library (STL). Here's a basic overview of how you can use `std::deque`:

```cpp
#include <iostream>
#include <deque>

int main() {
    // Declaration of deque
    std::deque<int> myDeque;

    // Insert elements at the back
    myDeque.push_back(10);
    myDeque.push_back(20);
    myDeque.push_back(30);

    // Insert elements at the front
    myDeque.push_front(5);
    myDeque.push_front(2);

    // Access elements
    std::cout << "Elements in deque: ";
    for (int elem : myDeque) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    // Remove elements from the front
    myDeque.pop_front();
    myDeque.pop_front();

    // Remove elements from the back
    myDeque.pop_back();

    // Access updated elements
    std::cout << "Updated deque: ";
    for (int elem : myDeque) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

This code demonstrates basic operations on a deque, such as insertion at both ends (`push_back` and `push_front`), removal from both ends (`pop_back` and `pop_front`), and traversal of elements using a range-based for loop.

Remember, `std::deque` provides constant time insertion and deletion at both the beginning and the end of the deque. However, accessing elements at arbitrary positions within the deque is less efficient compared to vectors (`std::vector`), as deque does not provide contiguous storage.

### 1. Algorithms & Data Structures (C++): Double Ended Queue using doubly linked list

Creating a double-ended queue (deque) using a doubly linked list in C++ involves implementing the necessary functionalities such as insertion and deletion from both ends of the deque. Here's a simple implementation:

```cpp
#include <iostream>

template <typename T>
class Node {
public:
    T data;
    Node<T>* next;
    Node<T>* prev;

    Node(T val) : data(val), next(nullptr), prev(nullptr) {}
};

template <typename T>
class Deque {
private:
    Node<T>* front;
    Node<T>* rear;

public:
    Deque() : front(nullptr), rear(nullptr) {}

    bool isEmpty() {
        return front == nullptr;
    }

    void insertFront(T val) {
        Node<T>* newNode = new Node<T>(val);
        if (isEmpty()) {
            front = rear = newNode;
        } else {
            newNode->next = front;
            front->prev = newNode;
            front = newNode;
        }
    }

    void insertRear(T val) {
        Node<T>* newNode = new Node<T>(val);
        if (isEmpty()) {
            front = rear = newNode;
        } else {
            rear->next = newNode;
            newNode->prev = rear;
            rear = newNode;
        }
    }

    T deleteFront() {
        if (isEmpty()) {
            std::cerr << "Deque is empty!" << std::endl;
            exit(1);
        }

        T deletedData = front->data;
        Node<T>* temp = front;
        if (front == rear) {
            front = rear = nullptr;
        } else {
            front = front->next;
            front->prev = nullptr;
        }
        delete temp;
        return deletedData;
    }

    T deleteRear() {
        if (isEmpty()) {
            std::cerr << "Deque is empty!" << std::endl;
            exit(1);
        }

        T deletedData = rear->data;
        Node<T>* temp = rear;
        if (front == rear) {
            front = rear = nullptr;
        } else {
            rear = rear->prev;
            rear->next = nullptr;
        }
        delete temp;
        return deletedData;
    }

    void display() {
        if (isEmpty()) {
            std::cout << "Deque is empty!" << std::endl;
            return;
        }

        Node<T>* current = front;
        while (current != nullptr) {
            std::cout << current->data << " ";
            current = current->next;
        }
        std::cout << std::endl;
    }
};

int main() {
    Deque<int> deque;
    
    deque.insertFront(10);
    deque.insertRear(20);
    deque.insertFront(5);
    deque.insertRear(30);
    
    deque.display(); // Output: 5 10 20 30
    
    std::cout << "Deleted front element: " << deque.deleteFront() << std::endl;
    std::cout << "Deleted rear element: " << deque.deleteRear() << std::endl;
    
    deque.display(); // Output: 10 20
    
    return 0;
}
```

This code defines a `Deque` class using a doubly linked list. It provides methods to insert elements at both the front and rear, delete elements from both ends, and display the contents of the deque.

### 1. Algorithms & Data Structures (C++): Double Ended Queues using Arrays

Certainly! A double-ended queue (deque) implemented using arrays in C++ allows for efficient insertion and deletion operations at both ends of the deque. Here's a basic implementation:

```cpp
#include <iostream>
using namespace std;

#define MAX_SIZE 100

class Deque {
private:
    int arr[MAX_SIZE];
    int front, rear;
public:
    Deque() {
        front = -1;
        rear = -1;
    }

    bool isEmpty() {
        return (front == -1 && rear == -1);
    }

    bool isFull() {
        return (rear + 1) % MAX_SIZE == front;
    }

    void insertFront(int x) {
        if (isFull()) {
            cout << "Deque is full. Overflow!" << endl;
            return;
        }
        if (isEmpty()) {
            front = rear = 0;
        } else {
            front = (front - 1 + MAX_SIZE) % MAX_SIZE;
        }
        arr[front] = x;
    }

    void insertRear(int x) {
        if (isFull()) {
            cout << "Deque is full. Overflow!" << endl;
            return;
        }
        if (isEmpty()) {
            front = rear = 0;
        } else {
            rear = (rear + 1) % MAX_SIZE;
        }
        arr[rear] = x;
    }

    void deleteFront() {
        if (isEmpty()) {
            cout << "Deque is empty. Underflow!" << endl;
            return;
        }
        if (front == rear) {
            front = rear = -1;
        } else {
            front = (front + 1) % MAX_SIZE;
        }
    }

    void deleteRear() {
        if (isEmpty()) {
            cout << "Deque is empty. Underflow!" << endl;
            return;
        }
        if (front == rear) {
            front = rear = -1;
        } else {
            rear = (rear - 1 + MAX_SIZE) % MAX_SIZE;
        }
    }

    int getFront() {
        if (isEmpty()) {
            cout << "Deque is empty." << endl;
            return -1;
        }
        return arr[front];
    }

    int getRear() {
        if (isEmpty()) {
            cout << "Deque is empty." << endl;
            return -1;
        }
        return arr[rear];
    }
};

int main() {
    Deque dq;
    dq.insertFront(5);
    dq.insertRear(10);
    dq.insertFront(3);
    dq.insertRear(15);
    cout << "Front element: " << dq.getFront() << endl;
    cout << "Rear element: " << dq.getRear() << endl;
    dq.deleteFront();
    dq.deleteRear();
    cout << "Front element after deletion: " << dq.getFront() << endl;
    cout << "Rear element after deletion: " << dq.getRear() << endl;
    return 0;
}
```

This implementation maintains a circular array to efficiently utilize the available space. The `insertFront`, `insertRear`, `deleteFront`, and `deleteRear` operations have a time complexity of O(1) on average. However, be aware that this implementation has a fixed maximum size (`MAX_SIZE`), and it doesn't dynamically resize itself.

### 1. Algorithms & Data Structures (C++): Double Ended Queues using Linked List

Sure, implementing a Double Ended Queue (Deque) using a linked list in C++ involves creating a structure for the nodes of the linked list and then implementing the necessary methods to manipulate the deque. Here's a basic implementation:

```cpp
#include <iostream>

using namespace std;

// Node structure for the linked list
struct Node {
    int data;
    Node* next;
    Node* prev;
    
    Node(int value) : data(value), next(nullptr), prev(nullptr) {}
};

class Deque {
private:
    Node* front;
    Node* rear;
    int size;
    
public:
    Deque() : front(nullptr), rear(nullptr), size(0) {}

    bool isEmpty() {
        return size == 0;
    }

    // Insert at the front of the deque
    void insertFront(int value) {
        Node* newNode = new Node(value);
        if (isEmpty()) {
            front = rear = newNode;
        } else {
            newNode->next = front;
            front->prev = newNode;
            front = newNode;
        }
        size++;
    }

    // Insert at the rear of the deque
    void insertRear(int value) {
        Node* newNode = new Node(value);
        if (isEmpty()) {
            front = rear = newNode;
        } else {
            rear->next = newNode;
            newNode->prev = rear;
            rear = newNode;
        }
        size++;
    }

    // Delete from the front of the deque
    void deleteFront() {
        if (isEmpty()) {
            cout << "Deque is empty." << endl;
            return;
        }
        Node* temp = front;
        if (front == rear) {
            front = rear = nullptr;
        } else {
            front = front->next;
            front->prev = nullptr;
        }
        delete temp;
        size--;
    }

    // Delete from the rear of the deque
    void deleteRear() {
        if (isEmpty()) {
            cout << "Deque is empty." << endl;
            return;
        }
        Node* temp = rear;
        if (front == rear) {
            front = rear = nullptr;
        } else {
            rear = rear->prev;
            rear->next = nullptr;
        }
        delete temp;
        size--;
    }

    // Display the elements of the deque
    void display() {
        if (isEmpty()) {
            cout << "Deque is empty." << endl;
            return;
        }
        Node* current = front;
        while (current != nullptr) {
            cout << current->data << " ";
            current = current->next;
        }
        cout << endl;
    }
};

int main() {
    Deque deque;
    deque.insertFront(5);
    deque.insertFront(10);
    deque.insertRear(15);
    deque.display(); // Output: 10 5 15
    deque.deleteFront();
    deque.display(); // Output: 5 15
    deque.deleteRear();
    deque.display(); // Output: 5
    return 0;
}
```

This implementation provides basic functionalities like inserting and deleting elements from both the front and rear ends of the deque, as well as checking if the deque is empty and displaying its contents.

### 1. Algorithms & Data Structures (C++): Dry run of the DEQ algorithm

The DEQ algorithm, also known as the Double Ended Queue algorithm, is commonly implemented using a doubly linked list. It allows insertion and deletion of elements from both ends of the queue. Let's dry run a simple DEQ algorithm implemented in C++:

```cpp
#include <iostream>

using namespace std;

// Node structure for doubly linked list
struct Node {
    int data;
    Node* next;
    Node* prev;
};

class DEQueue {
private:
    Node* front;
    Node* rear;
public:
    DEQueue() {
        front = nullptr;
        rear = nullptr;
    }

    // Function to check if the queue is empty
    bool isEmpty() {
        return front == nullptr;
    }

    // Function to insert element at the front of the queue
    void insertFront(int data) {
        Node* newNode = new Node();
        newNode->data = data;
        newNode->next = front;
        newNode->prev = nullptr;
        if (isEmpty()) {
            rear = newNode;
        } else {
            front->prev = newNode;
        }
        front = newNode;
    }

    // Function to insert element at the rear of the queue
    void insertRear(int data) {
        Node* newNode = new Node();
        newNode->data = data;
        newNode->next = nullptr;
        newNode->prev = rear;
        if (isEmpty()) {
            front = newNode;
        } else {
            rear->next = newNode;
        }
        rear = newNode;
    }

    // Function to delete element from the front of the queue
    void deleteFront() {
        if (isEmpty()) {
            cout << "Queue is empty\n";
            return;
        }
        Node* temp = front;
        front = front->next;
        if (front != nullptr) {
            front->prev = nullptr;
        } else {
            rear = nullptr;
        }
        delete temp;
    }

    // Function to delete element from the rear of the queue
    void deleteRear() {
        if (isEmpty()) {
            cout << "Queue is empty\n";
            return;
        }
        Node* temp = rear;
        rear = rear->prev;
        if (rear != nullptr) {
            rear->next = nullptr;
        } else {
            front = nullptr;
        }
        delete temp;
    }

    // Function to display the elements of the queue
    void display() {
        if (isEmpty()) {
            cout << "Queue is empty\n";
            return;
        }
        Node* temp = front;
        while (temp != nullptr) {
            cout << temp->data << " ";
            temp = temp->next;
        }
        cout << endl;
    }
};

int main() {
    DEQueue deq;

    // Insert elements at the front
    deq.insertFront(10);
    deq.insertFront(20);
    deq.insertFront(30);

    // Insert elements at the rear
    deq.insertRear(40);
    deq.insertRear(50);
    deq.insertRear(60);

    // Display the queue
    cout << "Queue elements: ";
    deq.display();

    // Delete elements from the front and rear
    deq.deleteFront();
    deq.deleteRear();

    // Display the queue after deletion
    cout << "Queue elements after deletion: ";
    deq.display();

    return 0;
}
```

Now, let's dry run this code step by step:

1. Initially, both the front and rear pointers are set to nullptr, indicating an empty queue.
2. Three elements (30, 20, 10) are inserted at the front of the queue.
3. Three elements (40, 50, 60) are inserted at the rear of the queue.
4. The queue elements are displayed: 30 20 10 40 50 60
5. One element is deleted from the front and one from the rear.
6. The queue elements after deletion are displayed: 20 10 40 50

### 1. Algorithms & Data Structures (C++): What are Double Ended Queues (DEQue) ?

Double Ended Queues, often abbreviated as DEQue or deque (pronounced "deck"), are a versatile data structure that allows insertion and deletion of elements from both ends. It combines the properties of stacks (Last-In-First-Out, or LIFO) and queues (First-In-First-Out, or FIFO).

In C++, the standard template library (STL) provides a deque container in the `<deque>` header, which implements a double-ended queue efficiently. It allows fast insertions and deletions at both the beginning and the end, as well as random access to elements.

Here are some key characteristics and operations of a deque:

1. **Double-ended**: Elements can be added or removed from both the front and the back of the deque.

2. **Dynamic resizing**: The underlying memory structure of a deque typically dynamically resizes itself to accommodate a varying number of elements efficiently.

3. **Random access**: Unlike some other data structures like linked lists, deques allow for constant-time random access to elements, meaning you can directly access any element with an index.

4. **Efficient insertion and deletion**: Both insertion and deletion operations at either end of the deque have a time complexity of O(1) on average.

5. **Not strictly sequential**: While elements are stored in a sequential manner in memory, they are not necessarily contiguous like arrays, due to the dynamic resizing nature of the deque.

Here are some common operations associated with deques:

* `push_front()`: Adds an element to the front of the deque.
* `pop_front()`: Removes the element from the front of the deque.
* `push_back()`: Adds an element to the back of the deque.
* `pop_back()`: Removes the element from the back of the deque.
* `front()`: Accesses the element at the front of the deque.
* `back()`: Accesses the element at the back of the deque.
* `size()`: Returns the number of elements in the deque.
* `empty()`: Checks if the deque is empty.

Double-ended queues are widely used in various applications where fast insertion and deletion operations are required at both ends of the data structure. They provide a flexible and efficient alternative to other linear data structures like stacks and queues.
